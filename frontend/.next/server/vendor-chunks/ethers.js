"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/ethers";
exports.ids = ["vendor-chunks/ethers"];
exports.modules = {

/***/ "(ssr)/./node_modules/ethers/lib.esm/_version.js":
/*!*************************************************!*\
  !*** ./node_modules/ethers/lib.esm/_version.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   version: () => (/* binding */ version)\n/* harmony export */ });\n/* Do NOT modify this file; see /src.ts/_admin/update-version.ts */ /**\n *  The current version of Ethers.\n */ const version = \"6.15.0\"; //# sourceMappingURL=_version.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vX3ZlcnNpb24uanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLGlFQUFpRSxHQUNqRTs7Q0FFQyxHQUNNLE1BQU1BLFVBQVUsU0FBUyxDQUNoQyxvQ0FBb0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tZWdhdmliZS1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9fdmVyc2lvbi5qcz82ZTE5Il0sInNvdXJjZXNDb250ZW50IjpbIi8qIERvIE5PVCBtb2RpZnkgdGhpcyBmaWxlOyBzZWUgL3NyYy50cy9fYWRtaW4vdXBkYXRlLXZlcnNpb24udHMgKi9cbi8qKlxuICogIFRoZSBjdXJyZW50IHZlcnNpb24gb2YgRXRoZXJzLlxuICovXG5leHBvcnQgY29uc3QgdmVyc2lvbiA9IFwiNi4xNS4wXCI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1fdmVyc2lvbi5qcy5tYXAiXSwibmFtZXMiOlsidmVyc2lvbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.esm/_version.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.esm/abi/abi-coder.js":
/*!******************************************************!*\
  !*** ./node_modules/ethers/lib.esm/abi/abi-coder.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AbiCoder: () => (/* binding */ AbiCoder)\n/* harmony export */ });\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/errors.js\");\n/* harmony import */ var _coders_abstract_coder_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./coders/abstract-coder.js */ \"(ssr)/./node_modules/ethers/lib.esm/abi/coders/abstract-coder.js\");\n/* harmony import */ var _coders_address_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./coders/address.js */ \"(ssr)/./node_modules/ethers/lib.esm/abi/coders/address.js\");\n/* harmony import */ var _coders_array_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./coders/array.js */ \"(ssr)/./node_modules/ethers/lib.esm/abi/coders/array.js\");\n/* harmony import */ var _coders_boolean_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./coders/boolean.js */ \"(ssr)/./node_modules/ethers/lib.esm/abi/coders/boolean.js\");\n/* harmony import */ var _coders_bytes_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./coders/bytes.js */ \"(ssr)/./node_modules/ethers/lib.esm/abi/coders/bytes.js\");\n/* harmony import */ var _coders_fixed_bytes_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./coders/fixed-bytes.js */ \"(ssr)/./node_modules/ethers/lib.esm/abi/coders/fixed-bytes.js\");\n/* harmony import */ var _coders_null_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./coders/null.js */ \"(ssr)/./node_modules/ethers/lib.esm/abi/coders/null.js\");\n/* harmony import */ var _coders_number_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./coders/number.js */ \"(ssr)/./node_modules/ethers/lib.esm/abi/coders/number.js\");\n/* harmony import */ var _coders_string_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./coders/string.js */ \"(ssr)/./node_modules/ethers/lib.esm/abi/coders/string.js\");\n/* harmony import */ var _coders_tuple_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./coders/tuple.js */ \"(ssr)/./node_modules/ethers/lib.esm/abi/coders/tuple.js\");\n/* harmony import */ var _fragments_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./fragments.js */ \"(ssr)/./node_modules/ethers/lib.esm/abi/fragments.js\");\n/* harmony import */ var _address_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../address/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/address/address.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/data.js\");\n/**\n *  When sending values to or receiving values from a [[Contract]], the\n *  data is generally encoded using the [ABI standard](link-solc-abi).\n *\n *  The AbiCoder provides a utility to encode values to ABI data and\n *  decode values from ABI data.\n *\n *  Most of the time, developers should favour the [[Contract]] class,\n *  which further abstracts a lot of the finer details of ABI data.\n *\n *  @_section api/abi/abi-coder:ABI Encoding\n */ // See: https://github.com/ethereum/wiki/wiki/Ethereum-Contract-ABI\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n// https://docs.soliditylang.org/en/v0.8.17/control-structures.html\nconst PanicReasons = new Map();\nPanicReasons.set(0x00, \"GENERIC_PANIC\");\nPanicReasons.set(0x01, \"ASSERT_FALSE\");\nPanicReasons.set(0x11, \"OVERFLOW\");\nPanicReasons.set(0x12, \"DIVIDE_BY_ZERO\");\nPanicReasons.set(0x21, \"ENUM_RANGE_ERROR\");\nPanicReasons.set(0x22, \"BAD_STORAGE_DATA\");\nPanicReasons.set(0x31, \"STACK_UNDERFLOW\");\nPanicReasons.set(0x32, \"ARRAY_RANGE_ERROR\");\nPanicReasons.set(0x41, \"OUT_OF_MEMORY\");\nPanicReasons.set(0x51, \"UNINITIALIZED_FUNCTION_CALL\");\nconst paramTypeBytes = new RegExp(/^bytes([0-9]*)$/);\nconst paramTypeNumber = new RegExp(/^(u?int)([0-9]*)$/);\nlet defaultCoder = null;\nlet defaultMaxInflation = 1024;\nfunction getBuiltinCallException(action, tx, data, abiCoder) {\n    let message = \"missing revert data\";\n    let reason = null;\n    const invocation = null;\n    let revert = null;\n    if (data) {\n        message = \"execution reverted\";\n        const bytes = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBytes)(data);\n        data = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(data);\n        if (bytes.length === 0) {\n            message += \" (no data present; likely require(false) occurred\";\n            reason = \"require(false)\";\n        } else if (bytes.length % 32 !== 4) {\n            message += \" (could not decode reason; invalid data length)\";\n        } else if ((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(bytes.slice(0, 4)) === \"0x08c379a0\") {\n            // Error(string)\n            try {\n                reason = abiCoder.decode([\n                    \"string\"\n                ], bytes.slice(4))[0];\n                revert = {\n                    signature: \"Error(string)\",\n                    name: \"Error\",\n                    args: [\n                        reason\n                    ]\n                };\n                message += `: ${JSON.stringify(reason)}`;\n            } catch (error) {\n                message += \" (could not decode reason; invalid string data)\";\n            }\n        } else if ((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(bytes.slice(0, 4)) === \"0x4e487b71\") {\n            // Panic(uint256)\n            try {\n                const code = Number(abiCoder.decode([\n                    \"uint256\"\n                ], bytes.slice(4))[0]);\n                revert = {\n                    signature: \"Panic(uint256)\",\n                    name: \"Panic\",\n                    args: [\n                        code\n                    ]\n                };\n                reason = `Panic due to ${PanicReasons.get(code) || \"UNKNOWN\"}(${code})`;\n                message += `: ${reason}`;\n            } catch (error) {\n                message += \" (could not decode panic code)\";\n            }\n        } else {\n            message += \" (unknown custom error)\";\n        }\n    }\n    const transaction = {\n        to: tx.to ? (0,_address_index_js__WEBPACK_IMPORTED_MODULE_1__.getAddress)(tx.to) : null,\n        data: tx.data || \"0x\"\n    };\n    if (tx.from) {\n        transaction.from = (0,_address_index_js__WEBPACK_IMPORTED_MODULE_1__.getAddress)(tx.from);\n    }\n    return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.makeError)(message, \"CALL_EXCEPTION\", {\n        action,\n        data,\n        reason,\n        transaction,\n        invocation,\n        revert\n    });\n}\n/**\n *  The **AbiCoder** is a low-level class responsible for encoding JavaScript\n *  values into binary data and decoding binary data into JavaScript values.\n */ class AbiCoder {\n    #getCoder(param) {\n        if (param.isArray()) {\n            return new _coders_array_js__WEBPACK_IMPORTED_MODULE_3__.ArrayCoder(this.#getCoder(param.arrayChildren), param.arrayLength, param.name);\n        }\n        if (param.isTuple()) {\n            return new _coders_tuple_js__WEBPACK_IMPORTED_MODULE_4__.TupleCoder(param.components.map((c)=>this.#getCoder(c)), param.name);\n        }\n        switch(param.baseType){\n            case \"address\":\n                return new _coders_address_js__WEBPACK_IMPORTED_MODULE_5__.AddressCoder(param.name);\n            case \"bool\":\n                return new _coders_boolean_js__WEBPACK_IMPORTED_MODULE_6__.BooleanCoder(param.name);\n            case \"string\":\n                return new _coders_string_js__WEBPACK_IMPORTED_MODULE_7__.StringCoder(param.name);\n            case \"bytes\":\n                return new _coders_bytes_js__WEBPACK_IMPORTED_MODULE_8__.BytesCoder(param.name);\n            case \"\":\n                return new _coders_null_js__WEBPACK_IMPORTED_MODULE_9__.NullCoder(param.name);\n        }\n        // u?int[0-9]*\n        let match = param.type.match(paramTypeNumber);\n        if (match) {\n            let size = parseInt(match[2] || \"256\");\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(size !== 0 && size <= 256 && size % 8 === 0, \"invalid \" + match[1] + \" bit length\", \"param\", param);\n            return new _coders_number_js__WEBPACK_IMPORTED_MODULE_10__.NumberCoder(size / 8, match[1] === \"int\", param.name);\n        }\n        // bytes[0-9]+\n        match = param.type.match(paramTypeBytes);\n        if (match) {\n            let size = parseInt(match[1]);\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(size !== 0 && size <= 32, \"invalid bytes length\", \"param\", param);\n            return new _coders_fixed_bytes_js__WEBPACK_IMPORTED_MODULE_11__.FixedBytesCoder(size, param.name);\n        }\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(false, \"invalid type\", \"type\", param.type);\n    }\n    /**\n     *  Get the default values for the given %%types%%.\n     *\n     *  For example, a ``uint`` is by default ``0`` and ``bool``\n     *  is by default ``false``.\n     */ getDefaultValue(types) {\n        const coders = types.map((type)=>this.#getCoder(_fragments_js__WEBPACK_IMPORTED_MODULE_12__.ParamType.from(type)));\n        const coder = new _coders_tuple_js__WEBPACK_IMPORTED_MODULE_4__.TupleCoder(coders, \"_\");\n        return coder.defaultValue();\n    }\n    /**\n     *  Encode the %%values%% as the %%types%% into ABI data.\n     *\n     *  @returns DataHexstring\n     */ encode(types, values) {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgumentCount)(values.length, types.length, \"types/values length mismatch\");\n        const coders = types.map((type)=>this.#getCoder(_fragments_js__WEBPACK_IMPORTED_MODULE_12__.ParamType.from(type)));\n        const coder = new _coders_tuple_js__WEBPACK_IMPORTED_MODULE_4__.TupleCoder(coders, \"_\");\n        const writer = new _coders_abstract_coder_js__WEBPACK_IMPORTED_MODULE_13__.Writer();\n        coder.encode(writer, values);\n        return writer.data;\n    }\n    /**\n     *  Decode the ABI %%data%% as the %%types%% into values.\n     *\n     *  If %%loose%% decoding is enabled, then strict padding is\n     *  not enforced. Some older versions of Solidity incorrectly\n     *  padded event data emitted from ``external`` functions.\n     */ decode(types, data, loose) {\n        const coders = types.map((type)=>this.#getCoder(_fragments_js__WEBPACK_IMPORTED_MODULE_12__.ParamType.from(type)));\n        const coder = new _coders_tuple_js__WEBPACK_IMPORTED_MODULE_4__.TupleCoder(coders, \"_\");\n        return coder.decode(new _coders_abstract_coder_js__WEBPACK_IMPORTED_MODULE_13__.Reader(data, loose, defaultMaxInflation));\n    }\n    static _setDefaultMaxInflation(value) {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(typeof value === \"number\" && Number.isInteger(value), \"invalid defaultMaxInflation factor\", \"value\", value);\n        defaultMaxInflation = value;\n    }\n    /**\n     *  Returns the shared singleton instance of a default [[AbiCoder]].\n     *\n     *  On the first call, the instance is created internally.\n     */ static defaultAbiCoder() {\n        if (defaultCoder == null) {\n            defaultCoder = new AbiCoder();\n        }\n        return defaultCoder;\n    }\n    /**\n     *  Returns an ethers-compatible [[CallExceptionError]] Error for the given\n     *  result %%data%% for the [[CallExceptionAction]] %%action%% against\n     *  the Transaction %%tx%%.\n     */ static getBuiltinCallException(action, tx, data) {\n        return getBuiltinCallException(action, tx, data, AbiCoder.defaultAbiCoder());\n    }\n} //# sourceMappingURL=abi-coder.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vYWJpL2FiaS1jb2Rlci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7Ozs7Ozs7Ozs7Q0FXQyxHQUNELG1FQUFtRTtBQUNLO0FBQ1o7QUFDVDtBQUNKO0FBQ0k7QUFDSjtBQUNXO0FBQ2I7QUFDSTtBQUNBO0FBQ0Y7QUFDSjtBQUNNO0FBQ2dCO0FBQ2pFLG1FQUFtRTtBQUNuRSxNQUFNa0IsZUFBZSxJQUFJQztBQUN6QkQsYUFBYUUsR0FBRyxDQUFDLE1BQU07QUFDdkJGLGFBQWFFLEdBQUcsQ0FBQyxNQUFNO0FBQ3ZCRixhQUFhRSxHQUFHLENBQUMsTUFBTTtBQUN2QkYsYUFBYUUsR0FBRyxDQUFDLE1BQU07QUFDdkJGLGFBQWFFLEdBQUcsQ0FBQyxNQUFNO0FBQ3ZCRixhQUFhRSxHQUFHLENBQUMsTUFBTTtBQUN2QkYsYUFBYUUsR0FBRyxDQUFDLE1BQU07QUFDdkJGLGFBQWFFLEdBQUcsQ0FBQyxNQUFNO0FBQ3ZCRixhQUFhRSxHQUFHLENBQUMsTUFBTTtBQUN2QkYsYUFBYUUsR0FBRyxDQUFDLE1BQU07QUFDdkIsTUFBTUMsaUJBQWlCLElBQUlDLE9BQU87QUFDbEMsTUFBTUMsa0JBQWtCLElBQUlELE9BQU87QUFDbkMsSUFBSUUsZUFBZTtBQUNuQixJQUFJQyxzQkFBc0I7QUFDMUIsU0FBU0Msd0JBQXdCQyxNQUFNLEVBQUVDLEVBQUUsRUFBRUMsSUFBSSxFQUFFQyxRQUFRO0lBQ3ZELElBQUlDLFVBQVU7SUFDZCxJQUFJQyxTQUFTO0lBQ2IsTUFBTUMsYUFBYTtJQUNuQixJQUFJQyxTQUFTO0lBQ2IsSUFBSUwsTUFBTTtRQUNORSxVQUFVO1FBQ1YsTUFBTUksUUFBUXBCLHlEQUFRQSxDQUFDYztRQUN2QkEsT0FBT2Isd0RBQU9BLENBQUNhO1FBQ2YsSUFBSU0sTUFBTUMsTUFBTSxLQUFLLEdBQUc7WUFDcEJMLFdBQVc7WUFDWEMsU0FBUztRQUNiLE9BQ0ssSUFBSUcs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O1FBQ2pFLE1BQU1NLFFBQVMsSUFBSXpELHdEQUFVQSxDQUFDd0QsUUFBUTtRQUN0QyxNQUFNSyxTQUFTLElBQUl0RSw4REFBTUE7UUFDekJrRSxNQUFNRSxNQUFNLENBQUNFLFFBQVFEO1FBQ3JCLE9BQU9DLE9BQU81QyxJQUFJO0lBQ3RCO0lBQ0E7Ozs7OztLQU1DLEdBQ0RTLE9BQU82QixLQUFLLEVBQUV0QyxJQUFJLEVBQUU2QyxLQUFLLEVBQUU7UUFDdkIsTUFBTU4sU0FBU0QsTUFBTVIsR0FBRyxDQUFDLENBQUNJLE9BQVMsSUFBSSxDQUFDLENBQUNYLFFBQVEsQ0FBQ3ZDLHFEQUFTQSxDQUFDcUMsSUFBSSxDQUFDYTtRQUNqRSxNQUFNTSxRQUFRLElBQUl6RCx3REFBVUEsQ0FBQ3dELFFBQVE7UUFDckMsT0FBT0MsTUFBTS9CLE1BQU0sQ0FBQyxJQUFJcEMsOERBQU1BLENBQUMyQixNQUFNNkMsT0FBT2pEO0lBQ2hEO0lBQ0EsT0FBT2tELHdCQUF3QkMsS0FBSyxFQUFFO1FBQ2xDM0UsK0RBQWNBLENBQUMsT0FBUTJFLFVBQVcsWUFBWTlCLE9BQU8rQixTQUFTLENBQUNELFFBQVEsc0NBQXNDLFNBQVNBO1FBQ3RIbkQsc0JBQXNCbUQ7SUFDMUI7SUFDQTs7OztLQUlDLEdBQ0QsT0FBT0Usa0JBQWtCO1FBQ3JCLElBQUl0RCxnQkFBZ0IsTUFBTTtZQUN0QkEsZUFBZSxJQUFJMkI7UUFDdkI7UUFDQSxPQUFPM0I7SUFDWDtJQUNBOzs7O0tBSUMsR0FDRCxPQUFPRSx3QkFBd0JDLE1BQU0sRUFBRUMsRUFBRSxFQUFFQyxJQUFJLEVBQUU7UUFDN0MsT0FBT0gsd0JBQXdCQyxRQUFRQyxJQUFJQyxNQUFNc0IsU0FBUzJCLGVBQWU7SUFDN0U7QUFDSixFQUNBLHFDQUFxQyIsInNvdXJjZXMiOlsid2VicGFjazovL21lZ2F2aWJlLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL2FiaS9hYmktY29kZXIuanM/ZmQ0MyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqICBXaGVuIHNlbmRpbmcgdmFsdWVzIHRvIG9yIHJlY2VpdmluZyB2YWx1ZXMgZnJvbSBhIFtbQ29udHJhY3RdXSwgdGhlXG4gKiAgZGF0YSBpcyBnZW5lcmFsbHkgZW5jb2RlZCB1c2luZyB0aGUgW0FCSSBzdGFuZGFyZF0obGluay1zb2xjLWFiaSkuXG4gKlxuICogIFRoZSBBYmlDb2RlciBwcm92aWRlcyBhIHV0aWxpdHkgdG8gZW5jb2RlIHZhbHVlcyB0byBBQkkgZGF0YSBhbmRcbiAqICBkZWNvZGUgdmFsdWVzIGZyb20gQUJJIGRhdGEuXG4gKlxuICogIE1vc3Qgb2YgdGhlIHRpbWUsIGRldmVsb3BlcnMgc2hvdWxkIGZhdm91ciB0aGUgW1tDb250cmFjdF1dIGNsYXNzLFxuICogIHdoaWNoIGZ1cnRoZXIgYWJzdHJhY3RzIGEgbG90IG9mIHRoZSBmaW5lciBkZXRhaWxzIG9mIEFCSSBkYXRhLlxuICpcbiAqICBAX3NlY3Rpb24gYXBpL2FiaS9hYmktY29kZXI6QUJJIEVuY29kaW5nXG4gKi9cbi8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2V0aGVyZXVtL3dpa2kvd2lraS9FdGhlcmV1bS1Db250cmFjdC1BQklcbmltcG9ydCB7IGFzc2VydEFyZ3VtZW50Q291bnQsIGFzc2VydEFyZ3VtZW50IH0gZnJvbSBcIi4uL3V0aWxzL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBSZWFkZXIsIFdyaXRlciB9IGZyb20gXCIuL2NvZGVycy9hYnN0cmFjdC1jb2Rlci5qc1wiO1xuaW1wb3J0IHsgQWRkcmVzc0NvZGVyIH0gZnJvbSBcIi4vY29kZXJzL2FkZHJlc3MuanNcIjtcbmltcG9ydCB7IEFycmF5Q29kZXIgfSBmcm9tIFwiLi9jb2RlcnMvYXJyYXkuanNcIjtcbmltcG9ydCB7IEJvb2xlYW5Db2RlciB9IGZyb20gXCIuL2NvZGVycy9ib29sZWFuLmpzXCI7XG5pbXBvcnQgeyBCeXRlc0NvZGVyIH0gZnJvbSBcIi4vY29kZXJzL2J5dGVzLmpzXCI7XG5pbXBvcnQgeyBGaXhlZEJ5dGVzQ29kZXIgfSBmcm9tIFwiLi9jb2RlcnMvZml4ZWQtYnl0ZXMuanNcIjtcbmltcG9ydCB7IE51bGxDb2RlciB9IGZyb20gXCIuL2NvZGVycy9udWxsLmpzXCI7XG5pbXBvcnQgeyBOdW1iZXJDb2RlciB9IGZyb20gXCIuL2NvZGVycy9udW1iZXIuanNcIjtcbmltcG9ydCB7IFN0cmluZ0NvZGVyIH0gZnJvbSBcIi4vY29kZXJzL3N0cmluZy5qc1wiO1xuaW1wb3J0IHsgVHVwbGVDb2RlciB9IGZyb20gXCIuL2NvZGVycy90dXBsZS5qc1wiO1xuaW1wb3J0IHsgUGFyYW1UeXBlIH0gZnJvbSBcIi4vZnJhZ21lbnRzLmpzXCI7XG5pbXBvcnQgeyBnZXRBZGRyZXNzIH0gZnJvbSBcIi4uL2FkZHJlc3MvaW5kZXguanNcIjtcbmltcG9ydCB7IGdldEJ5dGVzLCBoZXhsaWZ5LCBtYWtlRXJyb3IgfSBmcm9tIFwiLi4vdXRpbHMvaW5kZXguanNcIjtcbi8vIGh0dHBzOi8vZG9jcy5zb2xpZGl0eWxhbmcub3JnL2VuL3YwLjguMTcvY29udHJvbC1zdHJ1Y3R1cmVzLmh0bWxcbmNvbnN0IFBhbmljUmVhc29ucyA9IG5ldyBNYXAoKTtcblBhbmljUmVhc29ucy5zZXQoMHgwMCwgXCJHRU5FUklDX1BBTklDXCIpO1xuUGFuaWNSZWFzb25zLnNldCgweDAxLCBcIkFTU0VSVF9GQUxTRVwiKTtcblBhbmljUmVhc29ucy5zZXQoMHgxMSwgXCJPVkVSRkxPV1wiKTtcblBhbmljUmVhc29ucy5zZXQoMHgxMiwgXCJESVZJREVfQllfWkVST1wiKTtcblBhbmljUmVhc29ucy5zZXQoMHgyMSwgXCJFTlVNX1JBTkdFX0VSUk9SXCIpO1xuUGFuaWNSZWFzb25zLnNldCgweDIyLCBcIkJBRF9TVE9SQUdFX0RBVEFcIik7XG5QYW5pY1JlYXNvbnMuc2V0KDB4MzEsIFwiU1RBQ0tfVU5ERVJGTE9XXCIpO1xuUGFuaWNSZWFzb25zLnNldCgweDMyLCBcIkFSUkFZX1JBTkdFX0VSUk9SXCIpO1xuUGFuaWNSZWFzb25zLnNldCgweDQxLCBcIk9VVF9PRl9NRU1PUllcIik7XG5QYW5pY1JlYXNvbnMuc2V0KDB4NTEsIFwiVU5JTklUSUFMSVpFRF9GVU5DVElPTl9DQUxMXCIpO1xuY29uc3QgcGFyYW1UeXBlQnl0ZXMgPSBuZXcgUmVnRXhwKC9eYnl0ZXMoWzAtOV0qKSQvKTtcbmNvbnN0IHBhcmFtVHlwZU51bWJlciA9IG5ldyBSZWdFeHAoL14odT9pbnQpKFswLTldKikkLyk7XG5sZXQgZGVmYXVsdENvZGVyID0gbnVsbDtcbmxldCBkZWZhdWx0TWF4SW5mbGF0aW9uID0gMTAyNDtcbmZ1bmN0aW9uIGdldEJ1aWx0aW5DYWxsRXhjZXB0aW9uKGFjdGlvbiwgdHgsIGRhdGEsIGFiaUNvZGVyKSB7XG4gICAgbGV0IG1lc3NhZ2UgPSBcIm1pc3NpbmcgcmV2ZXJ0IGRhdGFcIjtcbiAgICBsZXQgcmVhc29uID0gbnVsbDtcbiAgICBjb25zdCBpbnZvY2F0aW9uID0gbnVsbDtcbiAgICBsZXQgcmV2ZXJ0ID0gbnVsbDtcbiAgICBpZiAoZGF0YSkge1xuICAgICAgICBtZXNzYWdlID0gXCJleGVjdXRpb24gcmV2ZXJ0ZWRcIjtcbiAgICAgICAgY29uc3QgYnl0ZXMgPSBnZXRCeXRlcyhkYXRhKTtcbiAgICAgICAgZGF0YSA9IGhleGxpZnkoZGF0YSk7XG4gICAgICAgIGlmIChieXRlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIG1lc3NhZ2UgKz0gXCIgKG5vIGRhdGEgcHJlc2VudDsgbGlrZWx5IHJlcXVpcmUoZmFsc2UpIG9jY3VycmVkXCI7XG4gICAgICAgICAgICByZWFzb24gPSBcInJlcXVpcmUoZmFsc2UpXCI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYnl0ZXMubGVuZ3RoICUgMzIgIT09IDQpIHtcbiAgICAgICAgICAgIG1lc3NhZ2UgKz0gXCIgKGNvdWxkIG5vdCBkZWNvZGUgcmVhc29uOyBpbnZhbGlkIGRhdGEgbGVuZ3RoKVwiO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGhleGxpZnkoYnl0ZXMuc2xpY2UoMCwgNCkpID09PSBcIjB4MDhjMzc5YTBcIikge1xuICAgICAgICAgICAgLy8gRXJyb3Ioc3RyaW5nKVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZWFzb24gPSBhYmlDb2Rlci5kZWNvZGUoW1wic3RyaW5nXCJdLCBieXRlcy5zbGljZSg0KSlbMF07XG4gICAgICAgICAgICAgICAgcmV2ZXJ0ID0ge1xuICAgICAgICAgICAgICAgICAgICBzaWduYXR1cmU6IFwiRXJyb3Ioc3RyaW5nKVwiLFxuICAgICAgICAgICAgICAgICAgICBuYW1lOiBcIkVycm9yXCIsXG4gICAgICAgICAgICAgICAgICAgIGFyZ3M6IFtyZWFzb25dXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBtZXNzYWdlICs9IGA6ICR7SlNPTi5zdHJpbmdpZnkocmVhc29uKX1gO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZSArPSBcIiAoY291bGQgbm90IGRlY29kZSByZWFzb247IGludmFsaWQgc3RyaW5nIGRhdGEpXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaGV4bGlmeShieXRlcy5zbGljZSgwLCA0KSkgPT09IFwiMHg0ZTQ4N2I3MVwiKSB7XG4gICAgICAgICAgICAvLyBQYW5pYyh1aW50MjU2KVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCBjb2RlID0gTnVtYmVyKGFiaUNvZGVyLmRlY29kZShbXCJ1aW50MjU2XCJdLCBieXRlcy5zbGljZSg0KSlbMF0pO1xuICAgICAgICAgICAgICAgIHJldmVydCA9IHtcbiAgICAgICAgICAgICAgICAgICAgc2lnbmF0dXJlOiBcIlBhbmljKHVpbnQyNTYpXCIsXG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IFwiUGFuaWNcIixcbiAgICAgICAgICAgICAgICAgICAgYXJnczogW2NvZGVdXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICByZWFzb24gPSBgUGFuaWMgZHVlIHRvICR7UGFuaWNSZWFzb25zLmdldChjb2RlKSB8fCBcIlVOS05PV05cIn0oJHtjb2RlfSlgO1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UgKz0gYDogJHtyZWFzb259YDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UgKz0gXCIgKGNvdWxkIG5vdCBkZWNvZGUgcGFuaWMgY29kZSlcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG1lc3NhZ2UgKz0gXCIgKHVua25vd24gY3VzdG9tIGVycm9yKVwiO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHRyYW5zYWN0aW9uID0ge1xuICAgICAgICB0bzogKHR4LnRvID8gZ2V0QWRkcmVzcyh0eC50bykgOiBudWxsKSxcbiAgICAgICAgZGF0YTogKHR4LmRhdGEgfHwgXCIweFwiKVxuICAgIH07XG4gICAgaWYgKHR4LmZyb20pIHtcbiAgICAgICAgdHJhbnNhY3Rpb24uZnJvbSA9IGdldEFkZHJlc3ModHguZnJvbSk7XG4gICAgfVxuICAgIHJldHVybiBtYWtlRXJyb3IobWVzc2FnZSwgXCJDQUxMX0VYQ0VQVElPTlwiLCB7XG4gICAgICAgIGFjdGlvbiwgZGF0YSwgcmVhc29uLCB0cmFuc2FjdGlvbiwgaW52b2NhdGlvbiwgcmV2ZXJ0XG4gICAgfSk7XG59XG4vKipcbiAqICBUaGUgKipBYmlDb2RlcioqIGlzIGEgbG93LWxldmVsIGNsYXNzIHJlc3BvbnNpYmxlIGZvciBlbmNvZGluZyBKYXZhU2NyaXB0XG4gKiAgdmFsdWVzIGludG8gYmluYXJ5IGRhdGEgYW5kIGRlY29kaW5nIGJpbmFyeSBkYXRhIGludG8gSmF2YVNjcmlwdCB2YWx1ZXMuXG4gKi9cbmV4cG9ydCBjbGFzcyBBYmlDb2RlciB7XG4gICAgI2dldENvZGVyKHBhcmFtKSB7XG4gICAgICAgIGlmIChwYXJhbS5pc0FycmF5KCkpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQXJyYXlDb2Rlcih0aGlzLiNnZXRDb2RlcihwYXJhbS5hcnJheUNoaWxkcmVuKSwgcGFyYW0uYXJyYXlMZW5ndGgsIHBhcmFtLm5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJhbS5pc1R1cGxlKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgVHVwbGVDb2RlcihwYXJhbS5jb21wb25lbnRzLm1hcCgoYykgPT4gdGhpcy4jZ2V0Q29kZXIoYykpLCBwYXJhbS5uYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKHBhcmFtLmJhc2VUeXBlKSB7XG4gICAgICAgICAgICBjYXNlIFwiYWRkcmVzc1wiOlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQWRkcmVzc0NvZGVyKHBhcmFtLm5hbWUpO1xuICAgICAgICAgICAgY2FzZSBcImJvb2xcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEJvb2xlYW5Db2RlcihwYXJhbS5uYW1lKTtcbiAgICAgICAgICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFN0cmluZ0NvZGVyKHBhcmFtLm5hbWUpO1xuICAgICAgICAgICAgY2FzZSBcImJ5dGVzXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBCeXRlc0NvZGVyKHBhcmFtLm5hbWUpO1xuICAgICAgICAgICAgY2FzZSBcIlwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgTnVsbENvZGVyKHBhcmFtLm5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHU/aW50WzAtOV0qXG4gICAgICAgIGxldCBtYXRjaCA9IHBhcmFtLnR5cGUubWF0Y2gocGFyYW1UeXBlTnVtYmVyKTtcbiAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICBsZXQgc2l6ZSA9IHBhcnNlSW50KG1hdGNoWzJdIHx8IFwiMjU2XCIpO1xuICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoc2l6ZSAhPT0gMCAmJiBzaXplIDw9IDI1NiAmJiAoc2l6ZSAlIDgpID09PSAwLCBcImludmFsaWQgXCIgKyBtYXRjaFsxXSArIFwiIGJpdCBsZW5ndGhcIiwgXCJwYXJhbVwiLCBwYXJhbSk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IE51bWJlckNvZGVyKHNpemUgLyA4LCAobWF0Y2hbMV0gPT09IFwiaW50XCIpLCBwYXJhbS5uYW1lKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBieXRlc1swLTldK1xuICAgICAgICBtYXRjaCA9IHBhcmFtLnR5cGUubWF0Y2gocGFyYW1UeXBlQnl0ZXMpO1xuICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgIGxldCBzaXplID0gcGFyc2VJbnQobWF0Y2hbMV0pO1xuICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoc2l6ZSAhPT0gMCAmJiBzaXplIDw9IDMyLCBcImludmFsaWQgYnl0ZXMgbGVuZ3RoXCIsIFwicGFyYW1cIiwgcGFyYW0pO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBGaXhlZEJ5dGVzQ29kZXIoc2l6ZSwgcGFyYW0ubmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgYXNzZXJ0QXJndW1lbnQoZmFsc2UsIFwiaW52YWxpZCB0eXBlXCIsIFwidHlwZVwiLCBwYXJhbS50eXBlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIEdldCB0aGUgZGVmYXVsdCB2YWx1ZXMgZm9yIHRoZSBnaXZlbiAlJXR5cGVzJSUuXG4gICAgICpcbiAgICAgKiAgRm9yIGV4YW1wbGUsIGEgYGB1aW50YGAgaXMgYnkgZGVmYXVsdCBgYDBgYCBhbmQgYGBib29sYGBcbiAgICAgKiAgaXMgYnkgZGVmYXVsdCBgYGZhbHNlYGAuXG4gICAgICovXG4gICAgZ2V0RGVmYXVsdFZhbHVlKHR5cGVzKSB7XG4gICAgICAgIGNvbnN0IGNvZGVycyA9IHR5cGVzLm1hcCgodHlwZSkgPT4gdGhpcy4jZ2V0Q29kZXIoUGFyYW1UeXBlLmZyb20odHlwZSkpKTtcbiAgICAgICAgY29uc3QgY29kZXIgPSBuZXcgVHVwbGVDb2Rlcihjb2RlcnMsIFwiX1wiKTtcbiAgICAgICAgcmV0dXJuIGNvZGVyLmRlZmF1bHRWYWx1ZSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgRW5jb2RlIHRoZSAlJXZhbHVlcyUlIGFzIHRoZSAlJXR5cGVzJSUgaW50byBBQkkgZGF0YS5cbiAgICAgKlxuICAgICAqICBAcmV0dXJucyBEYXRhSGV4c3RyaW5nXG4gICAgICovXG4gICAgZW5jb2RlKHR5cGVzLCB2YWx1ZXMpIHtcbiAgICAgICAgYXNzZXJ0QXJndW1lbnRDb3VudCh2YWx1ZXMubGVuZ3RoLCB0eXBlcy5sZW5ndGgsIFwidHlwZXMvdmFsdWVzIGxlbmd0aCBtaXNtYXRjaFwiKTtcbiAgICAgICAgY29uc3QgY29kZXJzID0gdHlwZXMubWFwKCh0eXBlKSA9PiB0aGlzLiNnZXRDb2RlcihQYXJhbVR5cGUuZnJvbSh0eXBlKSkpO1xuICAgICAgICBjb25zdCBjb2RlciA9IChuZXcgVHVwbGVDb2Rlcihjb2RlcnMsIFwiX1wiKSk7XG4gICAgICAgIGNvbnN0IHdyaXRlciA9IG5ldyBXcml0ZXIoKTtcbiAgICAgICAgY29kZXIuZW5jb2RlKHdyaXRlciwgdmFsdWVzKTtcbiAgICAgICAgcmV0dXJuIHdyaXRlci5kYXRhO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgRGVjb2RlIHRoZSBBQkkgJSVkYXRhJSUgYXMgdGhlICUldHlwZXMlJSBpbnRvIHZhbHVlcy5cbiAgICAgKlxuICAgICAqICBJZiAlJWxvb3NlJSUgZGVjb2RpbmcgaXMgZW5hYmxlZCwgdGhlbiBzdHJpY3QgcGFkZGluZyBpc1xuICAgICAqICBub3QgZW5mb3JjZWQuIFNvbWUgb2xkZXIgdmVyc2lvbnMgb2YgU29saWRpdHkgaW5jb3JyZWN0bHlcbiAgICAgKiAgcGFkZGVkIGV2ZW50IGRhdGEgZW1pdHRlZCBmcm9tIGBgZXh0ZXJuYWxgYCBmdW5jdGlvbnMuXG4gICAgICovXG4gICAgZGVjb2RlKHR5cGVzLCBkYXRhLCBsb29zZSkge1xuICAgICAgICBjb25zdCBjb2RlcnMgPSB0eXBlcy5tYXAoKHR5cGUpID0+IHRoaXMuI2dldENvZGVyKFBhcmFtVHlwZS5mcm9tKHR5cGUpKSk7XG4gICAgICAgIGNvbnN0IGNvZGVyID0gbmV3IFR1cGxlQ29kZXIoY29kZXJzLCBcIl9cIik7XG4gICAgICAgIHJldHVybiBjb2Rlci5kZWNvZGUobmV3IFJlYWRlcihkYXRhLCBsb29zZSwgZGVmYXVsdE1heEluZmxhdGlvbikpO1xuICAgIH1cbiAgICBzdGF0aWMgX3NldERlZmF1bHRNYXhJbmZsYXRpb24odmFsdWUpIHtcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQodHlwZW9mICh2YWx1ZSkgPT09IFwibnVtYmVyXCIgJiYgTnVtYmVyLmlzSW50ZWdlcih2YWx1ZSksIFwiaW52YWxpZCBkZWZhdWx0TWF4SW5mbGF0aW9uIGZhY3RvclwiLCBcInZhbHVlXCIsIHZhbHVlKTtcbiAgICAgICAgZGVmYXVsdE1heEluZmxhdGlvbiA9IHZhbHVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0aGUgc2hhcmVkIHNpbmdsZXRvbiBpbnN0YW5jZSBvZiBhIGRlZmF1bHQgW1tBYmlDb2Rlcl1dLlxuICAgICAqXG4gICAgICogIE9uIHRoZSBmaXJzdCBjYWxsLCB0aGUgaW5zdGFuY2UgaXMgY3JlYXRlZCBpbnRlcm5hbGx5LlxuICAgICAqL1xuICAgIHN0YXRpYyBkZWZhdWx0QWJpQ29kZXIoKSB7XG4gICAgICAgIGlmIChkZWZhdWx0Q29kZXIgPT0gbnVsbCkge1xuICAgICAgICAgICAgZGVmYXVsdENvZGVyID0gbmV3IEFiaUNvZGVyKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRlZmF1bHRDb2RlcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYW4gZXRoZXJzLWNvbXBhdGlibGUgW1tDYWxsRXhjZXB0aW9uRXJyb3JdXSBFcnJvciBmb3IgdGhlIGdpdmVuXG4gICAgICogIHJlc3VsdCAlJWRhdGElJSBmb3IgdGhlIFtbQ2FsbEV4Y2VwdGlvbkFjdGlvbl1dICUlYWN0aW9uJSUgYWdhaW5zdFxuICAgICAqICB0aGUgVHJhbnNhY3Rpb24gJSV0eCUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBnZXRCdWlsdGluQ2FsbEV4Y2VwdGlvbihhY3Rpb24sIHR4LCBkYXRhKSB7XG4gICAgICAgIHJldHVybiBnZXRCdWlsdGluQ2FsbEV4Y2VwdGlvbihhY3Rpb24sIHR4LCBkYXRhLCBBYmlDb2Rlci5kZWZhdWx0QWJpQ29kZXIoKSk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWJpLWNvZGVyLmpzLm1hcCJdLCJuYW1lcyI6WyJhc3NlcnRBcmd1bWVudENvdW50IiwiYXNzZXJ0QXJndW1lbnQiLCJSZWFkZXIiLCJXcml0ZXIiLCJBZGRyZXNzQ29kZXIiLCJBcnJheUNvZGVyIiwiQm9vbGVhbkNvZGVyIiwiQnl0ZXNDb2RlciIsIkZpeGVkQnl0ZXNDb2RlciIsIk51bGxDb2RlciIsIk51bWJlckNvZGVyIiwiU3RyaW5nQ29kZXIiLCJUdXBsZUNvZGVyIiwiUGFyYW1UeXBlIiwiZ2V0QWRkcmVzcyIsImdldEJ5dGVzIiwiaGV4bGlmeSIsIm1ha2VFcnJvciIsIlBhbmljUmVhc29ucyIsIk1hcCIsInNldCIsInBhcmFtVHlwZUJ5dGVzIiwiUmVnRXhwIiwicGFyYW1UeXBlTnVtYmVyIiwiZGVmYXVsdENvZGVyIiwiZGVmYXVsdE1heEluZmxhdGlvbiIsImdldEJ1aWx0aW5DYWxsRXhjZXB0aW9uIiwiYWN0aW9uIiwidHgiLCJkYXRhIiwiYWJpQ29kZXIiLCJtZXNzYWdlIiwicmVhc29uIiwiaW52b2NhdGlvbiIsInJldmVydCIsImJ5dGVzIiwibGVuZ3RoIiwic2xpY2UiLCJkZWNvZGUiLCJzaWduYXR1cmUiLCJuYW1lIiwiYXJncyIsIkpTT04iLCJzdHJpbmdpZnkiLCJlcnJvciIsImNvZGUiLCJOdW1iZXIiLCJnZXQiLCJ0cmFuc2FjdGlvbiIsInRvIiwiZnJvbSIsIkFiaUNvZGVyIiwiZ2V0Q29kZXIiLCJwYXJhbSIsImlzQXJyYXkiLCJhcnJheUNoaWxkcmVuIiwiYXJyYXlMZW5ndGgiLCJpc1R1cGxlIiwiY29tcG9uZW50cyIsIm1hcCIsImMiLCJiYXNlVHlwZSIsIm1hdGNoIiwidHlwZSIsInNpemUiLCJwYXJzZUludCIsImdldERlZmF1bHRWYWx1ZSIsInR5cGVzIiwiY29kZXJzIiwiY29kZXIiLCJkZWZhdWx0VmFsdWUiLCJlbmNvZGUiLCJ2YWx1ZXMiLCJ3cml0ZXIiLCJsb29zZSIsIl9zZXREZWZhdWx0TWF4SW5mbGF0aW9uIiwidmFsdWUiLCJpc0ludGVnZXIiLCJkZWZhdWx0QWJpQ29kZXIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.esm/abi/abi-coder.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.esm/abi/coders/abstract-coder.js":
/*!******************************************************************!*\
  !*** ./node_modules/ethers/lib.esm/abi/coders/abstract-coder.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Coder: () => (/* binding */ Coder),\n/* harmony export */   Reader: () => (/* binding */ Reader),\n/* harmony export */   Result: () => (/* binding */ Result),\n/* harmony export */   WordSize: () => (/* binding */ WordSize),\n/* harmony export */   Writer: () => (/* binding */ Writer),\n/* harmony export */   checkResultErrors: () => (/* binding */ checkResultErrors)\n/* harmony export */ });\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/maths.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/errors.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/data.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/properties.js\");\n\n/**\n * @_ignore:\n */ const WordSize = 32;\nconst Padding = new Uint8Array(WordSize);\n// Properties used to immediate pass through to the underlying object\n// - `then` is used to detect if an object is a Promise for await\nconst passProperties = [\n    \"then\"\n];\nconst _guard = {};\nconst resultNames = new WeakMap();\nfunction getNames(result) {\n    return resultNames.get(result);\n}\nfunction setNames(result, names) {\n    resultNames.set(result, names);\n}\nfunction throwError(name, error) {\n    const wrapped = new Error(`deferred error during ABI decoding triggered accessing ${name}`);\n    wrapped.error = error;\n    throw wrapped;\n}\nfunction toObject(names, items, deep) {\n    if (names.indexOf(null) >= 0) {\n        return items.map((item, index)=>{\n            if (item instanceof Result) {\n                return toObject(getNames(item), item, deep);\n            }\n            return item;\n        });\n    }\n    return names.reduce((accum, name, index)=>{\n        let item = items.getValue(name);\n        if (!(name in accum)) {\n            if (deep && item instanceof Result) {\n                item = toObject(getNames(item), item, deep);\n            }\n            accum[name] = item;\n        }\n        return accum;\n    }, {});\n}\n/**\n *  A [[Result]] is a sub-class of Array, which allows accessing any\n *  of its values either positionally by its index or, if keys are\n *  provided by its name.\n *\n *  @_docloc: api/abi\n */ class Result extends Array {\n    // No longer used; but cannot be removed as it will remove the\n    // #private field from the .d.ts which may break backwards\n    // compatibility\n    #names;\n    /**\n     *  @private\n     */ constructor(...args){\n        // To properly sub-class Array so the other built-in\n        // functions work, the constructor has to behave fairly\n        // well. So, in the event we are created via fromItems()\n        // we build the read-only Result object we want, but on\n        // any other input, we use the default constructor\n        // constructor(guard: any, items: Array<any>, keys?: Array<null | string>);\n        const guard = args[0];\n        let items = args[1];\n        let names = (args[2] || []).slice();\n        let wrap = true;\n        if (guard !== _guard) {\n            items = args;\n            names = [];\n            wrap = false;\n        }\n        // Can't just pass in ...items since an array of length 1\n        // is a special case in the super.\n        super(items.length);\n        items.forEach((item, index)=>{\n            this[index] = item;\n        });\n        // Find all unique keys\n        const nameCounts = names.reduce((accum, name)=>{\n            if (typeof name === \"string\") {\n                accum.set(name, (accum.get(name) || 0) + 1);\n            }\n            return accum;\n        }, new Map());\n        // Remove any key thats not unique\n        setNames(this, Object.freeze(items.map((item, index)=>{\n            const name = names[index];\n            if (name != null && nameCounts.get(name) === 1) {\n                return name;\n            }\n            return null;\n        })));\n        // Dummy operations to prevent TypeScript from complaining\n        this.#names = [];\n        if (this.#names == null) {\n            void this.#names;\n        }\n        if (!wrap) {\n            return;\n        }\n        // A wrapped Result is immutable\n        Object.freeze(this);\n        // Proxy indices and names so we can trap deferred errors\n        const proxy = new Proxy(this, {\n            get: (target, prop, receiver)=>{\n                if (typeof prop === \"string\") {\n                    // Index accessor\n                    if (prop.match(/^[0-9]+$/)) {\n                        const index = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getNumber)(prop, \"%index\");\n                        if (index < 0 || index >= this.length) {\n                            throw new RangeError(\"out of result range\");\n                        }\n                        const item = target[index];\n                        if (item instanceof Error) {\n                            throwError(`index ${index}`, item);\n                        }\n                        return item;\n                    }\n                    // Pass important checks (like `then` for Promise) through\n                    if (passProperties.indexOf(prop) >= 0) {\n                        return Reflect.get(target, prop, receiver);\n                    }\n                    const value = target[prop];\n                    if (value instanceof Function) {\n                        // Make sure functions work with private variables\n                        // See: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy#no_private_property_forwarding\n                        return function(...args) {\n                            return value.apply(this === receiver ? target : this, args);\n                        };\n                    } else if (!(prop in target)) {\n                        // Possible name accessor\n                        return target.getValue.apply(this === receiver ? target : this, [\n                            prop\n                        ]);\n                    }\n                }\n                return Reflect.get(target, prop, receiver);\n            }\n        });\n        setNames(proxy, getNames(this));\n        return proxy;\n    }\n    /**\n     *  Returns the Result as a normal Array. If %%deep%%, any children\n     *  which are Result objects are also converted to a normal Array.\n     *\n     *  This will throw if there are any outstanding deferred\n     *  errors.\n     */ toArray(deep) {\n        const result = [];\n        this.forEach((item, index)=>{\n            if (item instanceof Error) {\n                throwError(`index ${index}`, item);\n            }\n            if (deep && item instanceof Result) {\n                item = item.toArray(deep);\n            }\n            result.push(item);\n        });\n        return result;\n    }\n    /**\n     *  Returns the Result as an Object with each name-value pair. If\n     *  %%deep%%, any children which are Result objects are also\n     *  converted to an Object.\n     *\n     *  This will throw if any value is unnamed, or if there are\n     *  any outstanding deferred errors.\n     */ toObject(deep) {\n        const names = getNames(this);\n        return names.reduce((accum, name, index)=>{\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assert)(name != null, `value at index ${index} unnamed`, \"UNSUPPORTED_OPERATION\", {\n                operation: \"toObject()\"\n            });\n            return toObject(names, this, deep);\n        }, {});\n    }\n    /**\n     *  @_ignore\n     */ slice(start, end) {\n        if (start == null) {\n            start = 0;\n        }\n        if (start < 0) {\n            start += this.length;\n            if (start < 0) {\n                start = 0;\n            }\n        }\n        if (end == null) {\n            end = this.length;\n        }\n        if (end < 0) {\n            end += this.length;\n            if (end < 0) {\n                end = 0;\n            }\n        }\n        if (end > this.length) {\n            end = this.length;\n        }\n        const _names = getNames(this);\n        const result = [], names = [];\n        for(let i = start; i < end; i++){\n            result.push(this[i]);\n            names.push(_names[i]);\n        }\n        return new Result(_guard, result, names);\n    }\n    /**\n     *  @_ignore\n     */ filter(callback, thisArg) {\n        const _names = getNames(this);\n        const result = [], names = [];\n        for(let i = 0; i < this.length; i++){\n            const item = this[i];\n            if (item instanceof Error) {\n                throwError(`index ${i}`, item);\n            }\n            if (callback.call(thisArg, item, i, this)) {\n                result.push(item);\n                names.push(_names[i]);\n            }\n        }\n        return new Result(_guard, result, names);\n    }\n    /**\n     *  @_ignore\n     */ map(callback, thisArg) {\n        const result = [];\n        for(let i = 0; i < this.length; i++){\n            const item = this[i];\n            if (item instanceof Error) {\n                throwError(`index ${i}`, item);\n            }\n            result.push(callback.call(thisArg, item, i, this));\n        }\n        return result;\n    }\n    /**\n     *  Returns the value for %%name%%.\n     *\n     *  Since it is possible to have a key whose name conflicts with\n     *  a method on a [[Result]] or its superclass Array, or any\n     *  JavaScript keyword, this ensures all named values are still\n     *  accessible by name.\n     */ getValue(name) {\n        const index = getNames(this).indexOf(name);\n        if (index === -1) {\n            return undefined;\n        }\n        const value = this[index];\n        if (value instanceof Error) {\n            throwError(`property ${JSON.stringify(name)}`, value.error);\n        }\n        return value;\n    }\n    /**\n     *  Creates a new [[Result]] for %%items%% with each entry\n     *  also accessible by its corresponding name in %%keys%%.\n     */ static fromItems(items, keys) {\n        return new Result(_guard, items, keys);\n    }\n}\n/**\n *  Returns all errors found in a [[Result]].\n *\n *  Since certain errors encountered when creating a [[Result]] do\n *  not impact the ability to continue parsing data, they are\n *  deferred until they are actually accessed. Hence a faulty string\n *  in an Event that is never used does not impact the program flow.\n *\n *  However, sometimes it may be useful to access, identify or\n *  validate correctness of a [[Result]].\n *\n *  @_docloc api/abi\n */ function checkResultErrors(result) {\n    // Find the first error (if any)\n    const errors = [];\n    const checkErrors = function(path, object) {\n        if (!Array.isArray(object)) {\n            return;\n        }\n        for(let key in object){\n            const childPath = path.slice();\n            childPath.push(key);\n            try {\n                checkErrors(childPath, object[key]);\n            } catch (error) {\n                errors.push({\n                    path: childPath,\n                    error: error\n                });\n            }\n        }\n    };\n    checkErrors([], result);\n    return errors;\n}\nfunction getValue(value) {\n    let bytes = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.toBeArray)(value);\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assert)(bytes.length <= WordSize, \"value out-of-bounds\", \"BUFFER_OVERRUN\", {\n        buffer: bytes,\n        length: WordSize,\n        offset: bytes.length\n    });\n    if (bytes.length !== WordSize) {\n        bytes = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.getBytesCopy)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.concat)([\n            Padding.slice(bytes.length % WordSize),\n            bytes\n        ]));\n    }\n    return bytes;\n}\n/**\n *  @_ignore\n */ class Coder {\n    constructor(name, type, localName, dynamic){\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.defineProperties)(this, {\n            name,\n            type,\n            localName,\n            dynamic\n        }, {\n            name: \"string\",\n            type: \"string\",\n            localName: \"string\",\n            dynamic: \"boolean\"\n        });\n    }\n    _throwError(message, value) {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(false, message, this.localName, value);\n    }\n}\n/**\n *  @_ignore\n */ class Writer {\n    // An array of WordSize lengthed objects to concatenation\n    #data;\n    #dataLength;\n    constructor(){\n        this.#data = [];\n        this.#dataLength = 0;\n    }\n    get data() {\n        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.concat)(this.#data);\n    }\n    get length() {\n        return this.#dataLength;\n    }\n    #writeData(data) {\n        this.#data.push(data);\n        this.#dataLength += data.length;\n        return data.length;\n    }\n    appendWriter(writer) {\n        return this.#writeData((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.getBytesCopy)(writer.data));\n    }\n    // Arrayish item; pad on the right to *nearest* WordSize\n    writeBytes(value) {\n        let bytes = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.getBytesCopy)(value);\n        const paddingOffset = bytes.length % WordSize;\n        if (paddingOffset) {\n            bytes = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.getBytesCopy)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.concat)([\n                bytes,\n                Padding.slice(paddingOffset)\n            ]));\n        }\n        return this.#writeData(bytes);\n    }\n    // Numeric item; pad on the left *to* WordSize\n    writeValue(value) {\n        return this.#writeData(getValue(value));\n    }\n    // Inserts a numeric place-holder, returning a callback that can\n    // be used to asjust the value later\n    writeUpdatableValue() {\n        const offset = this.#data.length;\n        this.#data.push(Padding);\n        this.#dataLength += WordSize;\n        return (value)=>{\n            this.#data[offset] = getValue(value);\n        };\n    }\n}\n/**\n *  @_ignore\n */ class Reader {\n    #data;\n    #offset;\n    #bytesRead;\n    #parent;\n    #maxInflation;\n    constructor(data, allowLoose, maxInflation){\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.defineProperties)(this, {\n            allowLoose: !!allowLoose\n        });\n        this.#data = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.getBytesCopy)(data);\n        this.#bytesRead = 0;\n        this.#parent = null;\n        this.#maxInflation = maxInflation != null ? maxInflation : 1024;\n        this.#offset = 0;\n    }\n    get data() {\n        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.hexlify)(this.#data);\n    }\n    get dataLength() {\n        return this.#data.length;\n    }\n    get consumed() {\n        return this.#offset;\n    }\n    get bytes() {\n        return new Uint8Array(this.#data);\n    }\n    #incrementBytesRead(count) {\n        if (this.#parent) {\n            return this.#parent.#incrementBytesRead(count);\n        }\n        this.#bytesRead += count;\n        // Check for excessive inflation (see: #4537)\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assert)(this.#maxInflation < 1 || this.#bytesRead <= this.#maxInflation * this.dataLength, `compressed ABI data exceeds inflation ratio of ${this.#maxInflation} ( see: https:/\\/github.com/ethers-io/ethers.js/issues/4537 )`, \"BUFFER_OVERRUN\", {\n            buffer: (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.getBytesCopy)(this.#data),\n            offset: this.#offset,\n            length: count,\n            info: {\n                bytesRead: this.#bytesRead,\n                dataLength: this.dataLength\n            }\n        });\n    }\n    #peekBytes(offset, length, loose) {\n        let alignedLength = Math.ceil(length / WordSize) * WordSize;\n        if (this.#offset + alignedLength > this.#data.length) {\n            if (this.allowLoose && loose && this.#offset + length <= this.#data.length) {\n                alignedLength = length;\n            } else {\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assert)(false, \"data out-of-bounds\", \"BUFFER_OVERRUN\", {\n                    buffer: (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.getBytesCopy)(this.#data),\n                    length: this.#data.length,\n                    offset: this.#offset + alignedLength\n                });\n            }\n        }\n        return this.#data.slice(this.#offset, this.#offset + alignedLength);\n    }\n    // Create a sub-reader with the same underlying data, but offset\n    subReader(offset) {\n        const reader = new Reader(this.#data.slice(this.#offset + offset), this.allowLoose, this.#maxInflation);\n        reader.#parent = this;\n        return reader;\n    }\n    // Read bytes\n    readBytes(length, loose) {\n        let bytes = this.#peekBytes(0, length, !!loose);\n        this.#incrementBytesRead(length);\n        this.#offset += bytes.length;\n        // @TODO: Make sure the length..end bytes are all 0?\n        return bytes.slice(0, length);\n    }\n    // Read a numeric values\n    readValue() {\n        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.toBigInt)(this.readBytes(WordSize));\n    }\n    readIndex() {\n        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.toNumber)(this.readBytes(WordSize));\n    }\n} //# sourceMappingURL=abstract-coder.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vYWJpL2NvZGVycy9hYnN0cmFjdC1jb2Rlci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7O0FBRStCO0FBQy9COztDQUVDLEdBQ00sTUFBTVUsV0FBVyxHQUFHO0FBQzNCLE1BQU1DLFVBQVUsSUFBSUMsV0FBV0Y7QUFDL0IscUVBQXFFO0FBQ3JFLGlFQUFpRTtBQUNqRSxNQUFNRyxpQkFBaUI7SUFBQztDQUFPO0FBQy9CLE1BQU1DLFNBQVMsQ0FBQztBQUNoQixNQUFNQyxjQUFjLElBQUlDO0FBQ3hCLFNBQVNDLFNBQVNDLE1BQU07SUFDcEIsT0FBT0gsWUFBWUksR0FBRyxDQUFDRDtBQUMzQjtBQUNBLFNBQVNFLFNBQVNGLE1BQU0sRUFBRUcsS0FBSztJQUMzQk4sWUFBWU8sR0FBRyxDQUFDSixRQUFRRztBQUM1QjtBQUNBLFNBQVNFLFdBQVdDLElBQUksRUFBRUMsS0FBSztJQUMzQixNQUFNQyxVQUFVLElBQUlDLE1BQU0sQ0FBQyx1REFBdUQsRUFBRUgsS0FBSyxDQUFDO0lBQzFGRSxRQUFRRCxLQUFLLEdBQUdBO0lBQ2hCLE1BQU1DO0FBQ1Y7QUFDQSxTQUFTRSxTQUFTUCxLQUFLLEVBQUVRLEtBQUssRUFBRUMsSUFBSTtJQUNoQyxJQUFJVCxNQUFNVSxPQUFPLENBQUMsU0FBUyxHQUFHO1FBQzFCLE9BQU9GLE1BQU1HLEdBQUcsQ0FBQyxDQUFDQyxNQUFNQztZQUNwQixJQUFJRCxnQkFBZ0JFLFFBQVE7Z0JBQ3hCLE9BQU9QLFNBQVNYLFNBQVNnQixPQUFPQSxNQUFNSDtZQUMxQztZQUNBLE9BQU9HO1FBQ1g7SUFDSjtJQUNBLE9BQU9aLE1BQU1lLE1BQU0sQ0FBQyxDQUFDQyxPQUFPYixNQUFNVTtRQUM5QixJQUFJRCxPQUFPSixNQUFNUyxRQUFRLENBQUNkO1FBQzFCLElBQUksQ0FBRUEsQ0FBQUEsUUFBUWEsS0FBSSxHQUFJO1lBQ2xCLElBQUlQLFFBQVFHLGdCQUFnQkUsUUFBUTtn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R0FBR3JFLFFBQVEsQ0FBQyxDQUFDc0U7UUFDekMsSUFBSSxDQUFDLENBQUNKLGtCQUFrQixDQUFDbEU7UUFDekIsSUFBSSxDQUFDLENBQUMyQyxNQUFNLElBQUlGLE1BQU16QyxNQUFNO1FBQzVCLG9EQUFvRDtRQUNwRCxPQUFPeUMsTUFBTTNDLEtBQUssQ0FBQyxHQUFHRTtJQUMxQjtJQUNBLHdCQUF3QjtJQUN4QjZFLFlBQVk7UUFDUixPQUFPcEgseURBQVFBLENBQUMsSUFBSSxDQUFDbUgsU0FBUyxDQUFDL0c7SUFDbkM7SUFDQWlILFlBQVk7UUFDUixPQUFPcEgseURBQVFBLENBQUMsSUFBSSxDQUFDa0gsU0FBUyxDQUFDL0c7SUFDbkM7QUFDSixFQUNBLDBDQUEwQyIsInNvdXJjZXMiOlsid2VicGFjazovL21lZ2F2aWJlLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL2FiaS9jb2RlcnMvYWJzdHJhY3QtY29kZXIuanM/Y2VmMCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBkZWZpbmVQcm9wZXJ0aWVzLCBjb25jYXQsIGdldEJ5dGVzQ29weSwgZ2V0TnVtYmVyLCBoZXhsaWZ5LCB0b0JlQXJyYXksIHRvQmlnSW50LCB0b051bWJlciwgYXNzZXJ0LCBhc3NlcnRBcmd1bWVudFxuLyosIGlzRXJyb3IqL1xuIH0gZnJvbSBcIi4uLy4uL3V0aWxzL2luZGV4LmpzXCI7XG4vKipcbiAqIEBfaWdub3JlOlxuICovXG5leHBvcnQgY29uc3QgV29yZFNpemUgPSAzMjtcbmNvbnN0IFBhZGRpbmcgPSBuZXcgVWludDhBcnJheShXb3JkU2l6ZSk7XG4vLyBQcm9wZXJ0aWVzIHVzZWQgdG8gaW1tZWRpYXRlIHBhc3MgdGhyb3VnaCB0byB0aGUgdW5kZXJseWluZyBvYmplY3Rcbi8vIC0gYHRoZW5gIGlzIHVzZWQgdG8gZGV0ZWN0IGlmIGFuIG9iamVjdCBpcyBhIFByb21pc2UgZm9yIGF3YWl0XG5jb25zdCBwYXNzUHJvcGVydGllcyA9IFtcInRoZW5cIl07XG5jb25zdCBfZ3VhcmQgPSB7fTtcbmNvbnN0IHJlc3VsdE5hbWVzID0gbmV3IFdlYWtNYXAoKTtcbmZ1bmN0aW9uIGdldE5hbWVzKHJlc3VsdCkge1xuICAgIHJldHVybiByZXN1bHROYW1lcy5nZXQocmVzdWx0KTtcbn1cbmZ1bmN0aW9uIHNldE5hbWVzKHJlc3VsdCwgbmFtZXMpIHtcbiAgICByZXN1bHROYW1lcy5zZXQocmVzdWx0LCBuYW1lcyk7XG59XG5mdW5jdGlvbiB0aHJvd0Vycm9yKG5hbWUsIGVycm9yKSB7XG4gICAgY29uc3Qgd3JhcHBlZCA9IG5ldyBFcnJvcihgZGVmZXJyZWQgZXJyb3IgZHVyaW5nIEFCSSBkZWNvZGluZyB0cmlnZ2VyZWQgYWNjZXNzaW5nICR7bmFtZX1gKTtcbiAgICB3cmFwcGVkLmVycm9yID0gZXJyb3I7XG4gICAgdGhyb3cgd3JhcHBlZDtcbn1cbmZ1bmN0aW9uIHRvT2JqZWN0KG5hbWVzLCBpdGVtcywgZGVlcCkge1xuICAgIGlmIChuYW1lcy5pbmRleE9mKG51bGwpID49IDApIHtcbiAgICAgICAgcmV0dXJuIGl0ZW1zLm1hcCgoaXRlbSwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgIGlmIChpdGVtIGluc3RhbmNlb2YgUmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRvT2JqZWN0KGdldE5hbWVzKGl0ZW0pLCBpdGVtLCBkZWVwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIG5hbWVzLnJlZHVjZSgoYWNjdW0sIG5hbWUsIGluZGV4KSA9PiB7XG4gICAgICAgIGxldCBpdGVtID0gaXRlbXMuZ2V0VmFsdWUobmFtZSk7XG4gICAgICAgIGlmICghKG5hbWUgaW4gYWNjdW0pKSB7XG4gICAgICAgICAgICBpZiAoZGVlcCAmJiBpdGVtIGluc3RhbmNlb2YgUmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgaXRlbSA9IHRvT2JqZWN0KGdldE5hbWVzKGl0ZW0pLCBpdGVtLCBkZWVwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFjY3VtW25hbWVdID0gaXRlbTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYWNjdW07XG4gICAgfSwge30pO1xufVxuLyoqXG4gKiAgQSBbW1Jlc3VsdF1dIGlzIGEgc3ViLWNsYXNzIG9mIEFycmF5LCB3aGljaCBhbGxvd3MgYWNjZXNzaW5nIGFueVxuICogIG9mIGl0cyB2YWx1ZXMgZWl0aGVyIHBvc2l0aW9uYWxseSBieSBpdHMgaW5kZXggb3IsIGlmIGtleXMgYXJlXG4gKiAgcHJvdmlkZWQgYnkgaXRzIG5hbWUuXG4gKlxuICogIEBfZG9jbG9jOiBhcGkvYWJpXG4gKi9cbmV4cG9ydCBjbGFzcyBSZXN1bHQgZXh0ZW5kcyBBcnJheSB7XG4gICAgLy8gTm8gbG9uZ2VyIHVzZWQ7IGJ1dCBjYW5ub3QgYmUgcmVtb3ZlZCBhcyBpdCB3aWxsIHJlbW92ZSB0aGVcbiAgICAvLyAjcHJpdmF0ZSBmaWVsZCBmcm9tIHRoZSAuZC50cyB3aGljaCBtYXkgYnJlYWsgYmFja3dhcmRzXG4gICAgLy8gY29tcGF0aWJpbGl0eVxuICAgICNuYW1lcztcbiAgICAvKipcbiAgICAgKiAgQHByaXZhdGVcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvciguLi5hcmdzKSB7XG4gICAgICAgIC8vIFRvIHByb3Blcmx5IHN1Yi1jbGFzcyBBcnJheSBzbyB0aGUgb3RoZXIgYnVpbHQtaW5cbiAgICAgICAgLy8gZnVuY3Rpb25zIHdvcmssIHRoZSBjb25zdHJ1Y3RvciBoYXMgdG8gYmVoYXZlIGZhaXJseVxuICAgICAgICAvLyB3ZWxsLiBTbywgaW4gdGhlIGV2ZW50IHdlIGFyZSBjcmVhdGVkIHZpYSBmcm9tSXRlbXMoKVxuICAgICAgICAvLyB3ZSBidWlsZCB0aGUgcmVhZC1vbmx5IFJlc3VsdCBvYmplY3Qgd2Ugd2FudCwgYnV0IG9uXG4gICAgICAgIC8vIGFueSBvdGhlciBpbnB1dCwgd2UgdXNlIHRoZSBkZWZhdWx0IGNvbnN0cnVjdG9yXG4gICAgICAgIC8vIGNvbnN0cnVjdG9yKGd1YXJkOiBhbnksIGl0ZW1zOiBBcnJheTxhbnk+LCBrZXlzPzogQXJyYXk8bnVsbCB8IHN0cmluZz4pO1xuICAgICAgICBjb25zdCBndWFyZCA9IGFyZ3NbMF07XG4gICAgICAgIGxldCBpdGVtcyA9IGFyZ3NbMV07XG4gICAgICAgIGxldCBuYW1lcyA9IChhcmdzWzJdIHx8IFtdKS5zbGljZSgpO1xuICAgICAgICBsZXQgd3JhcCA9IHRydWU7XG4gICAgICAgIGlmIChndWFyZCAhPT0gX2d1YXJkKSB7XG4gICAgICAgICAgICBpdGVtcyA9IGFyZ3M7XG4gICAgICAgICAgICBuYW1lcyA9IFtdO1xuICAgICAgICAgICAgd3JhcCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIENhbid0IGp1c3QgcGFzcyBpbiAuLi5pdGVtcyBzaW5jZSBhbiBhcnJheSBvZiBsZW5ndGggMVxuICAgICAgICAvLyBpcyBhIHNwZWNpYWwgY2FzZSBpbiB0aGUgc3VwZXIuXG4gICAgICAgIHN1cGVyKGl0ZW1zLmxlbmd0aCk7XG4gICAgICAgIGl0ZW1zLmZvckVhY2goKGl0ZW0sIGluZGV4KSA9PiB7IHRoaXNbaW5kZXhdID0gaXRlbTsgfSk7XG4gICAgICAgIC8vIEZpbmQgYWxsIHVuaXF1ZSBrZXlzXG4gICAgICAgIGNvbnN0IG5hbWVDb3VudHMgPSBuYW1lcy5yZWR1Y2UoKGFjY3VtLCBuYW1lKSA9PiB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIChuYW1lKSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgIGFjY3VtLnNldChuYW1lLCAoYWNjdW0uZ2V0KG5hbWUpIHx8IDApICsgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYWNjdW07XG4gICAgICAgIH0sIChuZXcgTWFwKCkpKTtcbiAgICAgICAgLy8gUmVtb3ZlIGFueSBrZXkgdGhhdHMgbm90IHVuaXF1ZVxuICAgICAgICBzZXROYW1lcyh0aGlzLCBPYmplY3QuZnJlZXplKGl0ZW1zLm1hcCgoaXRlbSwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG5hbWUgPSBuYW1lc1tpbmRleF07XG4gICAgICAgICAgICBpZiAobmFtZSAhPSBudWxsICYmIG5hbWVDb3VudHMuZ2V0KG5hbWUpID09PSAxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5hbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfSkpKTtcbiAgICAgICAgLy8gRHVtbXkgb3BlcmF0aW9ucyB0byBwcmV2ZW50IFR5cGVTY3JpcHQgZnJvbSBjb21wbGFpbmluZ1xuICAgICAgICB0aGlzLiNuYW1lcyA9IFtdO1xuICAgICAgICBpZiAodGhpcy4jbmFtZXMgPT0gbnVsbCkge1xuICAgICAgICAgICAgdm9pZCAodGhpcy4jbmFtZXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghd3JhcCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIEEgd3JhcHBlZCBSZXN1bHQgaXMgaW1tdXRhYmxlXG4gICAgICAgIE9iamVjdC5mcmVlemUodGhpcyk7XG4gICAgICAgIC8vIFByb3h5IGluZGljZXMgYW5kIG5hbWVzIHNvIHdlIGNhbiB0cmFwIGRlZmVycmVkIGVycm9yc1xuICAgICAgICBjb25zdCBwcm94eSA9IG5ldyBQcm94eSh0aGlzLCB7XG4gICAgICAgICAgICBnZXQ6ICh0YXJnZXQsIHByb3AsIHJlY2VpdmVyKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiAocHJvcCkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSW5kZXggYWNjZXNzb3JcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByb3AubWF0Y2goL15bMC05XSskLykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gZ2V0TnVtYmVyKHByb3AsIFwiJWluZGV4XCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGluZGV4IDwgMCB8fCBpbmRleCA+PSB0aGlzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwib3V0IG9mIHJlc3VsdCByYW5nZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGl0ZW0gPSB0YXJnZXRbaW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGl0ZW0gaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93RXJyb3IoYGluZGV4ICR7aW5kZXh9YCwgaXRlbSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBQYXNzIGltcG9ydGFudCBjaGVja3MgKGxpa2UgYHRoZW5gIGZvciBQcm9taXNlKSB0aHJvdWdoXG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXNzUHJvcGVydGllcy5pbmRleE9mKHByb3ApID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBSZWZsZWN0LmdldCh0YXJnZXQsIHByb3AsIHJlY2VpdmVyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHRhcmdldFtwcm9wXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgRnVuY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSBmdW5jdGlvbnMgd29yayB3aXRoIHByaXZhdGUgdmFyaWFibGVzXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBTZWU6IGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL1Byb3h5I25vX3ByaXZhdGVfcHJvcGVydHlfZm9yd2FyZGluZ1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlLmFwcGx5KCh0aGlzID09PSByZWNlaXZlcikgPyB0YXJnZXQgOiB0aGlzLCBhcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoIShwcm9wIGluIHRhcmdldCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFBvc3NpYmxlIG5hbWUgYWNjZXNzb3JcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0YXJnZXQuZ2V0VmFsdWUuYXBwbHkoKHRoaXMgPT09IHJlY2VpdmVyKSA/IHRhcmdldCA6IHRoaXMsIFtwcm9wXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIFJlZmxlY3QuZ2V0KHRhcmdldCwgcHJvcCwgcmVjZWl2ZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgc2V0TmFtZXMocHJveHksIGdldE5hbWVzKHRoaXMpKTtcbiAgICAgICAgcmV0dXJuIHByb3h5O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0aGUgUmVzdWx0IGFzIGEgbm9ybWFsIEFycmF5LiBJZiAlJWRlZXAlJSwgYW55IGNoaWxkcmVuXG4gICAgICogIHdoaWNoIGFyZSBSZXN1bHQgb2JqZWN0cyBhcmUgYWxzbyBjb252ZXJ0ZWQgdG8gYSBub3JtYWwgQXJyYXkuXG4gICAgICpcbiAgICAgKiAgVGhpcyB3aWxsIHRocm93IGlmIHRoZXJlIGFyZSBhbnkgb3V0c3RhbmRpbmcgZGVmZXJyZWRcbiAgICAgKiAgZXJyb3JzLlxuICAgICAqL1xuICAgIHRvQXJyYXkoZGVlcCkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICAgICAgdGhpcy5mb3JFYWNoKChpdGVtLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgaWYgKGl0ZW0gaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgICAgIHRocm93RXJyb3IoYGluZGV4ICR7aW5kZXh9YCwgaXRlbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGVlcCAmJiBpdGVtIGluc3RhbmNlb2YgUmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgaXRlbSA9IGl0ZW0udG9BcnJheShkZWVwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGl0ZW0pO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdGhlIFJlc3VsdCBhcyBhbiBPYmplY3Qgd2l0aCBlYWNoIG5hbWUtdmFsdWUgcGFpci4gSWZcbiAgICAgKiAgJSVkZWVwJSUsIGFueSBjaGlsZHJlbiB3aGljaCBhcmUgUmVzdWx0IG9iamVjdHMgYXJlIGFsc29cbiAgICAgKiAgY29udmVydGVkIHRvIGFuIE9iamVjdC5cbiAgICAgKlxuICAgICAqICBUaGlzIHdpbGwgdGhyb3cgaWYgYW55IHZhbHVlIGlzIHVubmFtZWQsIG9yIGlmIHRoZXJlIGFyZVxuICAgICAqICBhbnkgb3V0c3RhbmRpbmcgZGVmZXJyZWQgZXJyb3JzLlxuICAgICAqL1xuICAgIHRvT2JqZWN0KGRlZXApIHtcbiAgICAgICAgY29uc3QgbmFtZXMgPSBnZXROYW1lcyh0aGlzKTtcbiAgICAgICAgcmV0dXJuIG5hbWVzLnJlZHVjZSgoYWNjdW0sIG5hbWUsIGluZGV4KSA9PiB7XG4gICAgICAgICAgICBhc3NlcnQobmFtZSAhPSBudWxsLCBgdmFsdWUgYXQgaW5kZXggJHtpbmRleH0gdW5uYW1lZGAsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHtcbiAgICAgICAgICAgICAgICBvcGVyYXRpb246IFwidG9PYmplY3QoKVwiXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiB0b09iamVjdChuYW1lcywgdGhpcywgZGVlcCk7XG4gICAgICAgIH0sIHt9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIEBfaWdub3JlXG4gICAgICovXG4gICAgc2xpY2Uoc3RhcnQsIGVuZCkge1xuICAgICAgICBpZiAoc3RhcnQgPT0gbnVsbCkge1xuICAgICAgICAgICAgc3RhcnQgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGFydCA8IDApIHtcbiAgICAgICAgICAgIHN0YXJ0ICs9IHRoaXMubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKHN0YXJ0IDwgMCkge1xuICAgICAgICAgICAgICAgIHN0YXJ0ID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZW5kID09IG51bGwpIHtcbiAgICAgICAgICAgIGVuZCA9IHRoaXMubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlbmQgPCAwKSB7XG4gICAgICAgICAgICBlbmQgKz0gdGhpcy5sZW5ndGg7XG4gICAgICAgICAgICBpZiAoZW5kIDwgMCkge1xuICAgICAgICAgICAgICAgIGVuZCA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVuZCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBlbmQgPSB0aGlzLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBfbmFtZXMgPSBnZXROYW1lcyh0aGlzKTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gW10sIG5hbWVzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaCh0aGlzW2ldKTtcbiAgICAgICAgICAgIG5hbWVzLnB1c2goX25hbWVzW2ldKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFJlc3VsdChfZ3VhcmQsIHJlc3VsdCwgbmFtZXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQF9pZ25vcmVcbiAgICAgKi9cbiAgICBmaWx0ZXIoY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICAgICAgY29uc3QgX25hbWVzID0gZ2V0TmFtZXModGhpcyk7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IFtdLCBuYW1lcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGl0ZW0gPSB0aGlzW2ldO1xuICAgICAgICAgICAgaWYgKGl0ZW0gaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgICAgIHRocm93RXJyb3IoYGluZGV4ICR7aX1gLCBpdGVtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjYWxsYmFjay5jYWxsKHRoaXNBcmcsIGl0ZW0sIGksIHRoaXMpKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goaXRlbSk7XG4gICAgICAgICAgICAgICAgbmFtZXMucHVzaChfbmFtZXNbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgUmVzdWx0KF9ndWFyZCwgcmVzdWx0LCBuYW1lcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBAX2lnbm9yZVxuICAgICAqL1xuICAgIG1hcChjYWxsYmFjaywgdGhpc0FyZykge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBpdGVtID0gdGhpc1tpXTtcbiAgICAgICAgICAgIGlmIChpdGVtIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgICAgICB0aHJvd0Vycm9yKGBpbmRleCAke2l9YCwgaXRlbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQucHVzaChjYWxsYmFjay5jYWxsKHRoaXNBcmcsIGl0ZW0sIGksIHRoaXMpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0aGUgdmFsdWUgZm9yICUlbmFtZSUlLlxuICAgICAqXG4gICAgICogIFNpbmNlIGl0IGlzIHBvc3NpYmxlIHRvIGhhdmUgYSBrZXkgd2hvc2UgbmFtZSBjb25mbGljdHMgd2l0aFxuICAgICAqICBhIG1ldGhvZCBvbiBhIFtbUmVzdWx0XV0gb3IgaXRzIHN1cGVyY2xhc3MgQXJyYXksIG9yIGFueVxuICAgICAqICBKYXZhU2NyaXB0IGtleXdvcmQsIHRoaXMgZW5zdXJlcyBhbGwgbmFtZWQgdmFsdWVzIGFyZSBzdGlsbFxuICAgICAqICBhY2Nlc3NpYmxlIGJ5IG5hbWUuXG4gICAgICovXG4gICAgZ2V0VmFsdWUobmFtZSkge1xuICAgICAgICBjb25zdCBpbmRleCA9IGdldE5hbWVzKHRoaXMpLmluZGV4T2YobmFtZSk7XG4gICAgICAgIGlmIChpbmRleCA9PT0gLTEpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzW2luZGV4XTtcbiAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93RXJyb3IoYHByb3BlcnR5ICR7SlNPTi5zdHJpbmdpZnkobmFtZSl9YCwgdmFsdWUuZXJyb3IpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIENyZWF0ZXMgYSBuZXcgW1tSZXN1bHRdXSBmb3IgJSVpdGVtcyUlIHdpdGggZWFjaCBlbnRyeVxuICAgICAqICBhbHNvIGFjY2Vzc2libGUgYnkgaXRzIGNvcnJlc3BvbmRpbmcgbmFtZSBpbiAlJWtleXMlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbUl0ZW1zKGl0ZW1zLCBrZXlzKSB7XG4gICAgICAgIHJldHVybiBuZXcgUmVzdWx0KF9ndWFyZCwgaXRlbXMsIGtleXMpO1xuICAgIH1cbn1cbi8qKlxuICogIFJldHVybnMgYWxsIGVycm9ycyBmb3VuZCBpbiBhIFtbUmVzdWx0XV0uXG4gKlxuICogIFNpbmNlIGNlcnRhaW4gZXJyb3JzIGVuY291bnRlcmVkIHdoZW4gY3JlYXRpbmcgYSBbW1Jlc3VsdF1dIGRvXG4gKiAgbm90IGltcGFjdCB0aGUgYWJpbGl0eSB0byBjb250aW51ZSBwYXJzaW5nIGRhdGEsIHRoZXkgYXJlXG4gKiAgZGVmZXJyZWQgdW50aWwgdGhleSBhcmUgYWN0dWFsbHkgYWNjZXNzZWQuIEhlbmNlIGEgZmF1bHR5IHN0cmluZ1xuICogIGluIGFuIEV2ZW50IHRoYXQgaXMgbmV2ZXIgdXNlZCBkb2VzIG5vdCBpbXBhY3QgdGhlIHByb2dyYW0gZmxvdy5cbiAqXG4gKiAgSG93ZXZlciwgc29tZXRpbWVzIGl0IG1heSBiZSB1c2VmdWwgdG8gYWNjZXNzLCBpZGVudGlmeSBvclxuICogIHZhbGlkYXRlIGNvcnJlY3RuZXNzIG9mIGEgW1tSZXN1bHRdXS5cbiAqXG4gKiAgQF9kb2Nsb2MgYXBpL2FiaVxuICovXG5leHBvcnQgZnVuY3Rpb24gY2hlY2tSZXN1bHRFcnJvcnMocmVzdWx0KSB7XG4gICAgLy8gRmluZCB0aGUgZmlyc3QgZXJyb3IgKGlmIGFueSlcbiAgICBjb25zdCBlcnJvcnMgPSBbXTtcbiAgICBjb25zdCBjaGVja0Vycm9ycyA9IGZ1bmN0aW9uIChwYXRoLCBvYmplY3QpIHtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG9iamVjdCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBrZXkgaW4gb2JqZWN0KSB7XG4gICAgICAgICAgICBjb25zdCBjaGlsZFBhdGggPSBwYXRoLnNsaWNlKCk7XG4gICAgICAgICAgICBjaGlsZFBhdGgucHVzaChrZXkpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjaGVja0Vycm9ycyhjaGlsZFBhdGgsIG9iamVjdFtrZXldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGVycm9ycy5wdXNoKHsgcGF0aDogY2hpbGRQYXRoLCBlcnJvcjogZXJyb3IgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGNoZWNrRXJyb3JzKFtdLCByZXN1bHQpO1xuICAgIHJldHVybiBlcnJvcnM7XG59XG5mdW5jdGlvbiBnZXRWYWx1ZSh2YWx1ZSkge1xuICAgIGxldCBieXRlcyA9IHRvQmVBcnJheSh2YWx1ZSk7XG4gICAgYXNzZXJ0KGJ5dGVzLmxlbmd0aCA8PSBXb3JkU2l6ZSwgXCJ2YWx1ZSBvdXQtb2YtYm91bmRzXCIsIFwiQlVGRkVSX09WRVJSVU5cIiwgeyBidWZmZXI6IGJ5dGVzLCBsZW5ndGg6IFdvcmRTaXplLCBvZmZzZXQ6IGJ5dGVzLmxlbmd0aCB9KTtcbiAgICBpZiAoYnl0ZXMubGVuZ3RoICE9PSBXb3JkU2l6ZSkge1xuICAgICAgICBieXRlcyA9IGdldEJ5dGVzQ29weShjb25jYXQoW1BhZGRpbmcuc2xpY2UoYnl0ZXMubGVuZ3RoICUgV29yZFNpemUpLCBieXRlc10pKTtcbiAgICB9XG4gICAgcmV0dXJuIGJ5dGVzO1xufVxuLyoqXG4gKiAgQF9pZ25vcmVcbiAqL1xuZXhwb3J0IGNsYXNzIENvZGVyIHtcbiAgICAvLyBUaGUgY29kZXIgbmFtZTpcbiAgICAvLyAgIC0gYWRkcmVzcywgdWludDI1NiwgdHVwbGUsIGFycmF5LCBldGMuXG4gICAgbmFtZTtcbiAgICAvLyBUaGUgZnVsbHkgZXhwYW5kZWQgdHlwZSwgaW5jbHVkaW5nIGNvbXBvc2l0ZSB0eXBlczpcbiAgICAvLyAgIC0gYWRkcmVzcywgdWludDI1NiwgdHVwbGUoYWRkcmVzcyxieXRlcyksIHVpbnQyNTZbM11bNF1bXSwgIGV0Yy5cbiAgICB0eXBlO1xuICAgIC8vIFRoZSBsb2NhbE5hbWUgYm91bmQgaW4gdGhlIHNpZ25hdHVyZSwgaW4gdGhpcyBleGFtcGxlIGl0IGlzIFwiYmF6XCI6XG4gICAgLy8gICAtIHR1cGxlKGFkZHJlc3MgZm9vLCB1aW50IGJhcikgYmF6XG4gICAgbG9jYWxOYW1lO1xuICAgIC8vIFdoZXRoZXIgdGhpcyB0eXBlIGlzIGR5bmFtaWM6XG4gICAgLy8gIC0gRHluYW1pYzogYnl0ZXMsIHN0cmluZywgYWRkcmVzc1tdLCB0dXBsZShib29sZWFuW10pLCBldGMuXG4gICAgLy8gIC0gTm90IER5bmFtaWM6IGFkZHJlc3MsIHVpbnQyNTYsIGJvb2xlYW5bM10sIHR1cGxlKGFkZHJlc3MsIHVpbnQ4KVxuICAgIGR5bmFtaWM7XG4gICAgY29uc3RydWN0b3IobmFtZSwgdHlwZSwgbG9jYWxOYW1lLCBkeW5hbWljKSB7XG4gICAgICAgIGRlZmluZVByb3BlcnRpZXModGhpcywgeyBuYW1lLCB0eXBlLCBsb2NhbE5hbWUsIGR5bmFtaWMgfSwge1xuICAgICAgICAgICAgbmFtZTogXCJzdHJpbmdcIiwgdHlwZTogXCJzdHJpbmdcIiwgbG9jYWxOYW1lOiBcInN0cmluZ1wiLCBkeW5hbWljOiBcImJvb2xlYW5cIlxuICAgICAgICB9KTtcbiAgICB9XG4gICAgX3Rocm93RXJyb3IobWVzc2FnZSwgdmFsdWUpIHtcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQoZmFsc2UsIG1lc3NhZ2UsIHRoaXMubG9jYWxOYW1lLCB2YWx1ZSk7XG4gICAgfVxufVxuLyoqXG4gKiAgQF9pZ25vcmVcbiAqL1xuZXhwb3J0IGNsYXNzIFdyaXRlciB7XG4gICAgLy8gQW4gYXJyYXkgb2YgV29yZFNpemUgbGVuZ3RoZWQgb2JqZWN0cyB0byBjb25jYXRlbmF0aW9uXG4gICAgI2RhdGE7XG4gICAgI2RhdGFMZW5ndGg7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuI2RhdGEgPSBbXTtcbiAgICAgICAgdGhpcy4jZGF0YUxlbmd0aCA9IDA7XG4gICAgfVxuICAgIGdldCBkYXRhKCkge1xuICAgICAgICByZXR1cm4gY29uY2F0KHRoaXMuI2RhdGEpO1xuICAgIH1cbiAgICBnZXQgbGVuZ3RoKCkgeyByZXR1cm4gdGhpcy4jZGF0YUxlbmd0aDsgfVxuICAgICN3cml0ZURhdGEoZGF0YSkge1xuICAgICAgICB0aGlzLiNkYXRhLnB1c2goZGF0YSk7XG4gICAgICAgIHRoaXMuI2RhdGFMZW5ndGggKz0gZGF0YS5sZW5ndGg7XG4gICAgICAgIHJldHVybiBkYXRhLmxlbmd0aDtcbiAgICB9XG4gICAgYXBwZW5kV3JpdGVyKHdyaXRlcikge1xuICAgICAgICByZXR1cm4gdGhpcy4jd3JpdGVEYXRhKGdldEJ5dGVzQ29weSh3cml0ZXIuZGF0YSkpO1xuICAgIH1cbiAgICAvLyBBcnJheWlzaCBpdGVtOyBwYWQgb24gdGhlIHJpZ2h0IHRvICpuZWFyZXN0KiBXb3JkU2l6ZVxuICAgIHdyaXRlQnl0ZXModmFsdWUpIHtcbiAgICAgICAgbGV0IGJ5dGVzID0gZ2V0Qnl0ZXNDb3B5KHZhbHVlKTtcbiAgICAgICAgY29uc3QgcGFkZGluZ09mZnNldCA9IGJ5dGVzLmxlbmd0aCAlIFdvcmRTaXplO1xuICAgICAgICBpZiAocGFkZGluZ09mZnNldCkge1xuICAgICAgICAgICAgYnl0ZXMgPSBnZXRCeXRlc0NvcHkoY29uY2F0KFtieXRlcywgUGFkZGluZy5zbGljZShwYWRkaW5nT2Zmc2V0KV0pKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy4jd3JpdGVEYXRhKGJ5dGVzKTtcbiAgICB9XG4gICAgLy8gTnVtZXJpYyBpdGVtOyBwYWQgb24gdGhlIGxlZnQgKnRvKiBXb3JkU2l6ZVxuICAgIHdyaXRlVmFsdWUodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI3dyaXRlRGF0YShnZXRWYWx1ZSh2YWx1ZSkpO1xuICAgIH1cbiAgICAvLyBJbnNlcnRzIGEgbnVtZXJpYyBwbGFjZS1ob2xkZXIsIHJldHVybmluZyBhIGNhbGxiYWNrIHRoYXQgY2FuXG4gICAgLy8gYmUgdXNlZCB0byBhc2p1c3QgdGhlIHZhbHVlIGxhdGVyXG4gICAgd3JpdGVVcGRhdGFibGVWYWx1ZSgpIHtcbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gdGhpcy4jZGF0YS5sZW5ndGg7XG4gICAgICAgIHRoaXMuI2RhdGEucHVzaChQYWRkaW5nKTtcbiAgICAgICAgdGhpcy4jZGF0YUxlbmd0aCArPSBXb3JkU2l6ZTtcbiAgICAgICAgcmV0dXJuICh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgdGhpcy4jZGF0YVtvZmZzZXRdID0gZ2V0VmFsdWUodmFsdWUpO1xuICAgICAgICB9O1xuICAgIH1cbn1cbi8qKlxuICogIEBfaWdub3JlXG4gKi9cbmV4cG9ydCBjbGFzcyBSZWFkZXIge1xuICAgIC8vIEFsbG93cyBpbmNvbXBsZXRlIHVucGFkZGVkIGRhdGEgdG8gYmUgcmVhZDsgb3RoZXJ3aXNlIGFuIGVycm9yXG4gICAgLy8gaXMgcmFpc2VkIGlmIGF0dGVtcHRpbmcgdG8gb3ZlcnJ1biB0aGUgYnVmZmVyLiBUaGlzIGlzIHJlcXVpcmVkXG4gICAgLy8gdG8gZGVhbCB3aXRoIGFuIG9sZCBTb2xpZGl0eSBidWcsIGluIHdoaWNoIGV2ZW50IGRhdGEgZm9yXG4gICAgLy8gZXh0ZXJuYWwgKG5vdCBwdWJsaWMgdGhvZ3VoKSB3YXMgdGlnaHRseSBwYWNrZWQuXG4gICAgYWxsb3dMb29zZTtcbiAgICAjZGF0YTtcbiAgICAjb2Zmc2V0O1xuICAgICNieXRlc1JlYWQ7XG4gICAgI3BhcmVudDtcbiAgICAjbWF4SW5mbGF0aW9uO1xuICAgIGNvbnN0cnVjdG9yKGRhdGEsIGFsbG93TG9vc2UsIG1heEluZmxhdGlvbikge1xuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHsgYWxsb3dMb29zZTogISFhbGxvd0xvb3NlIH0pO1xuICAgICAgICB0aGlzLiNkYXRhID0gZ2V0Qnl0ZXNDb3B5KGRhdGEpO1xuICAgICAgICB0aGlzLiNieXRlc1JlYWQgPSAwO1xuICAgICAgICB0aGlzLiNwYXJlbnQgPSBudWxsO1xuICAgICAgICB0aGlzLiNtYXhJbmZsYXRpb24gPSAobWF4SW5mbGF0aW9uICE9IG51bGwpID8gbWF4SW5mbGF0aW9uIDogMTAyNDtcbiAgICAgICAgdGhpcy4jb2Zmc2V0ID0gMDtcbiAgICB9XG4gICAgZ2V0IGRhdGEoKSB7IHJldHVybiBoZXhsaWZ5KHRoaXMuI2RhdGEpOyB9XG4gICAgZ2V0IGRhdGFMZW5ndGgoKSB7IHJldHVybiB0aGlzLiNkYXRhLmxlbmd0aDsgfVxuICAgIGdldCBjb25zdW1lZCgpIHsgcmV0dXJuIHRoaXMuI29mZnNldDsgfVxuICAgIGdldCBieXRlcygpIHsgcmV0dXJuIG5ldyBVaW50OEFycmF5KHRoaXMuI2RhdGEpOyB9XG4gICAgI2luY3JlbWVudEJ5dGVzUmVhZChjb3VudCkge1xuICAgICAgICBpZiAodGhpcy4jcGFyZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy4jcGFyZW50LiNpbmNyZW1lbnRCeXRlc1JlYWQoY291bnQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuI2J5dGVzUmVhZCArPSBjb3VudDtcbiAgICAgICAgLy8gQ2hlY2sgZm9yIGV4Y2Vzc2l2ZSBpbmZsYXRpb24gKHNlZTogIzQ1MzcpXG4gICAgICAgIGFzc2VydCh0aGlzLiNtYXhJbmZsYXRpb24gPCAxIHx8IHRoaXMuI2J5dGVzUmVhZCA8PSB0aGlzLiNtYXhJbmZsYXRpb24gKiB0aGlzLmRhdGFMZW5ndGgsIGBjb21wcmVzc2VkIEFCSSBkYXRhIGV4Y2VlZHMgaW5mbGF0aW9uIHJhdGlvIG9mICR7dGhpcy4jbWF4SW5mbGF0aW9ufSAoIHNlZTogaHR0cHM6L1xcL2dpdGh1Yi5jb20vZXRoZXJzLWlvL2V0aGVycy5qcy9pc3N1ZXMvNDUzNyApYCwgXCJCVUZGRVJfT1ZFUlJVTlwiLCB7XG4gICAgICAgICAgICBidWZmZXI6IGdldEJ5dGVzQ29weSh0aGlzLiNkYXRhKSwgb2Zmc2V0OiB0aGlzLiNvZmZzZXQsXG4gICAgICAgICAgICBsZW5ndGg6IGNvdW50LCBpbmZvOiB7XG4gICAgICAgICAgICAgICAgYnl0ZXNSZWFkOiB0aGlzLiNieXRlc1JlYWQsXG4gICAgICAgICAgICAgICAgZGF0YUxlbmd0aDogdGhpcy5kYXRhTGVuZ3RoXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAjcGVla0J5dGVzKG9mZnNldCwgbGVuZ3RoLCBsb29zZSkge1xuICAgICAgICBsZXQgYWxpZ25lZExlbmd0aCA9IE1hdGguY2VpbChsZW5ndGggLyBXb3JkU2l6ZSkgKiBXb3JkU2l6ZTtcbiAgICAgICAgaWYgKHRoaXMuI29mZnNldCArIGFsaWduZWRMZW5ndGggPiB0aGlzLiNkYXRhLmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuYWxsb3dMb29zZSAmJiBsb29zZSAmJiB0aGlzLiNvZmZzZXQgKyBsZW5ndGggPD0gdGhpcy4jZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBhbGlnbmVkTGVuZ3RoID0gbGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYXNzZXJ0KGZhbHNlLCBcImRhdGEgb3V0LW9mLWJvdW5kc1wiLCBcIkJVRkZFUl9PVkVSUlVOXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgYnVmZmVyOiBnZXRCeXRlc0NvcHkodGhpcy4jZGF0YSksXG4gICAgICAgICAgICAgICAgICAgIGxlbmd0aDogdGhpcy4jZGF0YS5sZW5ndGgsXG4gICAgICAgICAgICAgICAgICAgIG9mZnNldDogdGhpcy4jb2Zmc2V0ICsgYWxpZ25lZExlbmd0aFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLiNkYXRhLnNsaWNlKHRoaXMuI29mZnNldCwgdGhpcy4jb2Zmc2V0ICsgYWxpZ25lZExlbmd0aCk7XG4gICAgfVxuICAgIC8vIENyZWF0ZSBhIHN1Yi1yZWFkZXIgd2l0aCB0aGUgc2FtZSB1bmRlcmx5aW5nIGRhdGEsIGJ1dCBvZmZzZXRcbiAgICBzdWJSZWFkZXIob2Zmc2V0KSB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IG5ldyBSZWFkZXIodGhpcy4jZGF0YS5zbGljZSh0aGlzLiNvZmZzZXQgKyBvZmZzZXQpLCB0aGlzLmFsbG93TG9vc2UsIHRoaXMuI21heEluZmxhdGlvbik7XG4gICAgICAgIHJlYWRlci4jcGFyZW50ID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHJlYWRlcjtcbiAgICB9XG4gICAgLy8gUmVhZCBieXRlc1xuICAgIHJlYWRCeXRlcyhsZW5ndGgsIGxvb3NlKSB7XG4gICAgICAgIGxldCBieXRlcyA9IHRoaXMuI3BlZWtCeXRlcygwLCBsZW5ndGgsICEhbG9vc2UpO1xuICAgICAgICB0aGlzLiNpbmNyZW1lbnRCeXRlc1JlYWQobGVuZ3RoKTtcbiAgICAgICAgdGhpcy4jb2Zmc2V0ICs9IGJ5dGVzLmxlbmd0aDtcbiAgICAgICAgLy8gQFRPRE86IE1ha2Ugc3VyZSB0aGUgbGVuZ3RoLi5lbmQgYnl0ZXMgYXJlIGFsbCAwP1xuICAgICAgICByZXR1cm4gYnl0ZXMuc2xpY2UoMCwgbGVuZ3RoKTtcbiAgICB9XG4gICAgLy8gUmVhZCBhIG51bWVyaWMgdmFsdWVzXG4gICAgcmVhZFZhbHVlKCkge1xuICAgICAgICByZXR1cm4gdG9CaWdJbnQodGhpcy5yZWFkQnl0ZXMoV29yZFNpemUpKTtcbiAgICB9XG4gICAgcmVhZEluZGV4KCkge1xuICAgICAgICByZXR1cm4gdG9OdW1iZXIodGhpcy5yZWFkQnl0ZXMoV29yZFNpemUpKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hYnN0cmFjdC1jb2Rlci5qcy5tYXAiXSwibmFtZXMiOlsiZGVmaW5lUHJvcGVydGllcyIsImNvbmNhdCIsImdldEJ5dGVzQ29weSIsImdldE51bWJlciIsImhleGxpZnkiLCJ0b0JlQXJyYXkiLCJ0b0JpZ0ludCIsInRvTnVtYmVyIiwiYXNzZXJ0IiwiYXNzZXJ0QXJndW1lbnQiLCJXb3JkU2l6ZSIsIlBhZGRpbmciLCJVaW50OEFycmF5IiwicGFzc1Byb3BlcnRpZXMiLCJfZ3VhcmQiLCJyZXN1bHROYW1lcyIsIldlYWtNYXAiLCJnZXROYW1lcyIsInJlc3VsdCIsImdldCIsInNldE5hbWVzIiwibmFtZXMiLCJzZXQiLCJ0aHJvd0Vycm9yIiwibmFtZSIsImVycm9yIiwid3JhcHBlZCIsIkVycm9yIiwidG9PYmplY3QiLCJpdGVtcyIsImRlZXAiLCJpbmRleE9mIiwibWFwIiwiaXRlbSIsImluZGV4IiwiUmVzdWx0IiwicmVkdWNlIiwiYWNjdW0iLCJnZXRWYWx1ZSIsIkFycmF5IiwiY29uc3RydWN0b3IiLCJhcmdzIiwiZ3VhcmQiLCJzbGljZSIsIndyYXAiLCJsZW5ndGgiLCJmb3JFYWNoIiwibmFtZUNvdW50cyIsIk1hcCIsIk9iamVjdCIsImZyZWV6ZSIsInByb3h5IiwiUHJveHkiLCJ0YXJnZXQiLCJwcm9wIiwicmVjZWl2ZXIiLCJtYXRjaCIsIlJhbmdlRXJyb3IiLCJSZWZsZWN0IiwidmFsdWUiLCJGdW5jdGlvbiIsImFwcGx5IiwidG9BcnJheSIsInB1c2giLCJvcGVyYXRpb24iLCJzdGFydCIsImVuZCIsIl9uYW1lcyIsImkiLCJmaWx0ZXIiLCJjYWxsYmFjayIsInRoaXNBcmciLCJjYWxsIiwidW5kZWZpbmVkIiwiSlNPTiIsInN0cmluZ2lmeSIsImZyb21JdGVtcyIsImtleXMiLCJjaGVja1Jlc3VsdEVycm9ycyIsImVycm9ycyIsImNoZWNrRXJyb3JzIiwicGF0aCIsIm9iamVjdCIsImlzQXJyYXkiLCJrZXkiLCJjaGlsZFBhdGgiLCJieXRlcyIsImJ1ZmZlciIsIm9mZnNldCIsIkNvZGVyIiwidHlwZSIsImxvY2FsTmFtZSIsImR5bmFtaWMiLCJfdGhyb3dFcnJvciIsIm1lc3NhZ2UiLCJXcml0ZXIiLCJkYXRhIiwiZGF0YUxlbmd0aCIsIndyaXRlRGF0YSIsImFwcGVuZFdyaXRlciIsIndyaXRlciIsIndyaXRlQnl0ZXMiLCJwYWRkaW5nT2Zmc2V0Iiwid3JpdGVWYWx1ZSIsIndyaXRlVXBkYXRhYmxlVmFsdWUiLCJSZWFkZXIiLCJieXRlc1JlYWQiLCJwYXJlbnQiLCJtYXhJbmZsYXRpb24iLCJhbGxvd0xvb3NlIiwiY29uc3VtZWQiLCJpbmNyZW1lbnRCeXRlc1JlYWQiLCJjb3VudCIsImluZm8iLCJwZWVrQnl0ZXMiLCJsb29zZSIsImFsaWduZWRMZW5ndGgiLCJNYXRoIiwiY2VpbCIsInN1YlJlYWRlciIsInJlYWRlciIsInJlYWRCeXRlcyIsInJlYWRWYWx1ZSIsInJlYWRJbmRleCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.esm/abi/coders/abstract-coder.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.esm/abi/coders/address.js":
/*!***********************************************************!*\
  !*** ./node_modules/ethers/lib.esm/abi/coders/address.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AddressCoder: () => (/* binding */ AddressCoder)\n/* harmony export */ });\n/* harmony import */ var _address_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../address/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/address/address.js\");\n/* harmony import */ var _utils_maths_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../utils/maths.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/maths.js\");\n/* harmony import */ var _typed_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../typed.js */ \"(ssr)/./node_modules/ethers/lib.esm/abi/typed.js\");\n/* harmony import */ var _abstract_coder_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract-coder.js */ \"(ssr)/./node_modules/ethers/lib.esm/abi/coders/abstract-coder.js\");\n\n\n\n\n/**\n *  @_ignore\n */ class AddressCoder extends _abstract_coder_js__WEBPACK_IMPORTED_MODULE_0__.Coder {\n    constructor(localName){\n        super(\"address\", \"address\", localName, false);\n    }\n    defaultValue() {\n        return \"0x0000000000000000000000000000000000000000\";\n    }\n    encode(writer, _value) {\n        let value = _typed_js__WEBPACK_IMPORTED_MODULE_1__.Typed.dereference(_value, \"string\");\n        try {\n            value = (0,_address_index_js__WEBPACK_IMPORTED_MODULE_2__.getAddress)(value);\n        } catch (error) {\n            return this._throwError(error.message, _value);\n        }\n        return writer.writeValue(value);\n    }\n    decode(reader) {\n        return (0,_address_index_js__WEBPACK_IMPORTED_MODULE_2__.getAddress)((0,_utils_maths_js__WEBPACK_IMPORTED_MODULE_3__.toBeHex)(reader.readValue(), 20));\n    }\n} //# sourceMappingURL=address.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vYWJpL2NvZGVycy9hZGRyZXNzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQW9EO0FBQ0w7QUFDWDtBQUNRO0FBQzVDOztDQUVDLEdBQ00sTUFBTUkscUJBQXFCRCxxREFBS0E7SUFDbkNFLFlBQVlDLFNBQVMsQ0FBRTtRQUNuQixLQUFLLENBQUMsV0FBVyxXQUFXQSxXQUFXO0lBQzNDO0lBQ0FDLGVBQWU7UUFDWCxPQUFPO0lBQ1g7SUFDQUMsT0FBT0MsTUFBTSxFQUFFQyxNQUFNLEVBQUU7UUFDbkIsSUFBSUMsUUFBUVQsNENBQUtBLENBQUNVLFdBQVcsQ0FBQ0YsUUFBUTtRQUN0QyxJQUFJO1lBQ0FDLFFBQVFYLDZEQUFVQSxDQUFDVztRQUN2QixFQUNBLE9BQU9FLE9BQU87WUFDVixPQUFPLElBQUksQ0FBQ0MsV0FBVyxDQUFDRCxNQUFNRSxPQUFPLEVBQUVMO1FBQzNDO1FBQ0EsT0FBT0QsT0FBT08sVUFBVSxDQUFDTDtJQUM3QjtJQUNBTSxPQUFPQyxNQUFNLEVBQUU7UUFDWCxPQUFPbEIsNkRBQVVBLENBQUNDLHdEQUFPQSxDQUFDaUIsT0FBT0MsU0FBUyxJQUFJO0lBQ2xEO0FBQ0osRUFDQSxtQ0FBbUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tZWdhdmliZS1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9hYmkvY29kZXJzL2FkZHJlc3MuanM/Y2E4NiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBnZXRBZGRyZXNzIH0gZnJvbSBcIi4uLy4uL2FkZHJlc3MvaW5kZXguanNcIjtcbmltcG9ydCB7IHRvQmVIZXggfSBmcm9tIFwiLi4vLi4vdXRpbHMvbWF0aHMuanNcIjtcbmltcG9ydCB7IFR5cGVkIH0gZnJvbSBcIi4uL3R5cGVkLmpzXCI7XG5pbXBvcnQgeyBDb2RlciB9IGZyb20gXCIuL2Fic3RyYWN0LWNvZGVyLmpzXCI7XG4vKipcbiAqICBAX2lnbm9yZVxuICovXG5leHBvcnQgY2xhc3MgQWRkcmVzc0NvZGVyIGV4dGVuZHMgQ29kZXIge1xuICAgIGNvbnN0cnVjdG9yKGxvY2FsTmFtZSkge1xuICAgICAgICBzdXBlcihcImFkZHJlc3NcIiwgXCJhZGRyZXNzXCIsIGxvY2FsTmFtZSwgZmFsc2UpO1xuICAgIH1cbiAgICBkZWZhdWx0VmFsdWUoKSB7XG4gICAgICAgIHJldHVybiBcIjB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMFwiO1xuICAgIH1cbiAgICBlbmNvZGUod3JpdGVyLCBfdmFsdWUpIHtcbiAgICAgICAgbGV0IHZhbHVlID0gVHlwZWQuZGVyZWZlcmVuY2UoX3ZhbHVlLCBcInN0cmluZ1wiKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhbHVlID0gZ2V0QWRkcmVzcyh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdGhyb3dFcnJvcihlcnJvci5tZXNzYWdlLCBfdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3cml0ZXIud3JpdGVWYWx1ZSh2YWx1ZSk7XG4gICAgfVxuICAgIGRlY29kZShyZWFkZXIpIHtcbiAgICAgICAgcmV0dXJuIGdldEFkZHJlc3ModG9CZUhleChyZWFkZXIucmVhZFZhbHVlKCksIDIwKSk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWRkcmVzcy5qcy5tYXAiXSwibmFtZXMiOlsiZ2V0QWRkcmVzcyIsInRvQmVIZXgiLCJUeXBlZCIsIkNvZGVyIiwiQWRkcmVzc0NvZGVyIiwiY29uc3RydWN0b3IiLCJsb2NhbE5hbWUiLCJkZWZhdWx0VmFsdWUiLCJlbmNvZGUiLCJ3cml0ZXIiLCJfdmFsdWUiLCJ2YWx1ZSIsImRlcmVmZXJlbmNlIiwiZXJyb3IiLCJfdGhyb3dFcnJvciIsIm1lc3NhZ2UiLCJ3cml0ZVZhbHVlIiwiZGVjb2RlIiwicmVhZGVyIiwicmVhZFZhbHVlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.esm/abi/coders/address.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.esm/abi/coders/anonymous.js":
/*!*************************************************************!*\
  !*** ./node_modules/ethers/lib.esm/abi/coders/anonymous.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AnonymousCoder: () => (/* binding */ AnonymousCoder)\n/* harmony export */ });\n/* harmony import */ var _abstract_coder_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract-coder.js */ \"(ssr)/./node_modules/ethers/lib.esm/abi/coders/abstract-coder.js\");\n\n/**\n *  Clones the functionality of an existing Coder, but without a localName\n *\n *  @_ignore\n */ class AnonymousCoder extends _abstract_coder_js__WEBPACK_IMPORTED_MODULE_0__.Coder {\n    constructor(coder){\n        super(coder.name, coder.type, \"_\", coder.dynamic);\n        this.coder = coder;\n    }\n    defaultValue() {\n        return this.coder.defaultValue();\n    }\n    encode(writer, value) {\n        return this.coder.encode(writer, value);\n    }\n    decode(reader) {\n        return this.coder.decode(reader);\n    }\n} //# sourceMappingURL=anonymous.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vYWJpL2NvZGVycy9hbm9ueW1vdXMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBNEM7QUFDNUM7Ozs7Q0FJQyxHQUNNLE1BQU1DLHVCQUF1QkQscURBQUtBO0lBRXJDRSxZQUFZQyxLQUFLLENBQUU7UUFDZixLQUFLLENBQUNBLE1BQU1DLElBQUksRUFBRUQsTUFBTUUsSUFBSSxFQUFFLEtBQUtGLE1BQU1HLE9BQU87UUFDaEQsSUFBSSxDQUFDSCxLQUFLLEdBQUdBO0lBQ2pCO0lBQ0FJLGVBQWU7UUFDWCxPQUFPLElBQUksQ0FBQ0osS0FBSyxDQUFDSSxZQUFZO0lBQ2xDO0lBQ0FDLE9BQU9DLE1BQU0sRUFBRUMsS0FBSyxFQUFFO1FBQ2xCLE9BQU8sSUFBSSxDQUFDUCxLQUFLLENBQUNLLE1BQU0sQ0FBQ0MsUUFBUUM7SUFDckM7SUFDQUMsT0FBT0MsTUFBTSxFQUFFO1FBQ1gsT0FBTyxJQUFJLENBQUNULEtBQUssQ0FBQ1EsTUFBTSxDQUFDQztJQUM3QjtBQUNKLEVBQ0EscUNBQXFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbWVnYXZpYmUtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vYWJpL2NvZGVycy9hbm9ueW1vdXMuanM/ZDRiOSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDb2RlciB9IGZyb20gXCIuL2Fic3RyYWN0LWNvZGVyLmpzXCI7XG4vKipcbiAqICBDbG9uZXMgdGhlIGZ1bmN0aW9uYWxpdHkgb2YgYW4gZXhpc3RpbmcgQ29kZXIsIGJ1dCB3aXRob3V0IGEgbG9jYWxOYW1lXG4gKlxuICogIEBfaWdub3JlXG4gKi9cbmV4cG9ydCBjbGFzcyBBbm9ueW1vdXNDb2RlciBleHRlbmRzIENvZGVyIHtcbiAgICBjb2RlcjtcbiAgICBjb25zdHJ1Y3Rvcihjb2Rlcikge1xuICAgICAgICBzdXBlcihjb2Rlci5uYW1lLCBjb2Rlci50eXBlLCBcIl9cIiwgY29kZXIuZHluYW1pYyk7XG4gICAgICAgIHRoaXMuY29kZXIgPSBjb2RlcjtcbiAgICB9XG4gICAgZGVmYXVsdFZhbHVlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb2Rlci5kZWZhdWx0VmFsdWUoKTtcbiAgICB9XG4gICAgZW5jb2RlKHdyaXRlciwgdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29kZXIuZW5jb2RlKHdyaXRlciwgdmFsdWUpO1xuICAgIH1cbiAgICBkZWNvZGUocmVhZGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvZGVyLmRlY29kZShyZWFkZXIpO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFub255bW91cy5qcy5tYXAiXSwibmFtZXMiOlsiQ29kZXIiLCJBbm9ueW1vdXNDb2RlciIsImNvbnN0cnVjdG9yIiwiY29kZXIiLCJuYW1lIiwidHlwZSIsImR5bmFtaWMiLCJkZWZhdWx0VmFsdWUiLCJlbmNvZGUiLCJ3cml0ZXIiLCJ2YWx1ZSIsImRlY29kZSIsInJlYWRlciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.esm/abi/coders/anonymous.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.esm/abi/coders/array.js":
/*!*********************************************************!*\
  !*** ./node_modules/ethers/lib.esm/abi/coders/array.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ArrayCoder: () => (/* binding */ ArrayCoder),\n/* harmony export */   pack: () => (/* binding */ pack),\n/* harmony export */   unpack: () => (/* binding */ unpack)\n/* harmony export */ });\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/errors.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/properties.js\");\n/* harmony import */ var _typed_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../typed.js */ \"(ssr)/./node_modules/ethers/lib.esm/abi/typed.js\");\n/* harmony import */ var _abstract_coder_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./abstract-coder.js */ \"(ssr)/./node_modules/ethers/lib.esm/abi/coders/abstract-coder.js\");\n/* harmony import */ var _anonymous_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./anonymous.js */ \"(ssr)/./node_modules/ethers/lib.esm/abi/coders/anonymous.js\");\n\n\n\n\n/**\n *  @_ignore\n */ function pack(writer, coders, values) {\n    let arrayValues = [];\n    if (Array.isArray(values)) {\n        arrayValues = values;\n    } else if (values && typeof values === \"object\") {\n        let unique = {};\n        arrayValues = coders.map((coder)=>{\n            const name = coder.localName;\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assert)(name, \"cannot encode object for signature with missing names\", \"INVALID_ARGUMENT\", {\n                argument: \"values\",\n                info: {\n                    coder\n                },\n                value: values\n            });\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assert)(!unique[name], \"cannot encode object for signature with duplicate names\", \"INVALID_ARGUMENT\", {\n                argument: \"values\",\n                info: {\n                    coder\n                },\n                value: values\n            });\n            unique[name] = true;\n            return values[name];\n        });\n    } else {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(false, \"invalid tuple value\", \"tuple\", values);\n    }\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(coders.length === arrayValues.length, \"types/value length mismatch\", \"tuple\", values);\n    let staticWriter = new _abstract_coder_js__WEBPACK_IMPORTED_MODULE_1__.Writer();\n    let dynamicWriter = new _abstract_coder_js__WEBPACK_IMPORTED_MODULE_1__.Writer();\n    let updateFuncs = [];\n    coders.forEach((coder, index)=>{\n        let value = arrayValues[index];\n        if (coder.dynamic) {\n            // Get current dynamic offset (for the future pointer)\n            let dynamicOffset = dynamicWriter.length;\n            // Encode the dynamic value into the dynamicWriter\n            coder.encode(dynamicWriter, value);\n            // Prepare to populate the correct offset once we are done\n            let updateFunc = staticWriter.writeUpdatableValue();\n            updateFuncs.push((baseOffset)=>{\n                updateFunc(baseOffset + dynamicOffset);\n            });\n        } else {\n            coder.encode(staticWriter, value);\n        }\n    });\n    // Backfill all the dynamic offsets, now that we know the static length\n    updateFuncs.forEach((func)=>{\n        func(staticWriter.length);\n    });\n    let length = writer.appendWriter(staticWriter);\n    length += writer.appendWriter(dynamicWriter);\n    return length;\n}\n/**\n *  @_ignore\n */ function unpack(reader, coders) {\n    let values = [];\n    let keys = [];\n    // A reader anchored to this base\n    let baseReader = reader.subReader(0);\n    coders.forEach((coder)=>{\n        let value = null;\n        if (coder.dynamic) {\n            let offset = reader.readIndex();\n            let offsetReader = baseReader.subReader(offset);\n            try {\n                value = coder.decode(offsetReader);\n            } catch (error) {\n                // Cannot recover from this\n                if ((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.isError)(error, \"BUFFER_OVERRUN\")) {\n                    throw error;\n                }\n                value = error;\n                value.baseType = coder.name;\n                value.name = coder.localName;\n                value.type = coder.type;\n            }\n        } else {\n            try {\n                value = coder.decode(reader);\n            } catch (error) {\n                // Cannot recover from this\n                if ((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.isError)(error, \"BUFFER_OVERRUN\")) {\n                    throw error;\n                }\n                value = error;\n                value.baseType = coder.name;\n                value.name = coder.localName;\n                value.type = coder.type;\n            }\n        }\n        if (value == undefined) {\n            throw new Error(\"investigate\");\n        }\n        values.push(value);\n        keys.push(coder.localName || null);\n    });\n    return _abstract_coder_js__WEBPACK_IMPORTED_MODULE_1__.Result.fromItems(values, keys);\n}\n/**\n *  @_ignore\n */ class ArrayCoder extends _abstract_coder_js__WEBPACK_IMPORTED_MODULE_1__.Coder {\n    constructor(coder, length, localName){\n        const type = coder.type + \"[\" + (length >= 0 ? length : \"\") + \"]\";\n        const dynamic = length === -1 || coder.dynamic;\n        super(\"array\", type, localName, dynamic);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.defineProperties)(this, {\n            coder,\n            length\n        });\n    }\n    defaultValue() {\n        // Verifies the child coder is valid (even if the array is dynamic or 0-length)\n        const defaultChild = this.coder.defaultValue();\n        const result = [];\n        for(let i = 0; i < this.length; i++){\n            result.push(defaultChild);\n        }\n        return result;\n    }\n    encode(writer, _value) {\n        const value = _typed_js__WEBPACK_IMPORTED_MODULE_3__.Typed.dereference(_value, \"array\");\n        if (!Array.isArray(value)) {\n            this._throwError(\"expected array value\", value);\n        }\n        let count = this.length;\n        if (count === -1) {\n            count = value.length;\n            writer.writeValue(value.length);\n        }\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgumentCount)(value.length, count, \"coder array\" + (this.localName ? \" \" + this.localName : \"\"));\n        let coders = [];\n        for(let i = 0; i < value.length; i++){\n            coders.push(this.coder);\n        }\n        return pack(writer, coders, value);\n    }\n    decode(reader) {\n        let count = this.length;\n        if (count === -1) {\n            count = reader.readIndex();\n            // Check that there is *roughly* enough data to ensure\n            // stray random data is not being read as a length. Each\n            // slot requires at least 32 bytes for their value (or 32\n            // bytes as a link to the data). This could use a much\n            // tighter bound, but we are erroring on the side of safety.\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assert)(count * _abstract_coder_js__WEBPACK_IMPORTED_MODULE_1__.WordSize <= reader.dataLength, \"insufficient data length\", \"BUFFER_OVERRUN\", {\n                buffer: reader.bytes,\n                offset: count * _abstract_coder_js__WEBPACK_IMPORTED_MODULE_1__.WordSize,\n                length: reader.dataLength\n            });\n        }\n        let coders = [];\n        for(let i = 0; i < count; i++){\n            coders.push(new _anonymous_js__WEBPACK_IMPORTED_MODULE_4__.AnonymousCoder(this.coder));\n        }\n        return unpack(reader, coders);\n    }\n} //# sourceMappingURL=array.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vYWJpL2NvZGVycy9hcnJheS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUE4RztBQUMxRTtBQUNrQztBQUN0QjtBQUNoRDs7Q0FFQyxHQUNNLFNBQVNXLEtBQUtDLE1BQU0sRUFBRUMsTUFBTSxFQUFFQyxNQUFNO0lBQ3ZDLElBQUlDLGNBQWMsRUFBRTtJQUNwQixJQUFJQyxNQUFNQyxPQUFPLENBQUNILFNBQVM7UUFDdkJDLGNBQWNEO0lBQ2xCLE9BQ0ssSUFBSUEsVUFBVSxPQUFRQSxXQUFZLFVBQVU7UUFDN0MsSUFBSUksU0FBUyxDQUFDO1FBQ2RILGNBQWNGLE9BQU9NLEdBQUcsQ0FBQyxDQUFDQztZQUN0QixNQUFNQyxPQUFPRCxNQUFNRSxTQUFTO1lBQzVCcEIsdURBQU1BLENBQUNtQixNQUFNLHlEQUF5RCxvQkFBb0I7Z0JBQUVFLFVBQVU7Z0JBQVVDLE1BQU07b0JBQUVKO2dCQUFNO2dCQUFHSyxPQUFPWDtZQUFPO1lBQy9JWix1REFBTUEsQ0FBQyxDQUFDZ0IsTUFBTSxDQUFDRyxLQUFLLEVBQUUsMkRBQTJELG9CQUFvQjtnQkFBRUUsVUFBVTtnQkFBVUMsTUFBTTtvQkFBRUo7Z0JBQU07Z0JBQUdLLE9BQU9YO1lBQU87WUFDMUpJLE1BQU0sQ0FBQ0csS0FBSyxHQUFHO1lBQ2YsT0FBT1AsTUFBTSxDQUFDTyxLQUFLO1FBQ3ZCO0lBQ0osT0FDSztRQUNEbEIsK0RBQWNBLENBQUMsT0FBTyx1QkFBdUIsU0FBU1c7SUFDMUQ7SUFDQVgsK0RBQWNBLENBQUNVLE9BQU9hLE1BQU0sS0FBS1gsWUFBWVcsTUFBTSxFQUFFLCtCQUErQixTQUFTWjtJQUM3RixJQUFJYSxlQUFlLElBQUlsQixzREFBTUE7SUFDN0IsSUFBSW1CLGdCQUFnQixJQUFJbkIsc0RBQU1BO0lBQzlCLElBQUlvQixjQUFjLEVBQUU7SUFDcEJoQixPQUFPaUIsT0FBTyxDQUFDLENBQUNWLE9BQU9XO1FBQ25CLElBQUlO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RCxRQUFRekQsd0RBQVFBLElBQUlrQyxPQUFPeUIsVUFBVSxFQUFFLDRCQUE0QixrQkFBa0I7Z0JBQUVDLFFBQVExQixPQUFPMkIsS0FBSztnQkFBRXZCLFFBQVFtQixRQUFRekQsd0RBQVFBO2dCQUFFa0IsUUFBUWdCLE9BQU95QixVQUFVO1lBQUM7UUFDNUs7UUFDQSxJQUFJdEQsU0FBUyxFQUFFO1FBQ2YsSUFBSyxJQUFJZ0QsSUFBSSxHQUFHQSxJQUFJSSxPQUFPSixJQUFLO1lBQzVCaEQsT0FBT3dCLElBQUksQ0FBQyxJQUFJM0IseURBQWNBLENBQUMsSUFBSSxDQUFDVSxLQUFLO1FBQzdDO1FBQ0EsT0FBT3FCLE9BQU9DLFFBQVE3QjtJQUMxQjtBQUNKLEVBQ0EsaUNBQWlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbWVnYXZpYmUtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vYWJpL2NvZGVycy9hcnJheS5qcz9hOGJhIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGRlZmluZVByb3BlcnRpZXMsIGlzRXJyb3IsIGFzc2VydCwgYXNzZXJ0QXJndW1lbnQsIGFzc2VydEFyZ3VtZW50Q291bnQgfSBmcm9tIFwiLi4vLi4vdXRpbHMvaW5kZXguanNcIjtcbmltcG9ydCB7IFR5cGVkIH0gZnJvbSBcIi4uL3R5cGVkLmpzXCI7XG5pbXBvcnQgeyBDb2RlciwgUmVzdWx0LCBXb3JkU2l6ZSwgV3JpdGVyIH0gZnJvbSBcIi4vYWJzdHJhY3QtY29kZXIuanNcIjtcbmltcG9ydCB7IEFub255bW91c0NvZGVyIH0gZnJvbSBcIi4vYW5vbnltb3VzLmpzXCI7XG4vKipcbiAqICBAX2lnbm9yZVxuICovXG5leHBvcnQgZnVuY3Rpb24gcGFjayh3cml0ZXIsIGNvZGVycywgdmFsdWVzKSB7XG4gICAgbGV0IGFycmF5VmFsdWVzID0gW107XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWVzKSkge1xuICAgICAgICBhcnJheVZhbHVlcyA9IHZhbHVlcztcbiAgICB9XG4gICAgZWxzZSBpZiAodmFsdWVzICYmIHR5cGVvZiAodmFsdWVzKSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICBsZXQgdW5pcXVlID0ge307XG4gICAgICAgIGFycmF5VmFsdWVzID0gY29kZXJzLm1hcCgoY29kZXIpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG5hbWUgPSBjb2Rlci5sb2NhbE5hbWU7XG4gICAgICAgICAgICBhc3NlcnQobmFtZSwgXCJjYW5ub3QgZW5jb2RlIG9iamVjdCBmb3Igc2lnbmF0dXJlIHdpdGggbWlzc2luZyBuYW1lc1wiLCBcIklOVkFMSURfQVJHVU1FTlRcIiwgeyBhcmd1bWVudDogXCJ2YWx1ZXNcIiwgaW5mbzogeyBjb2RlciB9LCB2YWx1ZTogdmFsdWVzIH0pO1xuICAgICAgICAgICAgYXNzZXJ0KCF1bmlxdWVbbmFtZV0sIFwiY2Fubm90IGVuY29kZSBvYmplY3QgZm9yIHNpZ25hdHVyZSB3aXRoIGR1cGxpY2F0ZSBuYW1lc1wiLCBcIklOVkFMSURfQVJHVU1FTlRcIiwgeyBhcmd1bWVudDogXCJ2YWx1ZXNcIiwgaW5mbzogeyBjb2RlciB9LCB2YWx1ZTogdmFsdWVzIH0pO1xuICAgICAgICAgICAgdW5pcXVlW25hbWVdID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZXNbbmFtZV07XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQoZmFsc2UsIFwiaW52YWxpZCB0dXBsZSB2YWx1ZVwiLCBcInR1cGxlXCIsIHZhbHVlcyk7XG4gICAgfVxuICAgIGFzc2VydEFyZ3VtZW50KGNvZGVycy5sZW5ndGggPT09IGFycmF5VmFsdWVzLmxlbmd0aCwgXCJ0eXBlcy92YWx1ZSBsZW5ndGggbWlzbWF0Y2hcIiwgXCJ0dXBsZVwiLCB2YWx1ZXMpO1xuICAgIGxldCBzdGF0aWNXcml0ZXIgPSBuZXcgV3JpdGVyKCk7XG4gICAgbGV0IGR5bmFtaWNXcml0ZXIgPSBuZXcgV3JpdGVyKCk7XG4gICAgbGV0IHVwZGF0ZUZ1bmNzID0gW107XG4gICAgY29kZXJzLmZvckVhY2goKGNvZGVyLCBpbmRleCkgPT4ge1xuICAgICAgICBsZXQgdmFsdWUgPSBhcnJheVZhbHVlc1tpbmRleF07XG4gICAgICAgIGlmIChjb2Rlci5keW5hbWljKSB7XG4gICAgICAgICAgICAvLyBHZXQgY3VycmVudCBkeW5hbWljIG9mZnNldCAoZm9yIHRoZSBmdXR1cmUgcG9pbnRlcilcbiAgICAgICAgICAgIGxldCBkeW5hbWljT2Zmc2V0ID0gZHluYW1pY1dyaXRlci5sZW5ndGg7XG4gICAgICAgICAgICAvLyBFbmNvZGUgdGhlIGR5bmFtaWMgdmFsdWUgaW50byB0aGUgZHluYW1pY1dyaXRlclxuICAgICAgICAgICAgY29kZXIuZW5jb2RlKGR5bmFtaWNXcml0ZXIsIHZhbHVlKTtcbiAgICAgICAgICAgIC8vIFByZXBhcmUgdG8gcG9wdWxhdGUgdGhlIGNvcnJlY3Qgb2Zmc2V0IG9uY2Ugd2UgYXJlIGRvbmVcbiAgICAgICAgICAgIGxldCB1cGRhdGVGdW5jID0gc3RhdGljV3JpdGVyLndyaXRlVXBkYXRhYmxlVmFsdWUoKTtcbiAgICAgICAgICAgIHVwZGF0ZUZ1bmNzLnB1c2goKGJhc2VPZmZzZXQpID0+IHtcbiAgICAgICAgICAgICAgICB1cGRhdGVGdW5jKGJhc2VPZmZzZXQgKyBkeW5hbWljT2Zmc2V0KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29kZXIuZW5jb2RlKHN0YXRpY1dyaXRlciwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgLy8gQmFja2ZpbGwgYWxsIHRoZSBkeW5hbWljIG9mZnNldHMsIG5vdyB0aGF0IHdlIGtub3cgdGhlIHN0YXRpYyBsZW5ndGhcbiAgICB1cGRhdGVGdW5jcy5mb3JFYWNoKChmdW5jKSA9PiB7IGZ1bmMoc3RhdGljV3JpdGVyLmxlbmd0aCk7IH0pO1xuICAgIGxldCBsZW5ndGggPSB3cml0ZXIuYXBwZW5kV3JpdGVyKHN0YXRpY1dyaXRlcik7XG4gICAgbGVuZ3RoICs9IHdyaXRlci5hcHBlbmRXcml0ZXIoZHluYW1pY1dyaXRlcik7XG4gICAgcmV0dXJuIGxlbmd0aDtcbn1cbi8qKlxuICogIEBfaWdub3JlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1bnBhY2socmVhZGVyLCBjb2RlcnMpIHtcbiAgICBsZXQgdmFsdWVzID0gW107XG4gICAgbGV0IGtleXMgPSBbXTtcbiAgICAvLyBBIHJlYWRlciBhbmNob3JlZCB0byB0aGlzIGJhc2VcbiAgICBsZXQgYmFzZVJlYWRlciA9IHJlYWRlci5zdWJSZWFkZXIoMCk7XG4gICAgY29kZXJzLmZvckVhY2goKGNvZGVyKSA9PiB7XG4gICAgICAgIGxldCB2YWx1ZSA9IG51bGw7XG4gICAgICAgIGlmIChjb2Rlci5keW5hbWljKSB7XG4gICAgICAgICAgICBsZXQgb2Zmc2V0ID0gcmVhZGVyLnJlYWRJbmRleCgpO1xuICAgICAgICAgICAgbGV0IG9mZnNldFJlYWRlciA9IGJhc2VSZWFkZXIuc3ViUmVhZGVyKG9mZnNldCk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gY29kZXIuZGVjb2RlKG9mZnNldFJlYWRlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAvLyBDYW5ub3QgcmVjb3ZlciBmcm9tIHRoaXNcbiAgICAgICAgICAgICAgICBpZiAoaXNFcnJvcihlcnJvciwgXCJCVUZGRVJfT1ZFUlJVTlwiKSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBlcnJvcjtcbiAgICAgICAgICAgICAgICB2YWx1ZS5iYXNlVHlwZSA9IGNvZGVyLm5hbWU7XG4gICAgICAgICAgICAgICAgdmFsdWUubmFtZSA9IGNvZGVyLmxvY2FsTmFtZTtcbiAgICAgICAgICAgICAgICB2YWx1ZS50eXBlID0gY29kZXIudHlwZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBjb2Rlci5kZWNvZGUocmVhZGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIC8vIENhbm5vdCByZWNvdmVyIGZyb20gdGhpc1xuICAgICAgICAgICAgICAgIGlmIChpc0Vycm9yKGVycm9yLCBcIkJVRkZFUl9PVkVSUlVOXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGVycm9yO1xuICAgICAgICAgICAgICAgIHZhbHVlLmJhc2VUeXBlID0gY29kZXIubmFtZTtcbiAgICAgICAgICAgICAgICB2YWx1ZS5uYW1lID0gY29kZXIubG9jYWxOYW1lO1xuICAgICAgICAgICAgICAgIHZhbHVlLnR5cGUgPSBjb2Rlci50eXBlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh2YWx1ZSA9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmVzdGlnYXRlXCIpO1xuICAgICAgICB9XG4gICAgICAgIHZhbHVlcy5wdXNoKHZhbHVlKTtcbiAgICAgICAga2V5cy5wdXNoKGNvZGVyLmxvY2FsTmFtZSB8fCBudWxsKTtcbiAgICB9KTtcbiAgICByZXR1cm4gUmVzdWx0LmZyb21JdGVtcyh2YWx1ZXMsIGtleXMpO1xufVxuLyoqXG4gKiAgQF9pZ25vcmVcbiAqL1xuZXhwb3J0IGNsYXNzIEFycmF5Q29kZXIgZXh0ZW5kcyBDb2RlciB7XG4gICAgY29kZXI7XG4gICAgbGVuZ3RoO1xuICAgIGNvbnN0cnVjdG9yKGNvZGVyLCBsZW5ndGgsIGxvY2FsTmFtZSkge1xuICAgICAgICBjb25zdCB0eXBlID0gKGNvZGVyLnR5cGUgKyBcIltcIiArIChsZW5ndGggPj0gMCA/IGxlbmd0aCA6IFwiXCIpICsgXCJdXCIpO1xuICAgICAgICBjb25zdCBkeW5hbWljID0gKGxlbmd0aCA9PT0gLTEgfHwgY29kZXIuZHluYW1pYyk7XG4gICAgICAgIHN1cGVyKFwiYXJyYXlcIiwgdHlwZSwgbG9jYWxOYW1lLCBkeW5hbWljKTtcbiAgICAgICAgZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7IGNvZGVyLCBsZW5ndGggfSk7XG4gICAgfVxuICAgIGRlZmF1bHRWYWx1ZSgpIHtcbiAgICAgICAgLy8gVmVyaWZpZXMgdGhlIGNoaWxkIGNvZGVyIGlzIHZhbGlkIChldmVuIGlmIHRoZSBhcnJheSBpcyBkeW5hbWljIG9yIDAtbGVuZ3RoKVxuICAgICAgICBjb25zdCBkZWZhdWx0Q2hpbGQgPSB0aGlzLmNvZGVyLmRlZmF1bHRWYWx1ZSgpO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChkZWZhdWx0Q2hpbGQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGVuY29kZSh3cml0ZXIsIF92YWx1ZSkge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IFR5cGVkLmRlcmVmZXJlbmNlKF92YWx1ZSwgXCJhcnJheVwiKTtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgdGhpcy5fdGhyb3dFcnJvcihcImV4cGVjdGVkIGFycmF5IHZhbHVlXCIsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgY291bnQgPSB0aGlzLmxlbmd0aDtcbiAgICAgICAgaWYgKGNvdW50ID09PSAtMSkge1xuICAgICAgICAgICAgY291bnQgPSB2YWx1ZS5sZW5ndGg7XG4gICAgICAgICAgICB3cml0ZXIud3JpdGVWYWx1ZSh2YWx1ZS5sZW5ndGgpO1xuICAgICAgICB9XG4gICAgICAgIGFzc2VydEFyZ3VtZW50Q291bnQodmFsdWUubGVuZ3RoLCBjb3VudCwgXCJjb2RlciBhcnJheVwiICsgKHRoaXMubG9jYWxOYW1lID8gKFwiIFwiICsgdGhpcy5sb2NhbE5hbWUpIDogXCJcIikpO1xuICAgICAgICBsZXQgY29kZXJzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvZGVycy5wdXNoKHRoaXMuY29kZXIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYWNrKHdyaXRlciwgY29kZXJzLCB2YWx1ZSk7XG4gICAgfVxuICAgIGRlY29kZShyZWFkZXIpIHtcbiAgICAgICAgbGV0IGNvdW50ID0gdGhpcy5sZW5ndGg7XG4gICAgICAgIGlmIChjb3VudCA9PT0gLTEpIHtcbiAgICAgICAgICAgIGNvdW50ID0gcmVhZGVyLnJlYWRJbmRleCgpO1xuICAgICAgICAgICAgLy8gQ2hlY2sgdGhhdCB0aGVyZSBpcyAqcm91Z2hseSogZW5vdWdoIGRhdGEgdG8gZW5zdXJlXG4gICAgICAgICAgICAvLyBzdHJheSByYW5kb20gZGF0YSBpcyBub3QgYmVpbmcgcmVhZCBhcyBhIGxlbmd0aC4gRWFjaFxuICAgICAgICAgICAgLy8gc2xvdCByZXF1aXJlcyBhdCBsZWFzdCAzMiBieXRlcyBmb3IgdGhlaXIgdmFsdWUgKG9yIDMyXG4gICAgICAgICAgICAvLyBieXRlcyBhcyBhIGxpbmsgdG8gdGhlIGRhdGEpLiBUaGlzIGNvdWxkIHVzZSBhIG11Y2hcbiAgICAgICAgICAgIC8vIHRpZ2h0ZXIgYm91bmQsIGJ1dCB3ZSBhcmUgZXJyb3Jpbmcgb24gdGhlIHNpZGUgb2Ygc2FmZXR5LlxuICAgICAgICAgICAgYXNzZXJ0KGNvdW50ICogV29yZFNpemUgPD0gcmVhZGVyLmRhdGFMZW5ndGgsIFwiaW5zdWZmaWNpZW50IGRhdGEgbGVuZ3RoXCIsIFwiQlVGRkVSX09WRVJSVU5cIiwgeyBidWZmZXI6IHJlYWRlci5ieXRlcywgb2Zmc2V0OiBjb3VudCAqIFdvcmRTaXplLCBsZW5ndGg6IHJlYWRlci5kYXRhTGVuZ3RoIH0pO1xuICAgICAgICB9XG4gICAgICAgIGxldCBjb2RlcnMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgICAgICAgICBjb2RlcnMucHVzaChuZXcgQW5vbnltb3VzQ29kZXIodGhpcy5jb2RlcikpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bnBhY2socmVhZGVyLCBjb2RlcnMpO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFycmF5LmpzLm1hcCJdLCJuYW1lcyI6WyJkZWZpbmVQcm9wZXJ0aWVzIiwiaXNFcnJvciIsImFzc2VydCIsImFzc2VydEFyZ3VtZW50IiwiYXNzZXJ0QXJndW1lbnRDb3VudCIsIlR5cGVkIiwiQ29kZXIiLCJSZXN1bHQiLCJXb3JkU2l6ZSIsIldyaXRlciIsIkFub255bW91c0NvZGVyIiwicGFjayIsIndyaXRlciIsImNvZGVycyIsInZhbHVlcyIsImFycmF5VmFsdWVzIiwiQXJyYXkiLCJpc0FycmF5IiwidW5pcXVlIiwibWFwIiwiY29kZXIiLCJuYW1lIiwibG9jYWxOYW1lIiwiYXJndW1lbnQiLCJpbmZvIiwidmFsdWUiLCJsZW5ndGgiLCJzdGF0aWNXcml0ZXIiLCJkeW5hbWljV3JpdGVyIiwidXBkYXRlRnVuY3MiLCJmb3JFYWNoIiwiaW5kZXgiLCJkeW5hbWljIiwiZHluYW1pY09mZnNldCIsImVuY29kZSIsInVwZGF0ZUZ1bmMiLCJ3cml0ZVVwZGF0YWJsZVZhbHVlIiwicHVzaCIsImJhc2VPZmZzZXQiLCJmdW5jIiwiYXBwZW5kV3JpdGVyIiwidW5wYWNrIiwicmVhZGVyIiwia2V5cyIsImJhc2VSZWFkZXIiLCJzdWJSZWFkZXIiLCJvZmZzZXQiLCJyZWFkSW5kZXgiLCJvZmZzZXRSZWFkZXIiLCJkZWNvZGUiLCJlcnJvciIsImJhc2VUeXBlIiwidHlwZSIsInVuZGVmaW5lZCIsIkVycm9yIiwiZnJvbUl0ZW1zIiwiQXJyYXlDb2RlciIsImNvbnN0cnVjdG9yIiwiZGVmYXVsdFZhbHVlIiwiZGVmYXVsdENoaWxkIiwicmVzdWx0IiwiaSIsIl92YWx1ZSIsImRlcmVmZXJlbmNlIiwiX3Rocm93RXJyb3IiLCJjb3VudCIsIndyaXRlVmFsdWUiLCJkYXRhTGVuZ3RoIiwiYnVmZmVyIiwiYnl0ZXMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.esm/abi/coders/array.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.esm/abi/coders/boolean.js":
/*!***********************************************************!*\
  !*** ./node_modules/ethers/lib.esm/abi/coders/boolean.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BooleanCoder: () => (/* binding */ BooleanCoder)\n/* harmony export */ });\n/* harmony import */ var _typed_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../typed.js */ \"(ssr)/./node_modules/ethers/lib.esm/abi/typed.js\");\n/* harmony import */ var _abstract_coder_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract-coder.js */ \"(ssr)/./node_modules/ethers/lib.esm/abi/coders/abstract-coder.js\");\n\n\n/**\n *  @_ignore\n */ class BooleanCoder extends _abstract_coder_js__WEBPACK_IMPORTED_MODULE_0__.Coder {\n    constructor(localName){\n        super(\"bool\", \"bool\", localName, false);\n    }\n    defaultValue() {\n        return false;\n    }\n    encode(writer, _value) {\n        const value = _typed_js__WEBPACK_IMPORTED_MODULE_1__.Typed.dereference(_value, \"bool\");\n        return writer.writeValue(value ? 1 : 0);\n    }\n    decode(reader) {\n        return !!reader.readValue();\n    }\n} //# sourceMappingURL=boolean.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vYWJpL2NvZGVycy9ib29sZWFuLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFvQztBQUNRO0FBQzVDOztDQUVDLEdBQ00sTUFBTUUscUJBQXFCRCxxREFBS0E7SUFDbkNFLFlBQVlDLFNBQVMsQ0FBRTtRQUNuQixLQUFLLENBQUMsUUFBUSxRQUFRQSxXQUFXO0lBQ3JDO0lBQ0FDLGVBQWU7UUFDWCxPQUFPO0lBQ1g7SUFDQUMsT0FBT0MsTUFBTSxFQUFFQyxNQUFNLEVBQUU7UUFDbkIsTUFBTUMsUUFBUVQsNENBQUtBLENBQUNVLFdBQVcsQ0FBQ0YsUUFBUTtRQUN4QyxPQUFPRCxPQUFPSSxVQUFVLENBQUNGLFFBQVEsSUFBSTtJQUN6QztJQUNBRyxPQUFPQyxNQUFNLEVBQUU7UUFDWCxPQUFPLENBQUMsQ0FBQ0EsT0FBT0MsU0FBUztJQUM3QjtBQUNKLEVBQ0EsbUNBQW1DIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbWVnYXZpYmUtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vYWJpL2NvZGVycy9ib29sZWFuLmpzPzg2YzMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgVHlwZWQgfSBmcm9tIFwiLi4vdHlwZWQuanNcIjtcbmltcG9ydCB7IENvZGVyIH0gZnJvbSBcIi4vYWJzdHJhY3QtY29kZXIuanNcIjtcbi8qKlxuICogIEBfaWdub3JlXG4gKi9cbmV4cG9ydCBjbGFzcyBCb29sZWFuQ29kZXIgZXh0ZW5kcyBDb2RlciB7XG4gICAgY29uc3RydWN0b3IobG9jYWxOYW1lKSB7XG4gICAgICAgIHN1cGVyKFwiYm9vbFwiLCBcImJvb2xcIiwgbG9jYWxOYW1lLCBmYWxzZSk7XG4gICAgfVxuICAgIGRlZmF1bHRWYWx1ZSgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBlbmNvZGUod3JpdGVyLCBfdmFsdWUpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBUeXBlZC5kZXJlZmVyZW5jZShfdmFsdWUsIFwiYm9vbFwiKTtcbiAgICAgICAgcmV0dXJuIHdyaXRlci53cml0ZVZhbHVlKHZhbHVlID8gMSA6IDApO1xuICAgIH1cbiAgICBkZWNvZGUocmVhZGVyKSB7XG4gICAgICAgIHJldHVybiAhIXJlYWRlci5yZWFkVmFsdWUoKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ib29sZWFuLmpzLm1hcCJdLCJuYW1lcyI6WyJUeXBlZCIsIkNvZGVyIiwiQm9vbGVhbkNvZGVyIiwiY29uc3RydWN0b3IiLCJsb2NhbE5hbWUiLCJkZWZhdWx0VmFsdWUiLCJlbmNvZGUiLCJ3cml0ZXIiLCJfdmFsdWUiLCJ2YWx1ZSIsImRlcmVmZXJlbmNlIiwid3JpdGVWYWx1ZSIsImRlY29kZSIsInJlYWRlciIsInJlYWRWYWx1ZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.esm/abi/coders/boolean.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.esm/abi/coders/bytes.js":
/*!*********************************************************!*\
  !*** ./node_modules/ethers/lib.esm/abi/coders/bytes.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BytesCoder: () => (/* binding */ BytesCoder),\n/* harmony export */   DynamicBytesCoder: () => (/* binding */ DynamicBytesCoder)\n/* harmony export */ });\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/data.js\");\n/* harmony import */ var _abstract_coder_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract-coder.js */ \"(ssr)/./node_modules/ethers/lib.esm/abi/coders/abstract-coder.js\");\n\n\n/**\n *  @_ignore\n */ class DynamicBytesCoder extends _abstract_coder_js__WEBPACK_IMPORTED_MODULE_0__.Coder {\n    constructor(type, localName){\n        super(type, type, localName, true);\n    }\n    defaultValue() {\n        return \"0x\";\n    }\n    encode(writer, value) {\n        value = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.getBytesCopy)(value);\n        let length = writer.writeValue(value.length);\n        length += writer.writeBytes(value);\n        return length;\n    }\n    decode(reader) {\n        return reader.readBytes(reader.readIndex(), true);\n    }\n}\n/**\n *  @_ignore\n */ class BytesCoder extends DynamicBytesCoder {\n    constructor(localName){\n        super(\"bytes\", localName);\n    }\n    decode(reader) {\n        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.hexlify)(super.decode(reader));\n    }\n} //# sourceMappingURL=bytes.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vYWJpL2NvZGVycy9ieXRlcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQTZEO0FBQ2pCO0FBQzVDOztDQUVDLEdBQ00sTUFBTUcsMEJBQTBCRCxxREFBS0E7SUFDeENFLFlBQVlDLElBQUksRUFBRUMsU0FBUyxDQUFFO1FBQ3pCLEtBQUssQ0FBQ0QsTUFBTUEsTUFBTUMsV0FBVztJQUNqQztJQUNBQyxlQUFlO1FBQ1gsT0FBTztJQUNYO0lBQ0FDLE9BQU9DLE1BQU0sRUFBRUMsS0FBSyxFQUFFO1FBQ2xCQSxRQUFRViw2REFBWUEsQ0FBQ1U7UUFDckIsSUFBSUMsU0FBU0YsT0FBT0csVUFBVSxDQUFDRixNQUFNQyxNQUFNO1FBQzNDQSxVQUFVRixPQUFPSSxVQUFVLENBQUNIO1FBQzVCLE9BQU9DO0lBQ1g7SUFDQUcsT0FBT0MsTUFBTSxFQUFFO1FBQ1gsT0FBT0EsT0FBT0MsU0FBUyxDQUFDRCxPQUFPRSxTQUFTLElBQUk7SUFDaEQ7QUFDSjtBQUNBOztDQUVDLEdBQ00sTUFBTUMsbUJBQW1CZjtJQUM1QkMsWUFBWUUsU0FBUyxDQUFFO1FBQ25CLEtBQUssQ0FBQyxTQUFTQTtJQUNuQjtJQUNBUSxPQUFPQyxNQUFNLEVBQUU7UUFDWCxPQUFPZCx3REFBT0EsQ0FBQyxLQUFLLENBQUNhLE9BQU9DO0lBQ2hDO0FBQ0osRUFDQSxpQ0FBaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tZWdhdmliZS1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9hYmkvY29kZXJzL2J5dGVzLmpzP2YzNDQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZ2V0Qnl0ZXNDb3B5LCBoZXhsaWZ5IH0gZnJvbSBcIi4uLy4uL3V0aWxzL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBDb2RlciB9IGZyb20gXCIuL2Fic3RyYWN0LWNvZGVyLmpzXCI7XG4vKipcbiAqICBAX2lnbm9yZVxuICovXG5leHBvcnQgY2xhc3MgRHluYW1pY0J5dGVzQ29kZXIgZXh0ZW5kcyBDb2RlciB7XG4gICAgY29uc3RydWN0b3IodHlwZSwgbG9jYWxOYW1lKSB7XG4gICAgICAgIHN1cGVyKHR5cGUsIHR5cGUsIGxvY2FsTmFtZSwgdHJ1ZSk7XG4gICAgfVxuICAgIGRlZmF1bHRWYWx1ZSgpIHtcbiAgICAgICAgcmV0dXJuIFwiMHhcIjtcbiAgICB9XG4gICAgZW5jb2RlKHdyaXRlciwgdmFsdWUpIHtcbiAgICAgICAgdmFsdWUgPSBnZXRCeXRlc0NvcHkodmFsdWUpO1xuICAgICAgICBsZXQgbGVuZ3RoID0gd3JpdGVyLndyaXRlVmFsdWUodmFsdWUubGVuZ3RoKTtcbiAgICAgICAgbGVuZ3RoICs9IHdyaXRlci53cml0ZUJ5dGVzKHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIGxlbmd0aDtcbiAgICB9XG4gICAgZGVjb2RlKHJlYWRlcikge1xuICAgICAgICByZXR1cm4gcmVhZGVyLnJlYWRCeXRlcyhyZWFkZXIucmVhZEluZGV4KCksIHRydWUpO1xuICAgIH1cbn1cbi8qKlxuICogIEBfaWdub3JlXG4gKi9cbmV4cG9ydCBjbGFzcyBCeXRlc0NvZGVyIGV4dGVuZHMgRHluYW1pY0J5dGVzQ29kZXIge1xuICAgIGNvbnN0cnVjdG9yKGxvY2FsTmFtZSkge1xuICAgICAgICBzdXBlcihcImJ5dGVzXCIsIGxvY2FsTmFtZSk7XG4gICAgfVxuICAgIGRlY29kZShyZWFkZXIpIHtcbiAgICAgICAgcmV0dXJuIGhleGxpZnkoc3VwZXIuZGVjb2RlKHJlYWRlcikpO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJ5dGVzLmpzLm1hcCJdLCJuYW1lcyI6WyJnZXRCeXRlc0NvcHkiLCJoZXhsaWZ5IiwiQ29kZXIiLCJEeW5hbWljQnl0ZXNDb2RlciIsImNvbnN0cnVjdG9yIiwidHlwZSIsImxvY2FsTmFtZSIsImRlZmF1bHRWYWx1ZSIsImVuY29kZSIsIndyaXRlciIsInZhbHVlIiwibGVuZ3RoIiwid3JpdGVWYWx1ZSIsIndyaXRlQnl0ZXMiLCJkZWNvZGUiLCJyZWFkZXIiLCJyZWFkQnl0ZXMiLCJyZWFkSW5kZXgiLCJCeXRlc0NvZGVyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.esm/abi/coders/bytes.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.esm/abi/coders/fixed-bytes.js":
/*!***************************************************************!*\
  !*** ./node_modules/ethers/lib.esm/abi/coders/fixed-bytes.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FixedBytesCoder: () => (/* binding */ FixedBytesCoder)\n/* harmony export */ });\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/properties.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/data.js\");\n/* harmony import */ var _typed_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../typed.js */ \"(ssr)/./node_modules/ethers/lib.esm/abi/typed.js\");\n/* harmony import */ var _abstract_coder_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract-coder.js */ \"(ssr)/./node_modules/ethers/lib.esm/abi/coders/abstract-coder.js\");\n\n\n\n/**\n *  @_ignore\n */ class FixedBytesCoder extends _abstract_coder_js__WEBPACK_IMPORTED_MODULE_0__.Coder {\n    constructor(size, localName){\n        let name = \"bytes\" + String(size);\n        super(name, name, localName, false);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.defineProperties)(this, {\n            size\n        }, {\n            size: \"number\"\n        });\n    }\n    defaultValue() {\n        return \"0x0000000000000000000000000000000000000000000000000000000000000000\".substring(0, 2 + this.size * 2);\n    }\n    encode(writer, _value) {\n        let data = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.getBytesCopy)(_typed_js__WEBPACK_IMPORTED_MODULE_3__.Typed.dereference(_value, this.type));\n        if (data.length !== this.size) {\n            this._throwError(\"incorrect data length\", _value);\n        }\n        return writer.writeBytes(data);\n    }\n    decode(reader) {\n        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.hexlify)(reader.readBytes(this.size));\n    }\n} //# sourceMappingURL=fixed-bytes.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vYWJpL2NvZGVycy9maXhlZC1ieXRlcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUErRTtBQUMzQztBQUNRO0FBQzVDOztDQUVDLEdBQ00sTUFBTUssd0JBQXdCRCxxREFBS0E7SUFFdENFLFlBQVlDLElBQUksRUFBRUMsU0FBUyxDQUFFO1FBQ3pCLElBQUlDLE9BQU8sVUFBVUMsT0FBT0g7UUFDNUIsS0FBSyxDQUFDRSxNQUFNQSxNQUFNRCxXQUFXO1FBQzdCUixpRUFBZ0JBLENBQUMsSUFBSSxFQUFFO1lBQUVPO1FBQUssR0FBRztZQUFFQSxNQUFNO1FBQVM7SUFDdEQ7SUFDQUksZUFBZTtRQUNYLE9BQU8scUVBQXVFQyxTQUFTLENBQUMsR0FBRyxJQUFJLElBQUksQ0FBQ0wsSUFBSSxHQUFHO0lBQy9HO0lBQ0FNLE9BQU9DLE1BQU0sRUFBRUMsTUFBTSxFQUFFO1FBQ25CLElBQUlDLE9BQU9mLDZEQUFZQSxDQUFDRSw0Q0FBS0EsQ0FBQ2MsV0FBVyxDQUFDRixRQUFRLElBQUksQ0FBQ0csSUFBSTtRQUMzRCxJQUFJRixLQUFLRyxNQUFNLEtBQUssSUFBSSxDQUFDWixJQUFJLEVBQUU7WUFDM0IsSUFBSSxDQUFDYSxXQUFXLENBQUMseUJBQXlCTDtRQUM5QztRQUNBLE9BQU9ELE9BQU9PLFVBQVUsQ0FBQ0w7SUFDN0I7SUFDQU0sT0FBT0MsTUFBTSxFQUFFO1FBQ1gsT0FBT3JCLHdEQUFPQSxDQUFDcUIsT0FBT0MsU0FBUyxDQUFDLElBQUksQ0FBQ2pCLElBQUk7SUFDN0M7QUFDSixFQUNBLHVDQUF1QyIsInNvdXJjZXMiOlsid2VicGFjazovL21lZ2F2aWJlLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL2FiaS9jb2RlcnMvZml4ZWQtYnl0ZXMuanM/NmVlZCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBkZWZpbmVQcm9wZXJ0aWVzLCBnZXRCeXRlc0NvcHksIGhleGxpZnkgfSBmcm9tIFwiLi4vLi4vdXRpbHMvaW5kZXguanNcIjtcbmltcG9ydCB7IFR5cGVkIH0gZnJvbSBcIi4uL3R5cGVkLmpzXCI7XG5pbXBvcnQgeyBDb2RlciB9IGZyb20gXCIuL2Fic3RyYWN0LWNvZGVyLmpzXCI7XG4vKipcbiAqICBAX2lnbm9yZVxuICovXG5leHBvcnQgY2xhc3MgRml4ZWRCeXRlc0NvZGVyIGV4dGVuZHMgQ29kZXIge1xuICAgIHNpemU7XG4gICAgY29uc3RydWN0b3Ioc2l6ZSwgbG9jYWxOYW1lKSB7XG4gICAgICAgIGxldCBuYW1lID0gXCJieXRlc1wiICsgU3RyaW5nKHNpemUpO1xuICAgICAgICBzdXBlcihuYW1lLCBuYW1lLCBsb2NhbE5hbWUsIGZhbHNlKTtcbiAgICAgICAgZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7IHNpemUgfSwgeyBzaXplOiBcIm51bWJlclwiIH0pO1xuICAgIH1cbiAgICBkZWZhdWx0VmFsdWUoKSB7XG4gICAgICAgIHJldHVybiAoXCIweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDBcIikuc3Vic3RyaW5nKDAsIDIgKyB0aGlzLnNpemUgKiAyKTtcbiAgICB9XG4gICAgZW5jb2RlKHdyaXRlciwgX3ZhbHVlKSB7XG4gICAgICAgIGxldCBkYXRhID0gZ2V0Qnl0ZXNDb3B5KFR5cGVkLmRlcmVmZXJlbmNlKF92YWx1ZSwgdGhpcy50eXBlKSk7XG4gICAgICAgIGlmIChkYXRhLmxlbmd0aCAhPT0gdGhpcy5zaXplKSB7XG4gICAgICAgICAgICB0aGlzLl90aHJvd0Vycm9yKFwiaW5jb3JyZWN0IGRhdGEgbGVuZ3RoXCIsIF92YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdyaXRlci53cml0ZUJ5dGVzKGRhdGEpO1xuICAgIH1cbiAgICBkZWNvZGUocmVhZGVyKSB7XG4gICAgICAgIHJldHVybiBoZXhsaWZ5KHJlYWRlci5yZWFkQnl0ZXModGhpcy5zaXplKSk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Zml4ZWQtYnl0ZXMuanMubWFwIl0sIm5hbWVzIjpbImRlZmluZVByb3BlcnRpZXMiLCJnZXRCeXRlc0NvcHkiLCJoZXhsaWZ5IiwiVHlwZWQiLCJDb2RlciIsIkZpeGVkQnl0ZXNDb2RlciIsImNvbnN0cnVjdG9yIiwic2l6ZSIsImxvY2FsTmFtZSIsIm5hbWUiLCJTdHJpbmciLCJkZWZhdWx0VmFsdWUiLCJzdWJzdHJpbmciLCJlbmNvZGUiLCJ3cml0ZXIiLCJfdmFsdWUiLCJkYXRhIiwiZGVyZWZlcmVuY2UiLCJ0eXBlIiwibGVuZ3RoIiwiX3Rocm93RXJyb3IiLCJ3cml0ZUJ5dGVzIiwiZGVjb2RlIiwicmVhZGVyIiwicmVhZEJ5dGVzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.esm/abi/coders/fixed-bytes.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.esm/abi/coders/null.js":
/*!********************************************************!*\
  !*** ./node_modules/ethers/lib.esm/abi/coders/null.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   NullCoder: () => (/* binding */ NullCoder)\n/* harmony export */ });\n/* harmony import */ var _abstract_coder_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract-coder.js */ \"(ssr)/./node_modules/ethers/lib.esm/abi/coders/abstract-coder.js\");\n\nconst Empty = new Uint8Array([]);\n/**\n *  @_ignore\n */ class NullCoder extends _abstract_coder_js__WEBPACK_IMPORTED_MODULE_0__.Coder {\n    constructor(localName){\n        super(\"null\", \"\", localName, false);\n    }\n    defaultValue() {\n        return null;\n    }\n    encode(writer, value) {\n        if (value != null) {\n            this._throwError(\"not null\", value);\n        }\n        return writer.writeBytes(Empty);\n    }\n    decode(reader) {\n        reader.readBytes(0);\n        return null;\n    }\n} //# sourceMappingURL=null.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vYWJpL2NvZGVycy9udWxsLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQTRDO0FBQzVDLE1BQU1DLFFBQVEsSUFBSUMsV0FBVyxFQUFFO0FBQy9COztDQUVDLEdBQ00sTUFBTUMsa0JBQWtCSCxxREFBS0E7SUFDaENJLFlBQVlDLFNBQVMsQ0FBRTtRQUNuQixLQUFLLENBQUMsUUFBUSxJQUFJQSxXQUFXO0lBQ2pDO0lBQ0FDLGVBQWU7UUFDWCxPQUFPO0lBQ1g7SUFDQUMsT0FBT0MsTUFBTSxFQUFFQyxLQUFLLEVBQUU7UUFDbEIsSUFBSUEsU0FBUyxNQUFNO1lBQ2YsSUFBSSxDQUFDQyxXQUFXLENBQUMsWUFBWUQ7UUFDakM7UUFDQSxPQUFPRCxPQUFPRyxVQUFVLENBQUNWO0lBQzdCO0lBQ0FXLE9BQU9DLE1BQU0sRUFBRTtRQUNYQSxPQUFPQyxTQUFTLENBQUM7UUFDakIsT0FBTztJQUNYO0FBQ0osRUFDQSxnQ0FBZ0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tZWdhdmliZS1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9hYmkvY29kZXJzL251bGwuanM/YjIxNiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDb2RlciB9IGZyb20gXCIuL2Fic3RyYWN0LWNvZGVyLmpzXCI7XG5jb25zdCBFbXB0eSA9IG5ldyBVaW50OEFycmF5KFtdKTtcbi8qKlxuICogIEBfaWdub3JlXG4gKi9cbmV4cG9ydCBjbGFzcyBOdWxsQ29kZXIgZXh0ZW5kcyBDb2RlciB7XG4gICAgY29uc3RydWN0b3IobG9jYWxOYW1lKSB7XG4gICAgICAgIHN1cGVyKFwibnVsbFwiLCBcIlwiLCBsb2NhbE5hbWUsIGZhbHNlKTtcbiAgICB9XG4gICAgZGVmYXVsdFZhbHVlKCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZW5jb2RlKHdyaXRlciwgdmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuX3Rocm93RXJyb3IoXCJub3QgbnVsbFwiLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdyaXRlci53cml0ZUJ5dGVzKEVtcHR5KTtcbiAgICB9XG4gICAgZGVjb2RlKHJlYWRlcikge1xuICAgICAgICByZWFkZXIucmVhZEJ5dGVzKDApO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1udWxsLmpzLm1hcCJdLCJuYW1lcyI6WyJDb2RlciIsIkVtcHR5IiwiVWludDhBcnJheSIsIk51bGxDb2RlciIsImNvbnN0cnVjdG9yIiwibG9jYWxOYW1lIiwiZGVmYXVsdFZhbHVlIiwiZW5jb2RlIiwid3JpdGVyIiwidmFsdWUiLCJfdGhyb3dFcnJvciIsIndyaXRlQnl0ZXMiLCJkZWNvZGUiLCJyZWFkZXIiLCJyZWFkQnl0ZXMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.esm/abi/coders/null.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.esm/abi/coders/number.js":
/*!**********************************************************!*\
  !*** ./node_modules/ethers/lib.esm/abi/coders/number.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   NumberCoder: () => (/* binding */ NumberCoder)\n/* harmony export */ });\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/properties.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/maths.js\");\n/* harmony import */ var _typed_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../typed.js */ \"(ssr)/./node_modules/ethers/lib.esm/abi/typed.js\");\n/* harmony import */ var _abstract_coder_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract-coder.js */ \"(ssr)/./node_modules/ethers/lib.esm/abi/coders/abstract-coder.js\");\n\n\n\nconst BN_0 = BigInt(0);\nconst BN_1 = BigInt(1);\nconst BN_MAX_UINT256 = BigInt(\"0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\");\n/**\n *  @_ignore\n */ class NumberCoder extends _abstract_coder_js__WEBPACK_IMPORTED_MODULE_0__.Coder {\n    constructor(size, signed, localName){\n        const name = (signed ? \"int\" : \"uint\") + size * 8;\n        super(name, name, localName, false);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.defineProperties)(this, {\n            size,\n            signed\n        }, {\n            size: \"number\",\n            signed: \"boolean\"\n        });\n    }\n    defaultValue() {\n        return 0;\n    }\n    encode(writer, _value) {\n        let value = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.getBigInt)(_typed_js__WEBPACK_IMPORTED_MODULE_3__.Typed.dereference(_value, this.type));\n        // Check bounds are safe for encoding\n        let maxUintValue = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.mask)(BN_MAX_UINT256, _abstract_coder_js__WEBPACK_IMPORTED_MODULE_0__.WordSize * 8);\n        if (this.signed) {\n            let bounds = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.mask)(maxUintValue, this.size * 8 - 1);\n            if (value > bounds || value < -(bounds + BN_1)) {\n                this._throwError(\"value out-of-bounds\", _value);\n            }\n            value = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.toTwos)(value, 8 * _abstract_coder_js__WEBPACK_IMPORTED_MODULE_0__.WordSize);\n        } else if (value < BN_0 || value > (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.mask)(maxUintValue, this.size * 8)) {\n            this._throwError(\"value out-of-bounds\", _value);\n        }\n        return writer.writeValue(value);\n    }\n    decode(reader) {\n        let value = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.mask)(reader.readValue(), this.size * 8);\n        if (this.signed) {\n            value = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.fromTwos)(value, this.size * 8);\n        }\n        return value;\n    }\n} //# sourceMappingURL=number.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vYWJpL2NvZGVycy9udW1iZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBMkY7QUFDdkQ7QUFDa0I7QUFDdEQsTUFBTVEsT0FBT0MsT0FBTztBQUNwQixNQUFNQyxPQUFPRCxPQUFPO0FBQ3BCLE1BQU1FLGlCQUFpQkYsT0FBTztBQUM5Qjs7Q0FFQyxHQUNNLE1BQU1HLG9CQUFvQk4scURBQUtBO0lBR2xDTyxZQUFZQyxJQUFJLEVBQUVDLE1BQU0sRUFBRUMsU0FBUyxDQUFFO1FBQ2pDLE1BQU1DLE9BQVEsQ0FBQ0YsU0FBUyxRQUFRLE1BQUssSUFBTUQsT0FBTztRQUNsRCxLQUFLLENBQUNHLE1BQU1BLE1BQU1ELFdBQVc7UUFDN0JoQixpRUFBZ0JBLENBQUMsSUFBSSxFQUFFO1lBQUVjO1lBQU1DO1FBQU8sR0FBRztZQUFFRCxNQUFNO1lBQVVDLFFBQVE7UUFBVTtJQUNqRjtJQUNBRyxlQUFlO1FBQ1gsT0FBTztJQUNYO0lBQ0FDLE9BQU9DLE1BQU0sRUFBRUMsTUFBTSxFQUFFO1FBQ25CLElBQUlDLFFBQVFwQiwwREFBU0EsQ0FBQ0csNENBQUtBLENBQUNrQixXQUFXLENBQUNGLFFBQVEsSUFBSSxDQUFDRyxJQUFJO1FBQ3pELHFDQUFxQztRQUNyQyxJQUFJQyxlQUFldEIscURBQUlBLENBQUNRLGdCQUFnQkosd0RBQVFBLEdBQUc7UUFDbkQsSUFBSSxJQUFJLENBQUNRLE1BQU0sRUFBRTtZQUNiLElBQUlXLFNBQVN2QixxREFBSUEsQ0FBQ3NCLGNBQWMsSUFBSyxDQUFDWCxJQUFJLEdBQUcsSUFBSztZQUNsRCxJQUFJUSxRQUFRSSxVQUFVSixRQUFRLENBQUVJLENBQUFBLFNBQVNoQixJQUFHLEdBQUk7Z0JBQzVDLElBQUksQ0FBQ2lCLFdBQVcsQ0FBQyx1QkFBdUJOO1lBQzVDO1lBQ0FDLFFBQVFsQix1REFBTUEsQ0FBQ2tCLE9BQU8sSUFBSWYsd0RBQVFBO1FBQ3RDLE9BQ0ssSUFBSWUsUUFBUWQsUUFBUWMsUUFBUW5CLHFEQUFJQSxDQUFDc0IsY0FBYyxJQUFJLENBQUNYLElBQUksR0FBRyxJQUFJO1lBQ2hFLElBQUksQ0FBQ2EsV0FBVyxDQUFDLHVCQUF1Qk47UUFDNUM7UUFDQSxPQUFPRCxPQUFPUSxVQUFVLENBQUNOO0lBQzdCO0lBQ0FPLE9BQU9DLE1BQU0sRUFBRTtRQUNYLElBQUlSLFFBQVFuQixxREFBSUEsQ0FBQzJCLE9BQU9DLFNBQVMsSUFBSSxJQUFJLENBQUNqQixJQUFJLEdBQUc7UUFDakQsSUFBSSxJQUFJLENBQUNDLE1BQU0sRUFBRTtZQUNiTyxRQUFRckIseURBQVFBLENBQUNxQixPQUFPLElBQUksQ0FBQ1IsSUFBSSxHQUFHO1FBQ3hDO1FBQ0EsT0FBT1E7SUFDWDtBQUNKLEVBQ0Esa0NBQWtDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbWVnYXZpYmUtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vYWJpL2NvZGVycy9udW1iZXIuanM/NzE1NyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBkZWZpbmVQcm9wZXJ0aWVzLCBmcm9tVHdvcywgZ2V0QmlnSW50LCBtYXNrLCB0b1R3b3MgfSBmcm9tIFwiLi4vLi4vdXRpbHMvaW5kZXguanNcIjtcbmltcG9ydCB7IFR5cGVkIH0gZnJvbSBcIi4uL3R5cGVkLmpzXCI7XG5pbXBvcnQgeyBDb2RlciwgV29yZFNpemUgfSBmcm9tIFwiLi9hYnN0cmFjdC1jb2Rlci5qc1wiO1xuY29uc3QgQk5fMCA9IEJpZ0ludCgwKTtcbmNvbnN0IEJOXzEgPSBCaWdJbnQoMSk7XG5jb25zdCBCTl9NQVhfVUlOVDI1NiA9IEJpZ0ludChcIjB4ZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZlwiKTtcbi8qKlxuICogIEBfaWdub3JlXG4gKi9cbmV4cG9ydCBjbGFzcyBOdW1iZXJDb2RlciBleHRlbmRzIENvZGVyIHtcbiAgICBzaXplO1xuICAgIHNpZ25lZDtcbiAgICBjb25zdHJ1Y3RvcihzaXplLCBzaWduZWQsIGxvY2FsTmFtZSkge1xuICAgICAgICBjb25zdCBuYW1lID0gKChzaWduZWQgPyBcImludFwiIDogXCJ1aW50XCIpICsgKHNpemUgKiA4KSk7XG4gICAgICAgIHN1cGVyKG5hbWUsIG5hbWUsIGxvY2FsTmFtZSwgZmFsc2UpO1xuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHsgc2l6ZSwgc2lnbmVkIH0sIHsgc2l6ZTogXCJudW1iZXJcIiwgc2lnbmVkOiBcImJvb2xlYW5cIiB9KTtcbiAgICB9XG4gICAgZGVmYXVsdFZhbHVlKCkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgZW5jb2RlKHdyaXRlciwgX3ZhbHVlKSB7XG4gICAgICAgIGxldCB2YWx1ZSA9IGdldEJpZ0ludChUeXBlZC5kZXJlZmVyZW5jZShfdmFsdWUsIHRoaXMudHlwZSkpO1xuICAgICAgICAvLyBDaGVjayBib3VuZHMgYXJlIHNhZmUgZm9yIGVuY29kaW5nXG4gICAgICAgIGxldCBtYXhVaW50VmFsdWUgPSBtYXNrKEJOX01BWF9VSU5UMjU2LCBXb3JkU2l6ZSAqIDgpO1xuICAgICAgICBpZiAodGhpcy5zaWduZWQpIHtcbiAgICAgICAgICAgIGxldCBib3VuZHMgPSBtYXNrKG1heFVpbnRWYWx1ZSwgKHRoaXMuc2l6ZSAqIDgpIC0gMSk7XG4gICAgICAgICAgICBpZiAodmFsdWUgPiBib3VuZHMgfHwgdmFsdWUgPCAtKGJvdW5kcyArIEJOXzEpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdGhyb3dFcnJvcihcInZhbHVlIG91dC1vZi1ib3VuZHNcIiwgX3ZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhbHVlID0gdG9Ud29zKHZhbHVlLCA4ICogV29yZFNpemUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHZhbHVlIDwgQk5fMCB8fCB2YWx1ZSA+IG1hc2sobWF4VWludFZhbHVlLCB0aGlzLnNpemUgKiA4KSkge1xuICAgICAgICAgICAgdGhpcy5fdGhyb3dFcnJvcihcInZhbHVlIG91dC1vZi1ib3VuZHNcIiwgX3ZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd3JpdGVyLndyaXRlVmFsdWUodmFsdWUpO1xuICAgIH1cbiAgICBkZWNvZGUocmVhZGVyKSB7XG4gICAgICAgIGxldCB2YWx1ZSA9IG1hc2socmVhZGVyLnJlYWRWYWx1ZSgpLCB0aGlzLnNpemUgKiA4KTtcbiAgICAgICAgaWYgKHRoaXMuc2lnbmVkKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IGZyb21Ud29zKHZhbHVlLCB0aGlzLnNpemUgKiA4KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bnVtYmVyLmpzLm1hcCJdLCJuYW1lcyI6WyJkZWZpbmVQcm9wZXJ0aWVzIiwiZnJvbVR3b3MiLCJnZXRCaWdJbnQiLCJtYXNrIiwidG9Ud29zIiwiVHlwZWQiLCJDb2RlciIsIldvcmRTaXplIiwiQk5fMCIsIkJpZ0ludCIsIkJOXzEiLCJCTl9NQVhfVUlOVDI1NiIsIk51bWJlckNvZGVyIiwiY29uc3RydWN0b3IiLCJzaXplIiwic2lnbmVkIiwibG9jYWxOYW1lIiwibmFtZSIsImRlZmF1bHRWYWx1ZSIsImVuY29kZSIsIndyaXRlciIsIl92YWx1ZSIsInZhbHVlIiwiZGVyZWZlcmVuY2UiLCJ0eXBlIiwibWF4VWludFZhbHVlIiwiYm91bmRzIiwiX3Rocm93RXJyb3IiLCJ3cml0ZVZhbHVlIiwiZGVjb2RlIiwicmVhZGVyIiwicmVhZFZhbHVlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.esm/abi/coders/number.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.esm/abi/coders/string.js":
/*!**********************************************************!*\
  !*** ./node_modules/ethers/lib.esm/abi/coders/string.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   StringCoder: () => (/* binding */ StringCoder)\n/* harmony export */ });\n/* harmony import */ var _utils_utf8_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils/utf8.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/utf8.js\");\n/* harmony import */ var _typed_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../typed.js */ \"(ssr)/./node_modules/ethers/lib.esm/abi/typed.js\");\n/* harmony import */ var _bytes_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./bytes.js */ \"(ssr)/./node_modules/ethers/lib.esm/abi/coders/bytes.js\");\n\n\n\n/**\n *  @_ignore\n */ class StringCoder extends _bytes_js__WEBPACK_IMPORTED_MODULE_0__.DynamicBytesCoder {\n    constructor(localName){\n        super(\"string\", localName);\n    }\n    defaultValue() {\n        return \"\";\n    }\n    encode(writer, _value) {\n        return super.encode(writer, (0,_utils_utf8_js__WEBPACK_IMPORTED_MODULE_1__.toUtf8Bytes)(_typed_js__WEBPACK_IMPORTED_MODULE_2__.Typed.dereference(_value, \"string\")));\n    }\n    decode(reader) {\n        return (0,_utils_utf8_js__WEBPACK_IMPORTED_MODULE_1__.toUtf8String)(super.decode(reader));\n    }\n} //# sourceMappingURL=string.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vYWJpL2NvZGVycy9zdHJpbmcuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFnRTtBQUM1QjtBQUNXO0FBQy9DOztDQUVDLEdBQ00sTUFBTUksb0JBQW9CRCx3REFBaUJBO0lBQzlDRSxZQUFZQyxTQUFTLENBQUU7UUFDbkIsS0FBSyxDQUFDLFVBQVVBO0lBQ3BCO0lBQ0FDLGVBQWU7UUFDWCxPQUFPO0lBQ1g7SUFDQUMsT0FBT0MsTUFBTSxFQUFFQyxNQUFNLEVBQUU7UUFDbkIsT0FBTyxLQUFLLENBQUNGLE9BQU9DLFFBQVFULDJEQUFXQSxDQUFDRSw0Q0FBS0EsQ0FBQ1MsV0FBVyxDQUFDRCxRQUFRO0lBQ3RFO0lBQ0FFLE9BQU9DLE1BQU0sRUFBRTtRQUNYLE9BQU9aLDREQUFZQSxDQUFDLEtBQUssQ0FBQ1csT0FBT0M7SUFDckM7QUFDSixFQUNBLGtDQUFrQyIsInNvdXJjZXMiOlsid2VicGFjazovL21lZ2F2aWJlLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL2FiaS9jb2RlcnMvc3RyaW5nLmpzP2ZiNmMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgdG9VdGY4Qnl0ZXMsIHRvVXRmOFN0cmluZyB9IGZyb20gXCIuLi8uLi91dGlscy91dGY4LmpzXCI7XG5pbXBvcnQgeyBUeXBlZCB9IGZyb20gXCIuLi90eXBlZC5qc1wiO1xuaW1wb3J0IHsgRHluYW1pY0J5dGVzQ29kZXIgfSBmcm9tIFwiLi9ieXRlcy5qc1wiO1xuLyoqXG4gKiAgQF9pZ25vcmVcbiAqL1xuZXhwb3J0IGNsYXNzIFN0cmluZ0NvZGVyIGV4dGVuZHMgRHluYW1pY0J5dGVzQ29kZXIge1xuICAgIGNvbnN0cnVjdG9yKGxvY2FsTmFtZSkge1xuICAgICAgICBzdXBlcihcInN0cmluZ1wiLCBsb2NhbE5hbWUpO1xuICAgIH1cbiAgICBkZWZhdWx0VmFsdWUoKSB7XG4gICAgICAgIHJldHVybiBcIlwiO1xuICAgIH1cbiAgICBlbmNvZGUod3JpdGVyLCBfdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHN1cGVyLmVuY29kZSh3cml0ZXIsIHRvVXRmOEJ5dGVzKFR5cGVkLmRlcmVmZXJlbmNlKF92YWx1ZSwgXCJzdHJpbmdcIikpKTtcbiAgICB9XG4gICAgZGVjb2RlKHJlYWRlcikge1xuICAgICAgICByZXR1cm4gdG9VdGY4U3RyaW5nKHN1cGVyLmRlY29kZShyZWFkZXIpKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zdHJpbmcuanMubWFwIl0sIm5hbWVzIjpbInRvVXRmOEJ5dGVzIiwidG9VdGY4U3RyaW5nIiwiVHlwZWQiLCJEeW5hbWljQnl0ZXNDb2RlciIsIlN0cmluZ0NvZGVyIiwiY29uc3RydWN0b3IiLCJsb2NhbE5hbWUiLCJkZWZhdWx0VmFsdWUiLCJlbmNvZGUiLCJ3cml0ZXIiLCJfdmFsdWUiLCJkZXJlZmVyZW5jZSIsImRlY29kZSIsInJlYWRlciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.esm/abi/coders/string.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.esm/abi/coders/tuple.js":
/*!*********************************************************!*\
  !*** ./node_modules/ethers/lib.esm/abi/coders/tuple.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   TupleCoder: () => (/* binding */ TupleCoder)\n/* harmony export */ });\n/* harmony import */ var _utils_properties_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils/properties.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/properties.js\");\n/* harmony import */ var _typed_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../typed.js */ \"(ssr)/./node_modules/ethers/lib.esm/abi/typed.js\");\n/* harmony import */ var _abstract_coder_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract-coder.js */ \"(ssr)/./node_modules/ethers/lib.esm/abi/coders/abstract-coder.js\");\n/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./array.js */ \"(ssr)/./node_modules/ethers/lib.esm/abi/coders/array.js\");\n\n\n\n\n/**\n *  @_ignore\n */ class TupleCoder extends _abstract_coder_js__WEBPACK_IMPORTED_MODULE_0__.Coder {\n    constructor(coders, localName){\n        let dynamic = false;\n        const types = [];\n        coders.forEach((coder)=>{\n            if (coder.dynamic) {\n                dynamic = true;\n            }\n            types.push(coder.type);\n        });\n        const type = \"tuple(\" + types.join(\",\") + \")\";\n        super(\"tuple\", type, localName, dynamic);\n        (0,_utils_properties_js__WEBPACK_IMPORTED_MODULE_1__.defineProperties)(this, {\n            coders: Object.freeze(coders.slice())\n        });\n    }\n    defaultValue() {\n        const values = [];\n        this.coders.forEach((coder)=>{\n            values.push(coder.defaultValue());\n        });\n        // We only output named properties for uniquely named coders\n        const uniqueNames = this.coders.reduce((accum, coder)=>{\n            const name = coder.localName;\n            if (name) {\n                if (!accum[name]) {\n                    accum[name] = 0;\n                }\n                accum[name]++;\n            }\n            return accum;\n        }, {});\n        // Add named values\n        this.coders.forEach((coder, index)=>{\n            let name = coder.localName;\n            if (!name || uniqueNames[name] !== 1) {\n                return;\n            }\n            if (name === \"length\") {\n                name = \"_length\";\n            }\n            if (values[name] != null) {\n                return;\n            }\n            values[name] = values[index];\n        });\n        return Object.freeze(values);\n    }\n    encode(writer, _value) {\n        const value = _typed_js__WEBPACK_IMPORTED_MODULE_2__.Typed.dereference(_value, \"tuple\");\n        return (0,_array_js__WEBPACK_IMPORTED_MODULE_3__.pack)(writer, this.coders, value);\n    }\n    decode(reader) {\n        return (0,_array_js__WEBPACK_IMPORTED_MODULE_3__.unpack)(reader, this.coders);\n    }\n} //# sourceMappingURL=tuple.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vYWJpL2NvZGVycy90dXBsZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUE2RDtBQUN6QjtBQUNRO0FBQ0Y7QUFDMUM7O0NBRUMsR0FDTSxNQUFNSyxtQkFBbUJILHFEQUFLQTtJQUVqQ0ksWUFBWUMsTUFBTSxFQUFFQyxTQUFTLENBQUU7UUFDM0IsSUFBSUMsVUFBVTtRQUNkLE1BQU1DLFFBQVEsRUFBRTtRQUNoQkgsT0FBT0ksT0FBTyxDQUFDLENBQUNDO1lBQ1osSUFBSUEsTUFBTUgsT0FBTyxFQUFFO2dCQUNmQSxVQUFVO1lBQ2Q7WUFDQUMsTUFBTUcsSUFBSSxDQUFDRCxNQUFNRSxJQUFJO1FBQ3pCO1FBQ0EsTUFBTUEsT0FBUSxXQUFXSixNQUFNSyxJQUFJLENBQUMsT0FBTztRQUMzQyxLQUFLLENBQUMsU0FBU0QsTUFBTU4sV0FBV0M7UUFDaENULHNFQUFnQkEsQ0FBQyxJQUFJLEVBQUU7WUFBRU8sUUFBUVMsT0FBT0MsTUFBTSxDQUFDVixPQUFPVyxLQUFLO1FBQUk7SUFDbkU7SUFDQUMsZUFBZTtRQUNYLE1BQU1DLFNBQVMsRUFBRTtRQUNqQixJQUFJLENBQUNiLE1BQU0sQ0FBQ0ksT0FBTyxDQUFDLENBQUNDO1lBQ2pCUSxPQUFPUCxJQUFJLENBQUNELE1BQU1PLFlBQVk7UUFDbEM7UUFDQSw0REFBNEQ7UUFDNUQsTUFBTUUsY0FBYyxJQUFJLENBQUNkLE1BQU0sQ0FBQ2UsTUFBTSxDQUFDLENBQUNDLE9BQU9YO1lBQzNDLE1BQU1ZLE9BQU9aLE1BQU1KLFNBQVM7WUFDNUIsSUFBSWdCLE1BQU07Z0JBQ04sSUFBSSxDQUFDRCxLQUFLLENBQUNDLEtBQUssRUFBRTtvQkFDZEQsS0FBSyxDQUFDQyxLQUFLLEdBQUc7Z0JBQ2xCO2dCQUNBRCxLQUFLLENBQUNDLEtBQUs7WUFDZjtZQUNBLE9BQU9EO1FBQ1gsR0FBRyxDQUFDO1FBQ0osbUJBQW1CO1FBQ25CLElBQUksQ0FBQ2hCLE1BQU0sQ0FBQ0ksT0FBTyxDQUFDLENBQUNDLE9BQU9hO1lBQ3hCLElBQUlELE9BQU9aLE1BQU1KLFNBQVM7WUFDMUIsSUFBSSxDQUFDZ0IsUUFBUUgsV0FBVyxDQUFDRyxLQUFLLEtBQUssR0FBRztnQkFDbEM7WUFDSjtZQUNBLElBQUlBLFNBQVMsVUFBVTtnQkFDbkJBLE9BQU87WUFDWDtZQUNBLElBQUlKLE1BQU0sQ0FBQ0ksS0FBSyxJQUFJLE1BQU07Z0JBQ3RCO1lBQ0o7WUFDQUosTUFBTSxDQUFDSSxLQUFLLEdBQUdKLE1BQU0sQ0FBQ0ssTUFBTTtRQUNoQztRQUNBLE9BQU9ULE9BQU9DLE1BQU0sQ0FBQ0c7SUFDekI7SUFDQU0sT0FBT0MsTUFBTSxFQUFFQyxNQUFNLEVBQUU7UUFDbkIsTUFBTUMsUUFBUTVCLDRDQUFLQSxDQUFDNkIsV0FBVyxDQUFDRixRQUFRO1FBQ3hDLE9BQU96QiwrQ0FBSUEsQ0FBQ3dCLFFBQVEsSUFBSSxDQUFDcEIsTUFBTSxFQUFFc0I7SUFDckM7SUFDQUUsT0FBT0MsTUFBTSxFQUFFO1FBQ1gsT0FBTzVCLGlEQUFNQSxDQUFDNEIsUUFBUSxJQUFJLENBQUN6QixNQUFNO0lBQ3JDO0FBQ0osRUFDQSxpQ0FBaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tZWdhdmliZS1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9hYmkvY29kZXJzL3R1cGxlLmpzPzNhNGUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZGVmaW5lUHJvcGVydGllcyB9IGZyb20gXCIuLi8uLi91dGlscy9wcm9wZXJ0aWVzLmpzXCI7XG5pbXBvcnQgeyBUeXBlZCB9IGZyb20gXCIuLi90eXBlZC5qc1wiO1xuaW1wb3J0IHsgQ29kZXIgfSBmcm9tIFwiLi9hYnN0cmFjdC1jb2Rlci5qc1wiO1xuaW1wb3J0IHsgcGFjaywgdW5wYWNrIH0gZnJvbSBcIi4vYXJyYXkuanNcIjtcbi8qKlxuICogIEBfaWdub3JlXG4gKi9cbmV4cG9ydCBjbGFzcyBUdXBsZUNvZGVyIGV4dGVuZHMgQ29kZXIge1xuICAgIGNvZGVycztcbiAgICBjb25zdHJ1Y3Rvcihjb2RlcnMsIGxvY2FsTmFtZSkge1xuICAgICAgICBsZXQgZHluYW1pYyA9IGZhbHNlO1xuICAgICAgICBjb25zdCB0eXBlcyA9IFtdO1xuICAgICAgICBjb2RlcnMuZm9yRWFjaCgoY29kZXIpID0+IHtcbiAgICAgICAgICAgIGlmIChjb2Rlci5keW5hbWljKSB7XG4gICAgICAgICAgICAgICAgZHluYW1pYyA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0eXBlcy5wdXNoKGNvZGVyLnR5cGUpO1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgdHlwZSA9IChcInR1cGxlKFwiICsgdHlwZXMuam9pbihcIixcIikgKyBcIilcIik7XG4gICAgICAgIHN1cGVyKFwidHVwbGVcIiwgdHlwZSwgbG9jYWxOYW1lLCBkeW5hbWljKTtcbiAgICAgICAgZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7IGNvZGVyczogT2JqZWN0LmZyZWV6ZShjb2RlcnMuc2xpY2UoKSkgfSk7XG4gICAgfVxuICAgIGRlZmF1bHRWYWx1ZSgpIHtcbiAgICAgICAgY29uc3QgdmFsdWVzID0gW107XG4gICAgICAgIHRoaXMuY29kZXJzLmZvckVhY2goKGNvZGVyKSA9PiB7XG4gICAgICAgICAgICB2YWx1ZXMucHVzaChjb2Rlci5kZWZhdWx0VmFsdWUoKSk7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBXZSBvbmx5IG91dHB1dCBuYW1lZCBwcm9wZXJ0aWVzIGZvciB1bmlxdWVseSBuYW1lZCBjb2RlcnNcbiAgICAgICAgY29uc3QgdW5pcXVlTmFtZXMgPSB0aGlzLmNvZGVycy5yZWR1Y2UoKGFjY3VtLCBjb2RlcikgPT4ge1xuICAgICAgICAgICAgY29uc3QgbmFtZSA9IGNvZGVyLmxvY2FsTmFtZTtcbiAgICAgICAgICAgIGlmIChuYW1lKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFhY2N1bVtuYW1lXSkge1xuICAgICAgICAgICAgICAgICAgICBhY2N1bVtuYW1lXSA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGFjY3VtW25hbWVdKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYWNjdW07XG4gICAgICAgIH0sIHt9KTtcbiAgICAgICAgLy8gQWRkIG5hbWVkIHZhbHVlc1xuICAgICAgICB0aGlzLmNvZGVycy5mb3JFYWNoKChjb2RlciwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgIGxldCBuYW1lID0gY29kZXIubG9jYWxOYW1lO1xuICAgICAgICAgICAgaWYgKCFuYW1lIHx8IHVuaXF1ZU5hbWVzW25hbWVdICE9PSAxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5hbWUgPT09IFwibGVuZ3RoXCIpIHtcbiAgICAgICAgICAgICAgICBuYW1lID0gXCJfbGVuZ3RoXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodmFsdWVzW25hbWVdICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YWx1ZXNbbmFtZV0gPSB2YWx1ZXNbaW5kZXhdO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5mcmVlemUodmFsdWVzKTtcbiAgICB9XG4gICAgZW5jb2RlKHdyaXRlciwgX3ZhbHVlKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gVHlwZWQuZGVyZWZlcmVuY2UoX3ZhbHVlLCBcInR1cGxlXCIpO1xuICAgICAgICByZXR1cm4gcGFjayh3cml0ZXIsIHRoaXMuY29kZXJzLCB2YWx1ZSk7XG4gICAgfVxuICAgIGRlY29kZShyZWFkZXIpIHtcbiAgICAgICAgcmV0dXJuIHVucGFjayhyZWFkZXIsIHRoaXMuY29kZXJzKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD10dXBsZS5qcy5tYXAiXSwibmFtZXMiOlsiZGVmaW5lUHJvcGVydGllcyIsIlR5cGVkIiwiQ29kZXIiLCJwYWNrIiwidW5wYWNrIiwiVHVwbGVDb2RlciIsImNvbnN0cnVjdG9yIiwiY29kZXJzIiwibG9jYWxOYW1lIiwiZHluYW1pYyIsInR5cGVzIiwiZm9yRWFjaCIsImNvZGVyIiwicHVzaCIsInR5cGUiLCJqb2luIiwiT2JqZWN0IiwiZnJlZXplIiwic2xpY2UiLCJkZWZhdWx0VmFsdWUiLCJ2YWx1ZXMiLCJ1bmlxdWVOYW1lcyIsInJlZHVjZSIsImFjY3VtIiwibmFtZSIsImluZGV4IiwiZW5jb2RlIiwid3JpdGVyIiwiX3ZhbHVlIiwidmFsdWUiLCJkZXJlZmVyZW5jZSIsImRlY29kZSIsInJlYWRlciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.esm/abi/coders/tuple.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.esm/abi/fragments.js":
/*!******************************************************!*\
  !*** ./node_modules/ethers/lib.esm/abi/fragments.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ConstructorFragment: () => (/* binding */ ConstructorFragment),\n/* harmony export */   ErrorFragment: () => (/* binding */ ErrorFragment),\n/* harmony export */   EventFragment: () => (/* binding */ EventFragment),\n/* harmony export */   FallbackFragment: () => (/* binding */ FallbackFragment),\n/* harmony export */   Fragment: () => (/* binding */ Fragment),\n/* harmony export */   FunctionFragment: () => (/* binding */ FunctionFragment),\n/* harmony export */   NamedFragment: () => (/* binding */ NamedFragment),\n/* harmony export */   ParamType: () => (/* binding */ ParamType),\n/* harmony export */   StructFragment: () => (/* binding */ StructFragment)\n/* harmony export */ });\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/maths.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/errors.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/properties.js\");\n/* harmony import */ var _hash_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../hash/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/hash/id.js\");\n/**\n *  A fragment is a single item from an ABI, which may represent any of:\n *\n *  - [Functions](FunctionFragment)\n *  - [Events](EventFragment)\n *  - [Constructors](ConstructorFragment)\n *  - Custom [Errors](ErrorFragment)\n *  - [Fallback or Receive](FallbackFragment) functions\n *\n *  @_subsection api/abi/abi-coder:Fragments  [about-fragments]\n */ \n\n;\n// [ \"a\", \"b\" ] => { \"a\": 1, \"b\": 1 }\nfunction setify(items) {\n    const result = new Set();\n    items.forEach((k)=>result.add(k));\n    return Object.freeze(result);\n}\nconst _kwVisibDeploy = \"external public payable override\";\nconst KwVisibDeploy = setify(_kwVisibDeploy.split(\" \"));\n// Visibility Keywords\nconst _kwVisib = \"constant external internal payable private public pure view override\";\nconst KwVisib = setify(_kwVisib.split(\" \"));\nconst _kwTypes = \"constructor error event fallback function receive struct\";\nconst KwTypes = setify(_kwTypes.split(\" \"));\nconst _kwModifiers = \"calldata memory storage payable indexed\";\nconst KwModifiers = setify(_kwModifiers.split(\" \"));\nconst _kwOther = \"tuple returns\";\n// All Keywords\nconst _keywords = [\n    _kwTypes,\n    _kwModifiers,\n    _kwOther,\n    _kwVisib\n].join(\" \");\nconst Keywords = setify(_keywords.split(\" \"));\n// Single character tokens\nconst SimpleTokens = {\n    \"(\": \"OPEN_PAREN\",\n    \")\": \"CLOSE_PAREN\",\n    \"[\": \"OPEN_BRACKET\",\n    \"]\": \"CLOSE_BRACKET\",\n    \",\": \"COMMA\",\n    \"@\": \"AT\"\n};\n// Parser regexes to consume the next token\nconst regexWhitespacePrefix = new RegExp(\"^(\\\\s*)\");\nconst regexNumberPrefix = new RegExp(\"^([0-9]+)\");\nconst regexIdPrefix = new RegExp(\"^([a-zA-Z$_][a-zA-Z0-9$_]*)\");\n// Parser regexs to check validity\nconst regexId = new RegExp(\"^([a-zA-Z$_][a-zA-Z0-9$_]*)$\");\nconst regexType = new RegExp(\"^(address|bool|bytes([0-9]*)|string|u?int([0-9]*))$\");\nclass TokenString {\n    #offset;\n    #tokens;\n    get offset() {\n        return this.#offset;\n    }\n    get length() {\n        return this.#tokens.length - this.#offset;\n    }\n    constructor(tokens){\n        this.#offset = 0;\n        this.#tokens = tokens.slice();\n    }\n    clone() {\n        return new TokenString(this.#tokens);\n    }\n    reset() {\n        this.#offset = 0;\n    }\n    #subTokenString(from = 0, to = 0) {\n        return new TokenString(this.#tokens.slice(from, to).map((t)=>{\n            return Object.freeze(Object.assign({}, t, {\n                match: t.match - from,\n                linkBack: t.linkBack - from,\n                linkNext: t.linkNext - from\n            }));\n        }));\n    }\n    // Pops and returns the value of the next token, if it is a keyword in allowed; throws if out of tokens\n    popKeyword(allowed) {\n        const top = this.peek();\n        if (top.type !== \"KEYWORD\" || !allowed.has(top.text)) {\n            throw new Error(`expected keyword ${top.text}`);\n        }\n        return this.pop().text;\n    }\n    // Pops and returns the value of the next token if it is `type`; throws if out of tokens\n    popType(type) {\n        if (this.peek().type !== type) {\n            const top = this.peek();\n            throw new Error(`expected ${type}; got ${top.type} ${JSON.stringify(top.text)}`);\n        }\n        return this.pop().text;\n    }\n    // Pops and returns a \"(\" TOKENS \")\"\n    popParen() {\n        const top = this.peek();\n        if (top.type !== \"OPEN_PAREN\") {\n            throw new Error(\"bad start\");\n        }\n        const result = this.#subTokenString(this.#offset + 1, top.match + 1);\n        this.#offset = top.match + 1;\n        return result;\n    }\n    // Pops and returns the items within \"(\" ITEM1 \",\" ITEM2 \",\" ... \")\"\n    popParams() {\n        const top = this.peek();\n        if (top.type !== \"OPEN_PAREN\") {\n            throw new Error(\"bad start\");\n        }\n        const result = [];\n        while(this.#offset < top.match - 1){\n            const link = this.peek().linkNext;\n            result.push(this.#subTokenString(this.#offset + 1, link));\n            this.#offset = link;\n        }\n        this.#offset = top.match + 1;\n        return result;\n    }\n    // Returns the top Token, throwing if out of tokens\n    peek() {\n        if (this.#offset >= this.#tokens.length) {\n            throw new Error(\"out-of-bounds\");\n        }\n        return this.#tokens[this.#offset];\n    }\n    // Returns the next value, if it is a keyword in `allowed`\n    peekKeyword(allowed) {\n        const top = this.peekType(\"KEYWORD\");\n        return top != null && allowed.has(top) ? top : null;\n    }\n    // Returns the value of the next token if it is `type`\n    peekType(type) {\n        if (this.length === 0) {\n            return null;\n        }\n        const top = this.peek();\n        return top.type === type ? top.text : null;\n    }\n    // Returns the next token; throws if out of tokens\n    pop() {\n        const result = this.peek();\n        this.#offset++;\n        return result;\n    }\n    toString() {\n        const tokens = [];\n        for(let i = this.#offset; i < this.#tokens.length; i++){\n            const token = this.#tokens[i];\n            tokens.push(`${token.type}:${token.text}`);\n        }\n        return `<TokenString ${tokens.join(\" \")}>`;\n    }\n}\nfunction lex(text) {\n    const tokens = [];\n    const throwError = (message)=>{\n        const token = offset < text.length ? JSON.stringify(text[offset]) : \"$EOI\";\n        throw new Error(`invalid token ${token} at ${offset}: ${message}`);\n    };\n    let brackets = [];\n    let commas = [];\n    let offset = 0;\n    while(offset < text.length){\n        // Strip off any leading whitespace\n        let cur = text.substring(offset);\n        let match = cur.match(regexWhitespacePrefix);\n        if (match) {\n            offset += match[1].length;\n            cur = text.substring(offset);\n        }\n        const token = {\n            depth: brackets.length,\n            linkBack: -1,\n            linkNext: -1,\n            match: -1,\n            type: \"\",\n            text: \"\",\n            offset,\n            value: -1\n        };\n        tokens.push(token);\n        let type = SimpleTokens[cur[0]] || \"\";\n        if (type) {\n            token.type = type;\n            token.text = cur[0];\n            offset++;\n            if (type === \"OPEN_PAREN\") {\n                brackets.push(tokens.length - 1);\n                commas.push(tokens.length - 1);\n            } else if (type == \"CLOSE_PAREN\") {\n                if (brackets.length === 0) {\n                    throwError(\"no matching open bracket\");\n                }\n                token.match = brackets.pop();\n                tokens[token.match].match = tokens.length - 1;\n                token.depth--;\n                token.linkBack = commas.pop();\n                tokens[token.linkBack].linkNext = tokens.length - 1;\n            } else if (type === \"COMMA\") {\n                token.linkBack = commas.pop();\n                tokens[token.linkBack].linkNext = tokens.length - 1;\n                commas.push(tokens.length - 1);\n            } else if (type === \"OPEN_BRACKET\") {\n                token.type = \"BRACKET\";\n            } else if (type === \"CLOSE_BRACKET\") {\n                // Remove the CLOSE_BRACKET\n                let suffix = tokens.pop().text;\n                if (tokens.length > 0 && tokens[tokens.length - 1].type === \"NUMBER\") {\n                    const value = tokens.pop().text;\n                    suffix = value + suffix;\n                    tokens[tokens.length - 1].value = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getNumber)(value);\n                }\n                if (tokens.length === 0 || tokens[tokens.length - 1].type !== \"BRACKET\") {\n                    throw new Error(\"missing opening bracket\");\n                }\n                tokens[tokens.length - 1].text += suffix;\n            }\n            continue;\n        }\n        match = cur.match(regexIdPrefix);\n        if (match) {\n            token.text = match[1];\n            offset += token.text.length;\n            if (Keywords.has(token.text)) {\n                token.type = \"KEYWORD\";\n                continue;\n            }\n            if (token.text.match(regexType)) {\n                token.type = \"TYPE\";\n                continue;\n            }\n            token.type = \"ID\";\n            continue;\n        }\n        match = cur.match(regexNumberPrefix);\n        if (match) {\n            token.text = match[1];\n            token.type = \"NUMBER\";\n            offset += token.text.length;\n            continue;\n        }\n        throw new Error(`unexpected token ${JSON.stringify(cur[0])} at position ${offset}`);\n    }\n    return new TokenString(tokens.map((t)=>Object.freeze(t)));\n}\n// Check only one of `allowed` is in `set`\nfunction allowSingle(set, allowed) {\n    let included = [];\n    for(const key in allowed.keys()){\n        if (set.has(key)) {\n            included.push(key);\n        }\n    }\n    if (included.length > 1) {\n        throw new Error(`conflicting types: ${included.join(\", \")}`);\n    }\n}\n// Functions to process a Solidity Signature TokenString from left-to-right for...\n// ...the name with an optional type, returning the name\nfunction consumeName(type, tokens) {\n    if (tokens.peekKeyword(KwTypes)) {\n        const keyword = tokens.pop().text;\n        if (keyword !== type) {\n            throw new Error(`expected ${type}, got ${keyword}`);\n        }\n    }\n    return tokens.popType(\"ID\");\n}\n// ...all keywords matching allowed, returning the keywords\nfunction consumeKeywords(tokens, allowed) {\n    const keywords = new Set();\n    while(true){\n        const keyword = tokens.peekType(\"KEYWORD\");\n        if (keyword == null || allowed && !allowed.has(keyword)) {\n            break;\n        }\n        tokens.pop();\n        if (keywords.has(keyword)) {\n            throw new Error(`duplicate keywords: ${JSON.stringify(keyword)}`);\n        }\n        keywords.add(keyword);\n    }\n    return Object.freeze(keywords);\n}\n// ...all visibility keywords, returning the coalesced mutability\nfunction consumeMutability(tokens) {\n    let modifiers = consumeKeywords(tokens, KwVisib);\n    // Detect conflicting modifiers\n    allowSingle(modifiers, setify(\"constant payable nonpayable\".split(\" \")));\n    allowSingle(modifiers, setify(\"pure view payable nonpayable\".split(\" \")));\n    // Process mutability states\n    if (modifiers.has(\"view\")) {\n        return \"view\";\n    }\n    if (modifiers.has(\"pure\")) {\n        return \"pure\";\n    }\n    if (modifiers.has(\"payable\")) {\n        return \"payable\";\n    }\n    if (modifiers.has(\"nonpayable\")) {\n        return \"nonpayable\";\n    }\n    // Process legacy `constant` last\n    if (modifiers.has(\"constant\")) {\n        return \"view\";\n    }\n    return \"nonpayable\";\n}\n// ...a parameter list, returning the ParamType list\nfunction consumeParams(tokens, allowIndexed) {\n    return tokens.popParams().map((t)=>ParamType.from(t, allowIndexed));\n}\n// ...a gas limit, returning a BigNumber or null if none\nfunction consumeGas(tokens) {\n    if (tokens.peekType(\"AT\")) {\n        tokens.pop();\n        if (tokens.peekType(\"NUMBER\")) {\n            return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBigInt)(tokens.pop().text);\n        }\n        throw new Error(\"invalid gas\");\n    }\n    return null;\n}\nfunction consumeEoi(tokens) {\n    if (tokens.length) {\n        throw new Error(`unexpected tokens at offset ${tokens.offset}: ${tokens.toString()}`);\n    }\n}\nconst regexArrayType = new RegExp(/^(.*)\\[([0-9]*)\\]$/);\nfunction verifyBasicType(type) {\n    const match = type.match(regexType);\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(match, \"invalid type\", \"type\", type);\n    if (type === \"uint\") {\n        return \"uint256\";\n    }\n    if (type === \"int\") {\n        return \"int256\";\n    }\n    if (match[2]) {\n        // bytesXX\n        const length = parseInt(match[2]);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(length !== 0 && length <= 32, \"invalid bytes length\", \"type\", type);\n    } else if (match[3]) {\n        // intXX or uintXX\n        const size = parseInt(match[3]);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(size !== 0 && size <= 256 && size % 8 === 0, \"invalid numeric width\", \"type\", type);\n    }\n    return type;\n}\n// Make the Fragment constructors effectively private\nconst _guard = {};\nconst internal = Symbol.for(\"_ethers_internal\");\nconst ParamTypeInternal = \"_ParamTypeInternal\";\nconst ErrorFragmentInternal = \"_ErrorInternal\";\nconst EventFragmentInternal = \"_EventInternal\";\nconst ConstructorFragmentInternal = \"_ConstructorInternal\";\nconst FallbackFragmentInternal = \"_FallbackInternal\";\nconst FunctionFragmentInternal = \"_FunctionInternal\";\nconst StructFragmentInternal = \"_StructInternal\";\n/**\n *  Each input and output of a [[Fragment]] is an Array of **ParamType**.\n */ class ParamType {\n    /**\n     *  @private\n     */ constructor(guard, name, type, baseType, indexed, components, arrayLength, arrayChildren){\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertPrivate)(guard, _guard, \"ParamType\");\n        Object.defineProperty(this, internal, {\n            value: ParamTypeInternal\n        });\n        if (components) {\n            components = Object.freeze(components.slice());\n        }\n        if (baseType === \"array\") {\n            if (arrayLength == null || arrayChildren == null) {\n                throw new Error(\"\");\n            }\n        } else if (arrayLength != null || arrayChildren != null) {\n            throw new Error(\"\");\n        }\n        if (baseType === \"tuple\") {\n            if (components == null) {\n                throw new Error(\"\");\n            }\n        } else if (components != null) {\n            throw new Error(\"\");\n        }\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.defineProperties)(this, {\n            name,\n            type,\n            baseType,\n            indexed,\n            components,\n            arrayLength,\n            arrayChildren\n        });\n    }\n    /**\n     *  Return a string representation of this type.\n     *\n     *  For example,\n     *\n     *  ``sighash\" => \"(uint256,address)\"``\n     *\n     *  ``\"minimal\" => \"tuple(uint256,address) indexed\"``\n     *\n     *  ``\"full\" => \"tuple(uint256 foo, address bar) indexed baz\"``\n     */ format(format) {\n        if (format == null) {\n            format = \"sighash\";\n        }\n        if (format === \"json\") {\n            const name = this.name || \"\";\n            if (this.isArray()) {\n                const result = JSON.parse(this.arrayChildren.format(\"json\"));\n                result.name = name;\n                result.type += `[${this.arrayLength < 0 ? \"\" : String(this.arrayLength)}]`;\n                return JSON.stringify(result);\n            }\n            const result = {\n                type: this.baseType === \"tuple\" ? \"tuple\" : this.type,\n                name\n            };\n            if (typeof this.indexed === \"boolean\") {\n                result.indexed = this.indexed;\n            }\n            if (this.isTuple()) {\n                result.components = this.components.map((c)=>JSON.parse(c.format(format)));\n            }\n            return JSON.stringify(result);\n        }\n        let result = \"\";\n        // Array\n        if (this.isArray()) {\n            result += this.arrayChildren.format(format);\n            result += `[${this.arrayLength < 0 ? \"\" : String(this.arrayLength)}]`;\n        } else {\n            if (this.isTuple()) {\n                result += \"(\" + this.components.map((comp)=>comp.format(format)).join(format === \"full\" ? \", \" : \",\") + \")\";\n            } else {\n                result += this.type;\n            }\n        }\n        if (format !== \"sighash\") {\n            if (this.indexed === true) {\n                result += \" indexed\";\n            }\n            if (format === \"full\" && this.name) {\n                result += \" \" + this.name;\n            }\n        }\n        return result;\n    }\n    /**\n     *  Returns true if %%this%% is an Array type.\n     *\n     *  This provides a type gaurd ensuring that [[arrayChildren]]\n     *  and [[arrayLength]] are non-null.\n     */ isArray() {\n        return this.baseType === \"array\";\n    }\n    /**\n     *  Returns true if %%this%% is a Tuple type.\n     *\n     *  This provides a type gaurd ensuring that [[components]]\n     *  is non-null.\n     */ isTuple() {\n        return this.baseType === \"tuple\";\n    }\n    /**\n     *  Returns true if %%this%% is an Indexable type.\n     *\n     *  This provides a type gaurd ensuring that [[indexed]]\n     *  is non-null.\n     */ isIndexable() {\n        return this.indexed != null;\n    }\n    /**\n     *  Walks the **ParamType** with %%value%%, calling %%process%%\n     *  on each type, destructing the %%value%% recursively.\n     */ walk(value, process) {\n        if (this.isArray()) {\n            if (!Array.isArray(value)) {\n                throw new Error(\"invalid array value\");\n            }\n            if (this.arrayLength !== -1 && value.length !== this.arrayLength) {\n                throw new Error(\"array is wrong length\");\n            }\n            const _this = this;\n            return value.map((v)=>_this.arrayChildren.walk(v, process));\n        }\n        if (this.isTuple()) {\n            if (!Array.isArray(value)) {\n                throw new Error(\"invalid tuple value\");\n            }\n            if (value.length !== this.components.length) {\n                throw new Error(\"array is wrong length\");\n            }\n            const _this = this;\n            return value.map((v, i)=>_this.components[i].walk(v, process));\n        }\n        return process(this.type, value);\n    }\n    #walkAsync(promises, value, process, setValue) {\n        if (this.isArray()) {\n            if (!Array.isArray(value)) {\n                throw new Error(\"invalid array value\");\n            }\n            if (this.arrayLength !== -1 && value.length !== this.arrayLength) {\n                throw new Error(\"array is wrong length\");\n            }\n            const childType = this.arrayChildren;\n            const result = value.slice();\n            result.forEach((value, index)=>{\n                childType.#walkAsync(promises, value, process, (value)=>{\n                    result[index] = value;\n                });\n            });\n            setValue(result);\n            return;\n        }\n        if (this.isTuple()) {\n            const components = this.components;\n            // Convert the object into an array\n            let result;\n            if (Array.isArray(value)) {\n                result = value.slice();\n            } else {\n                if (value == null || typeof value !== \"object\") {\n                    throw new Error(\"invalid tuple value\");\n                }\n                result = components.map((param)=>{\n                    if (!param.name) {\n                        throw new Error(\"cannot use object value with unnamed components\");\n                    }\n                    if (!(param.name in value)) {\n                        throw new Error(`missing value for component ${param.name}`);\n                    }\n                    return value[param.name];\n                });\n            }\n            if (result.length !== this.components.length) {\n                throw new Error(\"array is wrong length\");\n            }\n            result.forEach((value, index)=>{\n                components[index].#walkAsync(promises, value, process, (value)=>{\n                    result[index] = value;\n                });\n            });\n            setValue(result);\n            return;\n        }\n        const result = process(this.type, value);\n        if (result.then) {\n            promises.push(async function() {\n                setValue(await result);\n            }());\n        } else {\n            setValue(result);\n        }\n    }\n    /**\n     *  Walks the **ParamType** with %%value%%, asynchronously calling\n     *  %%process%% on each type, destructing the %%value%% recursively.\n     *\n     *  This can be used to resolve ENS names by walking and resolving each\n     *  ``\"address\"`` type.\n     */ async walkAsync(value, process) {\n        const promises = [];\n        const result = [\n            value\n        ];\n        this.#walkAsync(promises, value, process, (value)=>{\n            result[0] = value;\n        });\n        if (promises.length) {\n            await Promise.all(promises);\n        }\n        return result[0];\n    }\n    /**\n     *  Creates a new **ParamType** for %%obj%%.\n     *\n     *  If %%allowIndexed%% then the ``indexed`` keyword is permitted,\n     *  otherwise the ``indexed`` keyword will throw an error.\n     */ static from(obj, allowIndexed) {\n        if (ParamType.isParamType(obj)) {\n            return obj;\n        }\n        if (typeof obj === \"string\") {\n            try {\n                return ParamType.from(lex(obj), allowIndexed);\n            } catch (error) {\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(false, \"invalid param type\", \"obj\", obj);\n            }\n        } else if (obj instanceof TokenString) {\n            let type = \"\", baseType = \"\";\n            let comps = null;\n            if (consumeKeywords(obj, setify([\n                \"tuple\"\n            ])).has(\"tuple\") || obj.peekType(\"OPEN_PAREN\")) {\n                // Tuple\n                baseType = \"tuple\";\n                comps = obj.popParams().map((t)=>ParamType.from(t));\n                type = `tuple(${comps.map((c)=>c.format()).join(\",\")})`;\n            } else {\n                // Normal\n                type = verifyBasicType(obj.popType(\"TYPE\"));\n                baseType = type;\n            }\n            // Check for Array\n            let arrayChildren = null;\n            let arrayLength = null;\n            while(obj.length && obj.peekType(\"BRACKET\")){\n                const bracket = obj.pop(); //arrays[i];\n                arrayChildren = new ParamType(_guard, \"\", type, baseType, null, comps, arrayLength, arrayChildren);\n                arrayLength = bracket.value;\n                type += bracket.text;\n                baseType = \"array\";\n                comps = null;\n            }\n            let indexed = null;\n            const keywords = consumeKeywords(obj, KwModifiers);\n            if (keywords.has(\"indexed\")) {\n                if (!allowIndexed) {\n                    throw new Error(\"\");\n                }\n                indexed = true;\n            }\n            const name = obj.peekType(\"ID\") ? obj.pop().text : \"\";\n            if (obj.length) {\n                throw new Error(\"leftover tokens\");\n            }\n            return new ParamType(_guard, name, type, baseType, indexed, comps, arrayLength, arrayChildren);\n        }\n        const name = obj.name;\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(!name || typeof name === \"string\" && name.match(regexId), \"invalid name\", \"obj.name\", name);\n        let indexed = obj.indexed;\n        if (indexed != null) {\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(allowIndexed, \"parameter cannot be indexed\", \"obj.indexed\", obj.indexed);\n            indexed = !!indexed;\n        }\n        let type = obj.type;\n        let arrayMatch = type.match(regexArrayType);\n        if (arrayMatch) {\n            const arrayLength = parseInt(arrayMatch[2] || \"-1\");\n            const arrayChildren = ParamType.from({\n                type: arrayMatch[1],\n                components: obj.components\n            });\n            return new ParamType(_guard, name || \"\", type, \"array\", indexed, null, arrayLength, arrayChildren);\n        }\n        if (type === \"tuple\" || type.startsWith(\"tuple(\" /* fix: ) */ ) || type.startsWith(\"(\" /* fix: ) */ )) {\n            const comps = obj.components != null ? obj.components.map((c)=>ParamType.from(c)) : null;\n            const tuple = new ParamType(_guard, name || \"\", type, \"tuple\", indexed, comps, null, null);\n            // @TODO: use lexer to validate and normalize type\n            return tuple;\n        }\n        type = verifyBasicType(obj.type);\n        return new ParamType(_guard, name || \"\", type, type, indexed, null, null, null);\n    }\n    /**\n     *  Returns true if %%value%% is a **ParamType**.\n     */ static isParamType(value) {\n        return value && value[internal] === ParamTypeInternal;\n    }\n}\n/**\n *  An abstract class to represent An individual fragment from a parse ABI.\n */ class Fragment {\n    /**\n     *  @private\n     */ constructor(guard, type, inputs){\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertPrivate)(guard, _guard, \"Fragment\");\n        inputs = Object.freeze(inputs.slice());\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.defineProperties)(this, {\n            type,\n            inputs\n        });\n    }\n    /**\n     *  Creates a new **Fragment** for %%obj%%, wich can be any supported\n     *  ABI frgament type.\n     */ static from(obj) {\n        if (typeof obj === \"string\") {\n            // Try parsing JSON...\n            try {\n                Fragment.from(JSON.parse(obj));\n            } catch (e) {}\n            // ...otherwise, use the human-readable lexer\n            return Fragment.from(lex(obj));\n        }\n        if (obj instanceof TokenString) {\n            // Human-readable ABI (already lexed)\n            const type = obj.peekKeyword(KwTypes);\n            switch(type){\n                case \"constructor\":\n                    return ConstructorFragment.from(obj);\n                case \"error\":\n                    return ErrorFragment.from(obj);\n                case \"event\":\n                    return EventFragment.from(obj);\n                case \"fallback\":\n                case \"receive\":\n                    return FallbackFragment.from(obj);\n                case \"function\":\n                    return FunctionFragment.from(obj);\n                case \"struct\":\n                    return StructFragment.from(obj);\n            }\n        } else if (typeof obj === \"object\") {\n            // JSON ABI\n            switch(obj.type){\n                case \"constructor\":\n                    return ConstructorFragment.from(obj);\n                case \"error\":\n                    return ErrorFragment.from(obj);\n                case \"event\":\n                    return EventFragment.from(obj);\n                case \"fallback\":\n                case \"receive\":\n                    return FallbackFragment.from(obj);\n                case \"function\":\n                    return FunctionFragment.from(obj);\n                case \"struct\":\n                    return StructFragment.from(obj);\n            }\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assert)(false, `unsupported type: ${obj.type}`, \"UNSUPPORTED_OPERATION\", {\n                operation: \"Fragment.from\"\n            });\n        }\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(false, \"unsupported frgament object\", \"obj\", obj);\n    }\n    /**\n     *  Returns true if %%value%% is a [[ConstructorFragment]].\n     */ static isConstructor(value) {\n        return ConstructorFragment.isFragment(value);\n    }\n    /**\n     *  Returns true if %%value%% is an [[ErrorFragment]].\n     */ static isError(value) {\n        return ErrorFragment.isFragment(value);\n    }\n    /**\n     *  Returns true if %%value%% is an [[EventFragment]].\n     */ static isEvent(value) {\n        return EventFragment.isFragment(value);\n    }\n    /**\n     *  Returns true if %%value%% is a [[FunctionFragment]].\n     */ static isFunction(value) {\n        return FunctionFragment.isFragment(value);\n    }\n    /**\n     *  Returns true if %%value%% is a [[StructFragment]].\n     */ static isStruct(value) {\n        return StructFragment.isFragment(value);\n    }\n}\n/**\n *  An abstract class to represent An individual fragment\n *  which has a name from a parse ABI.\n */ class NamedFragment extends Fragment {\n    /**\n     *  @private\n     */ constructor(guard, type, name, inputs){\n        super(guard, type, inputs);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(typeof name === \"string\" && name.match(regexId), \"invalid identifier\", \"name\", name);\n        inputs = Object.freeze(inputs.slice());\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.defineProperties)(this, {\n            name\n        });\n    }\n}\nfunction joinParams(format, params) {\n    return \"(\" + params.map((p)=>p.format(format)).join(format === \"full\" ? \", \" : \",\") + \")\";\n}\n/**\n *  A Fragment which represents a //Custom Error//.\n */ class ErrorFragment extends NamedFragment {\n    /**\n     *  @private\n     */ constructor(guard, name, inputs){\n        super(guard, \"error\", name, inputs);\n        Object.defineProperty(this, internal, {\n            value: ErrorFragmentInternal\n        });\n    }\n    /**\n     *  The Custom Error selector.\n     */ get selector() {\n        return (0,_hash_index_js__WEBPACK_IMPORTED_MODULE_3__.id)(this.format(\"sighash\")).substring(0, 10);\n    }\n    /**\n     *  Returns a string representation of this fragment as %%format%%.\n     */ format(format) {\n        if (format == null) {\n            format = \"sighash\";\n        }\n        if (format === \"json\") {\n            return JSON.stringify({\n                type: \"error\",\n                name: this.name,\n                inputs: this.inputs.map((input)=>JSON.parse(input.format(format)))\n            });\n        }\n        const result = [];\n        if (format !== \"sighash\") {\n            result.push(\"error\");\n        }\n        result.push(this.name + joinParams(format, this.inputs));\n        return result.join(\" \");\n    }\n    /**\n     *  Returns a new **ErrorFragment** for %%obj%%.\n     */ static from(obj) {\n        if (ErrorFragment.isFragment(obj)) {\n            return obj;\n        }\n        if (typeof obj === \"string\") {\n            return ErrorFragment.from(lex(obj));\n        } else if (obj instanceof TokenString) {\n            const name = consumeName(\"error\", obj);\n            const inputs = consumeParams(obj);\n            consumeEoi(obj);\n            return new ErrorFragment(_guard, name, inputs);\n        }\n        return new ErrorFragment(_guard, obj.name, obj.inputs ? obj.inputs.map(ParamType.from) : []);\n    }\n    /**\n     *  Returns ``true`` and provides a type guard if %%value%% is an\n     *  **ErrorFragment**.\n     */ static isFragment(value) {\n        return value && value[internal] === ErrorFragmentInternal;\n    }\n}\n/**\n *  A Fragment which represents an Event.\n */ class EventFragment extends NamedFragment {\n    /**\n     *  @private\n     */ constructor(guard, name, inputs, anonymous){\n        super(guard, \"event\", name, inputs);\n        Object.defineProperty(this, internal, {\n            value: EventFragmentInternal\n        });\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.defineProperties)(this, {\n            anonymous\n        });\n    }\n    /**\n     *  The Event topic hash.\n     */ get topicHash() {\n        return (0,_hash_index_js__WEBPACK_IMPORTED_MODULE_3__.id)(this.format(\"sighash\"));\n    }\n    /**\n     *  Returns a string representation of this event as %%format%%.\n     */ format(format) {\n        if (format == null) {\n            format = \"sighash\";\n        }\n        if (format === \"json\") {\n            return JSON.stringify({\n                type: \"event\",\n                anonymous: this.anonymous,\n                name: this.name,\n                inputs: this.inputs.map((i)=>JSON.parse(i.format(format)))\n            });\n        }\n        const result = [];\n        if (format !== \"sighash\") {\n            result.push(\"event\");\n        }\n        result.push(this.name + joinParams(format, this.inputs));\n        if (format !== \"sighash\" && this.anonymous) {\n            result.push(\"anonymous\");\n        }\n        return result.join(\" \");\n    }\n    /**\n     *  Return the topic hash for an event with %%name%% and %%params%%.\n     */ static getTopicHash(name, params) {\n        params = (params || []).map((p)=>ParamType.from(p));\n        const fragment = new EventFragment(_guard, name, params, false);\n        return fragment.topicHash;\n    }\n    /**\n     *  Returns a new **EventFragment** for %%obj%%.\n     */ static from(obj) {\n        if (EventFragment.isFragment(obj)) {\n            return obj;\n        }\n        if (typeof obj === \"string\") {\n            try {\n                return EventFragment.from(lex(obj));\n            } catch (error) {\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(false, \"invalid event fragment\", \"obj\", obj);\n            }\n        } else if (obj instanceof TokenString) {\n            const name = consumeName(\"event\", obj);\n            const inputs = consumeParams(obj, true);\n            const anonymous = !!consumeKeywords(obj, setify([\n                \"anonymous\"\n            ])).has(\"anonymous\");\n            consumeEoi(obj);\n            return new EventFragment(_guard, name, inputs, anonymous);\n        }\n        return new EventFragment(_guard, obj.name, obj.inputs ? obj.inputs.map((p)=>ParamType.from(p, true)) : [], !!obj.anonymous);\n    }\n    /**\n     *  Returns ``true`` and provides a type guard if %%value%% is an\n     *  **EventFragment**.\n     */ static isFragment(value) {\n        return value && value[internal] === EventFragmentInternal;\n    }\n}\n/**\n *  A Fragment which represents a constructor.\n */ class ConstructorFragment extends Fragment {\n    /**\n     *  @private\n     */ constructor(guard, type, inputs, payable, gas){\n        super(guard, type, inputs);\n        Object.defineProperty(this, internal, {\n            value: ConstructorFragmentInternal\n        });\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.defineProperties)(this, {\n            payable,\n            gas\n        });\n    }\n    /**\n     *  Returns a string representation of this constructor as %%format%%.\n     */ format(format) {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assert)(format != null && format !== \"sighash\", \"cannot format a constructor for sighash\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"format(sighash)\"\n        });\n        if (format === \"json\") {\n            return JSON.stringify({\n                type: \"constructor\",\n                stateMutability: this.payable ? \"payable\" : \"undefined\",\n                payable: this.payable,\n                gas: this.gas != null ? this.gas : undefined,\n                inputs: this.inputs.map((i)=>JSON.parse(i.format(format)))\n            });\n        }\n        const result = [\n            `constructor${joinParams(format, this.inputs)}`\n        ];\n        if (this.payable) {\n            result.push(\"payable\");\n        }\n        if (this.gas != null) {\n            result.push(`@${this.gas.toString()}`);\n        }\n        return result.join(\" \");\n    }\n    /**\n     *  Returns a new **ConstructorFragment** for %%obj%%.\n     */ static from(obj) {\n        if (ConstructorFragment.isFragment(obj)) {\n            return obj;\n        }\n        if (typeof obj === \"string\") {\n            try {\n                return ConstructorFragment.from(lex(obj));\n            } catch (error) {\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(false, \"invalid constuctor fragment\", \"obj\", obj);\n            }\n        } else if (obj instanceof TokenString) {\n            consumeKeywords(obj, setify([\n                \"constructor\"\n            ]));\n            const inputs = consumeParams(obj);\n            const payable = !!consumeKeywords(obj, KwVisibDeploy).has(\"payable\");\n            const gas = consumeGas(obj);\n            consumeEoi(obj);\n            return new ConstructorFragment(_guard, \"constructor\", inputs, payable, gas);\n        }\n        return new ConstructorFragment(_guard, \"constructor\", obj.inputs ? obj.inputs.map(ParamType.from) : [], !!obj.payable, obj.gas != null ? obj.gas : null);\n    }\n    /**\n     *  Returns ``true`` and provides a type guard if %%value%% is a\n     *  **ConstructorFragment**.\n     */ static isFragment(value) {\n        return value && value[internal] === ConstructorFragmentInternal;\n    }\n}\n/**\n *  A Fragment which represents a method.\n */ class FallbackFragment extends Fragment {\n    constructor(guard, inputs, payable){\n        super(guard, \"fallback\", inputs);\n        Object.defineProperty(this, internal, {\n            value: FallbackFragmentInternal\n        });\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.defineProperties)(this, {\n            payable\n        });\n    }\n    /**\n     *  Returns a string representation of this fallback as %%format%%.\n     */ format(format) {\n        const type = this.inputs.length === 0 ? \"receive\" : \"fallback\";\n        if (format === \"json\") {\n            const stateMutability = this.payable ? \"payable\" : \"nonpayable\";\n            return JSON.stringify({\n                type,\n                stateMutability\n            });\n        }\n        return `${type}()${this.payable ? \" payable\" : \"\"}`;\n    }\n    /**\n     *  Returns a new **FallbackFragment** for %%obj%%.\n     */ static from(obj) {\n        if (FallbackFragment.isFragment(obj)) {\n            return obj;\n        }\n        if (typeof obj === \"string\") {\n            try {\n                return FallbackFragment.from(lex(obj));\n            } catch (error) {\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(false, \"invalid fallback fragment\", \"obj\", obj);\n            }\n        } else if (obj instanceof TokenString) {\n            const errorObj = obj.toString();\n            const topIsValid = obj.peekKeyword(setify([\n                \"fallback\",\n                \"receive\"\n            ]));\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(topIsValid, \"type must be fallback or receive\", \"obj\", errorObj);\n            const type = obj.popKeyword(setify([\n                \"fallback\",\n                \"receive\"\n            ]));\n            // receive()\n            if (type === \"receive\") {\n                const inputs = consumeParams(obj);\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(inputs.length === 0, `receive cannot have arguments`, \"obj.inputs\", inputs);\n                consumeKeywords(obj, setify([\n                    \"payable\"\n                ]));\n                consumeEoi(obj);\n                return new FallbackFragment(_guard, [], true);\n            }\n            // fallback() [payable]\n            // fallback(bytes) [payable] returns (bytes)\n            let inputs = consumeParams(obj);\n            if (inputs.length) {\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(inputs.length === 1 && inputs[0].type === \"bytes\", \"invalid fallback inputs\", \"obj.inputs\", inputs.map((i)=>i.format(\"minimal\")).join(\", \"));\n            } else {\n                inputs = [\n                    ParamType.from(\"bytes\")\n                ];\n            }\n            const mutability = consumeMutability(obj);\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(mutability === \"nonpayable\" || mutability === \"payable\", \"fallback cannot be constants\", \"obj.stateMutability\", mutability);\n            if (consumeKeywords(obj, setify([\n                \"returns\"\n            ])).has(\"returns\")) {\n                const outputs = consumeParams(obj);\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(outputs.length === 1 && outputs[0].type === \"bytes\", \"invalid fallback outputs\", \"obj.outputs\", outputs.map((i)=>i.format(\"minimal\")).join(\", \"));\n            }\n            consumeEoi(obj);\n            return new FallbackFragment(_guard, inputs, mutability === \"payable\");\n        }\n        if (obj.type === \"receive\") {\n            return new FallbackFragment(_guard, [], true);\n        }\n        if (obj.type === \"fallback\") {\n            const inputs = [\n                ParamType.from(\"bytes\")\n            ];\n            const payable = obj.stateMutability === \"payable\";\n            return new FallbackFragment(_guard, inputs, payable);\n        }\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(false, \"invalid fallback description\", \"obj\", obj);\n    }\n    /**\n     *  Returns ``true`` and provides a type guard if %%value%% is a\n     *  **FallbackFragment**.\n     */ static isFragment(value) {\n        return value && value[internal] === FallbackFragmentInternal;\n    }\n}\n/**\n *  A Fragment which represents a method.\n */ class FunctionFragment extends NamedFragment {\n    /**\n     *  @private\n     */ constructor(guard, name, stateMutability, inputs, outputs, gas){\n        super(guard, \"function\", name, inputs);\n        Object.defineProperty(this, internal, {\n            value: FunctionFragmentInternal\n        });\n        outputs = Object.freeze(outputs.slice());\n        const constant = stateMutability === \"view\" || stateMutability === \"pure\";\n        const payable = stateMutability === \"payable\";\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.defineProperties)(this, {\n            constant,\n            gas,\n            outputs,\n            payable,\n            stateMutability\n        });\n    }\n    /**\n     *  The Function selector.\n     */ get selector() {\n        return (0,_hash_index_js__WEBPACK_IMPORTED_MODULE_3__.id)(this.format(\"sighash\")).substring(0, 10);\n    }\n    /**\n     *  Returns a string representation of this function as %%format%%.\n     */ format(format) {\n        if (format == null) {\n            format = \"sighash\";\n        }\n        if (format === \"json\") {\n            return JSON.stringify({\n                type: \"function\",\n                name: this.name,\n                constant: this.constant,\n                stateMutability: this.stateMutability !== \"nonpayable\" ? this.stateMutability : undefined,\n                payable: this.payable,\n                gas: this.gas != null ? this.gas : undefined,\n                inputs: this.inputs.map((i)=>JSON.parse(i.format(format))),\n                outputs: this.outputs.map((o)=>JSON.parse(o.format(format)))\n            });\n        }\n        const result = [];\n        if (format !== \"sighash\") {\n            result.push(\"function\");\n        }\n        result.push(this.name + joinParams(format, this.inputs));\n        if (format !== \"sighash\") {\n            if (this.stateMutability !== \"nonpayable\") {\n                result.push(this.stateMutability);\n            }\n            if (this.outputs && this.outputs.length) {\n                result.push(\"returns\");\n                result.push(joinParams(format, this.outputs));\n            }\n            if (this.gas != null) {\n                result.push(`@${this.gas.toString()}`);\n            }\n        }\n        return result.join(\" \");\n    }\n    /**\n     *  Return the selector for a function with %%name%% and %%params%%.\n     */ static getSelector(name, params) {\n        params = (params || []).map((p)=>ParamType.from(p));\n        const fragment = new FunctionFragment(_guard, name, \"view\", params, [], null);\n        return fragment.selector;\n    }\n    /**\n     *  Returns a new **FunctionFragment** for %%obj%%.\n     */ static from(obj) {\n        if (FunctionFragment.isFragment(obj)) {\n            return obj;\n        }\n        if (typeof obj === \"string\") {\n            try {\n                return FunctionFragment.from(lex(obj));\n            } catch (error) {\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(false, \"invalid function fragment\", \"obj\", obj);\n            }\n        } else if (obj instanceof TokenString) {\n            const name = consumeName(\"function\", obj);\n            const inputs = consumeParams(obj);\n            const mutability = consumeMutability(obj);\n            let outputs = [];\n            if (consumeKeywords(obj, setify([\n                \"returns\"\n            ])).has(\"returns\")) {\n                outputs = consumeParams(obj);\n            }\n            const gas = consumeGas(obj);\n            consumeEoi(obj);\n            return new FunctionFragment(_guard, name, mutability, inputs, outputs, gas);\n        }\n        let stateMutability = obj.stateMutability;\n        // Use legacy Solidity ABI logic if stateMutability is missing\n        if (stateMutability == null) {\n            stateMutability = \"payable\";\n            if (typeof obj.constant === \"boolean\") {\n                stateMutability = \"view\";\n                if (!obj.constant) {\n                    stateMutability = \"payable\";\n                    if (typeof obj.payable === \"boolean\" && !obj.payable) {\n                        stateMutability = \"nonpayable\";\n                    }\n                }\n            } else if (typeof obj.payable === \"boolean\" && !obj.payable) {\n                stateMutability = \"nonpayable\";\n            }\n        }\n        // @TODO: verifyState for stateMutability (e.g. throw if\n        //        payable: false but stateMutability is \"nonpayable\")\n        return new FunctionFragment(_guard, obj.name, stateMutability, obj.inputs ? obj.inputs.map(ParamType.from) : [], obj.outputs ? obj.outputs.map(ParamType.from) : [], obj.gas != null ? obj.gas : null);\n    }\n    /**\n     *  Returns ``true`` and provides a type guard if %%value%% is a\n     *  **FunctionFragment**.\n     */ static isFragment(value) {\n        return value && value[internal] === FunctionFragmentInternal;\n    }\n}\n/**\n *  A Fragment which represents a structure.\n */ class StructFragment extends NamedFragment {\n    /**\n     *  @private\n     */ constructor(guard, name, inputs){\n        super(guard, \"struct\", name, inputs);\n        Object.defineProperty(this, internal, {\n            value: StructFragmentInternal\n        });\n    }\n    /**\n     *  Returns a string representation of this struct as %%format%%.\n     */ format() {\n        throw new Error(\"@TODO\");\n    }\n    /**\n     *  Returns a new **StructFragment** for %%obj%%.\n     */ static from(obj) {\n        if (typeof obj === \"string\") {\n            try {\n                return StructFragment.from(lex(obj));\n            } catch (error) {\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(false, \"invalid struct fragment\", \"obj\", obj);\n            }\n        } else if (obj instanceof TokenString) {\n            const name = consumeName(\"struct\", obj);\n            const inputs = consumeParams(obj);\n            consumeEoi(obj);\n            return new StructFragment(_guard, name, inputs);\n        }\n        return new StructFragment(_guard, obj.name, obj.inputs ? obj.inputs.map(ParamType.from) : []);\n    }\n    // @TODO: fix this return type\n    /**\n     *  Returns ``true`` and provides a type guard if %%value%% is a\n     *  **StructFragment**.\n     */ static isFragment(value) {\n        return value && value[internal] === StructFragmentInternal;\n    }\n} //# sourceMappingURL=fragments.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vYWJpL2ZyYWdtZW50cy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7Ozs7Ozs7Ozs7Q0FVQyxHQUNpSDtBQUM1RTs7QUFFdEMscUNBQXFDO0FBQ3JDLFNBQVNPLE9BQU9DLEtBQUs7SUFDakIsTUFBTUMsU0FBUyxJQUFJQztJQUNuQkYsTUFBTUcsT0FBTyxDQUFDLENBQUNDLElBQU1ILE9BQU9JLEdBQUcsQ0FBQ0Q7SUFDaEMsT0FBT0UsT0FBT0MsTUFBTSxDQUFDTjtBQUN6QjtBQUNBLE1BQU1PLGlCQUFpQjtBQUN2QixNQUFNQyxnQkFBZ0JWLE9BQU9TLGVBQWVFLEtBQUssQ0FBQztBQUNsRCxzQkFBc0I7QUFDdEIsTUFBTUMsV0FBVztBQUNqQixNQUFNQyxVQUFVYixPQUFPWSxTQUFTRCxLQUFLLENBQUM7QUFDdEMsTUFBTUcsV0FBVztBQUNqQixNQUFNQyxVQUFVZixPQUFPYyxTQUFTSCxLQUFLLENBQUM7QUFDdEMsTUFBTUssZUFBZTtBQUNyQixNQUFNQyxjQUFjakIsT0FBT2dCLGFBQWFMLEtBQUssQ0FBQztBQUM5QyxNQUFNTyxXQUFXO0FBQ2pCLGVBQWU7QUFDZixNQUFNQyxZQUFZO0lBQUNMO0lBQVVFO0lBQWNFO0lBQVVOO0NBQVMsQ0FBQ1EsSUFBSSxDQUFDO0FBQ3BFLE1BQU1DLFdBQVdyQixPQUFPbUIsVUFBVVIsS0FBSyxDQUFDO0FBQ3hDLDBCQUEwQjtBQUMxQixNQUFNVyxlQUFlO0lBQ2pCLEtBQUs7SUFBYyxLQUFLO0lBQ3hCLEtBQUs7SUFBZ0IsS0FBSztJQUMxQixLQUFLO0lBQVMsS0FBSztBQUN2QjtBQUNBLDJDQUEyQztBQUMzQyxNQUFNQyx3QkFBd0IsSUFBSUMsT0FBTztBQUN6QyxNQUFNQyxvQkFBb0IsSUFBSUQsT0FBTztBQUNyQyxNQUFNRSxnQkFBZ0IsSUFBSUYsT0FBTztBQUNqQyxrQ0FBa0M7QUFDbEMsTUFBTUcsVUFBVSxJQUFJSCxPQUFP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LEtBQUtTO0lBQ3pDO0FBQ0osRUFDQSxxQ0FBcUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tZWdhdmliZS1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9hYmkvZnJhZ21lbnRzLmpzPzcxYjAiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiAgQSBmcmFnbWVudCBpcyBhIHNpbmdsZSBpdGVtIGZyb20gYW4gQUJJLCB3aGljaCBtYXkgcmVwcmVzZW50IGFueSBvZjpcbiAqXG4gKiAgLSBbRnVuY3Rpb25zXShGdW5jdGlvbkZyYWdtZW50KVxuICogIC0gW0V2ZW50c10oRXZlbnRGcmFnbWVudClcbiAqICAtIFtDb25zdHJ1Y3RvcnNdKENvbnN0cnVjdG9yRnJhZ21lbnQpXG4gKiAgLSBDdXN0b20gW0Vycm9yc10oRXJyb3JGcmFnbWVudClcbiAqICAtIFtGYWxsYmFjayBvciBSZWNlaXZlXShGYWxsYmFja0ZyYWdtZW50KSBmdW5jdGlvbnNcbiAqXG4gKiAgQF9zdWJzZWN0aW9uIGFwaS9hYmkvYWJpLWNvZGVyOkZyYWdtZW50cyAgW2Fib3V0LWZyYWdtZW50c11cbiAqL1xuaW1wb3J0IHsgZGVmaW5lUHJvcGVydGllcywgZ2V0QmlnSW50LCBnZXROdW1iZXIsIGFzc2VydCwgYXNzZXJ0UHJpdmF0ZSwgYXNzZXJ0QXJndW1lbnQgfSBmcm9tIFwiLi4vdXRpbHMvaW5kZXguanNcIjtcbmltcG9ydCB7IGlkIH0gZnJvbSBcIi4uL2hhc2gvaW5kZXguanNcIjtcbjtcbi8vIFsgXCJhXCIsIFwiYlwiIF0gPT4geyBcImFcIjogMSwgXCJiXCI6IDEgfVxuZnVuY3Rpb24gc2V0aWZ5KGl0ZW1zKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gbmV3IFNldCgpO1xuICAgIGl0ZW1zLmZvckVhY2goKGspID0+IHJlc3VsdC5hZGQoaykpO1xuICAgIHJldHVybiBPYmplY3QuZnJlZXplKHJlc3VsdCk7XG59XG5jb25zdCBfa3dWaXNpYkRlcGxveSA9IFwiZXh0ZXJuYWwgcHVibGljIHBheWFibGUgb3ZlcnJpZGVcIjtcbmNvbnN0IEt3VmlzaWJEZXBsb3kgPSBzZXRpZnkoX2t3VmlzaWJEZXBsb3kuc3BsaXQoXCIgXCIpKTtcbi8vIFZpc2liaWxpdHkgS2V5d29yZHNcbmNvbnN0IF9rd1Zpc2liID0gXCJjb25zdGFudCBleHRlcm5hbCBpbnRlcm5hbCBwYXlhYmxlIHByaXZhdGUgcHVibGljIHB1cmUgdmlldyBvdmVycmlkZVwiO1xuY29uc3QgS3dWaXNpYiA9IHNldGlmeShfa3dWaXNpYi5zcGxpdChcIiBcIikpO1xuY29uc3QgX2t3VHlwZXMgPSBcImNvbnN0cnVjdG9yIGVycm9yIGV2ZW50IGZhbGxiYWNrIGZ1bmN0aW9uIHJlY2VpdmUgc3RydWN0XCI7XG5jb25zdCBLd1R5cGVzID0gc2V0aWZ5KF9rd1R5cGVzLnNwbGl0KFwiIFwiKSk7XG5jb25zdCBfa3dNb2RpZmllcnMgPSBcImNhbGxkYXRhIG1lbW9yeSBzdG9yYWdlIHBheWFibGUgaW5kZXhlZFwiO1xuY29uc3QgS3dNb2RpZmllcnMgPSBzZXRpZnkoX2t3TW9kaWZpZXJzLnNwbGl0KFwiIFwiKSk7XG5jb25zdCBfa3dPdGhlciA9IFwidHVwbGUgcmV0dXJuc1wiO1xuLy8gQWxsIEtleXdvcmRzXG5jb25zdCBfa2V5d29yZHMgPSBbX2t3VHlwZXMsIF9rd01vZGlmaWVycywgX2t3T3RoZXIsIF9rd1Zpc2liXS5qb2luKFwiIFwiKTtcbmNvbnN0IEtleXdvcmRzID0gc2V0aWZ5KF9rZXl3b3Jkcy5zcGxpdChcIiBcIikpO1xuLy8gU2luZ2xlIGNoYXJhY3RlciB0b2tlbnNcbmNvbnN0IFNpbXBsZVRva2VucyA9IHtcbiAgICBcIihcIjogXCJPUEVOX1BBUkVOXCIsIFwiKVwiOiBcIkNMT1NFX1BBUkVOXCIsXG4gICAgXCJbXCI6IFwiT1BFTl9CUkFDS0VUXCIsIFwiXVwiOiBcIkNMT1NFX0JSQUNLRVRcIixcbiAgICBcIixcIjogXCJDT01NQVwiLCBcIkBcIjogXCJBVFwiXG59O1xuLy8gUGFyc2VyIHJlZ2V4ZXMgdG8gY29uc3VtZSB0aGUgbmV4dCB0b2tlblxuY29uc3QgcmVnZXhXaGl0ZXNwYWNlUHJlZml4ID0gbmV3IFJlZ0V4cChcIl4oXFxcXHMqKVwiKTtcbmNvbnN0IHJlZ2V4TnVtYmVyUHJlZml4ID0gbmV3IFJlZ0V4cChcIl4oWzAtOV0rKVwiKTtcbmNvbnN0IHJlZ2V4SWRQcmVmaXggPSBuZXcgUmVnRXhwKFwiXihbYS16QS1aJF9dW2EtekEtWjAtOSRfXSopXCIpO1xuLy8gUGFyc2VyIHJlZ2V4cyB0byBjaGVjayB2YWxpZGl0eVxuY29uc3QgcmVnZXhJZCA9IG5ldyBSZWdFeHAoXCJeKFthLXpBLVokX11bYS16QS1aMC05JF9dKikkXCIpO1xuY29uc3QgcmVnZXhUeXBlID0gbmV3IFJlZ0V4cChcIl4oYWRkcmVzc3xib29sfGJ5dGVzKFswLTldKil8c3RyaW5nfHU/aW50KFswLTldKikpJFwiKTtcbmNsYXNzIFRva2VuU3RyaW5nIHtcbiAgICAjb2Zmc2V0O1xuICAgICN0b2tlbnM7XG4gICAgZ2V0IG9mZnNldCgpIHsgcmV0dXJuIHRoaXMuI29mZnNldDsgfVxuICAgIGdldCBsZW5ndGgoKSB7IHJldHVybiB0aGlzLiN0b2tlbnMubGVuZ3RoIC0gdGhpcy4jb2Zmc2V0OyB9XG4gICAgY29uc3RydWN0b3IodG9rZW5zKSB7XG4gICAgICAgIHRoaXMuI29mZnNldCA9IDA7XG4gICAgICAgIHRoaXMuI3Rva2VucyA9IHRva2Vucy5zbGljZSgpO1xuICAgIH1cbiAgICBjbG9uZSgpIHsgcmV0dXJuIG5ldyBUb2tlblN0cmluZyh0aGlzLiN0b2tlbnMpOyB9XG4gICAgcmVzZXQoKSB7IHRoaXMuI29mZnNldCA9IDA7IH1cbiAgICAjc3ViVG9rZW5TdHJpbmcoZnJvbSA9IDAsIHRvID0gMCkge1xuICAgICAgICByZXR1cm4gbmV3IFRva2VuU3RyaW5nKHRoaXMuI3Rva2Vucy5zbGljZShmcm9tLCB0bykubWFwKCh0KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LmZyZWV6ZShPYmplY3QuYXNzaWduKHt9LCB0LCB7XG4gICAgICAgICAgICAgICAgbWF0Y2g6ICh0Lm1hdGNoIC0gZnJvbSksXG4gICAgICAgICAgICAgICAgbGlua0JhY2s6ICh0LmxpbmtCYWNrIC0gZnJvbSksXG4gICAgICAgICAgICAgICAgbGlua05leHQ6ICh0LmxpbmtOZXh0IC0gZnJvbSksXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH0pKTtcbiAgICB9XG4gICAgLy8gUG9wcyBhbmQgcmV0dXJucyB0aGUgdmFsdWUgb2YgdGhlIG5leHQgdG9rZW4sIGlmIGl0IGlzIGEga2V5d29yZCBpbiBhbGxvd2VkOyB0aHJvd3MgaWYgb3V0IG9mIHRva2Vuc1xuICAgIHBvcEtleXdvcmQoYWxsb3dlZCkge1xuICAgICAgICBjb25zdCB0b3AgPSB0aGlzLnBlZWsoKTtcbiAgICAgICAgaWYgKHRvcC50eXBlICE9PSBcIktFWVdPUkRcIiB8fCAhYWxsb3dlZC5oYXModG9wLnRleHQpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGV4cGVjdGVkIGtleXdvcmQgJHt0b3AudGV4dH1gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5wb3AoKS50ZXh0O1xuICAgIH1cbiAgICAvLyBQb3BzIGFuZCByZXR1cm5zIHRoZSB2YWx1ZSBvZiB0aGUgbmV4dCB0b2tlbiBpZiBpdCBpcyBgdHlwZWA7IHRocm93cyBpZiBvdXQgb2YgdG9rZW5zXG4gICAgcG9wVHlwZSh0eXBlKSB7XG4gICAgICAgIGlmICh0aGlzLnBlZWsoKS50eXBlICE9PSB0eXBlKSB7XG4gICAgICAgICAgICBjb25zdCB0b3AgPSB0aGlzLnBlZWsoKTtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgZXhwZWN0ZWQgJHt0eXBlfTsgZ290ICR7dG9wLnR5cGV9ICR7SlNPTi5zdHJpbmdpZnkodG9wLnRleHQpfWApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnBvcCgpLnRleHQ7XG4gICAgfVxuICAgIC8vIFBvcHMgYW5kIHJldHVybnMgYSBcIihcIiBUT0tFTlMgXCIpXCJcbiAgICBwb3BQYXJlbigpIHtcbiAgICAgICAgY29uc3QgdG9wID0gdGhpcy5wZWVrKCk7XG4gICAgICAgIGlmICh0b3AudHlwZSAhPT0gXCJPUEVOX1BBUkVOXCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImJhZCBzdGFydFwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLiNzdWJUb2tlblN0cmluZyh0aGlzLiNvZmZzZXQgKyAxLCB0b3AubWF0Y2ggKyAxKTtcbiAgICAgICAgdGhpcy4jb2Zmc2V0ID0gdG9wLm1hdGNoICsgMTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLy8gUG9wcyBhbmQgcmV0dXJucyB0aGUgaXRlbXMgd2l0aGluIFwiKFwiIElURU0xIFwiLFwiIElURU0yIFwiLFwiIC4uLiBcIilcIlxuICAgIHBvcFBhcmFtcygpIHtcbiAgICAgICAgY29uc3QgdG9wID0gdGhpcy5wZWVrKCk7XG4gICAgICAgIGlmICh0b3AudHlwZSAhPT0gXCJPUEVOX1BBUkVOXCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImJhZCBzdGFydFwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICAgICAgd2hpbGUgKHRoaXMuI29mZnNldCA8IHRvcC5tYXRjaCAtIDEpIHtcbiAgICAgICAgICAgIGNvbnN0IGxpbmsgPSB0aGlzLnBlZWsoKS5saW5rTmV4dDtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHRoaXMuI3N1YlRva2VuU3RyaW5nKHRoaXMuI29mZnNldCArIDEsIGxpbmspKTtcbiAgICAgICAgICAgIHRoaXMuI29mZnNldCA9IGxpbms7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4jb2Zmc2V0ID0gdG9wLm1hdGNoICsgMTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLy8gUmV0dXJucyB0aGUgdG9wIFRva2VuLCB0aHJvd2luZyBpZiBvdXQgb2YgdG9rZW5zXG4gICAgcGVlaygpIHtcbiAgICAgICAgaWYgKHRoaXMuI29mZnNldCA+PSB0aGlzLiN0b2tlbnMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJvdXQtb2YtYm91bmRzXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLiN0b2tlbnNbdGhpcy4jb2Zmc2V0XTtcbiAgICB9XG4gICAgLy8gUmV0dXJucyB0aGUgbmV4dCB2YWx1ZSwgaWYgaXQgaXMgYSBrZXl3b3JkIGluIGBhbGxvd2VkYFxuICAgIHBlZWtLZXl3b3JkKGFsbG93ZWQpIHtcbiAgICAgICAgY29uc3QgdG9wID0gdGhpcy5wZWVrVHlwZShcIktFWVdPUkRcIik7XG4gICAgICAgIHJldHVybiAodG9wICE9IG51bGwgJiYgYWxsb3dlZC5oYXModG9wKSkgPyB0b3AgOiBudWxsO1xuICAgIH1cbiAgICAvLyBSZXR1cm5zIHRoZSB2YWx1ZSBvZiB0aGUgbmV4dCB0b2tlbiBpZiBpdCBpcyBgdHlwZWBcbiAgICBwZWVrVHlwZSh0eXBlKSB7XG4gICAgICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdG9wID0gdGhpcy5wZWVrKCk7XG4gICAgICAgIHJldHVybiAodG9wLnR5cGUgPT09IHR5cGUpID8gdG9wLnRleHQgOiBudWxsO1xuICAgIH1cbiAgICAvLyBSZXR1cm5zIHRoZSBuZXh0IHRva2VuOyB0aHJvd3MgaWYgb3V0IG9mIHRva2Vuc1xuICAgIHBvcCgpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5wZWVrKCk7XG4gICAgICAgIHRoaXMuI29mZnNldCsrO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgY29uc3QgdG9rZW5zID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSB0aGlzLiNvZmZzZXQ7IGkgPCB0aGlzLiN0b2tlbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHRva2VuID0gdGhpcy4jdG9rZW5zW2ldO1xuICAgICAgICAgICAgdG9rZW5zLnB1c2goYCR7dG9rZW4udHlwZX06JHt0b2tlbi50ZXh0fWApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBgPFRva2VuU3RyaW5nICR7dG9rZW5zLmpvaW4oXCIgXCIpfT5gO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGxleCh0ZXh0KSB7XG4gICAgY29uc3QgdG9rZW5zID0gW107XG4gICAgY29uc3QgdGhyb3dFcnJvciA9IChtZXNzYWdlKSA9PiB7XG4gICAgICAgIGNvbnN0IHRva2VuID0gKG9mZnNldCA8IHRleHQubGVuZ3RoKSA/IEpTT04uc3RyaW5naWZ5KHRleHRbb2Zmc2V0XSkgOiBcIiRFT0lcIjtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIHRva2VuICR7dG9rZW59IGF0ICR7b2Zmc2V0fTogJHttZXNzYWdlfWApO1xuICAgIH07XG4gICAgbGV0IGJyYWNrZXRzID0gW107XG4gICAgbGV0IGNvbW1hcyA9IFtdO1xuICAgIGxldCBvZmZzZXQgPSAwO1xuICAgIHdoaWxlIChvZmZzZXQgPCB0ZXh0Lmxlbmd0aCkge1xuICAgICAgICAvLyBTdHJpcCBvZmYgYW55IGxlYWRpbmcgd2hpdGVzcGFjZVxuICAgICAgICBsZXQgY3VyID0gdGV4dC5zdWJzdHJpbmcob2Zmc2V0KTtcbiAgICAgICAgbGV0IG1hdGNoID0gY3VyLm1hdGNoKHJlZ2V4V2hpdGVzcGFjZVByZWZpeCk7XG4gICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgb2Zmc2V0ICs9IG1hdGNoWzFdLmxlbmd0aDtcbiAgICAgICAgICAgIGN1ciA9IHRleHQuc3Vic3RyaW5nKG9mZnNldCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdG9rZW4gPSB7IGRlcHRoOiBicmFja2V0cy5sZW5ndGgsIGxpbmtCYWNrOiAtMSwgbGlua05leHQ6IC0xLCBtYXRjaDogLTEsIHR5cGU6IFwiXCIsIHRleHQ6IFwiXCIsIG9mZnNldCwgdmFsdWU6IC0xIH07XG4gICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgbGV0IHR5cGUgPSAoU2ltcGxlVG9rZW5zW2N1clswXV0gfHwgXCJcIik7XG4gICAgICAgIGlmICh0eXBlKSB7XG4gICAgICAgICAgICB0b2tlbi50eXBlID0gdHlwZTtcbiAgICAgICAgICAgIHRva2VuLnRleHQgPSBjdXJbMF07XG4gICAgICAgICAgICBvZmZzZXQrKztcbiAgICAgICAgICAgIGlmICh0eXBlID09PSBcIk9QRU5fUEFSRU5cIikge1xuICAgICAgICAgICAgICAgIGJyYWNrZXRzLnB1c2godG9rZW5zLmxlbmd0aCAtIDEpO1xuICAgICAgICAgICAgICAgIGNvbW1hcy5wdXNoKHRva2Vucy5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGUgPT0gXCJDTE9TRV9QQVJFTlwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKGJyYWNrZXRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvd0Vycm9yKFwibm8gbWF0Y2hpbmcgb3BlbiBicmFja2V0XCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0b2tlbi5tYXRjaCA9IGJyYWNrZXRzLnBvcCgpO1xuICAgICAgICAgICAgICAgICh0b2tlbnNbdG9rZW4ubWF0Y2hdKS5tYXRjaCA9IHRva2Vucy5sZW5ndGggLSAxO1xuICAgICAgICAgICAgICAgIHRva2VuLmRlcHRoLS07XG4gICAgICAgICAgICAgICAgdG9rZW4ubGlua0JhY2sgPSBjb21tYXMucG9wKCk7XG4gICAgICAgICAgICAgICAgKHRva2Vuc1t0b2tlbi5saW5rQmFja10pLmxpbmtOZXh0ID0gdG9rZW5zLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlID09PSBcIkNPTU1BXCIpIHtcbiAgICAgICAgICAgICAgICB0b2tlbi5saW5rQmFjayA9IGNvbW1hcy5wb3AoKTtcbiAgICAgICAgICAgICAgICAodG9rZW5zW3Rva2VuLmxpbmtCYWNrXSkubGlua05leHQgPSB0b2tlbnMubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgICAgICBjb21tYXMucHVzaCh0b2tlbnMubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlID09PSBcIk9QRU5fQlJBQ0tFVFwiKSB7XG4gICAgICAgICAgICAgICAgdG9rZW4udHlwZSA9IFwiQlJBQ0tFVFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZSA9PT0gXCJDTE9TRV9CUkFDS0VUXCIpIHtcbiAgICAgICAgICAgICAgICAvLyBSZW1vdmUgdGhlIENMT1NFX0JSQUNLRVRcbiAgICAgICAgICAgICAgICBsZXQgc3VmZml4ID0gdG9rZW5zLnBvcCgpLnRleHQ7XG4gICAgICAgICAgICAgICAgaWYgKHRva2Vucy5sZW5ndGggPiAwICYmIHRva2Vuc1t0b2tlbnMubGVuZ3RoIC0gMV0udHlwZSA9PT0gXCJOVU1CRVJcIikge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHRva2Vucy5wb3AoKS50ZXh0O1xuICAgICAgICAgICAgICAgICAgICBzdWZmaXggPSB2YWx1ZSArIHN1ZmZpeDtcbiAgICAgICAgICAgICAgICAgICAgKHRva2Vuc1t0b2tlbnMubGVuZ3RoIC0gMV0pLnZhbHVlID0gZ2V0TnVtYmVyKHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRva2Vucy5sZW5ndGggPT09IDAgfHwgdG9rZW5zW3Rva2Vucy5sZW5ndGggLSAxXS50eXBlICE9PSBcIkJSQUNLRVRcIikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJtaXNzaW5nIG9wZW5pbmcgYnJhY2tldFwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgKHRva2Vuc1t0b2tlbnMubGVuZ3RoIC0gMV0pLnRleHQgKz0gc3VmZml4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgbWF0Y2ggPSBjdXIubWF0Y2gocmVnZXhJZFByZWZpeCk7XG4gICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgdG9rZW4udGV4dCA9IG1hdGNoWzFdO1xuICAgICAgICAgICAgb2Zmc2V0ICs9IHRva2VuLnRleHQubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKEtleXdvcmRzLmhhcyh0b2tlbi50ZXh0KSkge1xuICAgICAgICAgICAgICAgIHRva2VuLnR5cGUgPSBcIktFWVdPUkRcIjtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0b2tlbi50ZXh0Lm1hdGNoKHJlZ2V4VHlwZSkpIHtcbiAgICAgICAgICAgICAgICB0b2tlbi50eXBlID0gXCJUWVBFXCI7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0b2tlbi50eXBlID0gXCJJRFwiO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgbWF0Y2ggPSBjdXIubWF0Y2gocmVnZXhOdW1iZXJQcmVmaXgpO1xuICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgIHRva2VuLnRleHQgPSBtYXRjaFsxXTtcbiAgICAgICAgICAgIHRva2VuLnR5cGUgPSBcIk5VTUJFUlwiO1xuICAgICAgICAgICAgb2Zmc2V0ICs9IHRva2VuLnRleHQubGVuZ3RoO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGB1bmV4cGVjdGVkIHRva2VuICR7SlNPTi5zdHJpbmdpZnkoY3VyWzBdKX0gYXQgcG9zaXRpb24gJHtvZmZzZXR9YCk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgVG9rZW5TdHJpbmcodG9rZW5zLm1hcCgodCkgPT4gT2JqZWN0LmZyZWV6ZSh0KSkpO1xufVxuLy8gQ2hlY2sgb25seSBvbmUgb2YgYGFsbG93ZWRgIGlzIGluIGBzZXRgXG5mdW5jdGlvbiBhbGxvd1NpbmdsZShzZXQsIGFsbG93ZWQpIHtcbiAgICBsZXQgaW5jbHVkZWQgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBhbGxvd2VkLmtleXMoKSkge1xuICAgICAgICBpZiAoc2V0LmhhcyhrZXkpKSB7XG4gICAgICAgICAgICBpbmNsdWRlZC5wdXNoKGtleSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGluY2x1ZGVkLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBjb25mbGljdGluZyB0eXBlczogJHtpbmNsdWRlZC5qb2luKFwiLCBcIil9YCk7XG4gICAgfVxufVxuLy8gRnVuY3Rpb25zIHRvIHByb2Nlc3MgYSBTb2xpZGl0eSBTaWduYXR1cmUgVG9rZW5TdHJpbmcgZnJvbSBsZWZ0LXRvLXJpZ2h0IGZvci4uLlxuLy8gLi4udGhlIG5hbWUgd2l0aCBhbiBvcHRpb25hbCB0eXBlLCByZXR1cm5pbmcgdGhlIG5hbWVcbmZ1bmN0aW9uIGNvbnN1bWVOYW1lKHR5cGUsIHRva2Vucykge1xuICAgIGlmICh0b2tlbnMucGVla0tleXdvcmQoS3dUeXBlcykpIHtcbiAgICAgICAgY29uc3Qga2V5d29yZCA9IHRva2Vucy5wb3AoKS50ZXh0O1xuICAgICAgICBpZiAoa2V5d29yZCAhPT0gdHlwZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBleHBlY3RlZCAke3R5cGV9LCBnb3QgJHtrZXl3b3JkfWApO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0b2tlbnMucG9wVHlwZShcIklEXCIpO1xufVxuLy8gLi4uYWxsIGtleXdvcmRzIG1hdGNoaW5nIGFsbG93ZWQsIHJldHVybmluZyB0aGUga2V5d29yZHNcbmZ1bmN0aW9uIGNvbnN1bWVLZXl3b3Jkcyh0b2tlbnMsIGFsbG93ZWQpIHtcbiAgICBjb25zdCBrZXl3b3JkcyA9IG5ldyBTZXQoKTtcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICBjb25zdCBrZXl3b3JkID0gdG9rZW5zLnBlZWtUeXBlKFwiS0VZV09SRFwiKTtcbiAgICAgICAgaWYgKGtleXdvcmQgPT0gbnVsbCB8fCAoYWxsb3dlZCAmJiAhYWxsb3dlZC5oYXMoa2V5d29yZCkpKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICB0b2tlbnMucG9wKCk7XG4gICAgICAgIGlmIChrZXl3b3Jkcy5oYXMoa2V5d29yZCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgZHVwbGljYXRlIGtleXdvcmRzOiAke0pTT04uc3RyaW5naWZ5KGtleXdvcmQpfWApO1xuICAgICAgICB9XG4gICAgICAgIGtleXdvcmRzLmFkZChrZXl3b3JkKTtcbiAgICB9XG4gICAgcmV0dXJuIE9iamVjdC5mcmVlemUoa2V5d29yZHMpO1xufVxuLy8gLi4uYWxsIHZpc2liaWxpdHkga2V5d29yZHMsIHJldHVybmluZyB0aGUgY29hbGVzY2VkIG11dGFiaWxpdHlcbmZ1bmN0aW9uIGNvbnN1bWVNdXRhYmlsaXR5KHRva2Vucykge1xuICAgIGxldCBtb2RpZmllcnMgPSBjb25zdW1lS2V5d29yZHModG9rZW5zLCBLd1Zpc2liKTtcbiAgICAvLyBEZXRlY3QgY29uZmxpY3RpbmcgbW9kaWZpZXJzXG4gICAgYWxsb3dTaW5nbGUobW9kaWZpZXJzLCBzZXRpZnkoXCJjb25zdGFudCBwYXlhYmxlIG5vbnBheWFibGVcIi5zcGxpdChcIiBcIikpKTtcbiAgICBhbGxvd1NpbmdsZShtb2RpZmllcnMsIHNldGlmeShcInB1cmUgdmlldyBwYXlhYmxlIG5vbnBheWFibGVcIi5zcGxpdChcIiBcIikpKTtcbiAgICAvLyBQcm9jZXNzIG11dGFiaWxpdHkgc3RhdGVzXG4gICAgaWYgKG1vZGlmaWVycy5oYXMoXCJ2aWV3XCIpKSB7XG4gICAgICAgIHJldHVybiBcInZpZXdcIjtcbiAgICB9XG4gICAgaWYgKG1vZGlmaWVycy5oYXMoXCJwdXJlXCIpKSB7XG4gICAgICAgIHJldHVybiBcInB1cmVcIjtcbiAgICB9XG4gICAgaWYgKG1vZGlmaWVycy5oYXMoXCJwYXlhYmxlXCIpKSB7XG4gICAgICAgIHJldHVybiBcInBheWFibGVcIjtcbiAgICB9XG4gICAgaWYgKG1vZGlmaWVycy5oYXMoXCJub25wYXlhYmxlXCIpKSB7XG4gICAgICAgIHJldHVybiBcIm5vbnBheWFibGVcIjtcbiAgICB9XG4gICAgLy8gUHJvY2VzcyBsZWdhY3kgYGNvbnN0YW50YCBsYXN0XG4gICAgaWYgKG1vZGlmaWVycy5oYXMoXCJjb25zdGFudFwiKSkge1xuICAgICAgICByZXR1cm4gXCJ2aWV3XCI7XG4gICAgfVxuICAgIHJldHVybiBcIm5vbnBheWFibGVcIjtcbn1cbi8vIC4uLmEgcGFyYW1ldGVyIGxpc3QsIHJldHVybmluZyB0aGUgUGFyYW1UeXBlIGxpc3RcbmZ1bmN0aW9uIGNvbnN1bWVQYXJhbXModG9rZW5zLCBhbGxvd0luZGV4ZWQpIHtcbiAgICByZXR1cm4gdG9rZW5zLnBvcFBhcmFtcygpLm1hcCgodCkgPT4gUGFyYW1UeXBlLmZyb20odCwgYWxsb3dJbmRleGVkKSk7XG59XG4vLyAuLi5hIGdhcyBsaW1pdCwgcmV0dXJuaW5nIGEgQmlnTnVtYmVyIG9yIG51bGwgaWYgbm9uZVxuZnVuY3Rpb24gY29uc3VtZUdhcyh0b2tlbnMpIHtcbiAgICBpZiAodG9rZW5zLnBlZWtUeXBlKFwiQVRcIikpIHtcbiAgICAgICAgdG9rZW5zLnBvcCgpO1xuICAgICAgICBpZiAodG9rZW5zLnBlZWtUeXBlKFwiTlVNQkVSXCIpKSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0QmlnSW50KHRva2Vucy5wb3AoKS50ZXh0KTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGdhc1wiKTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBjb25zdW1lRW9pKHRva2Vucykge1xuICAgIGlmICh0b2tlbnMubGVuZ3RoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgdW5leHBlY3RlZCB0b2tlbnMgYXQgb2Zmc2V0ICR7dG9rZW5zLm9mZnNldH06ICR7dG9rZW5zLnRvU3RyaW5nKCl9YCk7XG4gICAgfVxufVxuY29uc3QgcmVnZXhBcnJheVR5cGUgPSBuZXcgUmVnRXhwKC9eKC4qKVxcWyhbMC05XSopXFxdJC8pO1xuZnVuY3Rpb24gdmVyaWZ5QmFzaWNUeXBlKHR5cGUpIHtcbiAgICBjb25zdCBtYXRjaCA9IHR5cGUubWF0Y2gocmVnZXhUeXBlKTtcbiAgICBhc3NlcnRBcmd1bWVudChtYXRjaCwgXCJpbnZhbGlkIHR5cGVcIiwgXCJ0eXBlXCIsIHR5cGUpO1xuICAgIGlmICh0eXBlID09PSBcInVpbnRcIikge1xuICAgICAgICByZXR1cm4gXCJ1aW50MjU2XCI7XG4gICAgfVxuICAgIGlmICh0eXBlID09PSBcImludFwiKSB7XG4gICAgICAgIHJldHVybiBcImludDI1NlwiO1xuICAgIH1cbiAgICBpZiAobWF0Y2hbMl0pIHtcbiAgICAgICAgLy8gYnl0ZXNYWFxuICAgICAgICBjb25zdCBsZW5ndGggPSBwYXJzZUludChtYXRjaFsyXSk7XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KGxlbmd0aCAhPT0gMCAmJiBsZW5ndGggPD0gMzIsIFwiaW52YWxpZCBieXRlcyBsZW5ndGhcIiwgXCJ0eXBlXCIsIHR5cGUpO1xuICAgIH1cbiAgICBlbHNlIGlmIChtYXRjaFszXSkge1xuICAgICAgICAvLyBpbnRYWCBvciB1aW50WFhcbiAgICAgICAgY29uc3Qgc2l6ZSA9IHBhcnNlSW50KG1hdGNoWzNdKTtcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQoc2l6ZSAhPT0gMCAmJiBzaXplIDw9IDI1NiAmJiAoc2l6ZSAlIDgpID09PSAwLCBcImludmFsaWQgbnVtZXJpYyB3aWR0aFwiLCBcInR5cGVcIiwgdHlwZSk7XG4gICAgfVxuICAgIHJldHVybiB0eXBlO1xufVxuLy8gTWFrZSB0aGUgRnJhZ21lbnQgY29uc3RydWN0b3JzIGVmZmVjdGl2ZWx5IHByaXZhdGVcbmNvbnN0IF9ndWFyZCA9IHt9O1xuY29uc3QgaW50ZXJuYWwgPSBTeW1ib2wuZm9yKFwiX2V0aGVyc19pbnRlcm5hbFwiKTtcbmNvbnN0IFBhcmFtVHlwZUludGVybmFsID0gXCJfUGFyYW1UeXBlSW50ZXJuYWxcIjtcbmNvbnN0IEVycm9yRnJhZ21lbnRJbnRlcm5hbCA9IFwiX0Vycm9ySW50ZXJuYWxcIjtcbmNvbnN0IEV2ZW50RnJhZ21lbnRJbnRlcm5hbCA9IFwiX0V2ZW50SW50ZXJuYWxcIjtcbmNvbnN0IENvbnN0cnVjdG9yRnJhZ21lbnRJbnRlcm5hbCA9IFwiX0NvbnN0cnVjdG9ySW50ZXJuYWxcIjtcbmNvbnN0IEZhbGxiYWNrRnJhZ21lbnRJbnRlcm5hbCA9IFwiX0ZhbGxiYWNrSW50ZXJuYWxcIjtcbmNvbnN0IEZ1bmN0aW9uRnJhZ21lbnRJbnRlcm5hbCA9IFwiX0Z1bmN0aW9uSW50ZXJuYWxcIjtcbmNvbnN0IFN0cnVjdEZyYWdtZW50SW50ZXJuYWwgPSBcIl9TdHJ1Y3RJbnRlcm5hbFwiO1xuLyoqXG4gKiAgRWFjaCBpbnB1dCBhbmQgb3V0cHV0IG9mIGEgW1tGcmFnbWVudF1dIGlzIGFuIEFycmF5IG9mICoqUGFyYW1UeXBlKiouXG4gKi9cbmV4cG9ydCBjbGFzcyBQYXJhbVR5cGUge1xuICAgIC8qKlxuICAgICAqICBUaGUgbG9jYWwgbmFtZSBvZiB0aGUgcGFyYW1ldGVyIChvciBgYFwiXCJgYCBpZiB1bmJvdW5kKVxuICAgICAqL1xuICAgIG5hbWU7XG4gICAgLyoqXG4gICAgICogIFRoZSBmdWxseSBxdWFsaWZpZWQgdHlwZSAoZS5nLiBgYFwiYWRkcmVzc1wiYGAsIGBgXCJ0dXBsZShhZGRyZXNzKVwiYGAsXG4gICAgICogIGBgXCJ1aW50MjU2WzNdW11cImBgKVxuICAgICAqL1xuICAgIHR5cGU7XG4gICAgLyoqXG4gICAgICogIFRoZSBiYXNlIHR5cGUgKGUuZy4gYGBcImFkZHJlc3NcImBgLCBgYFwidHVwbGVcImBgLCBgYFwiYXJyYXlcImBgKVxuICAgICAqL1xuICAgIGJhc2VUeXBlO1xuICAgIC8qKlxuICAgICAqICBUcnVlIGlmIHRoZSBwYXJhbWV0ZXJzIGlzIGluZGV4ZWQuXG4gICAgICpcbiAgICAgKiAgRm9yIG5vbi1pbmRleGFibGUgdHlwZXMgdGhpcyBpcyBgYG51bGxgYC5cbiAgICAgKi9cbiAgICBpbmRleGVkO1xuICAgIC8qKlxuICAgICAqICBUaGUgY29tcG9uZW50cyBmb3IgdGhlIHR1cGxlLlxuICAgICAqXG4gICAgICogIEZvciBub24tdHVwbGUgdHlwZXMgdGhpcyBpcyBgYG51bGxgYC5cbiAgICAgKi9cbiAgICBjb21wb25lbnRzO1xuICAgIC8qKlxuICAgICAqICBUaGUgYXJyYXkgbGVuZ3RoLCBvciBgYC0xYGAgZm9yIGR5bmFtaWMtbGVuZ3RoZWQgYXJyYXlzLlxuICAgICAqXG4gICAgICogIEZvciBub24tYXJyYXkgdHlwZXMgdGhpcyBpcyBgYG51bGxgYC5cbiAgICAgKi9cbiAgICBhcnJheUxlbmd0aDtcbiAgICAvKipcbiAgICAgKiAgVGhlIHR5cGUgb2YgZWFjaCBjaGlsZCBpbiB0aGUgYXJyYXkuXG4gICAgICpcbiAgICAgKiAgRm9yIG5vbi1hcnJheSB0eXBlcyB0aGlzIGlzIGBgbnVsbGBgLlxuICAgICAqL1xuICAgIGFycmF5Q2hpbGRyZW47XG4gICAgLyoqXG4gICAgICogIEBwcml2YXRlXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoZ3VhcmQsIG5hbWUsIHR5cGUsIGJhc2VUeXBlLCBpbmRleGVkLCBjb21wb25lbnRzLCBhcnJheUxlbmd0aCwgYXJyYXlDaGlsZHJlbikge1xuICAgICAgICBhc3NlcnRQcml2YXRlKGd1YXJkLCBfZ3VhcmQsIFwiUGFyYW1UeXBlXCIpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgaW50ZXJuYWwsIHsgdmFsdWU6IFBhcmFtVHlwZUludGVybmFsIH0pO1xuICAgICAgICBpZiAoY29tcG9uZW50cykge1xuICAgICAgICAgICAgY29tcG9uZW50cyA9IE9iamVjdC5mcmVlemUoY29tcG9uZW50cy5zbGljZSgpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYmFzZVR5cGUgPT09IFwiYXJyYXlcIikge1xuICAgICAgICAgICAgaWYgKGFycmF5TGVuZ3RoID09IG51bGwgfHwgYXJyYXlDaGlsZHJlbiA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGFycmF5TGVuZ3RoICE9IG51bGwgfHwgYXJyYXlDaGlsZHJlbiAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJhc2VUeXBlID09PSBcInR1cGxlXCIpIHtcbiAgICAgICAgICAgIGlmIChjb21wb25lbnRzID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY29tcG9uZW50cyAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJcIik7XG4gICAgICAgIH1cbiAgICAgICAgZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7XG4gICAgICAgICAgICBuYW1lLCB0eXBlLCBiYXNlVHlwZSwgaW5kZXhlZCwgY29tcG9uZW50cywgYXJyYXlMZW5ndGgsIGFycmF5Q2hpbGRyZW5cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyB0eXBlLlxuICAgICAqXG4gICAgICogIEZvciBleGFtcGxlLFxuICAgICAqXG4gICAgICogIGBgc2lnaGFzaFwiID0+IFwiKHVpbnQyNTYsYWRkcmVzcylcImBgXG4gICAgICpcbiAgICAgKiAgYGBcIm1pbmltYWxcIiA9PiBcInR1cGxlKHVpbnQyNTYsYWRkcmVzcykgaW5kZXhlZFwiYGBcbiAgICAgKlxuICAgICAqICBgYFwiZnVsbFwiID0+IFwidHVwbGUodWludDI1NiBmb28sIGFkZHJlc3MgYmFyKSBpbmRleGVkIGJhelwiYGBcbiAgICAgKi9cbiAgICBmb3JtYXQoZm9ybWF0KSB7XG4gICAgICAgIGlmIChmb3JtYXQgPT0gbnVsbCkge1xuICAgICAgICAgICAgZm9ybWF0ID0gXCJzaWdoYXNoXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZvcm1hdCA9PT0gXCJqc29uXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IG5hbWUgPSB0aGlzLm5hbWUgfHwgXCJcIjtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzQXJyYXkoKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IEpTT04ucGFyc2UodGhpcy5hcnJheUNoaWxkcmVuLmZvcm1hdChcImpzb25cIikpO1xuICAgICAgICAgICAgICAgIHJlc3VsdC5uYW1lID0gbmFtZTtcbiAgICAgICAgICAgICAgICByZXN1bHQudHlwZSArPSBgWyR7KHRoaXMuYXJyYXlMZW5ndGggPCAwID8gXCJcIiA6IFN0cmluZyh0aGlzLmFycmF5TGVuZ3RoKSl9XWA7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHJlc3VsdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSB7XG4gICAgICAgICAgICAgICAgdHlwZTogKCh0aGlzLmJhc2VUeXBlID09PSBcInR1cGxlXCIpID8gXCJ0dXBsZVwiIDogdGhpcy50eXBlKSxcbiAgICAgICAgICAgICAgICBuYW1lXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKHR5cGVvZiAodGhpcy5pbmRleGVkKSA9PT0gXCJib29sZWFuXCIpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQuaW5kZXhlZCA9IHRoaXMuaW5kZXhlZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmlzVHVwbGUoKSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5jb21wb25lbnRzID0gdGhpcy5jb21wb25lbnRzLm1hcCgoYykgPT4gSlNPTi5wYXJzZShjLmZvcm1hdChmb3JtYXQpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkocmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcmVzdWx0ID0gXCJcIjtcbiAgICAgICAgLy8gQXJyYXlcbiAgICAgICAgaWYgKHRoaXMuaXNBcnJheSgpKSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gdGhpcy5hcnJheUNoaWxkcmVuLmZvcm1hdChmb3JtYXQpO1xuICAgICAgICAgICAgcmVzdWx0ICs9IGBbJHsodGhpcy5hcnJheUxlbmd0aCA8IDAgPyBcIlwiIDogU3RyaW5nKHRoaXMuYXJyYXlMZW5ndGgpKX1dYDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzVHVwbGUoKSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCArPSBcIihcIiArIHRoaXMuY29tcG9uZW50cy5tYXAoKGNvbXApID0+IGNvbXAuZm9ybWF0KGZvcm1hdCkpLmpvaW4oKGZvcm1hdCA9PT0gXCJmdWxsXCIpID8gXCIsIFwiIDogXCIsXCIpICsgXCIpXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gdGhpcy50eXBlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChmb3JtYXQgIT09IFwic2lnaGFzaFwiKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5pbmRleGVkID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IFwiIGluZGV4ZWRcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmb3JtYXQgPT09IFwiZnVsbFwiICYmIHRoaXMubmFtZSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCArPSBcIiBcIiArIHRoaXMubmFtZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0cnVlIGlmICUldGhpcyUlIGlzIGFuIEFycmF5IHR5cGUuXG4gICAgICpcbiAgICAgKiAgVGhpcyBwcm92aWRlcyBhIHR5cGUgZ2F1cmQgZW5zdXJpbmcgdGhhdCBbW2FycmF5Q2hpbGRyZW5dXVxuICAgICAqICBhbmQgW1thcnJheUxlbmd0aF1dIGFyZSBub24tbnVsbC5cbiAgICAgKi9cbiAgICBpc0FycmF5KCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuYmFzZVR5cGUgPT09IFwiYXJyYXlcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRydWUgaWYgJSV0aGlzJSUgaXMgYSBUdXBsZSB0eXBlLlxuICAgICAqXG4gICAgICogIFRoaXMgcHJvdmlkZXMgYSB0eXBlIGdhdXJkIGVuc3VyaW5nIHRoYXQgW1tjb21wb25lbnRzXV1cbiAgICAgKiAgaXMgbm9uLW51bGwuXG4gICAgICovXG4gICAgaXNUdXBsZSgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLmJhc2VUeXBlID09PSBcInR1cGxlXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0cnVlIGlmICUldGhpcyUlIGlzIGFuIEluZGV4YWJsZSB0eXBlLlxuICAgICAqXG4gICAgICogIFRoaXMgcHJvdmlkZXMgYSB0eXBlIGdhdXJkIGVuc3VyaW5nIHRoYXQgW1tpbmRleGVkXV1cbiAgICAgKiAgaXMgbm9uLW51bGwuXG4gICAgICovXG4gICAgaXNJbmRleGFibGUoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5pbmRleGVkICE9IG51bGwpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgV2Fsa3MgdGhlICoqUGFyYW1UeXBlKiogd2l0aCAlJXZhbHVlJSUsIGNhbGxpbmcgJSVwcm9jZXNzJSVcbiAgICAgKiAgb24gZWFjaCB0eXBlLCBkZXN0cnVjdGluZyB0aGUgJSV2YWx1ZSUlIHJlY3Vyc2l2ZWx5LlxuICAgICAqL1xuICAgIHdhbGsodmFsdWUsIHByb2Nlc3MpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNBcnJheSgpKSB7XG4gICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBhcnJheSB2YWx1ZVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmFycmF5TGVuZ3RoICE9PSAtMSAmJiB2YWx1ZS5sZW5ndGggIT09IHRoaXMuYXJyYXlMZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJhcnJheSBpcyB3cm9uZyBsZW5ndGhcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUubWFwKCh2KSA9PiAoX3RoaXMuYXJyYXlDaGlsZHJlbi53YWxrKHYsIHByb2Nlc3MpKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaXNUdXBsZSgpKSB7XG4gICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCB0dXBsZSB2YWx1ZVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh2YWx1ZS5sZW5ndGggIT09IHRoaXMuY29tcG9uZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJhcnJheSBpcyB3cm9uZyBsZW5ndGhcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUubWFwKCh2LCBpKSA9PiAoX3RoaXMuY29tcG9uZW50c1tpXS53YWxrKHYsIHByb2Nlc3MpKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHByb2Nlc3ModGhpcy50eXBlLCB2YWx1ZSk7XG4gICAgfVxuICAgICN3YWxrQXN5bmMocHJvbWlzZXMsIHZhbHVlLCBwcm9jZXNzLCBzZXRWYWx1ZSkge1xuICAgICAgICBpZiAodGhpcy5pc0FycmF5KCkpIHtcbiAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGFycmF5IHZhbHVlXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuYXJyYXlMZW5ndGggIT09IC0xICYmIHZhbHVlLmxlbmd0aCAhPT0gdGhpcy5hcnJheUxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImFycmF5IGlzIHdyb25nIGxlbmd0aFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGNoaWxkVHlwZSA9IHRoaXMuYXJyYXlDaGlsZHJlbjtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHZhbHVlLnNsaWNlKCk7XG4gICAgICAgICAgICByZXN1bHQuZm9yRWFjaCgodmFsdWUsIGluZGV4KSA9PiB7XG4gICAgICAgICAgICAgICAgY2hpbGRUeXBlLiN3YWxrQXN5bmMocHJvbWlzZXMsIHZhbHVlLCBwcm9jZXNzLCAodmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0W2luZGV4XSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzZXRWYWx1ZShyZXN1bHQpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmlzVHVwbGUoKSkge1xuICAgICAgICAgICAgY29uc3QgY29tcG9uZW50cyA9IHRoaXMuY29tcG9uZW50cztcbiAgICAgICAgICAgIC8vIENvbnZlcnQgdGhlIG9iamVjdCBpbnRvIGFuIGFycmF5XG4gICAgICAgICAgICBsZXQgcmVzdWx0O1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gdmFsdWUuc2xpY2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBudWxsIHx8IHR5cGVvZiAodmFsdWUpICE9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgdHVwbGUgdmFsdWVcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGNvbXBvbmVudHMubWFwKChwYXJhbSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXBhcmFtLm5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImNhbm5vdCB1c2Ugb2JqZWN0IHZhbHVlIHdpdGggdW5uYW1lZCBjb21wb25lbnRzXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICghKHBhcmFtLm5hbWUgaW4gdmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYG1pc3NpbmcgdmFsdWUgZm9yIGNvbXBvbmVudCAke3BhcmFtLm5hbWV9YCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlW3BhcmFtLm5hbWVdO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlc3VsdC5sZW5ndGggIT09IHRoaXMuY29tcG9uZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJhcnJheSBpcyB3cm9uZyBsZW5ndGhcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQuZm9yRWFjaCgodmFsdWUsIGluZGV4KSA9PiB7XG4gICAgICAgICAgICAgICAgY29tcG9uZW50c1tpbmRleF0uI3dhbGtBc3luYyhwcm9taXNlcywgdmFsdWUsIHByb2Nlc3MsICh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRbaW5kZXhdID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHNldFZhbHVlKHJlc3VsdCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gcHJvY2Vzcyh0aGlzLnR5cGUsIHZhbHVlKTtcbiAgICAgICAgaWYgKHJlc3VsdC50aGVuKSB7XG4gICAgICAgICAgICBwcm9taXNlcy5wdXNoKChhc3luYyBmdW5jdGlvbiAoKSB7IHNldFZhbHVlKGF3YWl0IHJlc3VsdCk7IH0pKCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc2V0VmFsdWUocmVzdWx0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiAgV2Fsa3MgdGhlICoqUGFyYW1UeXBlKiogd2l0aCAlJXZhbHVlJSUsIGFzeW5jaHJvbm91c2x5IGNhbGxpbmdcbiAgICAgKiAgJSVwcm9jZXNzJSUgb24gZWFjaCB0eXBlLCBkZXN0cnVjdGluZyB0aGUgJSV2YWx1ZSUlIHJlY3Vyc2l2ZWx5LlxuICAgICAqXG4gICAgICogIFRoaXMgY2FuIGJlIHVzZWQgdG8gcmVzb2x2ZSBFTlMgbmFtZXMgYnkgd2Fsa2luZyBhbmQgcmVzb2x2aW5nIGVhY2hcbiAgICAgKiAgYGBcImFkZHJlc3NcImBgIHR5cGUuXG4gICAgICovXG4gICAgYXN5bmMgd2Fsa0FzeW5jKHZhbHVlLCBwcm9jZXNzKSB7XG4gICAgICAgIGNvbnN0IHByb21pc2VzID0gW107XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IFt2YWx1ZV07XG4gICAgICAgIHRoaXMuI3dhbGtBc3luYyhwcm9taXNlcywgdmFsdWUsIHByb2Nlc3MsICh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgcmVzdWx0WzBdID0gdmFsdWU7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAocHJvbWlzZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChwcm9taXNlcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdFswXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIENyZWF0ZXMgYSBuZXcgKipQYXJhbVR5cGUqKiBmb3IgJSVvYmolJS5cbiAgICAgKlxuICAgICAqICBJZiAlJWFsbG93SW5kZXhlZCUlIHRoZW4gdGhlIGBgaW5kZXhlZGBgIGtleXdvcmQgaXMgcGVybWl0dGVkLFxuICAgICAqICBvdGhlcndpc2UgdGhlIGBgaW5kZXhlZGBgIGtleXdvcmQgd2lsbCB0aHJvdyBhbiBlcnJvci5cbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbShvYmosIGFsbG93SW5kZXhlZCkge1xuICAgICAgICBpZiAoUGFyYW1UeXBlLmlzUGFyYW1UeXBlKG9iaikpIHtcbiAgICAgICAgICAgIHJldHVybiBvYmo7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiAob2JqKSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gUGFyYW1UeXBlLmZyb20obGV4KG9iaiksIGFsbG93SW5kZXhlZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBhc3NlcnRBcmd1bWVudChmYWxzZSwgXCJpbnZhbGlkIHBhcmFtIHR5cGVcIiwgXCJvYmpcIiwgb2JqKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChvYmogaW5zdGFuY2VvZiBUb2tlblN0cmluZykge1xuICAgICAgICAgICAgbGV0IHR5cGUgPSBcIlwiLCBiYXNlVHlwZSA9IFwiXCI7XG4gICAgICAgICAgICBsZXQgY29tcHMgPSBudWxsO1xuICAgICAgICAgICAgaWYgKGNvbnN1bWVLZXl3b3JkcyhvYmosIHNldGlmeShbXCJ0dXBsZVwiXSkpLmhhcyhcInR1cGxlXCIpIHx8IG9iai5wZWVrVHlwZShcIk9QRU5fUEFSRU5cIikpIHtcbiAgICAgICAgICAgICAgICAvLyBUdXBsZVxuICAgICAgICAgICAgICAgIGJhc2VUeXBlID0gXCJ0dXBsZVwiO1xuICAgICAgICAgICAgICAgIGNvbXBzID0gb2JqLnBvcFBhcmFtcygpLm1hcCgodCkgPT4gUGFyYW1UeXBlLmZyb20odCkpO1xuICAgICAgICAgICAgICAgIHR5cGUgPSBgdHVwbGUoJHtjb21wcy5tYXAoKGMpID0+IGMuZm9ybWF0KCkpLmpvaW4oXCIsXCIpfSlgO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gTm9ybWFsXG4gICAgICAgICAgICAgICAgdHlwZSA9IHZlcmlmeUJhc2ljVHlwZShvYmoucG9wVHlwZShcIlRZUEVcIikpO1xuICAgICAgICAgICAgICAgIGJhc2VUeXBlID0gdHlwZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIENoZWNrIGZvciBBcnJheVxuICAgICAgICAgICAgbGV0IGFycmF5Q2hpbGRyZW4gPSBudWxsO1xuICAgICAgICAgICAgbGV0IGFycmF5TGVuZ3RoID0gbnVsbDtcbiAgICAgICAgICAgIHdoaWxlIChvYmoubGVuZ3RoICYmIG9iai5wZWVrVHlwZShcIkJSQUNLRVRcIikpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBicmFja2V0ID0gb2JqLnBvcCgpOyAvL2FycmF5c1tpXTtcbiAgICAgICAgICAgICAgICBhcnJheUNoaWxkcmVuID0gbmV3IFBhcmFtVHlwZShfZ3VhcmQsIFwiXCIsIHR5cGUsIGJhc2VUeXBlLCBudWxsLCBjb21wcywgYXJyYXlMZW5ndGgsIGFycmF5Q2hpbGRyZW4pO1xuICAgICAgICAgICAgICAgIGFycmF5TGVuZ3RoID0gYnJhY2tldC52YWx1ZTtcbiAgICAgICAgICAgICAgICB0eXBlICs9IGJyYWNrZXQudGV4dDtcbiAgICAgICAgICAgICAgICBiYXNlVHlwZSA9IFwiYXJyYXlcIjtcbiAgICAgICAgICAgICAgICBjb21wcyA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgaW5kZXhlZCA9IG51bGw7XG4gICAgICAgICAgICBjb25zdCBrZXl3b3JkcyA9IGNvbnN1bWVLZXl3b3JkcyhvYmosIEt3TW9kaWZpZXJzKTtcbiAgICAgICAgICAgIGlmIChrZXl3b3Jkcy5oYXMoXCJpbmRleGVkXCIpKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFhbGxvd0luZGV4ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpbmRleGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG5hbWUgPSAob2JqLnBlZWtUeXBlKFwiSURcIikgPyBvYmoucG9wKCkudGV4dCA6IFwiXCIpO1xuICAgICAgICAgICAgaWYgKG9iai5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJsZWZ0b3ZlciB0b2tlbnNcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IFBhcmFtVHlwZShfZ3VhcmQsIG5hbWUsIHR5cGUsIGJhc2VUeXBlLCBpbmRleGVkLCBjb21wcywgYXJyYXlMZW5ndGgsIGFycmF5Q2hpbGRyZW4pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5hbWUgPSBvYmoubmFtZTtcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQoIW5hbWUgfHwgKHR5cGVvZiAobmFtZSkgPT09IFwic3RyaW5nXCIgJiYgbmFtZS5tYXRjaChyZWdleElkKSksIFwiaW52YWxpZCBuYW1lXCIsIFwib2JqLm5hbWVcIiwgbmFtZSk7XG4gICAgICAgIGxldCBpbmRleGVkID0gb2JqLmluZGV4ZWQ7XG4gICAgICAgIGlmIChpbmRleGVkICE9IG51bGwpIHtcbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KGFsbG93SW5kZXhlZCwgXCJwYXJhbWV0ZXIgY2Fubm90IGJlIGluZGV4ZWRcIiwgXCJvYmouaW5kZXhlZFwiLCBvYmouaW5kZXhlZCk7XG4gICAgICAgICAgICBpbmRleGVkID0gISFpbmRleGVkO1xuICAgICAgICB9XG4gICAgICAgIGxldCB0eXBlID0gb2JqLnR5cGU7XG4gICAgICAgIGxldCBhcnJheU1hdGNoID0gdHlwZS5tYXRjaChyZWdleEFycmF5VHlwZSk7XG4gICAgICAgIGlmIChhcnJheU1hdGNoKSB7XG4gICAgICAgICAgICBjb25zdCBhcnJheUxlbmd0aCA9IHBhcnNlSW50KGFycmF5TWF0Y2hbMl0gfHwgXCItMVwiKTtcbiAgICAgICAgICAgIGNvbnN0IGFycmF5Q2hpbGRyZW4gPSBQYXJhbVR5cGUuZnJvbSh7XG4gICAgICAgICAgICAgICAgdHlwZTogYXJyYXlNYXRjaFsxXSxcbiAgICAgICAgICAgICAgICBjb21wb25lbnRzOiBvYmouY29tcG9uZW50c1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFBhcmFtVHlwZShfZ3VhcmQsIG5hbWUgfHwgXCJcIiwgdHlwZSwgXCJhcnJheVwiLCBpbmRleGVkLCBudWxsLCBhcnJheUxlbmd0aCwgYXJyYXlDaGlsZHJlbik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGUgPT09IFwidHVwbGVcIiB8fCB0eXBlLnN0YXJ0c1dpdGgoXCJ0dXBsZShcIiAvKiBmaXg6ICkgKi8pIHx8IHR5cGUuc3RhcnRzV2l0aChcIihcIiAvKiBmaXg6ICkgKi8pKSB7XG4gICAgICAgICAgICBjb25zdCBjb21wcyA9IChvYmouY29tcG9uZW50cyAhPSBudWxsKSA/IG9iai5jb21wb25lbnRzLm1hcCgoYykgPT4gUGFyYW1UeXBlLmZyb20oYykpIDogbnVsbDtcbiAgICAgICAgICAgIGNvbnN0IHR1cGxlID0gbmV3IFBhcmFtVHlwZShfZ3VhcmQsIG5hbWUgfHwgXCJcIiwgdHlwZSwgXCJ0dXBsZVwiLCBpbmRleGVkLCBjb21wcywgbnVsbCwgbnVsbCk7XG4gICAgICAgICAgICAvLyBAVE9ETzogdXNlIGxleGVyIHRvIHZhbGlkYXRlIGFuZCBub3JtYWxpemUgdHlwZVxuICAgICAgICAgICAgcmV0dXJuIHR1cGxlO1xuICAgICAgICB9XG4gICAgICAgIHR5cGUgPSB2ZXJpZnlCYXNpY1R5cGUob2JqLnR5cGUpO1xuICAgICAgICByZXR1cm4gbmV3IFBhcmFtVHlwZShfZ3VhcmQsIG5hbWUgfHwgXCJcIiwgdHlwZSwgdHlwZSwgaW5kZXhlZCwgbnVsbCwgbnVsbCwgbnVsbCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRydWUgaWYgJSV2YWx1ZSUlIGlzIGEgKipQYXJhbVR5cGUqKi5cbiAgICAgKi9cbiAgICBzdGF0aWMgaXNQYXJhbVR5cGUodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuICh2YWx1ZSAmJiB2YWx1ZVtpbnRlcm5hbF0gPT09IFBhcmFtVHlwZUludGVybmFsKTtcbiAgICB9XG59XG4vKipcbiAqICBBbiBhYnN0cmFjdCBjbGFzcyB0byByZXByZXNlbnQgQW4gaW5kaXZpZHVhbCBmcmFnbWVudCBmcm9tIGEgcGFyc2UgQUJJLlxuICovXG5leHBvcnQgY2xhc3MgRnJhZ21lbnQge1xuICAgIC8qKlxuICAgICAqICBUaGUgdHlwZSBvZiB0aGUgZnJhZ21lbnQuXG4gICAgICovXG4gICAgdHlwZTtcbiAgICAvKipcbiAgICAgKiAgVGhlIGlucHV0cyBmb3IgdGhlIGZyYWdtZW50LlxuICAgICAqL1xuICAgIGlucHV0cztcbiAgICAvKipcbiAgICAgKiAgQHByaXZhdGVcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihndWFyZCwgdHlwZSwgaW5wdXRzKSB7XG4gICAgICAgIGFzc2VydFByaXZhdGUoZ3VhcmQsIF9ndWFyZCwgXCJGcmFnbWVudFwiKTtcbiAgICAgICAgaW5wdXRzID0gT2JqZWN0LmZyZWV6ZShpbnB1dHMuc2xpY2UoKSk7XG4gICAgICAgIGRlZmluZVByb3BlcnRpZXModGhpcywgeyB0eXBlLCBpbnB1dHMgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBDcmVhdGVzIGEgbmV3ICoqRnJhZ21lbnQqKiBmb3IgJSVvYmolJSwgd2ljaCBjYW4gYmUgYW55IHN1cHBvcnRlZFxuICAgICAqICBBQkkgZnJnYW1lbnQgdHlwZS5cbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbShvYmopIHtcbiAgICAgICAgaWYgKHR5cGVvZiAob2JqKSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgLy8gVHJ5IHBhcnNpbmcgSlNPTi4uLlxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBGcmFnbWVudC5mcm9tKEpTT04ucGFyc2Uob2JqKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkgeyB9XG4gICAgICAgICAgICAvLyAuLi5vdGhlcndpc2UsIHVzZSB0aGUgaHVtYW4tcmVhZGFibGUgbGV4ZXJcbiAgICAgICAgICAgIHJldHVybiBGcmFnbWVudC5mcm9tKGxleChvYmopKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob2JqIGluc3RhbmNlb2YgVG9rZW5TdHJpbmcpIHtcbiAgICAgICAgICAgIC8vIEh1bWFuLXJlYWRhYmxlIEFCSSAoYWxyZWFkeSBsZXhlZClcbiAgICAgICAgICAgIGNvbnN0IHR5cGUgPSBvYmoucGVla0tleXdvcmQoS3dUeXBlcyk7XG4gICAgICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFwiY29uc3RydWN0b3JcIjogcmV0dXJuIENvbnN0cnVjdG9yRnJhZ21lbnQuZnJvbShvYmopO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJlcnJvclwiOiByZXR1cm4gRXJyb3JGcmFnbWVudC5mcm9tKG9iaik7XG4gICAgICAgICAgICAgICAgY2FzZSBcImV2ZW50XCI6IHJldHVybiBFdmVudEZyYWdtZW50LmZyb20ob2JqKTtcbiAgICAgICAgICAgICAgICBjYXNlIFwiZmFsbGJhY2tcIjpcbiAgICAgICAgICAgICAgICBjYXNlIFwicmVjZWl2ZVwiOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gRmFsbGJhY2tGcmFnbWVudC5mcm9tKG9iaik7XG4gICAgICAgICAgICAgICAgY2FzZSBcImZ1bmN0aW9uXCI6IHJldHVybiBGdW5jdGlvbkZyYWdtZW50LmZyb20ob2JqKTtcbiAgICAgICAgICAgICAgICBjYXNlIFwic3RydWN0XCI6IHJldHVybiBTdHJ1Y3RGcmFnbWVudC5mcm9tKG9iaik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIChvYmopID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICAvLyBKU09OIEFCSVxuICAgICAgICAgICAgc3dpdGNoIChvYmoudHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgXCJjb25zdHJ1Y3RvclwiOiByZXR1cm4gQ29uc3RydWN0b3JGcmFnbWVudC5mcm9tKG9iaik7XG4gICAgICAgICAgICAgICAgY2FzZSBcImVycm9yXCI6IHJldHVybiBFcnJvckZyYWdtZW50LmZyb20ob2JqKTtcbiAgICAgICAgICAgICAgICBjYXNlIFwiZXZlbnRcIjogcmV0dXJuIEV2ZW50RnJhZ21lbnQuZnJvbShvYmopO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJmYWxsYmFja1wiOlxuICAgICAgICAgICAgICAgIGNhc2UgXCJyZWNlaXZlXCI6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBGYWxsYmFja0ZyYWdtZW50LmZyb20ob2JqKTtcbiAgICAgICAgICAgICAgICBjYXNlIFwiZnVuY3Rpb25cIjogcmV0dXJuIEZ1bmN0aW9uRnJhZ21lbnQuZnJvbShvYmopO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJzdHJ1Y3RcIjogcmV0dXJuIFN0cnVjdEZyYWdtZW50LmZyb20ob2JqKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFzc2VydChmYWxzZSwgYHVuc3VwcG9ydGVkIHR5cGU6ICR7b2JqLnR5cGV9YCwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwge1xuICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogXCJGcmFnbWVudC5mcm9tXCJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KGZhbHNlLCBcInVuc3VwcG9ydGVkIGZyZ2FtZW50IG9iamVjdFwiLCBcIm9ialwiLCBvYmopO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0cnVlIGlmICUldmFsdWUlJSBpcyBhIFtbQ29uc3RydWN0b3JGcmFnbWVudF1dLlxuICAgICAqL1xuICAgIHN0YXRpYyBpc0NvbnN0cnVjdG9yKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBDb25zdHJ1Y3RvckZyYWdtZW50LmlzRnJhZ21lbnQodmFsdWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0cnVlIGlmICUldmFsdWUlJSBpcyBhbiBbW0Vycm9yRnJhZ21lbnRdXS5cbiAgICAgKi9cbiAgICBzdGF0aWMgaXNFcnJvcih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gRXJyb3JGcmFnbWVudC5pc0ZyYWdtZW50KHZhbHVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdHJ1ZSBpZiAlJXZhbHVlJSUgaXMgYW4gW1tFdmVudEZyYWdtZW50XV0uXG4gICAgICovXG4gICAgc3RhdGljIGlzRXZlbnQodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIEV2ZW50RnJhZ21lbnQuaXNGcmFnbWVudCh2YWx1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRydWUgaWYgJSV2YWx1ZSUlIGlzIGEgW1tGdW5jdGlvbkZyYWdtZW50XV0uXG4gICAgICovXG4gICAgc3RhdGljIGlzRnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIEZ1bmN0aW9uRnJhZ21lbnQuaXNGcmFnbWVudCh2YWx1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRydWUgaWYgJSV2YWx1ZSUlIGlzIGEgW1tTdHJ1Y3RGcmFnbWVudF1dLlxuICAgICAqL1xuICAgIHN0YXRpYyBpc1N0cnVjdCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gU3RydWN0RnJhZ21lbnQuaXNGcmFnbWVudCh2YWx1ZSk7XG4gICAgfVxufVxuLyoqXG4gKiAgQW4gYWJzdHJhY3QgY2xhc3MgdG8gcmVwcmVzZW50IEFuIGluZGl2aWR1YWwgZnJhZ21lbnRcbiAqICB3aGljaCBoYXMgYSBuYW1lIGZyb20gYSBwYXJzZSBBQkkuXG4gKi9cbmV4cG9ydCBjbGFzcyBOYW1lZEZyYWdtZW50IGV4dGVuZHMgRnJhZ21lbnQge1xuICAgIC8qKlxuICAgICAqICBUaGUgbmFtZSBvZiB0aGUgZnJhZ21lbnQuXG4gICAgICovXG4gICAgbmFtZTtcbiAgICAvKipcbiAgICAgKiAgQHByaXZhdGVcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihndWFyZCwgdHlwZSwgbmFtZSwgaW5wdXRzKSB7XG4gICAgICAgIHN1cGVyKGd1YXJkLCB0eXBlLCBpbnB1dHMpO1xuICAgICAgICBhc3NlcnRBcmd1bWVudCh0eXBlb2YgKG5hbWUpID09PSBcInN0cmluZ1wiICYmIG5hbWUubWF0Y2gocmVnZXhJZCksIFwiaW52YWxpZCBpZGVudGlmaWVyXCIsIFwibmFtZVwiLCBuYW1lKTtcbiAgICAgICAgaW5wdXRzID0gT2JqZWN0LmZyZWV6ZShpbnB1dHMuc2xpY2UoKSk7XG4gICAgICAgIGRlZmluZVByb3BlcnRpZXModGhpcywgeyBuYW1lIH0pO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGpvaW5QYXJhbXMoZm9ybWF0LCBwYXJhbXMpIHtcbiAgICByZXR1cm4gXCIoXCIgKyBwYXJhbXMubWFwKChwKSA9PiBwLmZvcm1hdChmb3JtYXQpKS5qb2luKChmb3JtYXQgPT09IFwiZnVsbFwiKSA/IFwiLCBcIiA6IFwiLFwiKSArIFwiKVwiO1xufVxuLyoqXG4gKiAgQSBGcmFnbWVudCB3aGljaCByZXByZXNlbnRzIGEgLy9DdXN0b20gRXJyb3IvLy5cbiAqL1xuZXhwb3J0IGNsYXNzIEVycm9yRnJhZ21lbnQgZXh0ZW5kcyBOYW1lZEZyYWdtZW50IHtcbiAgICAvKipcbiAgICAgKiAgQHByaXZhdGVcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihndWFyZCwgbmFtZSwgaW5wdXRzKSB7XG4gICAgICAgIHN1cGVyKGd1YXJkLCBcImVycm9yXCIsIG5hbWUsIGlucHV0cyk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBpbnRlcm5hbCwgeyB2YWx1ZTogRXJyb3JGcmFnbWVudEludGVybmFsIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhlIEN1c3RvbSBFcnJvciBzZWxlY3Rvci5cbiAgICAgKi9cbiAgICBnZXQgc2VsZWN0b3IoKSB7XG4gICAgICAgIHJldHVybiBpZCh0aGlzLmZvcm1hdChcInNpZ2hhc2hcIikpLnN1YnN0cmluZygwLCAxMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgZnJhZ21lbnQgYXMgJSVmb3JtYXQlJS5cbiAgICAgKi9cbiAgICBmb3JtYXQoZm9ybWF0KSB7XG4gICAgICAgIGlmIChmb3JtYXQgPT0gbnVsbCkge1xuICAgICAgICAgICAgZm9ybWF0ID0gXCJzaWdoYXNoXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZvcm1hdCA9PT0gXCJqc29uXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJlcnJvclwiLFxuICAgICAgICAgICAgICAgIG5hbWU6IHRoaXMubmFtZSxcbiAgICAgICAgICAgICAgICBpbnB1dHM6IHRoaXMuaW5wdXRzLm1hcCgoaW5wdXQpID0+IEpTT04ucGFyc2UoaW5wdXQuZm9ybWF0KGZvcm1hdCkpKSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgICAgICBpZiAoZm9ybWF0ICE9PSBcInNpZ2hhc2hcIikge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goXCJlcnJvclwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQucHVzaCh0aGlzLm5hbWUgKyBqb2luUGFyYW1zKGZvcm1hdCwgdGhpcy5pbnB1dHMpKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdC5qb2luKFwiIFwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYSBuZXcgKipFcnJvckZyYWdtZW50KiogZm9yICUlb2JqJSUuXG4gICAgICovXG4gICAgc3RhdGljIGZyb20ob2JqKSB7XG4gICAgICAgIGlmIChFcnJvckZyYWdtZW50LmlzRnJhZ21lbnQob2JqKSkge1xuICAgICAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIChvYmopID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICByZXR1cm4gRXJyb3JGcmFnbWVudC5mcm9tKGxleChvYmopKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChvYmogaW5zdGFuY2VvZiBUb2tlblN0cmluZykge1xuICAgICAgICAgICAgY29uc3QgbmFtZSA9IGNvbnN1bWVOYW1lKFwiZXJyb3JcIiwgb2JqKTtcbiAgICAgICAgICAgIGNvbnN0IGlucHV0cyA9IGNvbnN1bWVQYXJhbXMob2JqKTtcbiAgICAgICAgICAgIGNvbnN1bWVFb2kob2JqKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRXJyb3JGcmFnbWVudChfZ3VhcmQsIG5hbWUsIGlucHV0cyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBFcnJvckZyYWdtZW50KF9ndWFyZCwgb2JqLm5hbWUsIG9iai5pbnB1dHMgPyBvYmouaW5wdXRzLm1hcChQYXJhbVR5cGUuZnJvbSkgOiBbXSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGBgdHJ1ZWBgIGFuZCBwcm92aWRlcyBhIHR5cGUgZ3VhcmQgaWYgJSV2YWx1ZSUlIGlzIGFuXG4gICAgICogICoqRXJyb3JGcmFnbWVudCoqLlxuICAgICAqL1xuICAgIHN0YXRpYyBpc0ZyYWdtZW50KHZhbHVlKSB7XG4gICAgICAgIHJldHVybiAodmFsdWUgJiYgdmFsdWVbaW50ZXJuYWxdID09PSBFcnJvckZyYWdtZW50SW50ZXJuYWwpO1xuICAgIH1cbn1cbi8qKlxuICogIEEgRnJhZ21lbnQgd2hpY2ggcmVwcmVzZW50cyBhbiBFdmVudC5cbiAqL1xuZXhwb3J0IGNsYXNzIEV2ZW50RnJhZ21lbnQgZXh0ZW5kcyBOYW1lZEZyYWdtZW50IHtcbiAgICAvKipcbiAgICAgKiAgV2hldGhlciB0aGlzIGV2ZW50IGlzIGFub255bW91cy5cbiAgICAgKi9cbiAgICBhbm9ueW1vdXM7XG4gICAgLyoqXG4gICAgICogIEBwcml2YXRlXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoZ3VhcmQsIG5hbWUsIGlucHV0cywgYW5vbnltb3VzKSB7XG4gICAgICAgIHN1cGVyKGd1YXJkLCBcImV2ZW50XCIsIG5hbWUsIGlucHV0cyk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBpbnRlcm5hbCwgeyB2YWx1ZTogRXZlbnRGcmFnbWVudEludGVybmFsIH0pO1xuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHsgYW5vbnltb3VzIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhlIEV2ZW50IHRvcGljIGhhc2guXG4gICAgICovXG4gICAgZ2V0IHRvcGljSGFzaCgpIHtcbiAgICAgICAgcmV0dXJuIGlkKHRoaXMuZm9ybWF0KFwic2lnaGFzaFwiKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgZXZlbnQgYXMgJSVmb3JtYXQlJS5cbiAgICAgKi9cbiAgICBmb3JtYXQoZm9ybWF0KSB7XG4gICAgICAgIGlmIChmb3JtYXQgPT0gbnVsbCkge1xuICAgICAgICAgICAgZm9ybWF0ID0gXCJzaWdoYXNoXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZvcm1hdCA9PT0gXCJqc29uXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJldmVudFwiLFxuICAgICAgICAgICAgICAgIGFub255bW91czogdGhpcy5hbm9ueW1vdXMsXG4gICAgICAgICAgICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgICAgICAgICAgIGlucHV0czogdGhpcy5pbnB1dHMubWFwKChpKSA9PiBKU09OLnBhcnNlKGkuZm9ybWF0KGZvcm1hdCkpKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgICAgIGlmIChmb3JtYXQgIT09IFwic2lnaGFzaFwiKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChcImV2ZW50XCIpO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdC5wdXNoKHRoaXMubmFtZSArIGpvaW5QYXJhbXMoZm9ybWF0LCB0aGlzLmlucHV0cykpO1xuICAgICAgICBpZiAoZm9ybWF0ICE9PSBcInNpZ2hhc2hcIiAmJiB0aGlzLmFub255bW91cykge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goXCJhbm9ueW1vdXNcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdC5qb2luKFwiIFwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiB0aGUgdG9waWMgaGFzaCBmb3IgYW4gZXZlbnQgd2l0aCAlJW5hbWUlJSBhbmQgJSVwYXJhbXMlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0VG9waWNIYXNoKG5hbWUsIHBhcmFtcykge1xuICAgICAgICBwYXJhbXMgPSAocGFyYW1zIHx8IFtdKS5tYXAoKHApID0+IFBhcmFtVHlwZS5mcm9tKHApKTtcbiAgICAgICAgY29uc3QgZnJhZ21lbnQgPSBuZXcgRXZlbnRGcmFnbWVudChfZ3VhcmQsIG5hbWUsIHBhcmFtcywgZmFsc2UpO1xuICAgICAgICByZXR1cm4gZnJhZ21lbnQudG9waWNIYXNoO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBhIG5ldyAqKkV2ZW50RnJhZ21lbnQqKiBmb3IgJSVvYmolJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbShvYmopIHtcbiAgICAgICAgaWYgKEV2ZW50RnJhZ21lbnQuaXNGcmFnbWVudChvYmopKSB7XG4gICAgICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgKG9iaikgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEV2ZW50RnJhZ21lbnQuZnJvbShsZXgob2JqKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBhc3NlcnRBcmd1bWVudChmYWxzZSwgXCJpbnZhbGlkIGV2ZW50IGZyYWdtZW50XCIsIFwib2JqXCIsIG9iaik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob2JqIGluc3RhbmNlb2YgVG9rZW5TdHJpbmcpIHtcbiAgICAgICAgICAgIGNvbnN0IG5hbWUgPSBjb25zdW1lTmFtZShcImV2ZW50XCIsIG9iaik7XG4gICAgICAgICAgICBjb25zdCBpbnB1dHMgPSBjb25zdW1lUGFyYW1zKG9iaiwgdHJ1ZSk7XG4gICAgICAgICAgICBjb25zdCBhbm9ueW1vdXMgPSAhIWNvbnN1bWVLZXl3b3JkcyhvYmosIHNldGlmeShbXCJhbm9ueW1vdXNcIl0pKS5oYXMoXCJhbm9ueW1vdXNcIik7XG4gICAgICAgICAgICBjb25zdW1lRW9pKG9iaik7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEV2ZW50RnJhZ21lbnQoX2d1YXJkLCBuYW1lLCBpbnB1dHMsIGFub255bW91cyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBFdmVudEZyYWdtZW50KF9ndWFyZCwgb2JqLm5hbWUsIG9iai5pbnB1dHMgPyBvYmouaW5wdXRzLm1hcCgocCkgPT4gUGFyYW1UeXBlLmZyb20ocCwgdHJ1ZSkpIDogW10sICEhb2JqLmFub255bW91cyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGBgdHJ1ZWBgIGFuZCBwcm92aWRlcyBhIHR5cGUgZ3VhcmQgaWYgJSV2YWx1ZSUlIGlzIGFuXG4gICAgICogICoqRXZlbnRGcmFnbWVudCoqLlxuICAgICAqL1xuICAgIHN0YXRpYyBpc0ZyYWdtZW50KHZhbHVlKSB7XG4gICAgICAgIHJldHVybiAodmFsdWUgJiYgdmFsdWVbaW50ZXJuYWxdID09PSBFdmVudEZyYWdtZW50SW50ZXJuYWwpO1xuICAgIH1cbn1cbi8qKlxuICogIEEgRnJhZ21lbnQgd2hpY2ggcmVwcmVzZW50cyBhIGNvbnN0cnVjdG9yLlxuICovXG5leHBvcnQgY2xhc3MgQ29uc3RydWN0b3JGcmFnbWVudCBleHRlbmRzIEZyYWdtZW50IHtcbiAgICAvKipcbiAgICAgKiAgV2hldGhlciB0aGUgY29uc3RydWN0b3IgY2FuIHJlY2VpdmUgYW4gZW5kb3dtZW50LlxuICAgICAqL1xuICAgIHBheWFibGU7XG4gICAgLyoqXG4gICAgICogIFRoZSByZWNvbW1lbmRlZCBnYXMgbGltaXQgZm9yIGRlcGxveW1lbnQgb3IgYGBudWxsYGAuXG4gICAgICovXG4gICAgZ2FzO1xuICAgIC8qKlxuICAgICAqICBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGd1YXJkLCB0eXBlLCBpbnB1dHMsIHBheWFibGUsIGdhcykge1xuICAgICAgICBzdXBlcihndWFyZCwgdHlwZSwgaW5wdXRzKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIGludGVybmFsLCB7IHZhbHVlOiBDb25zdHJ1Y3RvckZyYWdtZW50SW50ZXJuYWwgfSk7XG4gICAgICAgIGRlZmluZVByb3BlcnRpZXModGhpcywgeyBwYXlhYmxlLCBnYXMgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgY29uc3RydWN0b3IgYXMgJSVmb3JtYXQlJS5cbiAgICAgKi9cbiAgICBmb3JtYXQoZm9ybWF0KSB7XG4gICAgICAgIGFzc2VydChmb3JtYXQgIT0gbnVsbCAmJiBmb3JtYXQgIT09IFwic2lnaGFzaFwiLCBcImNhbm5vdCBmb3JtYXQgYSBjb25zdHJ1Y3RvciBmb3Igc2lnaGFzaFwiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7IG9wZXJhdGlvbjogXCJmb3JtYXQoc2lnaGFzaClcIiB9KTtcbiAgICAgICAgaWYgKGZvcm1hdCA9PT0gXCJqc29uXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJjb25zdHJ1Y3RvclwiLFxuICAgICAgICAgICAgICAgIHN0YXRlTXV0YWJpbGl0eTogKHRoaXMucGF5YWJsZSA/IFwicGF5YWJsZVwiIDogXCJ1bmRlZmluZWRcIiksXG4gICAgICAgICAgICAgICAgcGF5YWJsZTogdGhpcy5wYXlhYmxlLFxuICAgICAgICAgICAgICAgIGdhczogKCh0aGlzLmdhcyAhPSBudWxsKSA/IHRoaXMuZ2FzIDogdW5kZWZpbmVkKSxcbiAgICAgICAgICAgICAgICBpbnB1dHM6IHRoaXMuaW5wdXRzLm1hcCgoaSkgPT4gSlNPTi5wYXJzZShpLmZvcm1hdChmb3JtYXQpKSlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IFtgY29uc3RydWN0b3Ike2pvaW5QYXJhbXMoZm9ybWF0LCB0aGlzLmlucHV0cyl9YF07XG4gICAgICAgIGlmICh0aGlzLnBheWFibGUpIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKFwicGF5YWJsZVwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5nYXMgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goYEAke3RoaXMuZ2FzLnRvU3RyaW5nKCl9YCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdC5qb2luKFwiIFwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYSBuZXcgKipDb25zdHJ1Y3RvckZyYWdtZW50KiogZm9yICUlb2JqJSUuXG4gICAgICovXG4gICAgc3RhdGljIGZyb20ob2JqKSB7XG4gICAgICAgIGlmIChDb25zdHJ1Y3RvckZyYWdtZW50LmlzRnJhZ21lbnQob2JqKSkge1xuICAgICAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIChvYmopID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiBDb25zdHJ1Y3RvckZyYWdtZW50LmZyb20obGV4KG9iaikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoZmFsc2UsIFwiaW52YWxpZCBjb25zdHVjdG9yIGZyYWdtZW50XCIsIFwib2JqXCIsIG9iaik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob2JqIGluc3RhbmNlb2YgVG9rZW5TdHJpbmcpIHtcbiAgICAgICAgICAgIGNvbnN1bWVLZXl3b3JkcyhvYmosIHNldGlmeShbXCJjb25zdHJ1Y3RvclwiXSkpO1xuICAgICAgICAgICAgY29uc3QgaW5wdXRzID0gY29uc3VtZVBhcmFtcyhvYmopO1xuICAgICAgICAgICAgY29uc3QgcGF5YWJsZSA9ICEhY29uc3VtZUtleXdvcmRzKG9iaiwgS3dWaXNpYkRlcGxveSkuaGFzKFwicGF5YWJsZVwiKTtcbiAgICAgICAgICAgIGNvbnN0IGdhcyA9IGNvbnN1bWVHYXMob2JqKTtcbiAgICAgICAgICAgIGNvbnN1bWVFb2kob2JqKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQ29uc3RydWN0b3JGcmFnbWVudChfZ3VhcmQsIFwiY29uc3RydWN0b3JcIiwgaW5wdXRzLCBwYXlhYmxlLCBnYXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgQ29uc3RydWN0b3JGcmFnbWVudChfZ3VhcmQsIFwiY29uc3RydWN0b3JcIiwgb2JqLmlucHV0cyA/IG9iai5pbnB1dHMubWFwKFBhcmFtVHlwZS5mcm9tKSA6IFtdLCAhIW9iai5wYXlhYmxlLCAob2JqLmdhcyAhPSBudWxsKSA/IG9iai5nYXMgOiBudWxsKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYGB0cnVlYGAgYW5kIHByb3ZpZGVzIGEgdHlwZSBndWFyZCBpZiAlJXZhbHVlJSUgaXMgYVxuICAgICAqICAqKkNvbnN0cnVjdG9yRnJhZ21lbnQqKi5cbiAgICAgKi9cbiAgICBzdGF0aWMgaXNGcmFnbWVudCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gKHZhbHVlICYmIHZhbHVlW2ludGVybmFsXSA9PT0gQ29uc3RydWN0b3JGcmFnbWVudEludGVybmFsKTtcbiAgICB9XG59XG4vKipcbiAqICBBIEZyYWdtZW50IHdoaWNoIHJlcHJlc2VudHMgYSBtZXRob2QuXG4gKi9cbmV4cG9ydCBjbGFzcyBGYWxsYmFja0ZyYWdtZW50IGV4dGVuZHMgRnJhZ21lbnQge1xuICAgIC8qKlxuICAgICAqICBJZiB0aGUgZnVuY3Rpb24gY2FuIGJlIHNlbnQgdmFsdWUgZHVyaW5nIGludm9jYXRpb24uXG4gICAgICovXG4gICAgcGF5YWJsZTtcbiAgICBjb25zdHJ1Y3RvcihndWFyZCwgaW5wdXRzLCBwYXlhYmxlKSB7XG4gICAgICAgIHN1cGVyKGd1YXJkLCBcImZhbGxiYWNrXCIsIGlucHV0cyk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBpbnRlcm5hbCwgeyB2YWx1ZTogRmFsbGJhY2tGcmFnbWVudEludGVybmFsIH0pO1xuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHsgcGF5YWJsZSB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBmYWxsYmFjayBhcyAlJWZvcm1hdCUlLlxuICAgICAqL1xuICAgIGZvcm1hdChmb3JtYXQpIHtcbiAgICAgICAgY29uc3QgdHlwZSA9ICgodGhpcy5pbnB1dHMubGVuZ3RoID09PSAwKSA/IFwicmVjZWl2ZVwiIDogXCJmYWxsYmFja1wiKTtcbiAgICAgICAgaWYgKGZvcm1hdCA9PT0gXCJqc29uXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IHN0YXRlTXV0YWJpbGl0eSA9ICh0aGlzLnBheWFibGUgPyBcInBheWFibGVcIiA6IFwibm9ucGF5YWJsZVwiKTtcbiAgICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh7IHR5cGUsIHN0YXRlTXV0YWJpbGl0eSB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYCR7dHlwZX0oKSR7dGhpcy5wYXlhYmxlID8gXCIgcGF5YWJsZVwiIDogXCJcIn1gO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBhIG5ldyAqKkZhbGxiYWNrRnJhZ21lbnQqKiBmb3IgJSVvYmolJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbShvYmopIHtcbiAgICAgICAgaWYgKEZhbGxiYWNrRnJhZ21lbnQuaXNGcmFnbWVudChvYmopKSB7XG4gICAgICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgKG9iaikgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEZhbGxiYWNrRnJhZ21lbnQuZnJvbShsZXgob2JqKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBhc3NlcnRBcmd1bWVudChmYWxzZSwgXCJpbnZhbGlkIGZhbGxiYWNrIGZyYWdtZW50XCIsIFwib2JqXCIsIG9iaik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob2JqIGluc3RhbmNlb2YgVG9rZW5TdHJpbmcpIHtcbiAgICAgICAgICAgIGNvbnN0IGVycm9yT2JqID0gb2JqLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICBjb25zdCB0b3BJc1ZhbGlkID0gb2JqLnBlZWtLZXl3b3JkKHNldGlmeShbXCJmYWxsYmFja1wiLCBcInJlY2VpdmVcIl0pKTtcbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KHRvcElzVmFsaWQsIFwidHlwZSBtdXN0IGJlIGZhbGxiYWNrIG9yIHJlY2VpdmVcIiwgXCJvYmpcIiwgZXJyb3JPYmopO1xuICAgICAgICAgICAgY29uc3QgdHlwZSA9IG9iai5wb3BLZXl3b3JkKHNldGlmeShbXCJmYWxsYmFja1wiLCBcInJlY2VpdmVcIl0pKTtcbiAgICAgICAgICAgIC8vIHJlY2VpdmUoKVxuICAgICAgICAgICAgaWYgKHR5cGUgPT09IFwicmVjZWl2ZVwiKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaW5wdXRzID0gY29uc3VtZVBhcmFtcyhvYmopO1xuICAgICAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KGlucHV0cy5sZW5ndGggPT09IDAsIGByZWNlaXZlIGNhbm5vdCBoYXZlIGFyZ3VtZW50c2AsIFwib2JqLmlucHV0c1wiLCBpbnB1dHMpO1xuICAgICAgICAgICAgICAgIGNvbnN1bWVLZXl3b3JkcyhvYmosIHNldGlmeShbXCJwYXlhYmxlXCJdKSk7XG4gICAgICAgICAgICAgICAgY29uc3VtZUVvaShvYmopO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRmFsbGJhY2tGcmFnbWVudChfZ3VhcmQsIFtdLCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGZhbGxiYWNrKCkgW3BheWFibGVdXG4gICAgICAgICAgICAvLyBmYWxsYmFjayhieXRlcykgW3BheWFibGVdIHJldHVybnMgKGJ5dGVzKVxuICAgICAgICAgICAgbGV0IGlucHV0cyA9IGNvbnN1bWVQYXJhbXMob2JqKTtcbiAgICAgICAgICAgIGlmIChpbnB1dHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoaW5wdXRzLmxlbmd0aCA9PT0gMSAmJiBpbnB1dHNbMF0udHlwZSA9PT0gXCJieXRlc1wiLCBcImludmFsaWQgZmFsbGJhY2sgaW5wdXRzXCIsIFwib2JqLmlucHV0c1wiLCBpbnB1dHMubWFwKChpKSA9PiBpLmZvcm1hdChcIm1pbmltYWxcIikpLmpvaW4oXCIsIFwiKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpbnB1dHMgPSBbUGFyYW1UeXBlLmZyb20oXCJieXRlc1wiKV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBtdXRhYmlsaXR5ID0gY29uc3VtZU11dGFiaWxpdHkob2JqKTtcbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KG11dGFiaWxpdHkgPT09IFwibm9ucGF5YWJsZVwiIHx8IG11dGFiaWxpdHkgPT09IFwicGF5YWJsZVwiLCBcImZhbGxiYWNrIGNhbm5vdCBiZSBjb25zdGFudHNcIiwgXCJvYmouc3RhdGVNdXRhYmlsaXR5XCIsIG11dGFiaWxpdHkpO1xuICAgICAgICAgICAgaWYgKGNvbnN1bWVLZXl3b3JkcyhvYmosIHNldGlmeShbXCJyZXR1cm5zXCJdKSkuaGFzKFwicmV0dXJuc1wiKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG91dHB1dHMgPSBjb25zdW1lUGFyYW1zKG9iaik7XG4gICAgICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQob3V0cHV0cy5sZW5ndGggPT09IDEgJiYgb3V0cHV0c1swXS50eXBlID09PSBcImJ5dGVzXCIsIFwiaW52YWxpZCBmYWxsYmFjayBvdXRwdXRzXCIsIFwib2JqLm91dHB1dHNcIiwgb3V0cHV0cy5tYXAoKGkpID0+IGkuZm9ybWF0KFwibWluaW1hbFwiKSkuam9pbihcIiwgXCIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN1bWVFb2kob2JqKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRmFsbGJhY2tGcmFnbWVudChfZ3VhcmQsIGlucHV0cywgbXV0YWJpbGl0eSA9PT0gXCJwYXlhYmxlXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvYmoudHlwZSA9PT0gXCJyZWNlaXZlXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRmFsbGJhY2tGcmFnbWVudChfZ3VhcmQsIFtdLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob2JqLnR5cGUgPT09IFwiZmFsbGJhY2tcIikge1xuICAgICAgICAgICAgY29uc3QgaW5wdXRzID0gW1BhcmFtVHlwZS5mcm9tKFwiYnl0ZXNcIildO1xuICAgICAgICAgICAgY29uc3QgcGF5YWJsZSA9IChvYmouc3RhdGVNdXRhYmlsaXR5ID09PSBcInBheWFibGVcIik7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEZhbGxiYWNrRnJhZ21lbnQoX2d1YXJkLCBpbnB1dHMsIHBheWFibGUpO1xuICAgICAgICB9XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KGZhbHNlLCBcImludmFsaWQgZmFsbGJhY2sgZGVzY3JpcHRpb25cIiwgXCJvYmpcIiwgb2JqKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYGB0cnVlYGAgYW5kIHByb3ZpZGVzIGEgdHlwZSBndWFyZCBpZiAlJXZhbHVlJSUgaXMgYVxuICAgICAqICAqKkZhbGxiYWNrRnJhZ21lbnQqKi5cbiAgICAgKi9cbiAgICBzdGF0aWMgaXNGcmFnbWVudCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gKHZhbHVlICYmIHZhbHVlW2ludGVybmFsXSA9PT0gRmFsbGJhY2tGcmFnbWVudEludGVybmFsKTtcbiAgICB9XG59XG4vKipcbiAqICBBIEZyYWdtZW50IHdoaWNoIHJlcHJlc2VudHMgYSBtZXRob2QuXG4gKi9cbmV4cG9ydCBjbGFzcyBGdW5jdGlvbkZyYWdtZW50IGV4dGVuZHMgTmFtZWRGcmFnbWVudCB7XG4gICAgLyoqXG4gICAgICogIElmIHRoZSBmdW5jdGlvbiBpcyBjb25zdGFudCAoZS5nLiBgYHB1cmVgYCBvciBgYHZpZXdgYCBmdW5jdGlvbnMpLlxuICAgICAqL1xuICAgIGNvbnN0YW50O1xuICAgIC8qKlxuICAgICAqICBUaGUgcmV0dXJuZWQgdHlwZXMgZm9yIHRoZSByZXN1bHQgb2YgY2FsbGluZyB0aGlzIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIG91dHB1dHM7XG4gICAgLyoqXG4gICAgICogIFRoZSBzdGF0ZSBtdXRhYmlsaXR5IChlLmcuIGBgcGF5YWJsZWBgLCBgYG5vbnBheWFibGVgYCwgYGB2aWV3YGBcbiAgICAgKiAgb3IgYGBwdXJlYGApXG4gICAgICovXG4gICAgc3RhdGVNdXRhYmlsaXR5O1xuICAgIC8qKlxuICAgICAqICBJZiB0aGUgZnVuY3Rpb24gY2FuIGJlIHNlbnQgdmFsdWUgZHVyaW5nIGludm9jYXRpb24uXG4gICAgICovXG4gICAgcGF5YWJsZTtcbiAgICAvKipcbiAgICAgKiAgVGhlIHJlY29tbWVuZGVkIGdhcyBsaW1pdCB0byBzZW5kIHdoZW4gY2FsbGluZyB0aGlzIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGdhcztcbiAgICAvKipcbiAgICAgKiAgQHByaXZhdGVcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihndWFyZCwgbmFtZSwgc3RhdGVNdXRhYmlsaXR5LCBpbnB1dHMsIG91dHB1dHMsIGdhcykge1xuICAgICAgICBzdXBlcihndWFyZCwgXCJmdW5jdGlvblwiLCBuYW1lLCBpbnB1dHMpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgaW50ZXJuYWwsIHsgdmFsdWU6IEZ1bmN0aW9uRnJhZ21lbnRJbnRlcm5hbCB9KTtcbiAgICAgICAgb3V0cHV0cyA9IE9iamVjdC5mcmVlemUob3V0cHV0cy5zbGljZSgpKTtcbiAgICAgICAgY29uc3QgY29uc3RhbnQgPSAoc3RhdGVNdXRhYmlsaXR5ID09PSBcInZpZXdcIiB8fCBzdGF0ZU11dGFiaWxpdHkgPT09IFwicHVyZVwiKTtcbiAgICAgICAgY29uc3QgcGF5YWJsZSA9IChzdGF0ZU11dGFiaWxpdHkgPT09IFwicGF5YWJsZVwiKTtcbiAgICAgICAgZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7IGNvbnN0YW50LCBnYXMsIG91dHB1dHMsIHBheWFibGUsIHN0YXRlTXV0YWJpbGl0eSB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRoZSBGdW5jdGlvbiBzZWxlY3Rvci5cbiAgICAgKi9cbiAgICBnZXQgc2VsZWN0b3IoKSB7XG4gICAgICAgIHJldHVybiBpZCh0aGlzLmZvcm1hdChcInNpZ2hhc2hcIikpLnN1YnN0cmluZygwLCAxMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgZnVuY3Rpb24gYXMgJSVmb3JtYXQlJS5cbiAgICAgKi9cbiAgICBmb3JtYXQoZm9ybWF0KSB7XG4gICAgICAgIGlmIChmb3JtYXQgPT0gbnVsbCkge1xuICAgICAgICAgICAgZm9ybWF0ID0gXCJzaWdoYXNoXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZvcm1hdCA9PT0gXCJqc29uXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJmdW5jdGlvblwiLFxuICAgICAgICAgICAgICAgIG5hbWU6IHRoaXMubmFtZSxcbiAgICAgICAgICAgICAgICBjb25zdGFudDogdGhpcy5jb25zdGFudCxcbiAgICAgICAgICAgICAgICBzdGF0ZU11dGFiaWxpdHk6ICgodGhpcy5zdGF0ZU11dGFiaWxpdHkgIT09IFwibm9ucGF5YWJsZVwiKSA/IHRoaXMuc3RhdGVNdXRhYmlsaXR5IDogdW5kZWZpbmVkKSxcbiAgICAgICAgICAgICAgICBwYXlhYmxlOiB0aGlzLnBheWFibGUsXG4gICAgICAgICAgICAgICAgZ2FzOiAoKHRoaXMuZ2FzICE9IG51bGwpID8gdGhpcy5nYXMgOiB1bmRlZmluZWQpLFxuICAgICAgICAgICAgICAgIGlucHV0czogdGhpcy5pbnB1dHMubWFwKChpKSA9PiBKU09OLnBhcnNlKGkuZm9ybWF0KGZvcm1hdCkpKSxcbiAgICAgICAgICAgICAgICBvdXRwdXRzOiB0aGlzLm91dHB1dHMubWFwKChvKSA9PiBKU09OLnBhcnNlKG8uZm9ybWF0KGZvcm1hdCkpKSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgICAgICBpZiAoZm9ybWF0ICE9PSBcInNpZ2hhc2hcIikge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goXCJmdW5jdGlvblwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQucHVzaCh0aGlzLm5hbWUgKyBqb2luUGFyYW1zKGZvcm1hdCwgdGhpcy5pbnB1dHMpKTtcbiAgICAgICAgaWYgKGZvcm1hdCAhPT0gXCJzaWdoYXNoXCIpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnN0YXRlTXV0YWJpbGl0eSAhPT0gXCJub25wYXlhYmxlXCIpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh0aGlzLnN0YXRlTXV0YWJpbGl0eSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5vdXRwdXRzICYmIHRoaXMub3V0cHV0cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChcInJldHVybnNcIik7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goam9pblBhcmFtcyhmb3JtYXQsIHRoaXMub3V0cHV0cykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuZ2FzICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChgQCR7dGhpcy5nYXMudG9TdHJpbmcoKX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0LmpvaW4oXCIgXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIHRoZSBzZWxlY3RvciBmb3IgYSBmdW5jdGlvbiB3aXRoICUlbmFtZSUlIGFuZCAlJXBhcmFtcyUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBnZXRTZWxlY3RvcihuYW1lLCBwYXJhbXMpIHtcbiAgICAgICAgcGFyYW1zID0gKHBhcmFtcyB8fCBbXSkubWFwKChwKSA9PiBQYXJhbVR5cGUuZnJvbShwKSk7XG4gICAgICAgIGNvbnN0IGZyYWdtZW50ID0gbmV3IEZ1bmN0aW9uRnJhZ21lbnQoX2d1YXJkLCBuYW1lLCBcInZpZXdcIiwgcGFyYW1zLCBbXSwgbnVsbCk7XG4gICAgICAgIHJldHVybiBmcmFnbWVudC5zZWxlY3RvcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYSBuZXcgKipGdW5jdGlvbkZyYWdtZW50KiogZm9yICUlb2JqJSUuXG4gICAgICovXG4gICAgc3RhdGljIGZyb20ob2JqKSB7XG4gICAgICAgIGlmIChGdW5jdGlvbkZyYWdtZW50LmlzRnJhZ21lbnQob2JqKSkge1xuICAgICAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIChvYmopID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiBGdW5jdGlvbkZyYWdtZW50LmZyb20obGV4KG9iaikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoZmFsc2UsIFwiaW52YWxpZCBmdW5jdGlvbiBmcmFnbWVudFwiLCBcIm9ialwiLCBvYmopO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG9iaiBpbnN0YW5jZW9mIFRva2VuU3RyaW5nKSB7XG4gICAgICAgICAgICBjb25zdCBuYW1lID0gY29uc3VtZU5hbWUoXCJmdW5jdGlvblwiLCBvYmopO1xuICAgICAgICAgICAgY29uc3QgaW5wdXRzID0gY29uc3VtZVBhcmFtcyhvYmopO1xuICAgICAgICAgICAgY29uc3QgbXV0YWJpbGl0eSA9IGNvbnN1bWVNdXRhYmlsaXR5KG9iaik7XG4gICAgICAgICAgICBsZXQgb3V0cHV0cyA9IFtdO1xuICAgICAgICAgICAgaWYgKGNvbnN1bWVLZXl3b3JkcyhvYmosIHNldGlmeShbXCJyZXR1cm5zXCJdKSkuaGFzKFwicmV0dXJuc1wiKSkge1xuICAgICAgICAgICAgICAgIG91dHB1dHMgPSBjb25zdW1lUGFyYW1zKG9iaik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBnYXMgPSBjb25zdW1lR2FzKG9iaik7XG4gICAgICAgICAgICBjb25zdW1lRW9pKG9iaik7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEZ1bmN0aW9uRnJhZ21lbnQoX2d1YXJkLCBuYW1lLCBtdXRhYmlsaXR5LCBpbnB1dHMsIG91dHB1dHMsIGdhcyk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHN0YXRlTXV0YWJpbGl0eSA9IG9iai5zdGF0ZU11dGFiaWxpdHk7XG4gICAgICAgIC8vIFVzZSBsZWdhY3kgU29saWRpdHkgQUJJIGxvZ2ljIGlmIHN0YXRlTXV0YWJpbGl0eSBpcyBtaXNzaW5nXG4gICAgICAgIGlmIChzdGF0ZU11dGFiaWxpdHkgPT0gbnVsbCkge1xuICAgICAgICAgICAgc3RhdGVNdXRhYmlsaXR5ID0gXCJwYXlhYmxlXCI7XG4gICAgICAgICAgICBpZiAodHlwZW9mIChvYmouY29uc3RhbnQpID09PSBcImJvb2xlYW5cIikge1xuICAgICAgICAgICAgICAgIHN0YXRlTXV0YWJpbGl0eSA9IFwidmlld1wiO1xuICAgICAgICAgICAgICAgIGlmICghb2JqLmNvbnN0YW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlTXV0YWJpbGl0eSA9IFwicGF5YWJsZVwiO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIChvYmoucGF5YWJsZSkgPT09IFwiYm9vbGVhblwiICYmICFvYmoucGF5YWJsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGVNdXRhYmlsaXR5ID0gXCJub25wYXlhYmxlXCI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgKG9iai5wYXlhYmxlKSA9PT0gXCJib29sZWFuXCIgJiYgIW9iai5wYXlhYmxlKSB7XG4gICAgICAgICAgICAgICAgc3RhdGVNdXRhYmlsaXR5ID0gXCJub25wYXlhYmxlXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gQFRPRE86IHZlcmlmeVN0YXRlIGZvciBzdGF0ZU11dGFiaWxpdHkgKGUuZy4gdGhyb3cgaWZcbiAgICAgICAgLy8gICAgICAgIHBheWFibGU6IGZhbHNlIGJ1dCBzdGF0ZU11dGFiaWxpdHkgaXMgXCJub25wYXlhYmxlXCIpXG4gICAgICAgIHJldHVybiBuZXcgRnVuY3Rpb25GcmFnbWVudChfZ3VhcmQsIG9iai5uYW1lLCBzdGF0ZU11dGFiaWxpdHksIG9iai5pbnB1dHMgPyBvYmouaW5wdXRzLm1hcChQYXJhbVR5cGUuZnJvbSkgOiBbXSwgb2JqLm91dHB1dHMgPyBvYmoub3V0cHV0cy5tYXAoUGFyYW1UeXBlLmZyb20pIDogW10sIChvYmouZ2FzICE9IG51bGwpID8gb2JqLmdhcyA6IG51bGwpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBgYHRydWVgYCBhbmQgcHJvdmlkZXMgYSB0eXBlIGd1YXJkIGlmICUldmFsdWUlJSBpcyBhXG4gICAgICogICoqRnVuY3Rpb25GcmFnbWVudCoqLlxuICAgICAqL1xuICAgIHN0YXRpYyBpc0ZyYWdtZW50KHZhbHVlKSB7XG4gICAgICAgIHJldHVybiAodmFsdWUgJiYgdmFsdWVbaW50ZXJuYWxdID09PSBGdW5jdGlvbkZyYWdtZW50SW50ZXJuYWwpO1xuICAgIH1cbn1cbi8qKlxuICogIEEgRnJhZ21lbnQgd2hpY2ggcmVwcmVzZW50cyBhIHN0cnVjdHVyZS5cbiAqL1xuZXhwb3J0IGNsYXNzIFN0cnVjdEZyYWdtZW50IGV4dGVuZHMgTmFtZWRGcmFnbWVudCB7XG4gICAgLyoqXG4gICAgICogIEBwcml2YXRlXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoZ3VhcmQsIG5hbWUsIGlucHV0cykge1xuICAgICAgICBzdXBlcihndWFyZCwgXCJzdHJ1Y3RcIiwgbmFtZSwgaW5wdXRzKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIGludGVybmFsLCB7IHZhbHVlOiBTdHJ1Y3RGcmFnbWVudEludGVybmFsIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIHN0cnVjdCBhcyAlJWZvcm1hdCUlLlxuICAgICAqL1xuICAgIGZvcm1hdCgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQFRPRE9cIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGEgbmV3ICoqU3RydWN0RnJhZ21lbnQqKiBmb3IgJSVvYmolJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbShvYmopIHtcbiAgICAgICAgaWYgKHR5cGVvZiAob2JqKSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gU3RydWN0RnJhZ21lbnQuZnJvbShsZXgob2JqKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBhc3NlcnRBcmd1bWVudChmYWxzZSwgXCJpbnZhbGlkIHN0cnVjdCBmcmFnbWVudFwiLCBcIm9ialwiLCBvYmopO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG9iaiBpbnN0YW5jZW9mIFRva2VuU3RyaW5nKSB7XG4gICAgICAgICAgICBjb25zdCBuYW1lID0gY29uc3VtZU5hbWUoXCJzdHJ1Y3RcIiwgb2JqKTtcbiAgICAgICAgICAgIGNvbnN0IGlucHV0cyA9IGNvbnN1bWVQYXJhbXMob2JqKTtcbiAgICAgICAgICAgIGNvbnN1bWVFb2kob2JqKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgU3RydWN0RnJhZ21lbnQoX2d1YXJkLCBuYW1lLCBpbnB1dHMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgU3RydWN0RnJhZ21lbnQoX2d1YXJkLCBvYmoubmFtZSwgb2JqLmlucHV0cyA/IG9iai5pbnB1dHMubWFwKFBhcmFtVHlwZS5mcm9tKSA6IFtdKTtcbiAgICB9XG4gICAgLy8gQFRPRE86IGZpeCB0aGlzIHJldHVybiB0eXBlXG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYGB0cnVlYGAgYW5kIHByb3ZpZGVzIGEgdHlwZSBndWFyZCBpZiAlJXZhbHVlJSUgaXMgYVxuICAgICAqICAqKlN0cnVjdEZyYWdtZW50KiouXG4gICAgICovXG4gICAgc3RhdGljIGlzRnJhZ21lbnQodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuICh2YWx1ZSAmJiB2YWx1ZVtpbnRlcm5hbF0gPT09IFN0cnVjdEZyYWdtZW50SW50ZXJuYWwpO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZyYWdtZW50cy5qcy5tYXAiXSwibmFtZXMiOlsiZGVmaW5lUHJvcGVydGllcyIsImdldEJpZ0ludCIsImdldE51bWJlciIsImFzc2VydCIsImFzc2VydFByaXZhdGUiLCJhc3NlcnRBcmd1bWVudCIsImlkIiwic2V0aWZ5IiwiaXRlbXMiLCJyZXN1bHQiLCJTZXQiLCJmb3JFYWNoIiwiayIsImFkZCIsIk9iamVjdCIsImZyZWV6ZSIsIl9rd1Zpc2liRGVwbG95IiwiS3dWaXNpYkRlcGxveSIsInNwbGl0IiwiX2t3VmlzaWIiLCJLd1Zpc2liIiwiX2t3VHlwZXMiLCJLd1R5cGVzIiwiX2t3TW9kaWZpZXJzIiwiS3dNb2RpZmllcnMiLCJfa3dPdGhlciIsIl9rZXl3b3JkcyIsImpvaW4iLCJLZXl3b3JkcyIsIlNpbXBsZVRva2VucyIsInJlZ2V4V2hpdGVzcGFjZVByZWZpeCIsIlJlZ0V4cCIsInJlZ2V4TnVtYmVyUHJlZml4IiwicmVnZXhJZFByZWZpeCIsInJlZ2V4SWQiLCJyZWdleFR5cGUiLCJUb2tlblN0cmluZyIsIm9mZnNldCIsInRva2VucyIsImxlbmd0aCIsImNvbnN0cnVjdG9yIiwic2xpY2UiLCJjbG9uZSIsInJlc2V0Iiwic3ViVG9rZW5TdHJpbmciLCJmcm9tIiwidG8iLCJtYXAiLCJ0IiwiYXNzaWduIiwibWF0Y2giLCJsaW5rQmFjayIsImxpbmtOZXh0IiwicG9wS2V5d29yZCIsImFsbG93ZWQiLCJ0b3AiLCJwZWVrIiwidHlwZSIsImhhcyIsInRleHQiLCJFcnJvciIsInBvcCIsInBvcFR5cGUiLCJKU09OIiwic3RyaW5naWZ5IiwicG9wUGFyZW4iLCJwb3BQYXJhbXMiLCJsaW5rIiwicHVzaCIsInBlZWtLZXl3b3JkIiwicGVla1R5cGUiLCJ0b1N0cmluZyIsImkiLCJ0b2tlbiIsImxleCIsInRocm93RXJyb3IiLCJtZXNzYWdlIiwiYnJhY2tldHMiLCJjb21tYXMiLCJjdXIiLCJzdWJzdHJpbmciLCJkZXB0aCIsInZhbHVlIiwic3VmZml4IiwiYWxsb3dTaW5nbGUiLCJzZXQiLCJpbmNsdWRlZCIsImtleSIsImtleXMiLCJjb25zdW1lTmFtZSIsImtleXdvcmQiLCJjb25zdW1lS2V5d29yZHMiLCJrZXl3b3JkcyIsImNvbnN1bWVNdXRhYmlsaXR5IiwibW9kaWZpZXJzIiwiY29uc3VtZVBhcmFtcyIsImFsbG93SW5kZXhlZCIsIlBhcmFtVHlwZSIsImNvbnN1bWVHYXMiLCJjb25zdW1lRW9pIiwicmVnZXhBcnJheVR5cGUiLCJ2ZXJpZnlCYXNpY1R5cGUiLCJwYXJzZUludCIsInNpemUiLCJfZ3VhcmQiLCJpbnRlcm5hbCIsIlN5bWJvbCIsImZvciIsIlBhcmFtVHlwZUludGVybmFsIiwiRXJyb3JGcmFnbWVudEludGVybmFsIiwiRXZlbnRGcmFnbWVudEludGVybmFsIiwiQ29uc3RydWN0b3JGcmFnbWVudEludGVybmFsIiwiRmFsbGJhY2tGcmFnbWVudEludGVybmFsIiwiRnVuY3Rpb25GcmFnbWVudEludGVybmFsIiwiU3RydWN0RnJhZ21lbnRJbnRlcm5hbCIsImd1YXJkIiwibmFtZSIsImJhc2VUeXBlIiwiaW5kZXhlZCIsImNvbXBvbmVudHMiLCJhcnJheUxlbmd0aCIsImFycmF5Q2hpbGRyZW4iLCJkZWZpbmVQcm9wZXJ0eSIsImZvcm1hdCIsImlzQXJyYXkiLCJwYXJzZSIsIlN0cmluZyIsImlzVHVwbGUiLCJjIiwiY29tcCIsImlzSW5kZXhhYmxlIiwid2FsayIsInByb2Nlc3MiLCJBcnJheSIsIl90aGlzIiwidiIsIndhbGtBc3luYyIsInByb21pc2VzIiwic2V0VmFsdWUiLCJjaGlsZFR5cGUiLCJpbmRleCIsInBhcmFtIiwidGhlbiIsIlByb21pc2UiLCJhbGwiLCJvYmoiLCJpc1BhcmFtVHlwZSIsImVycm9yIiwiY29tcHMiLCJicmFja2V0IiwiYXJyYXlNYXRjaCIsInN0YXJ0c1dpdGgiLCJ0dXBsZSIsIkZyYWdtZW50IiwiaW5wdXRzIiwiZSIsIkNvbnN0cnVjdG9yRnJhZ21lbnQiLCJFcnJvckZyYWdtZW50IiwiRXZlbnRGcmFnbWVudCIsIkZhbGxiYWNrRnJhZ21lbnQiLCJGdW5jdGlvbkZyYWdtZW50IiwiU3RydWN0RnJhZ21lbnQiLCJvcGVyYXRpb24iLCJpc0NvbnN0cnVjdG9yIiwiaXNGcmFnbWVudCIsImlzRXJyb3IiLCJpc0V2ZW50IiwiaXNGdW5jdGlvbiIsImlzU3RydWN0IiwiTmFtZWRGcmFnbWVudCIsImpvaW5QYXJhbXMiLCJwYXJhbXMiLCJwIiwic2VsZWN0b3IiLCJpbnB1dCIsImFub255bW91cyIsInRvcGljSGFzaCIsImdldFRvcGljSGFzaCIsImZyYWdtZW50IiwicGF5YWJsZSIsImdhcyIsInN0YXRlTXV0YWJpbGl0eSIsInVuZGVmaW5lZCIsImVycm9yT2JqIiwidG9wSXNWYWxpZCIsIm11dGFiaWxpdHkiLCJvdXRwdXRzIiwiY29uc3RhbnQiLCJvIiwiZ2V0U2VsZWN0b3IiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.esm/abi/fragments.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.esm/abi/interface.js":
/*!******************************************************!*\
  !*** ./node_modules/ethers/lib.esm/abi/interface.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ErrorDescription: () => (/* binding */ ErrorDescription),\n/* harmony export */   Indexed: () => (/* binding */ Indexed),\n/* harmony export */   Interface: () => (/* binding */ Interface),\n/* harmony export */   LogDescription: () => (/* binding */ LogDescription),\n/* harmony export */   Result: () => (/* reexport safe */ _coders_abstract_coder_js__WEBPACK_IMPORTED_MODULE_0__.Result),\n/* harmony export */   TransactionDescription: () => (/* binding */ TransactionDescription),\n/* harmony export */   checkResultErrors: () => (/* reexport safe */ _coders_abstract_coder_js__WEBPACK_IMPORTED_MODULE_0__.checkResultErrors)\n/* harmony export */ });\n/* harmony import */ var _crypto_index_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../crypto/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/crypto/keccak.js\");\n/* harmony import */ var _hash_index_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../hash/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/hash/id.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/properties.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/errors.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/data.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/maths.js\");\n/* harmony import */ var _abi_coder_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./abi-coder.js */ \"(ssr)/./node_modules/ethers/lib.esm/abi/abi-coder.js\");\n/* harmony import */ var _coders_abstract_coder_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./coders/abstract-coder.js */ \"(ssr)/./node_modules/ethers/lib.esm/abi/coders/abstract-coder.js\");\n/* harmony import */ var _fragments_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./fragments.js */ \"(ssr)/./node_modules/ethers/lib.esm/abi/fragments.js\");\n/* harmony import */ var _typed_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./typed.js */ \"(ssr)/./node_modules/ethers/lib.esm/abi/typed.js\");\n/**\n *  The Interface class is a low-level class that accepts an\n *  ABI and provides all the necessary functionality to encode\n *  and decode paramaters to and results from methods, events\n *  and errors.\n *\n *  It also provides several convenience methods to automatically\n *  search and find matching transactions and events to parse them.\n *\n *  @_subsection api/abi:Interfaces  [interfaces]\n */ \n\n\n\n\n\n\n\n/**\n *  When using the [[Interface-parseLog]] to automatically match a Log to its event\n *  for parsing, a **LogDescription** is returned.\n */ class LogDescription {\n    /**\n     *  @_ignore:\n     */ constructor(fragment, topic, args){\n        const name = fragment.name, signature = fragment.format();\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.defineProperties)(this, {\n            fragment,\n            name,\n            signature,\n            topic,\n            args\n        });\n    }\n}\n/**\n *  When using the [[Interface-parseTransaction]] to automatically match\n *  a transaction data to its function for parsing,\n *  a **TransactionDescription** is returned.\n */ class TransactionDescription {\n    /**\n     *  @_ignore:\n     */ constructor(fragment, selector, args, value){\n        const name = fragment.name, signature = fragment.format();\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.defineProperties)(this, {\n            fragment,\n            name,\n            args,\n            signature,\n            selector,\n            value\n        });\n    }\n}\n/**\n *  When using the [[Interface-parseError]] to automatically match an\n *  error for a call result for parsing, an **ErrorDescription** is returned.\n */ class ErrorDescription {\n    /**\n     *  @_ignore:\n     */ constructor(fragment, selector, args){\n        const name = fragment.name, signature = fragment.format();\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.defineProperties)(this, {\n            fragment,\n            name,\n            args,\n            signature,\n            selector\n        });\n    }\n}\n/**\n *  An **Indexed** is used as a value when a value that does not\n *  fit within a topic (i.e. not a fixed-length, 32-byte type). It\n *  is the ``keccak256`` of the value, and used for types such as\n *  arrays, tuples, bytes and strings.\n */ class Indexed {\n    /**\n     *  Returns ``true`` if %%value%% is an **Indexed**.\n     *\n     *  This provides a Type Guard for property access.\n     */ static isIndexed(value) {\n        return !!(value && value._isIndexed);\n    }\n    /**\n     *  @_ignore:\n     */ constructor(hash){\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.defineProperties)(this, {\n            hash,\n            _isIndexed: true\n        });\n    }\n}\n// https://docs.soliditylang.org/en/v0.8.13/control-structures.html?highlight=panic#panic-via-assert-and-error-via-require\nconst PanicReasons = {\n    \"0\": \"generic panic\",\n    \"1\": \"assert(false)\",\n    \"17\": \"arithmetic overflow\",\n    \"18\": \"division or modulo by zero\",\n    \"33\": \"enum overflow\",\n    \"34\": \"invalid encoded storage byte array accessed\",\n    \"49\": \"out-of-bounds array access; popping on an empty array\",\n    \"50\": \"out-of-bounds access of an array or bytesN\",\n    \"65\": \"out of memory\",\n    \"81\": \"uninitialized function\"\n};\nconst BuiltinErrors = {\n    \"0x08c379a0\": {\n        signature: \"Error(string)\",\n        name: \"Error\",\n        inputs: [\n            \"string\"\n        ],\n        reason: (message)=>{\n            return `reverted with reason string ${JSON.stringify(message)}`;\n        }\n    },\n    \"0x4e487b71\": {\n        signature: \"Panic(uint256)\",\n        name: \"Panic\",\n        inputs: [\n            \"uint256\"\n        ],\n        reason: (code)=>{\n            let reason = \"unknown panic code\";\n            if (code >= 0 && code <= 0xff && PanicReasons[code.toString()]) {\n                reason = PanicReasons[code.toString()];\n            }\n            return `reverted with panic code 0x${code.toString(16)} (${reason})`;\n        }\n    }\n};\n/**\n *  An Interface abstracts many of the low-level details for\n *  encoding and decoding the data on the blockchain.\n *\n *  An ABI provides information on how to encode data to send to\n *  a Contract, how to decode the results and events and how to\n *  interpret revert errors.\n *\n *  The ABI can be specified by [any supported format](InterfaceAbi).\n */ class Interface {\n    #errors;\n    #events;\n    #functions;\n    //    #structs: Map<string, StructFragment>;\n    #abiCoder;\n    /**\n     *  Create a new Interface for the %%fragments%%.\n     */ constructor(fragments){\n        let abi = [];\n        if (typeof fragments === \"string\") {\n            abi = JSON.parse(fragments);\n        } else {\n            abi = fragments;\n        }\n        this.#functions = new Map();\n        this.#errors = new Map();\n        this.#events = new Map();\n        //        this.#structs = new Map();\n        const frags = [];\n        for (const a of abi){\n            try {\n                frags.push(_fragments_js__WEBPACK_IMPORTED_MODULE_2__.Fragment.from(a));\n            } catch (error) {\n                console.log(`[Warning] Invalid Fragment ${JSON.stringify(a)}:`, error.message);\n            }\n        }\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.defineProperties)(this, {\n            fragments: Object.freeze(frags)\n        });\n        let fallback = null;\n        let receive = false;\n        this.#abiCoder = this.getAbiCoder();\n        // Add all fragments by their signature\n        this.fragments.forEach((fragment, index)=>{\n            let bucket;\n            switch(fragment.type){\n                case \"constructor\":\n                    if (this.deploy) {\n                        console.log(\"duplicate definition - constructor\");\n                        return;\n                    }\n                    //checkNames(fragment, \"input\", fragment.inputs);\n                    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.defineProperties)(this, {\n                        deploy: fragment\n                    });\n                    return;\n                case \"fallback\":\n                    if (fragment.inputs.length === 0) {\n                        receive = true;\n                    } else {\n                        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(!fallback || fragment.payable !== fallback.payable, \"conflicting fallback fragments\", `fragments[${index}]`, fragment);\n                        fallback = fragment;\n                        receive = fallback.payable;\n                    }\n                    return;\n                case \"function\":\n                    //checkNames(fragment, \"input\", fragment.inputs);\n                    //checkNames(fragment, \"output\", (<FunctionFragment>fragment).outputs);\n                    bucket = this.#functions;\n                    break;\n                case \"event\":\n                    //checkNames(fragment, \"input\", fragment.inputs);\n                    bucket = this.#events;\n                    break;\n                case \"error\":\n                    bucket = this.#errors;\n                    break;\n                default:\n                    return;\n            }\n            // Two identical entries; ignore it\n            const signature = fragment.format();\n            if (bucket.has(signature)) {\n                return;\n            }\n            bucket.set(signature, fragment);\n        });\n        // If we do not have a constructor add a default\n        if (!this.deploy) {\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.defineProperties)(this, {\n                deploy: _fragments_js__WEBPACK_IMPORTED_MODULE_2__.ConstructorFragment.from(\"constructor()\")\n            });\n        }\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.defineProperties)(this, {\n            fallback,\n            receive\n        });\n    }\n    /**\n     *  Returns the entire Human-Readable ABI, as an array of\n     *  signatures, optionally as %%minimal%% strings, which\n     *  removes parameter names and unneceesary spaces.\n     */ format(minimal) {\n        const format = minimal ? \"minimal\" : \"full\";\n        const abi = this.fragments.map((f)=>f.format(format));\n        return abi;\n    }\n    /**\n     *  Return the JSON-encoded ABI. This is the format Solidiy\n     *  returns.\n     */ formatJson() {\n        const abi = this.fragments.map((f)=>f.format(\"json\"));\n        // We need to re-bundle the JSON fragments a bit\n        return JSON.stringify(abi.map((j)=>JSON.parse(j)));\n    }\n    /**\n     *  The ABI coder that will be used to encode and decode binary\n     *  data.\n     */ getAbiCoder() {\n        return _abi_coder_js__WEBPACK_IMPORTED_MODULE_4__.AbiCoder.defaultAbiCoder();\n    }\n    // Find a function definition by any means necessary (unless it is ambiguous)\n    #getFunction(key, values, forceUnique) {\n        // Selector\n        if ((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.isHexString)(key)) {\n            const selector = key.toLowerCase();\n            for (const fragment of this.#functions.values()){\n                if (selector === fragment.selector) {\n                    return fragment;\n                }\n            }\n            return null;\n        }\n        // It is a bare name, look up the function (will return null if ambiguous)\n        if (key.indexOf(\"(\") === -1) {\n            const matching = [];\n            for (const [name, fragment] of this.#functions){\n                if (name.split(\"(\" /* fix:) */ )[0] === key) {\n                    matching.push(fragment);\n                }\n            }\n            if (values) {\n                const lastValue = values.length > 0 ? values[values.length - 1] : null;\n                let valueLength = values.length;\n                let allowOptions = true;\n                if (_typed_js__WEBPACK_IMPORTED_MODULE_6__.Typed.isTyped(lastValue) && lastValue.type === \"overrides\") {\n                    allowOptions = false;\n                    valueLength--;\n                }\n                // Remove all matches that don't have a compatible length. The args\n                // may contain an overrides, so the match may have n or n - 1 parameters\n                for(let i = matching.length - 1; i >= 0; i--){\n                    const inputs = matching[i].inputs.length;\n                    if (inputs !== valueLength && (!allowOptions || inputs !== valueLength - 1)) {\n                        matching.splice(i, 1);\n                    }\n                }\n                // Remove all matches that don't match the Typed signature\n                for(let i = matching.length - 1; i >= 0; i--){\n                    const inputs = matching[i].inputs;\n                    for(let j = 0; j < values.length; j++){\n                        // Not a typed value\n                        if (!_typed_js__WEBPACK_IMPORTED_MODULE_6__.Typed.isTyped(values[j])) {\n                            continue;\n                        }\n                        // We are past the inputs\n                        if (j >= inputs.length) {\n                            if (values[j].type === \"overrides\") {\n                                continue;\n                            }\n                            matching.splice(i, 1);\n                            break;\n                        }\n                        // Make sure the value type matches the input type\n                        if (values[j].type !== inputs[j].baseType) {\n                            matching.splice(i, 1);\n                            break;\n                        }\n                    }\n                }\n            }\n            // We found a single matching signature with an overrides, but the\n            // last value is something that cannot possibly be an options\n            if (matching.length === 1 && values && values.length !== matching[0].inputs.length) {\n                const lastArg = values[values.length - 1];\n                if (lastArg == null || Array.isArray(lastArg) || typeof lastArg !== \"object\") {\n                    matching.splice(0, 1);\n                }\n            }\n            if (matching.length === 0) {\n                return null;\n            }\n            if (matching.length > 1 && forceUnique) {\n                const matchStr = matching.map((m)=>JSON.stringify(m.format())).join(\", \");\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(false, `ambiguous function description (i.e. matches ${matchStr})`, \"key\", key);\n            }\n            return matching[0];\n        }\n        // Normalize the signature and lookup the function\n        const result = this.#functions.get(_fragments_js__WEBPACK_IMPORTED_MODULE_2__.FunctionFragment.from(key).format());\n        if (result) {\n            return result;\n        }\n        return null;\n    }\n    /**\n     *  Get the function name for %%key%%, which may be a function selector,\n     *  function name or function signature that belongs to the ABI.\n     */ getFunctionName(key) {\n        const fragment = this.#getFunction(key, null, false);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(fragment, \"no matching function\", \"key\", key);\n        return fragment.name;\n    }\n    /**\n     *  Returns true if %%key%% (a function selector, function name or\n     *  function signature) is present in the ABI.\n     *\n     *  In the case of a function name, the name may be ambiguous, so\n     *  accessing the [[FunctionFragment]] may require refinement.\n     */ hasFunction(key) {\n        return !!this.#getFunction(key, null, false);\n    }\n    /**\n     *  Get the [[FunctionFragment]] for %%key%%, which may be a function\n     *  selector, function name or function signature that belongs to the ABI.\n     *\n     *  If %%values%% is provided, it will use the Typed API to handle\n     *  ambiguous cases where multiple functions match by name.\n     *\n     *  If the %%key%% and %%values%% do not refine to a single function in\n     *  the ABI, this will throw.\n     */ getFunction(key, values) {\n        return this.#getFunction(key, values || null, true);\n    }\n    /**\n     *  Iterate over all functions, calling %%callback%%, sorted by their name.\n     */ forEachFunction(callback) {\n        const names = Array.from(this.#functions.keys());\n        names.sort((a, b)=>a.localeCompare(b));\n        for(let i = 0; i < names.length; i++){\n            const name = names[i];\n            callback(this.#functions.get(name), i);\n        }\n    }\n    // Find an event definition by any means necessary (unless it is ambiguous)\n    #getEvent(key, values, forceUnique) {\n        // EventTopic\n        if ((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.isHexString)(key)) {\n            const eventTopic = key.toLowerCase();\n            for (const fragment of this.#events.values()){\n                if (eventTopic === fragment.topicHash) {\n                    return fragment;\n                }\n            }\n            return null;\n        }\n        // It is a bare name, look up the function (will return null if ambiguous)\n        if (key.indexOf(\"(\") === -1) {\n            const matching = [];\n            for (const [name, fragment] of this.#events){\n                if (name.split(\"(\" /* fix:) */ )[0] === key) {\n                    matching.push(fragment);\n                }\n            }\n            if (values) {\n                // Remove all matches that don't have a compatible length.\n                for(let i = matching.length - 1; i >= 0; i--){\n                    if (matching[i].inputs.length < values.length) {\n                        matching.splice(i, 1);\n                    }\n                }\n                // Remove all matches that don't match the Typed signature\n                for(let i = matching.length - 1; i >= 0; i--){\n                    const inputs = matching[i].inputs;\n                    for(let j = 0; j < values.length; j++){\n                        // Not a typed value\n                        if (!_typed_js__WEBPACK_IMPORTED_MODULE_6__.Typed.isTyped(values[j])) {\n                            continue;\n                        }\n                        // Make sure the value type matches the input type\n                        if (values[j].type !== inputs[j].baseType) {\n                            matching.splice(i, 1);\n                            break;\n                        }\n                    }\n                }\n            }\n            if (matching.length === 0) {\n                return null;\n            }\n            if (matching.length > 1 && forceUnique) {\n                const matchStr = matching.map((m)=>JSON.stringify(m.format())).join(\", \");\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(false, `ambiguous event description (i.e. matches ${matchStr})`, \"key\", key);\n            }\n            return matching[0];\n        }\n        // Normalize the signature and lookup the function\n        const result = this.#events.get(_fragments_js__WEBPACK_IMPORTED_MODULE_2__.EventFragment.from(key).format());\n        if (result) {\n            return result;\n        }\n        return null;\n    }\n    /**\n     *  Get the event name for %%key%%, which may be a topic hash,\n     *  event name or event signature that belongs to the ABI.\n     */ getEventName(key) {\n        const fragment = this.#getEvent(key, null, false);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(fragment, \"no matching event\", \"key\", key);\n        return fragment.name;\n    }\n    /**\n     *  Returns true if %%key%% (an event topic hash, event name or\n     *  event signature) is present in the ABI.\n     *\n     *  In the case of an event name, the name may be ambiguous, so\n     *  accessing the [[EventFragment]] may require refinement.\n     */ hasEvent(key) {\n        return !!this.#getEvent(key, null, false);\n    }\n    /**\n     *  Get the [[EventFragment]] for %%key%%, which may be a topic hash,\n     *  event name or event signature that belongs to the ABI.\n     *\n     *  If %%values%% is provided, it will use the Typed API to handle\n     *  ambiguous cases where multiple events match by name.\n     *\n     *  If the %%key%% and %%values%% do not refine to a single event in\n     *  the ABI, this will throw.\n     */ getEvent(key, values) {\n        return this.#getEvent(key, values || null, true);\n    }\n    /**\n     *  Iterate over all events, calling %%callback%%, sorted by their name.\n     */ forEachEvent(callback) {\n        const names = Array.from(this.#events.keys());\n        names.sort((a, b)=>a.localeCompare(b));\n        for(let i = 0; i < names.length; i++){\n            const name = names[i];\n            callback(this.#events.get(name), i);\n        }\n    }\n    /**\n     *  Get the [[ErrorFragment]] for %%key%%, which may be an error\n     *  selector, error name or error signature that belongs to the ABI.\n     *\n     *  If %%values%% is provided, it will use the Typed API to handle\n     *  ambiguous cases where multiple errors match by name.\n     *\n     *  If the %%key%% and %%values%% do not refine to a single error in\n     *  the ABI, this will throw.\n     */ getError(key, values) {\n        if ((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.isHexString)(key)) {\n            const selector = key.toLowerCase();\n            if (BuiltinErrors[selector]) {\n                return _fragments_js__WEBPACK_IMPORTED_MODULE_2__.ErrorFragment.from(BuiltinErrors[selector].signature);\n            }\n            for (const fragment of this.#errors.values()){\n                if (selector === fragment.selector) {\n                    return fragment;\n                }\n            }\n            return null;\n        }\n        // It is a bare name, look up the function (will return null if ambiguous)\n        if (key.indexOf(\"(\") === -1) {\n            const matching = [];\n            for (const [name, fragment] of this.#errors){\n                if (name.split(\"(\" /* fix:) */ )[0] === key) {\n                    matching.push(fragment);\n                }\n            }\n            if (matching.length === 0) {\n                if (key === \"Error\") {\n                    return _fragments_js__WEBPACK_IMPORTED_MODULE_2__.ErrorFragment.from(\"error Error(string)\");\n                }\n                if (key === \"Panic\") {\n                    return _fragments_js__WEBPACK_IMPORTED_MODULE_2__.ErrorFragment.from(\"error Panic(uint256)\");\n                }\n                return null;\n            } else if (matching.length > 1) {\n                const matchStr = matching.map((m)=>JSON.stringify(m.format())).join(\", \");\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(false, `ambiguous error description (i.e. ${matchStr})`, \"name\", key);\n            }\n            return matching[0];\n        }\n        // Normalize the signature and lookup the function\n        key = _fragments_js__WEBPACK_IMPORTED_MODULE_2__.ErrorFragment.from(key).format();\n        if (key === \"Error(string)\") {\n            return _fragments_js__WEBPACK_IMPORTED_MODULE_2__.ErrorFragment.from(\"error Error(string)\");\n        }\n        if (key === \"Panic(uint256)\") {\n            return _fragments_js__WEBPACK_IMPORTED_MODULE_2__.ErrorFragment.from(\"error Panic(uint256)\");\n        }\n        const result = this.#errors.get(key);\n        if (result) {\n            return result;\n        }\n        return null;\n    }\n    /**\n     *  Iterate over all errors, calling %%callback%%, sorted by their name.\n     */ forEachError(callback) {\n        const names = Array.from(this.#errors.keys());\n        names.sort((a, b)=>a.localeCompare(b));\n        for(let i = 0; i < names.length; i++){\n            const name = names[i];\n            callback(this.#errors.get(name), i);\n        }\n    }\n    // Get the 4-byte selector used by Solidity to identify a function\n    /*\ngetSelector(fragment: ErrorFragment | FunctionFragment): string {\n    if (typeof(fragment) === \"string\") {\n        const matches: Array<Fragment> = [ ];\n\n        try { matches.push(this.getFunction(fragment)); } catch (error) { }\n        try { matches.push(this.getError(<string>fragment)); } catch (_) { }\n\n        if (matches.length === 0) {\n            logger.throwArgumentError(\"unknown fragment\", \"key\", fragment);\n        } else if (matches.length > 1) {\n            logger.throwArgumentError(\"ambiguous fragment matches function and error\", \"key\", fragment);\n        }\n\n        fragment = matches[0];\n    }\n\n    return dataSlice(id(fragment.format()), 0, 4);\n}\n    */ // Get the 32-byte topic hash used by Solidity to identify an event\n    /*\n    getEventTopic(fragment: EventFragment): string {\n        //if (typeof(fragment) === \"string\") { fragment = this.getEvent(eventFragment); }\n        return id(fragment.format());\n    }\n    */ _decodeParams(params, data) {\n        return this.#abiCoder.decode(params, data);\n    }\n    _encodeParams(params, values) {\n        return this.#abiCoder.encode(params, values);\n    }\n    /**\n     *  Encodes a ``tx.data`` object for deploying the Contract with\n     *  the %%values%% as the constructor arguments.\n     */ encodeDeploy(values) {\n        return this._encodeParams(this.deploy.inputs, values || []);\n    }\n    /**\n     *  Decodes the result %%data%% (e.g. from an ``eth_call``) for the\n     *  specified error (see [[getError]] for valid values for\n     *  %%key%%).\n     *\n     *  Most developers should prefer the [[parseCallResult]] method instead,\n     *  which will automatically detect a ``CALL_EXCEPTION`` and throw the\n     *  corresponding error.\n     */ decodeErrorResult(fragment, data) {\n        if (typeof fragment === \"string\") {\n            const f = this.getError(fragment);\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(f, \"unknown error\", \"fragment\", fragment);\n            fragment = f;\n        }\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.dataSlice)(data, 0, 4) === fragment.selector, `data signature does not match error ${fragment.name}.`, \"data\", data);\n        return this._decodeParams(fragment.inputs, (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.dataSlice)(data, 4));\n    }\n    /**\n     *  Encodes the transaction revert data for a call result that\n     *  reverted from the the Contract with the sepcified %%error%%\n     *  (see [[getError]] for valid values for %%fragment%%) with the %%values%%.\n     *\n     *  This is generally not used by most developers, unless trying to mock\n     *  a result from a Contract.\n     */ encodeErrorResult(fragment, values) {\n        if (typeof fragment === \"string\") {\n            const f = this.getError(fragment);\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(f, \"unknown error\", \"fragment\", fragment);\n            fragment = f;\n        }\n        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.concat)([\n            fragment.selector,\n            this._encodeParams(fragment.inputs, values || [])\n        ]);\n    }\n    /**\n     *  Decodes the %%data%% from a transaction ``tx.data`` for\n     *  the function specified (see [[getFunction]] for valid values\n     *  for %%fragment%%).\n     *\n     *  Most developers should prefer the [[parseTransaction]] method\n     *  instead, which will automatically detect the fragment.\n     */ decodeFunctionData(fragment, data) {\n        if (typeof fragment === \"string\") {\n            const f = this.getFunction(fragment);\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(f, \"unknown function\", \"fragment\", fragment);\n            fragment = f;\n        }\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.dataSlice)(data, 0, 4) === fragment.selector, `data signature does not match function ${fragment.name}.`, \"data\", data);\n        return this._decodeParams(fragment.inputs, (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.dataSlice)(data, 4));\n    }\n    /**\n     *  Encodes the ``tx.data`` for a transaction that calls the function\n     *  specified (see [[getFunction]] for valid values for %%fragment%%) with\n     *  the %%values%%.\n     */ encodeFunctionData(fragment, values) {\n        if (typeof fragment === \"string\") {\n            const f = this.getFunction(fragment);\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(f, \"unknown function\", \"fragment\", fragment);\n            fragment = f;\n        }\n        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.concat)([\n            fragment.selector,\n            this._encodeParams(fragment.inputs, values || [])\n        ]);\n    }\n    /**\n     *  Decodes the result %%data%% (e.g. from an ``eth_call``) for the\n     *  specified function (see [[getFunction]] for valid values for\n     *  %%key%%).\n     *\n     *  Most developers should prefer the [[parseCallResult]] method instead,\n     *  which will automatically detect a ``CALL_EXCEPTION`` and throw the\n     *  corresponding error.\n     */ decodeFunctionResult(fragment, data) {\n        if (typeof fragment === \"string\") {\n            const f = this.getFunction(fragment);\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(f, \"unknown function\", \"fragment\", fragment);\n            fragment = f;\n        }\n        let message = \"invalid length for result data\";\n        const bytes = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.getBytesCopy)(data);\n        if (bytes.length % 32 === 0) {\n            try {\n                return this.#abiCoder.decode(fragment.outputs, bytes);\n            } catch (error) {\n                message = \"could not decode result data\";\n            }\n        }\n        // Call returned data with no error, but the data is junk\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assert)(false, message, \"BAD_DATA\", {\n            value: (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.hexlify)(bytes),\n            info: {\n                method: fragment.name,\n                signature: fragment.format()\n            }\n        });\n    }\n    makeError(_data, tx) {\n        const data = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.getBytes)(_data, \"data\");\n        const error = _abi_coder_js__WEBPACK_IMPORTED_MODULE_4__.AbiCoder.getBuiltinCallException(\"call\", tx, data);\n        // Not a built-in error; try finding a custom error\n        const customPrefix = \"execution reverted (unknown custom error)\";\n        if (error.message.startsWith(customPrefix)) {\n            const selector = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.hexlify)(data.slice(0, 4));\n            const ef = this.getError(selector);\n            if (ef) {\n                try {\n                    const args = this.#abiCoder.decode(ef.inputs, data.slice(4));\n                    error.revert = {\n                        name: ef.name,\n                        signature: ef.format(),\n                        args\n                    };\n                    error.reason = error.revert.signature;\n                    error.message = `execution reverted: ${error.reason}`;\n                } catch (e) {\n                    error.message = `execution reverted (coult not decode custom error)`;\n                }\n            }\n        }\n        // Add the invocation, if available\n        const parsed = this.parseTransaction(tx);\n        if (parsed) {\n            error.invocation = {\n                method: parsed.name,\n                signature: parsed.signature,\n                args: parsed.args\n            };\n        }\n        return error;\n    }\n    /**\n     *  Encodes the result data (e.g. from an ``eth_call``) for the\n     *  specified function (see [[getFunction]] for valid values\n     *  for %%fragment%%) with %%values%%.\n     *\n     *  This is generally not used by most developers, unless trying to mock\n     *  a result from a Contract.\n     */ encodeFunctionResult(fragment, values) {\n        if (typeof fragment === \"string\") {\n            const f = this.getFunction(fragment);\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(f, \"unknown function\", \"fragment\", fragment);\n            fragment = f;\n        }\n        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.hexlify)(this.#abiCoder.encode(fragment.outputs, values || []));\n    }\n    /*\n        spelunk(inputs: Array<ParamType>, values: ReadonlyArray<any>, processfunc: (type: string, value: any) => Promise<any>): Promise<Array<any>> {\n            const promises: Array<Promise<>> = [ ];\n            const process = function(type: ParamType, value: any): any {\n                if (type.baseType === \"array\") {\n                    return descend(type.child\n                }\n                if (type. === \"address\") {\n                }\n            };\n    \n            const descend = function (inputs: Array<ParamType>, values: ReadonlyArray<any>) {\n                if (inputs.length !== values.length) { throw new Error(\"length mismatch\"); }\n                \n            };\n    \n            const result: Array<any> = [ ];\n            values.forEach((value, index) => {\n                if (value == null) {\n                    topics.push(null);\n                } else if (param.baseType === \"array\" || param.baseType === \"tuple\") {\n                    logger.throwArgumentError(\"filtering with tuples or arrays not supported\", (\"contract.\" + param.name), value);\n                } else if (Array.isArray(value)) {\n                    topics.push(value.map((value) => encodeTopic(param, value)));\n                } else {\n                    topics.push(encodeTopic(param, value));\n                }\n            });\n        }\n    */ // Create the filter for the event with search criteria (e.g. for eth_filterLog)\n    encodeFilterTopics(fragment, values) {\n        if (typeof fragment === \"string\") {\n            const f = this.getEvent(fragment);\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(f, \"unknown event\", \"eventFragment\", fragment);\n            fragment = f;\n        }\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assert)(values.length <= fragment.inputs.length, `too many arguments for ${fragment.format()}`, \"UNEXPECTED_ARGUMENT\", {\n            count: values.length,\n            expectedCount: fragment.inputs.length\n        });\n        const topics = [];\n        if (!fragment.anonymous) {\n            topics.push(fragment.topicHash);\n        }\n        // @TODO: Use the coders for this; to properly support tuples, etc.\n        const encodeTopic = (param, value)=>{\n            if (param.type === \"string\") {\n                return (0,_hash_index_js__WEBPACK_IMPORTED_MODULE_7__.id)(value);\n            } else if (param.type === \"bytes\") {\n                return (0,_crypto_index_js__WEBPACK_IMPORTED_MODULE_8__.keccak256)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.hexlify)(value));\n            }\n            if (param.type === \"bool\" && typeof value === \"boolean\") {\n                value = value ? \"0x01\" : \"0x00\";\n            } else if (param.type.match(/^u?int/)) {\n                value = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_9__.toBeHex)(value); // @TODO: Should this toTwos??\n            } else if (param.type.match(/^bytes/)) {\n                value = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.zeroPadBytes)(value, 32);\n            } else if (param.type === \"address\") {\n                // Check addresses are valid\n                this.#abiCoder.encode([\n                    \"address\"\n                ], [\n                    value\n                ]);\n            }\n            return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.zeroPadValue)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.hexlify)(value), 32);\n        };\n        values.forEach((value, index)=>{\n            const param = fragment.inputs[index];\n            if (!param.indexed) {\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(value == null, \"cannot filter non-indexed parameters; must be null\", \"contract.\" + param.name, value);\n                return;\n            }\n            if (value == null) {\n                topics.push(null);\n            } else if (param.baseType === \"array\" || param.baseType === \"tuple\") {\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(false, \"filtering with tuples or arrays not supported\", \"contract.\" + param.name, value);\n            } else if (Array.isArray(value)) {\n                topics.push(value.map((value)=>encodeTopic(param, value)));\n            } else {\n                topics.push(encodeTopic(param, value));\n            }\n        });\n        // Trim off trailing nulls\n        while(topics.length && topics[topics.length - 1] === null){\n            topics.pop();\n        }\n        return topics;\n    }\n    encodeEventLog(fragment, values) {\n        if (typeof fragment === \"string\") {\n            const f = this.getEvent(fragment);\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(f, \"unknown event\", \"eventFragment\", fragment);\n            fragment = f;\n        }\n        const topics = [];\n        const dataTypes = [];\n        const dataValues = [];\n        if (!fragment.anonymous) {\n            topics.push(fragment.topicHash);\n        }\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(values.length === fragment.inputs.length, \"event arguments/values mismatch\", \"values\", values);\n        fragment.inputs.forEach((param, index)=>{\n            const value = values[index];\n            if (param.indexed) {\n                if (param.type === \"string\") {\n                    topics.push((0,_hash_index_js__WEBPACK_IMPORTED_MODULE_7__.id)(value));\n                } else if (param.type === \"bytes\") {\n                    topics.push((0,_crypto_index_js__WEBPACK_IMPORTED_MODULE_8__.keccak256)(value));\n                } else if (param.baseType === \"tuple\" || param.baseType === \"array\") {\n                    // @TODO\n                    throw new Error(\"not implemented\");\n                } else {\n                    topics.push(this.#abiCoder.encode([\n                        param.type\n                    ], [\n                        value\n                    ]));\n                }\n            } else {\n                dataTypes.push(param);\n                dataValues.push(value);\n            }\n        });\n        return {\n            data: this.#abiCoder.encode(dataTypes, dataValues),\n            topics: topics\n        };\n    }\n    // Decode a filter for the event and the search criteria\n    decodeEventLog(fragment, data, topics) {\n        if (typeof fragment === \"string\") {\n            const f = this.getEvent(fragment);\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(f, \"unknown event\", \"eventFragment\", fragment);\n            fragment = f;\n        }\n        if (topics != null && !fragment.anonymous) {\n            const eventTopic = fragment.topicHash;\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.isHexString)(topics[0], 32) && topics[0].toLowerCase() === eventTopic, \"fragment/topic mismatch\", \"topics[0]\", topics[0]);\n            topics = topics.slice(1);\n        }\n        const indexed = [];\n        const nonIndexed = [];\n        const dynamic = [];\n        fragment.inputs.forEach((param, index)=>{\n            if (param.indexed) {\n                if (param.type === \"string\" || param.type === \"bytes\" || param.baseType === \"tuple\" || param.baseType === \"array\") {\n                    indexed.push(_fragments_js__WEBPACK_IMPORTED_MODULE_2__.ParamType.from({\n                        type: \"bytes32\",\n                        name: param.name\n                    }));\n                    dynamic.push(true);\n                } else {\n                    indexed.push(param);\n                    dynamic.push(false);\n                }\n            } else {\n                nonIndexed.push(param);\n                dynamic.push(false);\n            }\n        });\n        const resultIndexed = topics != null ? this.#abiCoder.decode(indexed, (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.concat)(topics)) : null;\n        const resultNonIndexed = this.#abiCoder.decode(nonIndexed, data, true);\n        //const result: (Array<any> & { [ key: string ]: any }) = [ ];\n        const values = [];\n        const keys = [];\n        let nonIndexedIndex = 0, indexedIndex = 0;\n        fragment.inputs.forEach((param, index)=>{\n            let value = null;\n            if (param.indexed) {\n                if (resultIndexed == null) {\n                    value = new Indexed(null);\n                } else if (dynamic[index]) {\n                    value = new Indexed(resultIndexed[indexedIndex++]);\n                } else {\n                    try {\n                        value = resultIndexed[indexedIndex++];\n                    } catch (error) {\n                        value = error;\n                    }\n                }\n            } else {\n                try {\n                    value = resultNonIndexed[nonIndexedIndex++];\n                } catch (error) {\n                    value = error;\n                }\n            }\n            values.push(value);\n            keys.push(param.name || null);\n        });\n        return _coders_abstract_coder_js__WEBPACK_IMPORTED_MODULE_0__.Result.fromItems(values, keys);\n    }\n    /**\n     *  Parses a transaction, finding the matching function and extracts\n     *  the parameter values along with other useful function details.\n     *\n     *  If the matching function cannot be found, return null.\n     */ parseTransaction(tx) {\n        const data = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.getBytes)(tx.data, \"tx.data\");\n        const value = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_9__.getBigInt)(tx.value != null ? tx.value : 0, \"tx.value\");\n        const fragment = this.getFunction((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.hexlify)(data.slice(0, 4)));\n        if (!fragment) {\n            return null;\n        }\n        const args = this.#abiCoder.decode(fragment.inputs, data.slice(4));\n        return new TransactionDescription(fragment, fragment.selector, args, value);\n    }\n    parseCallResult(data) {\n        throw new Error(\"@TODO\");\n    }\n    /**\n     *  Parses a receipt log, finding the matching event and extracts\n     *  the parameter values along with other useful event details.\n     *\n     *  If the matching event cannot be found, returns null.\n     */ parseLog(log) {\n        const fragment = this.getEvent(log.topics[0]);\n        if (!fragment || fragment.anonymous) {\n            return null;\n        }\n        // @TODO: If anonymous, and the only method, and the input count matches, should we parse?\n        //        Probably not, because just because it is the only event in the ABI does\n        //        not mean we have the full ABI; maybe just a fragment?\n        return new LogDescription(fragment, fragment.topicHash, this.decodeEventLog(fragment, log.data, log.topics));\n    }\n    /**\n     *  Parses a revert data, finding the matching error and extracts\n     *  the parameter values along with other useful error details.\n     *\n     *  If the matching error cannot be found, returns null.\n     */ parseError(data) {\n        const hexData = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.hexlify)(data);\n        const fragment = this.getError((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.dataSlice)(hexData, 0, 4));\n        if (!fragment) {\n            return null;\n        }\n        const args = this.#abiCoder.decode(fragment.inputs, (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.dataSlice)(hexData, 4));\n        return new ErrorDescription(fragment, fragment.selector, args);\n    }\n    /**\n     *  Creates a new [[Interface]] from the ABI %%value%%.\n     *\n     *  The %%value%% may be provided as an existing [[Interface]] object,\n     *  a JSON-encoded ABI or any Human-Readable ABI format.\n     */ static from(value) {\n        // Already an Interface, which is immutable\n        if (value instanceof Interface) {\n            return value;\n        }\n        // JSON\n        if (typeof value === \"string\") {\n            return new Interface(JSON.parse(value));\n        }\n        // An Interface; possibly from another v6 instance\n        if (typeof value.formatJson === \"function\") {\n            return new Interface(value.formatJson());\n        }\n        // A legacy Interface; from an older version\n        if (typeof value.format === \"function\") {\n            return new Interface(value.format(\"json\"));\n        }\n        // Array of fragments\n        return new Interface(value);\n    }\n} //# sourceMappingURL=interface.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vYWJpL2ludGVyZmFjZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBOzs7Ozs7Ozs7O0NBVUMsR0FDOEM7QUFDVDtBQUN3SjtBQUNwSjtBQUM2QjtBQUNtRDtBQUN2RjtBQUNFO0FBQ3JDOzs7Q0FHQyxHQUNNLE1BQU15QjtJQXFCVDs7S0FFQyxHQUNEQyxZQUFZQyxRQUFRLEVBQUVDLEtBQUssRUFBRUMsSUFBSSxDQUFFO1FBQy9CLE1BQU1DLE9BQU9ILFNBQVNHLElBQUksRUFBRUMsWUFBWUosU0FBU0ssTUFBTTtRQUN2RHJCLGlFQUFnQkEsQ0FBQyxJQUFJLEVBQUU7WUFDbkJnQjtZQUFVRztZQUFNQztZQUFXSDtZQUFPQztRQUN0QztJQUNKO0FBQ0o7QUFDQTs7OztDQUlDLEdBQ00sTUFBTUk7SUF5QlQ7O0tBRUMsR0FDRFAsWUFBWUMsUUFBUSxFQUFFTyxRQUFRLEVBQUVMLElBQUksRUFBRU0sS0FBSyxDQUFFO1FBQ3pDLE1BQU1MLE9BQU9ILFNBQVNHLElBQUksRUFBRUMsWUFBWUosU0FBU0ssTUFBTTtRQUN2RHJCLGlFQUFnQkEsQ0FBQyxJQUFJLEVBQUU7WUFDbkJnQjtZQUFVRztZQUFNRDtZQUFNRTtZQUFXRztZQUFVQztRQUMvQztJQUNKO0FBQ0o7QUFDQTs7O0NBR0MsR0FDTSxNQUFNQztJQXFCVDs7S0FFQyxHQUNEVixZQUFZQyxRQUFRLEVBQUVPLFFBQVEsRUFBRUwsSUFBSSxDQUFFO1FBQ2xDLE1BQU1DLE9BQU9ILFNBQVNHLElBQUksRUFBRUMsWUFBWUosU0FBU0ssTUFBTTtRQUN2RHJCLGlFQUFnQkEsQ0FBQyxJQUFJLEVBQUU7WUFDbkJnQjtZQUFVRztZQUFNRDtZQUFNRTtZQUFXRztRQUNyQztJQUNKO0FBQ0o7QUFDQTs7Ozs7Q0FLQyxHQUNNLE1BQU1HO0lBU1Q7Ozs7S0FJQyxHQUNELE9BQU9DLFVBQVVILEtBQUssRUFBRTtRQUNwQixPQUFPLENB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VXNDLElBQUkrRCxJQUFJLEVBQUUvRCxJQUFJOEYsTUFBTTtJQUM5RztJQUNBOzs7OztLQUtDLEdBQ0RxQixXQUFXcEQsSUFBSSxFQUFFO1FBQ2IsTUFBTXFELFVBQVU5Syx3REFBT0EsQ0FBQ3lIO1FBQ3hCLE1BQU1yRyxXQUFXLElBQUksQ0FBQ2lHLFFBQVEsQ0FBQ3pILDBEQUFTQSxDQUFDa0wsU0FBUyxHQUFHO1FBQ3JELElBQUksQ0FBQzFKLFVBQVU7WUFDWCxPQUFPO1FBQ1g7UUFDQSxNQUFNRSxPQUFPLElBQUksQ0FBQyxDQUFDeUIsUUFBUSxDQUFDMkUsTUFBTSxDQUFDdEcsU0FBU2dCLE1BQU0sRUFBRXhDLDBEQUFTQSxDQUFDa0wsU0FBUztRQUN2RSxPQUFPLElBQUlqSixpQkFBaUJULFVBQVVBLFNBQVNPLFFBQVEsRUFBRUw7SUFDN0Q7SUFDQTs7Ozs7S0FLQyxHQUNELE9BQU9pQyxLQUFLM0IsS0FBSyxFQUFFO1FBQ2YsMkNBQTJDO1FBQzNDLElBQUlBLGlCQUFpQmUsV0FBVztZQUM1QixPQUFPZjtRQUNYO1FBQ0EsT0FBTztRQUNQLElBQUksT0FBUUEsVUFBVyxVQUFVO1lBQzdCLE9BQU8sSUFBSWUsVUFBVUosS0FBS1csS0FBSyxDQUFDdEI7UUFDcEM7UUFDQSxrREFBa0Q7UUFDbEQsSUFBSSxPQUFRQSxNQUFNZ0QsVUFBVSxLQUFNLFlBQVk7WUFDMUMsT0FBTyxJQUFJakMsVUFBVWYsTUFBTWdELFVBQVU7UUFDekM7UUFDQSw0Q0FBNEM7UUFDNUMsSUFBSSxPQUFRaEQsTUFBTUgsTUFBTSxLQUFNLFlBQVk7WUFDdEMsT0FBTyxJQUFJa0IsVUFBVWYsTUFBTUgsTUFBTSxDQUFDO1FBQ3RDO1FBQ0EscUJBQXFCO1FBQ3JCLE9BQU8sSUFBSWtCLFVBQVVmO0lBQ3pCO0FBQ0osRUFDQSxxQ0FBcUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tZWdhdmliZS1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9hYmkvaW50ZXJmYWNlLmpzP2U1NjciXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiAgVGhlIEludGVyZmFjZSBjbGFzcyBpcyBhIGxvdy1sZXZlbCBjbGFzcyB0aGF0IGFjY2VwdHMgYW5cbiAqICBBQkkgYW5kIHByb3ZpZGVzIGFsbCB0aGUgbmVjZXNzYXJ5IGZ1bmN0aW9uYWxpdHkgdG8gZW5jb2RlXG4gKiAgYW5kIGRlY29kZSBwYXJhbWF0ZXJzIHRvIGFuZCByZXN1bHRzIGZyb20gbWV0aG9kcywgZXZlbnRzXG4gKiAgYW5kIGVycm9ycy5cbiAqXG4gKiAgSXQgYWxzbyBwcm92aWRlcyBzZXZlcmFsIGNvbnZlbmllbmNlIG1ldGhvZHMgdG8gYXV0b21hdGljYWxseVxuICogIHNlYXJjaCBhbmQgZmluZCBtYXRjaGluZyB0cmFuc2FjdGlvbnMgYW5kIGV2ZW50cyB0byBwYXJzZSB0aGVtLlxuICpcbiAqICBAX3N1YnNlY3Rpb24gYXBpL2FiaTpJbnRlcmZhY2VzICBbaW50ZXJmYWNlc11cbiAqL1xuaW1wb3J0IHsga2VjY2FrMjU2IH0gZnJvbSBcIi4uL2NyeXB0by9pbmRleC5qc1wiO1xuaW1wb3J0IHsgaWQgfSBmcm9tIFwiLi4vaGFzaC9pbmRleC5qc1wiO1xuaW1wb3J0IHsgY29uY2F0LCBkYXRhU2xpY2UsIGdldEJpZ0ludCwgZ2V0Qnl0ZXMsIGdldEJ5dGVzQ29weSwgaGV4bGlmeSwgemVyb1BhZEJ5dGVzLCB6ZXJvUGFkVmFsdWUsIGlzSGV4U3RyaW5nLCBkZWZpbmVQcm9wZXJ0aWVzLCBhc3NlcnRBcmd1bWVudCwgdG9CZUhleCwgYXNzZXJ0IH0gZnJvbSBcIi4uL3V0aWxzL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBBYmlDb2RlciB9IGZyb20gXCIuL2FiaS1jb2Rlci5qc1wiO1xuaW1wb3J0IHsgY2hlY2tSZXN1bHRFcnJvcnMsIFJlc3VsdCB9IGZyb20gXCIuL2NvZGVycy9hYnN0cmFjdC1jb2Rlci5qc1wiO1xuaW1wb3J0IHsgQ29uc3RydWN0b3JGcmFnbWVudCwgRXJyb3JGcmFnbWVudCwgRXZlbnRGcmFnbWVudCwgRnJhZ21lbnQsIEZ1bmN0aW9uRnJhZ21lbnQsIFBhcmFtVHlwZSB9IGZyb20gXCIuL2ZyYWdtZW50cy5qc1wiO1xuaW1wb3J0IHsgVHlwZWQgfSBmcm9tIFwiLi90eXBlZC5qc1wiO1xuZXhwb3J0IHsgY2hlY2tSZXN1bHRFcnJvcnMsIFJlc3VsdCB9O1xuLyoqXG4gKiAgV2hlbiB1c2luZyB0aGUgW1tJbnRlcmZhY2UtcGFyc2VMb2ddXSB0byBhdXRvbWF0aWNhbGx5IG1hdGNoIGEgTG9nIHRvIGl0cyBldmVudFxuICogIGZvciBwYXJzaW5nLCBhICoqTG9nRGVzY3JpcHRpb24qKiBpcyByZXR1cm5lZC5cbiAqL1xuZXhwb3J0IGNsYXNzIExvZ0Rlc2NyaXB0aW9uIHtcbiAgICAvKipcbiAgICAgKiAgVGhlIG1hdGNoaW5nIGZyYWdtZW50IGZvciB0aGUgYGB0b3BpYzBgYC5cbiAgICAgKi9cbiAgICBmcmFnbWVudDtcbiAgICAvKipcbiAgICAgKiAgVGhlIG5hbWUgb2YgdGhlIEV2ZW50LlxuICAgICAqL1xuICAgIG5hbWU7XG4gICAgLyoqXG4gICAgICogIFRoZSBmdWxsIEV2ZW50IHNpZ25hdHVyZS5cbiAgICAgKi9cbiAgICBzaWduYXR1cmU7XG4gICAgLyoqXG4gICAgICogIFRoZSB0b3BpYyBoYXNoIGZvciB0aGUgRXZlbnQuXG4gICAgICovXG4gICAgdG9waWM7XG4gICAgLyoqXG4gICAgICogIFRoZSBhcmd1bWVudHMgcGFzc2VkIGludG8gdGhlIEV2ZW50IHdpdGggYGBlbWl0YGAuXG4gICAgICovXG4gICAgYXJncztcbiAgICAvKipcbiAgICAgKiAgQF9pZ25vcmU6XG4gICAgICovXG4gICAgY29uc3RydWN0b3IoZnJhZ21lbnQsIHRvcGljLCBhcmdzKSB7XG4gICAgICAgIGNvbnN0IG5hbWUgPSBmcmFnbWVudC5uYW1lLCBzaWduYXR1cmUgPSBmcmFnbWVudC5mb3JtYXQoKTtcbiAgICAgICAgZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7XG4gICAgICAgICAgICBmcmFnbWVudCwgbmFtZSwgc2lnbmF0dXJlLCB0b3BpYywgYXJnc1xuICAgICAgICB9KTtcbiAgICB9XG59XG4vKipcbiAqICBXaGVuIHVzaW5nIHRoZSBbW0ludGVyZmFjZS1wYXJzZVRyYW5zYWN0aW9uXV0gdG8gYXV0b21hdGljYWxseSBtYXRjaFxuICogIGEgdHJhbnNhY3Rpb24gZGF0YSB0byBpdHMgZnVuY3Rpb24gZm9yIHBhcnNpbmcsXG4gKiAgYSAqKlRyYW5zYWN0aW9uRGVzY3JpcHRpb24qKiBpcyByZXR1cm5lZC5cbiAqL1xuZXhwb3J0IGNsYXNzIFRyYW5zYWN0aW9uRGVzY3JpcHRpb24ge1xuICAgIC8qKlxuICAgICAqICBUaGUgbWF0Y2hpbmcgZnJhZ21lbnQgZnJvbSB0aGUgdHJhbnNhY3Rpb24gYGBkYXRhYGAuXG4gICAgICovXG4gICAgZnJhZ21lbnQ7XG4gICAgLyoqXG4gICAgICogIFRoZSBuYW1lIG9mIHRoZSBGdW5jdGlvbiBmcm9tIHRoZSB0cmFuc2FjdGlvbiBgYGRhdGFgYC5cbiAgICAgKi9cbiAgICBuYW1lO1xuICAgIC8qKlxuICAgICAqICBUaGUgYXJndW1lbnRzIHBhc3NlZCB0byB0aGUgRnVuY3Rpb24gZnJvbSB0aGUgdHJhbnNhY3Rpb24gYGBkYXRhYGAuXG4gICAgICovXG4gICAgYXJncztcbiAgICAvKipcbiAgICAgKiAgVGhlIGZ1bGwgRnVuY3Rpb24gc2lnbmF0dXJlIGZyb20gdGhlIHRyYW5zYWN0aW9uIGBgZGF0YWBgLlxuICAgICAqL1xuICAgIHNpZ25hdHVyZTtcbiAgICAvKipcbiAgICAgKiAgVGhlIHNlbGVjdG9yIGZvciB0aGUgRnVuY3Rpb24gZnJvbSB0aGUgdHJhbnNhY3Rpb24gYGBkYXRhYGAuXG4gICAgICovXG4gICAgc2VsZWN0b3I7XG4gICAgLyoqXG4gICAgICogIFRoZSBgYHZhbHVlYGAgKGluIHdlaSkgZnJvbSB0aGUgdHJhbnNhY3Rpb24uXG4gICAgICovXG4gICAgdmFsdWU7XG4gICAgLyoqXG4gICAgICogIEBfaWdub3JlOlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGZyYWdtZW50LCBzZWxlY3RvciwgYXJncywgdmFsdWUpIHtcbiAgICAgICAgY29uc3QgbmFtZSA9IGZyYWdtZW50Lm5hbWUsIHNpZ25hdHVyZSA9IGZyYWdtZW50LmZvcm1hdCgpO1xuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHtcbiAgICAgICAgICAgIGZyYWdtZW50LCBuYW1lLCBhcmdzLCBzaWduYXR1cmUsIHNlbGVjdG9yLCB2YWx1ZVxuICAgICAgICB9KTtcbiAgICB9XG59XG4vKipcbiAqICBXaGVuIHVzaW5nIHRoZSBbW0ludGVyZmFjZS1wYXJzZUVycm9yXV0gdG8gYXV0b21hdGljYWxseSBtYXRjaCBhblxuICogIGVycm9yIGZvciBhIGNhbGwgcmVzdWx0IGZvciBwYXJzaW5nLCBhbiAqKkVycm9yRGVzY3JpcHRpb24qKiBpcyByZXR1cm5lZC5cbiAqL1xuZXhwb3J0IGNsYXNzIEVycm9yRGVzY3JpcHRpb24ge1xuICAgIC8qKlxuICAgICAqICBUaGUgbWF0Y2hpbmcgZnJhZ21lbnQuXG4gICAgICovXG4gICAgZnJhZ21lbnQ7XG4gICAgLyoqXG4gICAgICogIFRoZSBuYW1lIG9mIHRoZSBFcnJvci5cbiAgICAgKi9cbiAgICBuYW1lO1xuICAgIC8qKlxuICAgICAqICBUaGUgYXJndW1lbnRzIHBhc3NlZCB0byB0aGUgRXJyb3Igd2l0aCBgYHJldmVydGBgLlxuICAgICAqL1xuICAgIGFyZ3M7XG4gICAgLyoqXG4gICAgICogIFRoZSBmdWxsIEVycm9yIHNpZ25hdHVyZS5cbiAgICAgKi9cbiAgICBzaWduYXR1cmU7XG4gICAgLyoqXG4gICAgICogIFRoZSBzZWxlY3RvciBmb3IgdGhlIEVycm9yLlxuICAgICAqL1xuICAgIHNlbGVjdG9yO1xuICAgIC8qKlxuICAgICAqICBAX2lnbm9yZTpcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihmcmFnbWVudCwgc2VsZWN0b3IsIGFyZ3MpIHtcbiAgICAgICAgY29uc3QgbmFtZSA9IGZyYWdtZW50Lm5hbWUsIHNpZ25hdHVyZSA9IGZyYWdtZW50LmZvcm1hdCgpO1xuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHtcbiAgICAgICAgICAgIGZyYWdtZW50LCBuYW1lLCBhcmdzLCBzaWduYXR1cmUsIHNlbGVjdG9yXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8qKlxuICogIEFuICoqSW5kZXhlZCoqIGlzIHVzZWQgYXMgYSB2YWx1ZSB3aGVuIGEgdmFsdWUgdGhhdCBkb2VzIG5vdFxuICogIGZpdCB3aXRoaW4gYSB0b3BpYyAoaS5lLiBub3QgYSBmaXhlZC1sZW5ndGgsIDMyLWJ5dGUgdHlwZSkuIEl0XG4gKiAgaXMgdGhlIGBga2VjY2FrMjU2YGAgb2YgdGhlIHZhbHVlLCBhbmQgdXNlZCBmb3IgdHlwZXMgc3VjaCBhc1xuICogIGFycmF5cywgdHVwbGVzLCBieXRlcyBhbmQgc3RyaW5ncy5cbiAqL1xuZXhwb3J0IGNsYXNzIEluZGV4ZWQge1xuICAgIC8qKlxuICAgICAqICBUaGUgYGBrZWNjYWsyNTZgYCBvZiB0aGUgdmFsdWUgbG9nZ2VkLlxuICAgICAqL1xuICAgIGhhc2g7XG4gICAgLyoqXG4gICAgICogIEBfaWdub3JlOlxuICAgICAqL1xuICAgIF9pc0luZGV4ZWQ7XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYGB0cnVlYGAgaWYgJSV2YWx1ZSUlIGlzIGFuICoqSW5kZXhlZCoqLlxuICAgICAqXG4gICAgICogIFRoaXMgcHJvdmlkZXMgYSBUeXBlIEd1YXJkIGZvciBwcm9wZXJ0eSBhY2Nlc3MuXG4gICAgICovXG4gICAgc3RhdGljIGlzSW5kZXhlZCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gISEodmFsdWUgJiYgdmFsdWUuX2lzSW5kZXhlZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBAX2lnbm9yZTpcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihoYXNoKSB7XG4gICAgICAgIGRlZmluZVByb3BlcnRpZXModGhpcywgeyBoYXNoLCBfaXNJbmRleGVkOiB0cnVlIH0pO1xuICAgIH1cbn1cbi8vIGh0dHBzOi8vZG9jcy5zb2xpZGl0eWxhbmcub3JnL2VuL3YwLjguMTMvY29udHJvbC1zdHJ1Y3R1cmVzLmh0bWw/aGlnaGxpZ2h0PXBhbmljI3BhbmljLXZpYS1hc3NlcnQtYW5kLWVycm9yLXZpYS1yZXF1aXJlXG5jb25zdCBQYW5pY1JlYXNvbnMgPSB7XG4gICAgXCIwXCI6IFwiZ2VuZXJpYyBwYW5pY1wiLFxuICAgIFwiMVwiOiBcImFzc2VydChmYWxzZSlcIixcbiAgICBcIjE3XCI6IFwiYXJpdGhtZXRpYyBvdmVyZmxvd1wiLFxuICAgIFwiMThcIjogXCJkaXZpc2lvbiBvciBtb2R1bG8gYnkgemVyb1wiLFxuICAgIFwiMzNcIjogXCJlbnVtIG92ZXJmbG93XCIsXG4gICAgXCIzNFwiOiBcImludmFsaWQgZW5jb2RlZCBzdG9yYWdlIGJ5dGUgYXJyYXkgYWNjZXNzZWRcIixcbiAgICBcIjQ5XCI6IFwib3V0LW9mLWJvdW5kcyBhcnJheSBhY2Nlc3M7IHBvcHBpbmcgb24gYW4gZW1wdHkgYXJyYXlcIixcbiAgICBcIjUwXCI6IFwib3V0LW9mLWJvdW5kcyBhY2Nlc3Mgb2YgYW4gYXJyYXkgb3IgYnl0ZXNOXCIsXG4gICAgXCI2NVwiOiBcIm91dCBvZiBtZW1vcnlcIixcbiAgICBcIjgxXCI6IFwidW5pbml0aWFsaXplZCBmdW5jdGlvblwiLFxufTtcbmNvbnN0IEJ1aWx0aW5FcnJvcnMgPSB7XG4gICAgXCIweDA4YzM3OWEwXCI6IHtcbiAgICAgICAgc2lnbmF0dXJlOiBcIkVycm9yKHN0cmluZylcIixcbiAgICAgICAgbmFtZTogXCJFcnJvclwiLFxuICAgICAgICBpbnB1dHM6IFtcInN0cmluZ1wiXSxcbiAgICAgICAgcmVhc29uOiAobWVzc2FnZSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGByZXZlcnRlZCB3aXRoIHJlYXNvbiBzdHJpbmcgJHtKU09OLnN0cmluZ2lmeShtZXNzYWdlKX1gO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBcIjB4NGU0ODdiNzFcIjoge1xuICAgICAgICBzaWduYXR1cmU6IFwiUGFuaWModWludDI1NilcIixcbiAgICAgICAgbmFtZTogXCJQYW5pY1wiLFxuICAgICAgICBpbnB1dHM6IFtcInVpbnQyNTZcIl0sXG4gICAgICAgIHJlYXNvbjogKGNvZGUpID0+IHtcbiAgICAgICAgICAgIGxldCByZWFzb24gPSBcInVua25vd24gcGFuaWMgY29kZVwiO1xuICAgICAgICAgICAgaWYgKGNvZGUgPj0gMCAmJiBjb2RlIDw9IDB4ZmYgJiYgUGFuaWNSZWFzb25zW2NvZGUudG9TdHJpbmcoKV0pIHtcbiAgICAgICAgICAgICAgICByZWFzb24gPSBQYW5pY1JlYXNvbnNbY29kZS50b1N0cmluZygpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBgcmV2ZXJ0ZWQgd2l0aCBwYW5pYyBjb2RlIDB4JHtjb2RlLnRvU3RyaW5nKDE2KX0gKCR7cmVhc29ufSlgO1xuICAgICAgICB9XG4gICAgfVxufTtcbi8qKlxuICogIEFuIEludGVyZmFjZSBhYnN0cmFjdHMgbWFueSBvZiB0aGUgbG93LWxldmVsIGRldGFpbHMgZm9yXG4gKiAgZW5jb2RpbmcgYW5kIGRlY29kaW5nIHRoZSBkYXRhIG9uIHRoZSBibG9ja2NoYWluLlxuICpcbiAqICBBbiBBQkkgcHJvdmlkZXMgaW5mb3JtYXRpb24gb24gaG93IHRvIGVuY29kZSBkYXRhIHRvIHNlbmQgdG9cbiAqICBhIENvbnRyYWN0LCBob3cgdG8gZGVjb2RlIHRoZSByZXN1bHRzIGFuZCBldmVudHMgYW5kIGhvdyB0b1xuICogIGludGVycHJldCByZXZlcnQgZXJyb3JzLlxuICpcbiAqICBUaGUgQUJJIGNhbiBiZSBzcGVjaWZpZWQgYnkgW2FueSBzdXBwb3J0ZWQgZm9ybWF0XShJbnRlcmZhY2VBYmkpLlxuICovXG5leHBvcnQgY2xhc3MgSW50ZXJmYWNlIHtcbiAgICAvKipcbiAgICAgKiAgQWxsIHRoZSBDb250cmFjdCBBQkkgbWVtYmVycyAoaS5lLiBtZXRob2RzLCBldmVudHMsIGVycm9ycywgZXRjKS5cbiAgICAgKi9cbiAgICBmcmFnbWVudHM7XG4gICAgLyoqXG4gICAgICogIFRoZSBDb250cmFjdCBjb25zdHJ1Y3Rvci5cbiAgICAgKi9cbiAgICBkZXBsb3k7XG4gICAgLyoqXG4gICAgICogIFRoZSBGYWxsYmFjayBtZXRob2QsIGlmIGFueS5cbiAgICAgKi9cbiAgICBmYWxsYmFjaztcbiAgICAvKipcbiAgICAgKiAgSWYgcmVjZWl2aW5nIGV0aGVyIGlzIHN1cHBvcnRlZC5cbiAgICAgKi9cbiAgICByZWNlaXZlO1xuICAgICNlcnJvcnM7XG4gICAgI2V2ZW50cztcbiAgICAjZnVuY3Rpb25zO1xuICAgIC8vICAgICNzdHJ1Y3RzOiBNYXA8c3RyaW5nLCBTdHJ1Y3RGcmFnbWVudD47XG4gICAgI2FiaUNvZGVyO1xuICAgIC8qKlxuICAgICAqICBDcmVhdGUgYSBuZXcgSW50ZXJmYWNlIGZvciB0aGUgJSVmcmFnbWVudHMlJS5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihmcmFnbWVudHMpIHtcbiAgICAgICAgbGV0IGFiaSA9IFtdO1xuICAgICAgICBpZiAodHlwZW9mIChmcmFnbWVudHMpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBhYmkgPSBKU09OLnBhcnNlKGZyYWdtZW50cyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBhYmkgPSBmcmFnbWVudHM7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4jZnVuY3Rpb25zID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLiNlcnJvcnMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuI2V2ZW50cyA9IG5ldyBNYXAoKTtcbiAgICAgICAgLy8gICAgICAgIHRoaXMuI3N0cnVjdHMgPSBuZXcgTWFwKCk7XG4gICAgICAgIGNvbnN0IGZyYWdzID0gW107XG4gICAgICAgIGZvciAoY29uc3QgYSBvZiBhYmkpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgZnJhZ3MucHVzaChGcmFnbWVudC5mcm9tKGEpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBbV2FybmluZ10gSW52YWxpZCBGcmFnbWVudCAke0pTT04uc3RyaW5naWZ5KGEpfTpgLCBlcnJvci5tZXNzYWdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHtcbiAgICAgICAgICAgIGZyYWdtZW50czogT2JqZWN0LmZyZWV6ZShmcmFncylcbiAgICAgICAgfSk7XG4gICAgICAgIGxldCBmYWxsYmFjayA9IG51bGw7XG4gICAgICAgIGxldCByZWNlaXZlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuI2FiaUNvZGVyID0gdGhpcy5nZXRBYmlDb2RlcigpO1xuICAgICAgICAvLyBBZGQgYWxsIGZyYWdtZW50cyBieSB0aGVpciBzaWduYXR1cmVcbiAgICAgICAgdGhpcy5mcmFnbWVudHMuZm9yRWFjaCgoZnJhZ21lbnQsIGluZGV4KSA9PiB7XG4gICAgICAgICAgICBsZXQgYnVja2V0O1xuICAgICAgICAgICAgc3dpdGNoIChmcmFnbWVudC50eXBlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBcImNvbnN0cnVjdG9yXCI6XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmRlcGxveSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJkdXBsaWNhdGUgZGVmaW5pdGlvbiAtIGNvbnN0cnVjdG9yXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vY2hlY2tOYW1lcyhmcmFnbWVudCwgXCJpbnB1dFwiLCBmcmFnbWVudC5pbnB1dHMpO1xuICAgICAgICAgICAgICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHsgZGVwbG95OiBmcmFnbWVudCB9KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJmYWxsYmFja1wiOlxuICAgICAgICAgICAgICAgICAgICBpZiAoZnJhZ21lbnQuaW5wdXRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVjZWl2ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnRBcmd1bWVudCghZmFsbGJhY2sgfHwgZnJhZ21lbnQucGF5YWJsZSAhPT0gZmFsbGJhY2sucGF5YWJsZSwgXCJjb25mbGljdGluZyBmYWxsYmFjayBmcmFnbWVudHNcIiwgYGZyYWdtZW50c1ske2luZGV4fV1gLCBmcmFnbWVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBmYWxsYmFjayA9IGZyYWdtZW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVjZWl2ZSA9IGZhbGxiYWNrLnBheWFibGU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJmdW5jdGlvblwiOlxuICAgICAgICAgICAgICAgICAgICAvL2NoZWNrTmFtZXMoZnJhZ21lbnQsIFwiaW5wdXRcIiwgZnJhZ21lbnQuaW5wdXRzKTtcbiAgICAgICAgICAgICAgICAgICAgLy9jaGVja05hbWVzKGZyYWdtZW50LCBcIm91dHB1dFwiLCAoPEZ1bmN0aW9uRnJhZ21lbnQ+ZnJhZ21lbnQpLm91dHB1dHMpO1xuICAgICAgICAgICAgICAgICAgICBidWNrZXQgPSB0aGlzLiNmdW5jdGlvbnM7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJldmVudFwiOlxuICAgICAgICAgICAgICAgICAgICAvL2NoZWNrTmFtZXMoZnJhZ21lbnQsIFwiaW5wdXRcIiwgZnJhZ21lbnQuaW5wdXRzKTtcbiAgICAgICAgICAgICAgICAgICAgYnVja2V0ID0gdGhpcy4jZXZlbnRzO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwiZXJyb3JcIjpcbiAgICAgICAgICAgICAgICAgICAgYnVja2V0ID0gdGhpcy4jZXJyb3JzO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBUd28gaWRlbnRpY2FsIGVudHJpZXM7IGlnbm9yZSBpdFxuICAgICAgICAgICAgY29uc3Qgc2lnbmF0dXJlID0gZnJhZ21lbnQuZm9ybWF0KCk7XG4gICAgICAgICAgICBpZiAoYnVja2V0LmhhcyhzaWduYXR1cmUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnVja2V0LnNldChzaWduYXR1cmUsIGZyYWdtZW50KTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIElmIHdlIGRvIG5vdCBoYXZlIGEgY29uc3RydWN0b3IgYWRkIGEgZGVmYXVsdFxuICAgICAgICBpZiAoIXRoaXMuZGVwbG95KSB7XG4gICAgICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHtcbiAgICAgICAgICAgICAgICBkZXBsb3k6IENvbnN0cnVjdG9yRnJhZ21lbnQuZnJvbShcImNvbnN0cnVjdG9yKClcIilcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGRlZmluZVByb3BlcnRpZXModGhpcywgeyBmYWxsYmFjaywgcmVjZWl2ZSB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdGhlIGVudGlyZSBIdW1hbi1SZWFkYWJsZSBBQkksIGFzIGFuIGFycmF5IG9mXG4gICAgICogIHNpZ25hdHVyZXMsIG9wdGlvbmFsbHkgYXMgJSVtaW5pbWFsJSUgc3RyaW5ncywgd2hpY2hcbiAgICAgKiAgcmVtb3ZlcyBwYXJhbWV0ZXIgbmFtZXMgYW5kIHVubmVjZWVzYXJ5IHNwYWNlcy5cbiAgICAgKi9cbiAgICBmb3JtYXQobWluaW1hbCkge1xuICAgICAgICBjb25zdCBmb3JtYXQgPSAobWluaW1hbCA/IFwibWluaW1hbFwiIDogXCJmdWxsXCIpO1xuICAgICAgICBjb25zdCBhYmkgPSB0aGlzLmZyYWdtZW50cy5tYXAoKGYpID0+IGYuZm9ybWF0KGZvcm1hdCkpO1xuICAgICAgICByZXR1cm4gYWJpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIHRoZSBKU09OLWVuY29kZWQgQUJJLiBUaGlzIGlzIHRoZSBmb3JtYXQgU29saWRpeVxuICAgICAqICByZXR1cm5zLlxuICAgICAqL1xuICAgIGZvcm1hdEpzb24oKSB7XG4gICAgICAgIGNvbnN0IGFiaSA9IHRoaXMuZnJhZ21lbnRzLm1hcCgoZikgPT4gZi5mb3JtYXQoXCJqc29uXCIpKTtcbiAgICAgICAgLy8gV2UgbmVlZCB0byByZS1idW5kbGUgdGhlIEpTT04gZnJhZ21lbnRzIGEgYml0XG4gICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShhYmkubWFwKChqKSA9PiBKU09OLnBhcnNlKGopKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgQUJJIGNvZGVyIHRoYXQgd2lsbCBiZSB1c2VkIHRvIGVuY29kZSBhbmQgZGVjb2RlIGJpbmFyeVxuICAgICAqICBkYXRhLlxuICAgICAqL1xuICAgIGdldEFiaUNvZGVyKCkge1xuICAgICAgICByZXR1cm4gQWJpQ29kZXIuZGVmYXVsdEFiaUNvZGVyKCk7XG4gICAgfVxuICAgIC8vIEZpbmQgYSBmdW5jdGlvbiBkZWZpbml0aW9uIGJ5IGFueSBtZWFucyBuZWNlc3NhcnkgKHVubGVzcyBpdCBpcyBhbWJpZ3VvdXMpXG4gICAgI2dldEZ1bmN0aW9uKGtleSwgdmFsdWVzLCBmb3JjZVVuaXF1ZSkge1xuICAgICAgICAvLyBTZWxlY3RvclxuICAgICAgICBpZiAoaXNIZXhTdHJpbmcoa2V5KSkge1xuICAgICAgICAgICAgY29uc3Qgc2VsZWN0b3IgPSBrZXkudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgZnJhZ21lbnQgb2YgdGhpcy4jZnVuY3Rpb25zLnZhbHVlcygpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNlbGVjdG9yID09PSBmcmFnbWVudC5zZWxlY3Rvcikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnJhZ21lbnQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSXQgaXMgYSBiYXJlIG5hbWUsIGxvb2sgdXAgdGhlIGZ1bmN0aW9uICh3aWxsIHJldHVybiBudWxsIGlmIGFtYmlndW91cylcbiAgICAgICAgaWYgKGtleS5pbmRleE9mKFwiKFwiKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIGNvbnN0IG1hdGNoaW5nID0gW107XG4gICAgICAgICAgICBmb3IgKGNvbnN0IFtuYW1lLCBmcmFnbWVudF0gb2YgdGhpcy4jZnVuY3Rpb25zKSB7XG4gICAgICAgICAgICAgICAgaWYgKG5hbWUuc3BsaXQoXCIoXCIgLyogZml4OikgKi8pWzBdID09PSBrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgbWF0Y2hpbmcucHVzaChmcmFnbWVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHZhbHVlcykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGxhc3RWYWx1ZSA9ICh2YWx1ZXMubGVuZ3RoID4gMCkgPyB2YWx1ZXNbdmFsdWVzLmxlbmd0aCAtIDFdIDogbnVsbDtcbiAgICAgICAgICAgICAgICBsZXQgdmFsdWVMZW5ndGggPSB2YWx1ZXMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGxldCBhbGxvd09wdGlvbnMgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGlmIChUeXBlZC5pc1R5cGVkKGxhc3RWYWx1ZSkgJiYgbGFzdFZhbHVlLnR5cGUgPT09IFwib3ZlcnJpZGVzXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgYWxsb3dPcHRpb25zID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlTGVuZ3RoLS07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFJlbW92ZSBhbGwgbWF0Y2hlcyB0aGF0IGRvbid0IGhhdmUgYSBjb21wYXRpYmxlIGxlbmd0aC4gVGhlIGFyZ3NcbiAgICAgICAgICAgICAgICAvLyBtYXkgY29udGFpbiBhbiBvdmVycmlkZXMsIHNvIHRoZSBtYXRjaCBtYXkgaGF2ZSBuIG9yIG4gLSAxIHBhcmFtZXRlcnNcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gbWF0Y2hpbmcubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaW5wdXRzID0gbWF0Y2hpbmdbaV0uaW5wdXRzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlucHV0cyAhPT0gdmFsdWVMZW5ndGggJiYgKCFhbGxvd09wdGlvbnMgfHwgaW5wdXRzICE9PSB2YWx1ZUxlbmd0aCAtIDEpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRjaGluZy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gUmVtb3ZlIGFsbCBtYXRjaGVzIHRoYXQgZG9uJ3QgbWF0Y2ggdGhlIFR5cGVkIHNpZ25hdHVyZVxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSBtYXRjaGluZy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBpbnB1dHMgPSBtYXRjaGluZ1tpXS5pbnB1dHM7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgdmFsdWVzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBOb3QgYSB0eXBlZCB2YWx1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFUeXBlZC5pc1R5cGVkKHZhbHVlc1tqXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIGFyZSBwYXN0IHRoZSBpbnB1dHNcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChqID49IGlucHV0cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWVzW2pdLnR5cGUgPT09IFwib3ZlcnJpZGVzXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoaW5nLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSB0aGUgdmFsdWUgdHlwZSBtYXRjaGVzIHRoZSBpbnB1dCB0eXBlXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWVzW2pdLnR5cGUgIT09IGlucHV0c1tqXS5iYXNlVHlwZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoaW5nLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFdlIGZvdW5kIGEgc2luZ2xlIG1hdGNoaW5nIHNpZ25hdHVyZSB3aXRoIGFuIG92ZXJyaWRlcywgYnV0IHRoZVxuICAgICAgICAgICAgLy8gbGFzdCB2YWx1ZSBpcyBzb21ldGhpbmcgdGhhdCBjYW5ub3QgcG9zc2libHkgYmUgYW4gb3B0aW9uc1xuICAgICAgICAgICAgaWYgKG1hdGNoaW5nLmxlbmd0aCA9PT0gMSAmJiB2YWx1ZXMgJiYgdmFsdWVzLmxlbmd0aCAhPT0gbWF0Y2hpbmdbMF0uaW5wdXRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGxhc3RBcmcgPSB2YWx1ZXNbdmFsdWVzLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgICAgIGlmIChsYXN0QXJnID09IG51bGwgfHwgQXJyYXkuaXNBcnJheShsYXN0QXJnKSB8fCB0eXBlb2YgKGxhc3RBcmcpICE9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIG1hdGNoaW5nLnNwbGljZSgwLCAxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWF0Y2hpbmcubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWF0Y2hpbmcubGVuZ3RoID4gMSAmJiBmb3JjZVVuaXF1ZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1hdGNoU3RyID0gbWF0Y2hpbmcubWFwKChtKSA9PiBKU09OLnN0cmluZ2lmeShtLmZvcm1hdCgpKSkuam9pbihcIiwgXCIpO1xuICAgICAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KGZhbHNlLCBgYW1iaWd1b3VzIGZ1bmN0aW9uIGRlc2NyaXB0aW9uIChpLmUuIG1hdGNoZXMgJHttYXRjaFN0cn0pYCwgXCJrZXlcIiwga2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtYXRjaGluZ1swXTtcbiAgICAgICAgfVxuICAgICAgICAvLyBOb3JtYWxpemUgdGhlIHNpZ25hdHVyZSBhbmQgbG9va3VwIHRoZSBmdW5jdGlvblxuICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLiNmdW5jdGlvbnMuZ2V0KEZ1bmN0aW9uRnJhZ21lbnQuZnJvbShrZXkpLmZvcm1hdCgpKTtcbiAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIEdldCB0aGUgZnVuY3Rpb24gbmFtZSBmb3IgJSVrZXklJSwgd2hpY2ggbWF5IGJlIGEgZnVuY3Rpb24gc2VsZWN0b3IsXG4gICAgICogIGZ1bmN0aW9uIG5hbWUgb3IgZnVuY3Rpb24gc2lnbmF0dXJlIHRoYXQgYmVsb25ncyB0byB0aGUgQUJJLlxuICAgICAqL1xuICAgIGdldEZ1bmN0aW9uTmFtZShrZXkpIHtcbiAgICAgICAgY29uc3QgZnJhZ21lbnQgPSB0aGlzLiNnZXRGdW5jdGlvbihrZXksIG51bGwsIGZhbHNlKTtcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQoZnJhZ21lbnQsIFwibm8gbWF0Y2hpbmcgZnVuY3Rpb25cIiwgXCJrZXlcIiwga2V5KTtcbiAgICAgICAgcmV0dXJuIGZyYWdtZW50Lm5hbWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRydWUgaWYgJSVrZXklJSAoYSBmdW5jdGlvbiBzZWxlY3RvciwgZnVuY3Rpb24gbmFtZSBvclxuICAgICAqICBmdW5jdGlvbiBzaWduYXR1cmUpIGlzIHByZXNlbnQgaW4gdGhlIEFCSS5cbiAgICAgKlxuICAgICAqICBJbiB0aGUgY2FzZSBvZiBhIGZ1bmN0aW9uIG5hbWUsIHRoZSBuYW1lIG1heSBiZSBhbWJpZ3VvdXMsIHNvXG4gICAgICogIGFjY2Vzc2luZyB0aGUgW1tGdW5jdGlvbkZyYWdtZW50XV0gbWF5IHJlcXVpcmUgcmVmaW5lbWVudC5cbiAgICAgKi9cbiAgICBoYXNGdW5jdGlvbihrZXkpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy4jZ2V0RnVuY3Rpb24oa2V5LCBudWxsLCBmYWxzZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBHZXQgdGhlIFtbRnVuY3Rpb25GcmFnbWVudF1dIGZvciAlJWtleSUlLCB3aGljaCBtYXkgYmUgYSBmdW5jdGlvblxuICAgICAqICBzZWxlY3RvciwgZnVuY3Rpb24gbmFtZSBvciBmdW5jdGlvbiBzaWduYXR1cmUgdGhhdCBiZWxvbmdzIHRvIHRoZSBBQkkuXG4gICAgICpcbiAgICAgKiAgSWYgJSV2YWx1ZXMlJSBpcyBwcm92aWRlZCwgaXQgd2lsbCB1c2UgdGhlIFR5cGVkIEFQSSB0byBoYW5kbGVcbiAgICAgKiAgYW1iaWd1b3VzIGNhc2VzIHdoZXJlIG11bHRpcGxlIGZ1bmN0aW9ucyBtYXRjaCBieSBuYW1lLlxuICAgICAqXG4gICAgICogIElmIHRoZSAlJWtleSUlIGFuZCAlJXZhbHVlcyUlIGRvIG5vdCByZWZpbmUgdG8gYSBzaW5nbGUgZnVuY3Rpb24gaW5cbiAgICAgKiAgdGhlIEFCSSwgdGhpcyB3aWxsIHRocm93LlxuICAgICAqL1xuICAgIGdldEZ1bmN0aW9uKGtleSwgdmFsdWVzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiNnZXRGdW5jdGlvbihrZXksIHZhbHVlcyB8fCBudWxsLCB0cnVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIEl0ZXJhdGUgb3ZlciBhbGwgZnVuY3Rpb25zLCBjYWxsaW5nICUlY2FsbGJhY2slJSwgc29ydGVkIGJ5IHRoZWlyIG5hbWUuXG4gICAgICovXG4gICAgZm9yRWFjaEZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgICAgIGNvbnN0IG5hbWVzID0gQXJyYXkuZnJvbSh0aGlzLiNmdW5jdGlvbnMua2V5cygpKTtcbiAgICAgICAgbmFtZXMuc29ydCgoYSwgYikgPT4gYS5sb2NhbGVDb21wYXJlKGIpKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuYW1lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgbmFtZSA9IG5hbWVzW2ldO1xuICAgICAgICAgICAgY2FsbGJhY2soKHRoaXMuI2Z1bmN0aW9ucy5nZXQobmFtZSkpLCBpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBGaW5kIGFuIGV2ZW50IGRlZmluaXRpb24gYnkgYW55IG1lYW5zIG5lY2Vzc2FyeSAodW5sZXNzIGl0IGlzIGFtYmlndW91cylcbiAgICAjZ2V0RXZlbnQoa2V5LCB2YWx1ZXMsIGZvcmNlVW5pcXVlKSB7XG4gICAgICAgIC8vIEV2ZW50VG9waWNcbiAgICAgICAgaWYgKGlzSGV4U3RyaW5nKGtleSkpIHtcbiAgICAgICAgICAgIGNvbnN0IGV2ZW50VG9waWMgPSBrZXkudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgZnJhZ21lbnQgb2YgdGhpcy4jZXZlbnRzLnZhbHVlcygpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGV2ZW50VG9waWMgPT09IGZyYWdtZW50LnRvcGljSGFzaCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnJhZ21lbnQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSXQgaXMgYSBiYXJlIG5hbWUsIGxvb2sgdXAgdGhlIGZ1bmN0aW9uICh3aWxsIHJldHVybiBudWxsIGlmIGFtYmlndW91cylcbiAgICAgICAgaWYgKGtleS5pbmRleE9mKFwiKFwiKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIGNvbnN0IG1hdGNoaW5nID0gW107XG4gICAgICAgICAgICBmb3IgKGNvbnN0IFtuYW1lLCBmcmFnbWVudF0gb2YgdGhpcy4jZXZlbnRzKSB7XG4gICAgICAgICAgICAgICAgaWYgKG5hbWUuc3BsaXQoXCIoXCIgLyogZml4OikgKi8pWzBdID09PSBrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgbWF0Y2hpbmcucHVzaChmcmFnbWVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHZhbHVlcykge1xuICAgICAgICAgICAgICAgIC8vIFJlbW92ZSBhbGwgbWF0Y2hlcyB0aGF0IGRvbid0IGhhdmUgYSBjb21wYXRpYmxlIGxlbmd0aC5cbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gbWF0Y2hpbmcubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1hdGNoaW5nW2ldLmlucHV0cy5sZW5ndGggPCB2YWx1ZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRjaGluZy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gUmVtb3ZlIGFsbCBtYXRjaGVzIHRoYXQgZG9uJ3QgbWF0Y2ggdGhlIFR5cGVkIHNpZ25hdHVyZVxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSBtYXRjaGluZy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBpbnB1dHMgPSBtYXRjaGluZ1tpXS5pbnB1dHM7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgdmFsdWVzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBOb3QgYSB0eXBlZCB2YWx1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFUeXBlZC5pc1R5cGVkKHZhbHVlc1tqXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSB0aGUgdmFsdWUgdHlwZSBtYXRjaGVzIHRoZSBpbnB1dCB0eXBlXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWVzW2pdLnR5cGUgIT09IGlucHV0c1tqXS5iYXNlVHlwZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoaW5nLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtYXRjaGluZy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtYXRjaGluZy5sZW5ndGggPiAxICYmIGZvcmNlVW5pcXVlKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbWF0Y2hTdHIgPSBtYXRjaGluZy5tYXAoKG0pID0+IEpTT04uc3RyaW5naWZ5KG0uZm9ybWF0KCkpKS5qb2luKFwiLCBcIik7XG4gICAgICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoZmFsc2UsIGBhbWJpZ3VvdXMgZXZlbnQgZGVzY3JpcHRpb24gKGkuZS4gbWF0Y2hlcyAke21hdGNoU3RyfSlgLCBcImtleVwiLCBrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG1hdGNoaW5nWzBdO1xuICAgICAgICB9XG4gICAgICAgIC8vIE5vcm1hbGl6ZSB0aGUgc2lnbmF0dXJlIGFuZCBsb29rdXAgdGhlIGZ1bmN0aW9uXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuI2V2ZW50cy5nZXQoRXZlbnRGcmFnbWVudC5mcm9tKGtleSkuZm9ybWF0KCkpO1xuICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgR2V0IHRoZSBldmVudCBuYW1lIGZvciAlJWtleSUlLCB3aGljaCBtYXkgYmUgYSB0b3BpYyBoYXNoLFxuICAgICAqICBldmVudCBuYW1lIG9yIGV2ZW50IHNpZ25hdHVyZSB0aGF0IGJlbG9uZ3MgdG8gdGhlIEFCSS5cbiAgICAgKi9cbiAgICBnZXRFdmVudE5hbWUoa2V5KSB7XG4gICAgICAgIGNvbnN0IGZyYWdtZW50ID0gdGhpcy4jZ2V0RXZlbnQoa2V5LCBudWxsLCBmYWxzZSk7XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KGZyYWdtZW50LCBcIm5vIG1hdGNoaW5nIGV2ZW50XCIsIFwia2V5XCIsIGtleSk7XG4gICAgICAgIHJldHVybiBmcmFnbWVudC5uYW1lO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0cnVlIGlmICUla2V5JSUgKGFuIGV2ZW50IHRvcGljIGhhc2gsIGV2ZW50IG5hbWUgb3JcbiAgICAgKiAgZXZlbnQgc2lnbmF0dXJlKSBpcyBwcmVzZW50IGluIHRoZSBBQkkuXG4gICAgICpcbiAgICAgKiAgSW4gdGhlIGNhc2Ugb2YgYW4gZXZlbnQgbmFtZSwgdGhlIG5hbWUgbWF5IGJlIGFtYmlndW91cywgc29cbiAgICAgKiAgYWNjZXNzaW5nIHRoZSBbW0V2ZW50RnJhZ21lbnRdXSBtYXkgcmVxdWlyZSByZWZpbmVtZW50LlxuICAgICAqL1xuICAgIGhhc0V2ZW50KGtleSkge1xuICAgICAgICByZXR1cm4gISF0aGlzLiNnZXRFdmVudChrZXksIG51bGwsIGZhbHNlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIEdldCB0aGUgW1tFdmVudEZyYWdtZW50XV0gZm9yICUla2V5JSUsIHdoaWNoIG1heSBiZSBhIHRvcGljIGhhc2gsXG4gICAgICogIGV2ZW50IG5hbWUgb3IgZXZlbnQgc2lnbmF0dXJlIHRoYXQgYmVsb25ncyB0byB0aGUgQUJJLlxuICAgICAqXG4gICAgICogIElmICUldmFsdWVzJSUgaXMgcHJvdmlkZWQsIGl0IHdpbGwgdXNlIHRoZSBUeXBlZCBBUEkgdG8gaGFuZGxlXG4gICAgICogIGFtYmlndW91cyBjYXNlcyB3aGVyZSBtdWx0aXBsZSBldmVudHMgbWF0Y2ggYnkgbmFtZS5cbiAgICAgKlxuICAgICAqICBJZiB0aGUgJSVrZXklJSBhbmQgJSV2YWx1ZXMlJSBkbyBub3QgcmVmaW5lIHRvIGEgc2luZ2xlIGV2ZW50IGluXG4gICAgICogIHRoZSBBQkksIHRoaXMgd2lsbCB0aHJvdy5cbiAgICAgKi9cbiAgICBnZXRFdmVudChrZXksIHZhbHVlcykge1xuICAgICAgICByZXR1cm4gdGhpcy4jZ2V0RXZlbnQoa2V5LCB2YWx1ZXMgfHwgbnVsbCwgdHJ1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBJdGVyYXRlIG92ZXIgYWxsIGV2ZW50cywgY2FsbGluZyAlJWNhbGxiYWNrJSUsIHNvcnRlZCBieSB0aGVpciBuYW1lLlxuICAgICAqL1xuICAgIGZvckVhY2hFdmVudChjYWxsYmFjaykge1xuICAgICAgICBjb25zdCBuYW1lcyA9IEFycmF5LmZyb20odGhpcy4jZXZlbnRzLmtleXMoKSk7XG4gICAgICAgIG5hbWVzLnNvcnQoKGEsIGIpID0+IGEubG9jYWxlQ29tcGFyZShiKSk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IG5hbWUgPSBuYW1lc1tpXTtcbiAgICAgICAgICAgIGNhbGxiYWNrKCh0aGlzLiNldmVudHMuZ2V0KG5hbWUpKSwgaSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogIEdldCB0aGUgW1tFcnJvckZyYWdtZW50XV0gZm9yICUla2V5JSUsIHdoaWNoIG1heSBiZSBhbiBlcnJvclxuICAgICAqICBzZWxlY3RvciwgZXJyb3IgbmFtZSBvciBlcnJvciBzaWduYXR1cmUgdGhhdCBiZWxvbmdzIHRvIHRoZSBBQkkuXG4gICAgICpcbiAgICAgKiAgSWYgJSV2YWx1ZXMlJSBpcyBwcm92aWRlZCwgaXQgd2lsbCB1c2UgdGhlIFR5cGVkIEFQSSB0byBoYW5kbGVcbiAgICAgKiAgYW1iaWd1b3VzIGNhc2VzIHdoZXJlIG11bHRpcGxlIGVycm9ycyBtYXRjaCBieSBuYW1lLlxuICAgICAqXG4gICAgICogIElmIHRoZSAlJWtleSUlIGFuZCAlJXZhbHVlcyUlIGRvIG5vdCByZWZpbmUgdG8gYSBzaW5nbGUgZXJyb3IgaW5cbiAgICAgKiAgdGhlIEFCSSwgdGhpcyB3aWxsIHRocm93LlxuICAgICAqL1xuICAgIGdldEVycm9yKGtleSwgdmFsdWVzKSB7XG4gICAgICAgIGlmIChpc0hleFN0cmluZyhrZXkpKSB7XG4gICAgICAgICAgICBjb25zdCBzZWxlY3RvciA9IGtleS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgaWYgKEJ1aWx0aW5FcnJvcnNbc2VsZWN0b3JdKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEVycm9yRnJhZ21lbnQuZnJvbShCdWlsdGluRXJyb3JzW3NlbGVjdG9yXS5zaWduYXR1cmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChjb25zdCBmcmFnbWVudCBvZiB0aGlzLiNlcnJvcnMudmFsdWVzKCkpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2VsZWN0b3IgPT09IGZyYWdtZW50LnNlbGVjdG9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmcmFnbWVudDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICAvLyBJdCBpcyBhIGJhcmUgbmFtZSwgbG9vayB1cCB0aGUgZnVuY3Rpb24gKHdpbGwgcmV0dXJuIG51bGwgaWYgYW1iaWd1b3VzKVxuICAgICAgICBpZiAoa2V5LmluZGV4T2YoXCIoXCIpID09PSAtMSkge1xuICAgICAgICAgICAgY29uc3QgbWF0Y2hpbmcgPSBbXTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgW25hbWUsIGZyYWdtZW50XSBvZiB0aGlzLiNlcnJvcnMpIHtcbiAgICAgICAgICAgICAgICBpZiAobmFtZS5zcGxpdChcIihcIiAvKiBmaXg6KSAqLylbMF0gPT09IGtleSkge1xuICAgICAgICAgICAgICAgICAgICBtYXRjaGluZy5wdXNoKGZyYWdtZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWF0Y2hpbmcubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKGtleSA9PT0gXCJFcnJvclwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBFcnJvckZyYWdtZW50LmZyb20oXCJlcnJvciBFcnJvcihzdHJpbmcpXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoa2V5ID09PSBcIlBhbmljXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEVycm9yRnJhZ21lbnQuZnJvbShcImVycm9yIFBhbmljKHVpbnQyNTYpXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG1hdGNoaW5nLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBtYXRjaFN0ciA9IG1hdGNoaW5nLm1hcCgobSkgPT4gSlNPTi5zdHJpbmdpZnkobS5mb3JtYXQoKSkpLmpvaW4oXCIsIFwiKTtcbiAgICAgICAgICAgICAgICBhc3NlcnRBcmd1bWVudChmYWxzZSwgYGFtYmlndW91cyBlcnJvciBkZXNjcmlwdGlvbiAoaS5lLiAke21hdGNoU3RyfSlgLCBcIm5hbWVcIiwga2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtYXRjaGluZ1swXTtcbiAgICAgICAgfVxuICAgICAgICAvLyBOb3JtYWxpemUgdGhlIHNpZ25hdHVyZSBhbmQgbG9va3VwIHRoZSBmdW5jdGlvblxuICAgICAgICBrZXkgPSBFcnJvckZyYWdtZW50LmZyb20oa2V5KS5mb3JtYXQoKTtcbiAgICAgICAgaWYgKGtleSA9PT0gXCJFcnJvcihzdHJpbmcpXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBFcnJvckZyYWdtZW50LmZyb20oXCJlcnJvciBFcnJvcihzdHJpbmcpXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChrZXkgPT09IFwiUGFuaWModWludDI1NilcIikge1xuICAgICAgICAgICAgcmV0dXJuIEVycm9yRnJhZ21lbnQuZnJvbShcImVycm9yIFBhbmljKHVpbnQyNTYpXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuI2Vycm9ycy5nZXQoa2V5KTtcbiAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIEl0ZXJhdGUgb3ZlciBhbGwgZXJyb3JzLCBjYWxsaW5nICUlY2FsbGJhY2slJSwgc29ydGVkIGJ5IHRoZWlyIG5hbWUuXG4gICAgICovXG4gICAgZm9yRWFjaEVycm9yKGNhbGxiYWNrKSB7XG4gICAgICAgIGNvbnN0IG5hbWVzID0gQXJyYXkuZnJvbSh0aGlzLiNlcnJvcnMua2V5cygpKTtcbiAgICAgICAgbmFtZXMuc29ydCgoYSwgYikgPT4gYS5sb2NhbGVDb21wYXJlKGIpKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuYW1lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgbmFtZSA9IG5hbWVzW2ldO1xuICAgICAgICAgICAgY2FsbGJhY2soKHRoaXMuI2Vycm9ycy5nZXQobmFtZSkpLCBpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBHZXQgdGhlIDQtYnl0ZSBzZWxlY3RvciB1c2VkIGJ5IFNvbGlkaXR5IHRvIGlkZW50aWZ5IGEgZnVuY3Rpb25cbiAgICAvKlxuZ2V0U2VsZWN0b3IoZnJhZ21lbnQ6IEVycm9yRnJhZ21lbnQgfCBGdW5jdGlvbkZyYWdtZW50KTogc3RyaW5nIHtcbiAgICBpZiAodHlwZW9mKGZyYWdtZW50KSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBjb25zdCBtYXRjaGVzOiBBcnJheTxGcmFnbWVudD4gPSBbIF07XG5cbiAgICAgICAgdHJ5IHsgbWF0Y2hlcy5wdXNoKHRoaXMuZ2V0RnVuY3Rpb24oZnJhZ21lbnQpKTsgfSBjYXRjaCAoZXJyb3IpIHsgfVxuICAgICAgICB0cnkgeyBtYXRjaGVzLnB1c2godGhpcy5nZXRFcnJvcig8c3RyaW5nPmZyYWdtZW50KSk7IH0gY2F0Y2ggKF8pIHsgfVxuXG4gICAgICAgIGlmIChtYXRjaGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcInVua25vd24gZnJhZ21lbnRcIiwgXCJrZXlcIiwgZnJhZ21lbnQpO1xuICAgICAgICB9IGVsc2UgaWYgKG1hdGNoZXMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImFtYmlndW91cyBmcmFnbWVudCBtYXRjaGVzIGZ1bmN0aW9uIGFuZCBlcnJvclwiLCBcImtleVwiLCBmcmFnbWVudCk7XG4gICAgICAgIH1cblxuICAgICAgICBmcmFnbWVudCA9IG1hdGNoZXNbMF07XG4gICAgfVxuXG4gICAgcmV0dXJuIGRhdGFTbGljZShpZChmcmFnbWVudC5mb3JtYXQoKSksIDAsIDQpO1xufVxuICAgICovXG4gICAgLy8gR2V0IHRoZSAzMi1ieXRlIHRvcGljIGhhc2ggdXNlZCBieSBTb2xpZGl0eSB0byBpZGVudGlmeSBhbiBldmVudFxuICAgIC8qXG4gICAgZ2V0RXZlbnRUb3BpYyhmcmFnbWVudDogRXZlbnRGcmFnbWVudCk6IHN0cmluZyB7XG4gICAgICAgIC8vaWYgKHR5cGVvZihmcmFnbWVudCkgPT09IFwic3RyaW5nXCIpIHsgZnJhZ21lbnQgPSB0aGlzLmdldEV2ZW50KGV2ZW50RnJhZ21lbnQpOyB9XG4gICAgICAgIHJldHVybiBpZChmcmFnbWVudC5mb3JtYXQoKSk7XG4gICAgfVxuICAgICovXG4gICAgX2RlY29kZVBhcmFtcyhwYXJhbXMsIGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI2FiaUNvZGVyLmRlY29kZShwYXJhbXMsIGRhdGEpO1xuICAgIH1cbiAgICBfZW5jb2RlUGFyYW1zKHBhcmFtcywgdmFsdWVzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiNhYmlDb2Rlci5lbmNvZGUocGFyYW1zLCB2YWx1ZXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgRW5jb2RlcyBhIGBgdHguZGF0YWBgIG9iamVjdCBmb3IgZGVwbG95aW5nIHRoZSBDb250cmFjdCB3aXRoXG4gICAgICogIHRoZSAlJXZhbHVlcyUlIGFzIHRoZSBjb25zdHJ1Y3RvciBhcmd1bWVudHMuXG4gICAgICovXG4gICAgZW5jb2RlRGVwbG95KHZhbHVlcykge1xuICAgICAgICByZXR1cm4gdGhpcy5fZW5jb2RlUGFyYW1zKHRoaXMuZGVwbG95LmlucHV0cywgdmFsdWVzIHx8IFtdKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIERlY29kZXMgdGhlIHJlc3VsdCAlJWRhdGElJSAoZS5nLiBmcm9tIGFuIGBgZXRoX2NhbGxgYCkgZm9yIHRoZVxuICAgICAqICBzcGVjaWZpZWQgZXJyb3IgKHNlZSBbW2dldEVycm9yXV0gZm9yIHZhbGlkIHZhbHVlcyBmb3JcbiAgICAgKiAgJSVrZXklJSkuXG4gICAgICpcbiAgICAgKiAgTW9zdCBkZXZlbG9wZXJzIHNob3VsZCBwcmVmZXIgdGhlIFtbcGFyc2VDYWxsUmVzdWx0XV0gbWV0aG9kIGluc3RlYWQsXG4gICAgICogIHdoaWNoIHdpbGwgYXV0b21hdGljYWxseSBkZXRlY3QgYSBgYENBTExfRVhDRVBUSU9OYGAgYW5kIHRocm93IHRoZVxuICAgICAqICBjb3JyZXNwb25kaW5nIGVycm9yLlxuICAgICAqL1xuICAgIGRlY29kZUVycm9yUmVzdWx0KGZyYWdtZW50LCBkYXRhKSB7XG4gICAgICAgIGlmICh0eXBlb2YgKGZyYWdtZW50KSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgY29uc3QgZiA9IHRoaXMuZ2V0RXJyb3IoZnJhZ21lbnQpO1xuICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoZiwgXCJ1bmtub3duIGVycm9yXCIsIFwiZnJhZ21lbnRcIiwgZnJhZ21lbnQpO1xuICAgICAgICAgICAgZnJhZ21lbnQgPSBmO1xuICAgICAgICB9XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KGRhdGFTbGljZShkYXRhLCAwLCA0KSA9PT0gZnJhZ21lbnQuc2VsZWN0b3IsIGBkYXRhIHNpZ25hdHVyZSBkb2VzIG5vdCBtYXRjaCBlcnJvciAke2ZyYWdtZW50Lm5hbWV9LmAsIFwiZGF0YVwiLCBkYXRhKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlY29kZVBhcmFtcyhmcmFnbWVudC5pbnB1dHMsIGRhdGFTbGljZShkYXRhLCA0KSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBFbmNvZGVzIHRoZSB0cmFuc2FjdGlvbiByZXZlcnQgZGF0YSBmb3IgYSBjYWxsIHJlc3VsdCB0aGF0XG4gICAgICogIHJldmVydGVkIGZyb20gdGhlIHRoZSBDb250cmFjdCB3aXRoIHRoZSBzZXBjaWZpZWQgJSVlcnJvciUlXG4gICAgICogIChzZWUgW1tnZXRFcnJvcl1dIGZvciB2YWxpZCB2YWx1ZXMgZm9yICUlZnJhZ21lbnQlJSkgd2l0aCB0aGUgJSV2YWx1ZXMlJS5cbiAgICAgKlxuICAgICAqICBUaGlzIGlzIGdlbmVyYWxseSBub3QgdXNlZCBieSBtb3N0IGRldmVsb3BlcnMsIHVubGVzcyB0cnlpbmcgdG8gbW9ja1xuICAgICAqICBhIHJlc3VsdCBmcm9tIGEgQ29udHJhY3QuXG4gICAgICovXG4gICAgZW5jb2RlRXJyb3JSZXN1bHQoZnJhZ21lbnQsIHZhbHVlcykge1xuICAgICAgICBpZiAodHlwZW9mIChmcmFnbWVudCkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IGYgPSB0aGlzLmdldEVycm9yKGZyYWdtZW50KTtcbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KGYsIFwidW5rbm93biBlcnJvclwiLCBcImZyYWdtZW50XCIsIGZyYWdtZW50KTtcbiAgICAgICAgICAgIGZyYWdtZW50ID0gZjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29uY2F0KFtcbiAgICAgICAgICAgIGZyYWdtZW50LnNlbGVjdG9yLFxuICAgICAgICAgICAgdGhpcy5fZW5jb2RlUGFyYW1zKGZyYWdtZW50LmlucHV0cywgdmFsdWVzIHx8IFtdKVxuICAgICAgICBdKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIERlY29kZXMgdGhlICUlZGF0YSUlIGZyb20gYSB0cmFuc2FjdGlvbiBgYHR4LmRhdGFgYCBmb3JcbiAgICAgKiAgdGhlIGZ1bmN0aW9uIHNwZWNpZmllZCAoc2VlIFtbZ2V0RnVuY3Rpb25dXSBmb3IgdmFsaWQgdmFsdWVzXG4gICAgICogIGZvciAlJWZyYWdtZW50JSUpLlxuICAgICAqXG4gICAgICogIE1vc3QgZGV2ZWxvcGVycyBzaG91bGQgcHJlZmVyIHRoZSBbW3BhcnNlVHJhbnNhY3Rpb25dXSBtZXRob2RcbiAgICAgKiAgaW5zdGVhZCwgd2hpY2ggd2lsbCBhdXRvbWF0aWNhbGx5IGRldGVjdCB0aGUgZnJhZ21lbnQuXG4gICAgICovXG4gICAgZGVjb2RlRnVuY3Rpb25EYXRhKGZyYWdtZW50LCBkYXRhKSB7XG4gICAgICAgIGlmICh0eXBlb2YgKGZyYWdtZW50KSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgY29uc3QgZiA9IHRoaXMuZ2V0RnVuY3Rpb24oZnJhZ21lbnQpO1xuICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoZiwgXCJ1bmtub3duIGZ1bmN0aW9uXCIsIFwiZnJhZ21lbnRcIiwgZnJhZ21lbnQpO1xuICAgICAgICAgICAgZnJhZ21lbnQgPSBmO1xuICAgICAgICB9XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KGRhdGFTbGljZShkYXRhLCAwLCA0KSA9PT0gZnJhZ21lbnQuc2VsZWN0b3IsIGBkYXRhIHNpZ25hdHVyZSBkb2VzIG5vdCBtYXRjaCBmdW5jdGlvbiAke2ZyYWdtZW50Lm5hbWV9LmAsIFwiZGF0YVwiLCBkYXRhKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlY29kZVBhcmFtcyhmcmFnbWVudC5pbnB1dHMsIGRhdGFTbGljZShkYXRhLCA0KSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBFbmNvZGVzIHRoZSBgYHR4LmRhdGFgYCBmb3IgYSB0cmFuc2FjdGlvbiB0aGF0IGNhbGxzIHRoZSBmdW5jdGlvblxuICAgICAqICBzcGVjaWZpZWQgKHNlZSBbW2dldEZ1bmN0aW9uXV0gZm9yIHZhbGlkIHZhbHVlcyBmb3IgJSVmcmFnbWVudCUlKSB3aXRoXG4gICAgICogIHRoZSAlJXZhbHVlcyUlLlxuICAgICAqL1xuICAgIGVuY29kZUZ1bmN0aW9uRGF0YShmcmFnbWVudCwgdmFsdWVzKSB7XG4gICAgICAgIGlmICh0eXBlb2YgKGZyYWdtZW50KSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgY29uc3QgZiA9IHRoaXMuZ2V0RnVuY3Rpb24oZnJhZ21lbnQpO1xuICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoZiwgXCJ1bmtub3duIGZ1bmN0aW9uXCIsIFwiZnJhZ21lbnRcIiwgZnJhZ21lbnQpO1xuICAgICAgICAgICAgZnJhZ21lbnQgPSBmO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb25jYXQoW1xuICAgICAgICAgICAgZnJhZ21lbnQuc2VsZWN0b3IsXG4gICAgICAgICAgICB0aGlzLl9lbmNvZGVQYXJhbXMoZnJhZ21lbnQuaW5wdXRzLCB2YWx1ZXMgfHwgW10pXG4gICAgICAgIF0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgRGVjb2RlcyB0aGUgcmVzdWx0ICUlZGF0YSUlIChlLmcuIGZyb20gYW4gYGBldGhfY2FsbGBgKSBmb3IgdGhlXG4gICAgICogIHNwZWNpZmllZCBmdW5jdGlvbiAoc2VlIFtbZ2V0RnVuY3Rpb25dXSBmb3IgdmFsaWQgdmFsdWVzIGZvclxuICAgICAqICAlJWtleSUlKS5cbiAgICAgKlxuICAgICAqICBNb3N0IGRldmVsb3BlcnMgc2hvdWxkIHByZWZlciB0aGUgW1twYXJzZUNhbGxSZXN1bHRdXSBtZXRob2QgaW5zdGVhZCxcbiAgICAgKiAgd2hpY2ggd2lsbCBhdXRvbWF0aWNhbGx5IGRldGVjdCBhIGBgQ0FMTF9FWENFUFRJT05gYCBhbmQgdGhyb3cgdGhlXG4gICAgICogIGNvcnJlc3BvbmRpbmcgZXJyb3IuXG4gICAgICovXG4gICAgZGVjb2RlRnVuY3Rpb25SZXN1bHQoZnJhZ21lbnQsIGRhdGEpIHtcbiAgICAgICAgaWYgKHR5cGVvZiAoZnJhZ21lbnQpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBjb25zdCBmID0gdGhpcy5nZXRGdW5jdGlvbihmcmFnbWVudCk7XG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudChmLCBcInVua25vd24gZnVuY3Rpb25cIiwgXCJmcmFnbWVudFwiLCBmcmFnbWVudCk7XG4gICAgICAgICAgICBmcmFnbWVudCA9IGY7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG1lc3NhZ2UgPSBcImludmFsaWQgbGVuZ3RoIGZvciByZXN1bHQgZGF0YVwiO1xuICAgICAgICBjb25zdCBieXRlcyA9IGdldEJ5dGVzQ29weShkYXRhKTtcbiAgICAgICAgaWYgKChieXRlcy5sZW5ndGggJSAzMikgPT09IDApIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuI2FiaUNvZGVyLmRlY29kZShmcmFnbWVudC5vdXRwdXRzLCBieXRlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlID0gXCJjb3VsZCBub3QgZGVjb2RlIHJlc3VsdCBkYXRhXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2FsbCByZXR1cm5lZCBkYXRhIHdpdGggbm8gZXJyb3IsIGJ1dCB0aGUgZGF0YSBpcyBqdW5rXG4gICAgICAgIGFzc2VydChmYWxzZSwgbWVzc2FnZSwgXCJCQURfREFUQVwiLCB7XG4gICAgICAgICAgICB2YWx1ZTogaGV4bGlmeShieXRlcyksXG4gICAgICAgICAgICBpbmZvOiB7IG1ldGhvZDogZnJhZ21lbnQubmFtZSwgc2lnbmF0dXJlOiBmcmFnbWVudC5mb3JtYXQoKSB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBtYWtlRXJyb3IoX2RhdGEsIHR4KSB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBnZXRCeXRlcyhfZGF0YSwgXCJkYXRhXCIpO1xuICAgICAgICBjb25zdCBlcnJvciA9IEFiaUNvZGVyLmdldEJ1aWx0aW5DYWxsRXhjZXB0aW9uKFwiY2FsbFwiLCB0eCwgZGF0YSk7XG4gICAgICAgIC8vIE5vdCBhIGJ1aWx0LWluIGVycm9yOyB0cnkgZmluZGluZyBhIGN1c3RvbSBlcnJvclxuICAgICAgICBjb25zdCBjdXN0b21QcmVmaXggPSBcImV4ZWN1dGlvbiByZXZlcnRlZCAodW5rbm93biBjdXN0b20gZXJyb3IpXCI7XG4gICAgICAgIGlmIChlcnJvci5tZXNzYWdlLnN0YXJ0c1dpdGgoY3VzdG9tUHJlZml4KSkge1xuICAgICAgICAgICAgY29uc3Qgc2VsZWN0b3IgPSBoZXhsaWZ5KGRhdGEuc2xpY2UoMCwgNCkpO1xuICAgICAgICAgICAgY29uc3QgZWYgPSB0aGlzLmdldEVycm9yKHNlbGVjdG9yKTtcbiAgICAgICAgICAgIGlmIChlZikge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGFyZ3MgPSB0aGlzLiNhYmlDb2Rlci5kZWNvZGUoZWYuaW5wdXRzLCBkYXRhLnNsaWNlKDQpKTtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3IucmV2ZXJ0ID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogZWYubmFtZSwgc2lnbmF0dXJlOiBlZi5mb3JtYXQoKSwgYXJnc1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBlcnJvci5yZWFzb24gPSBlcnJvci5yZXZlcnQuc2lnbmF0dXJlO1xuICAgICAgICAgICAgICAgICAgICBlcnJvci5tZXNzYWdlID0gYGV4ZWN1dGlvbiByZXZlcnRlZDogJHtlcnJvci5yZWFzb259YDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3IubWVzc2FnZSA9IGBleGVjdXRpb24gcmV2ZXJ0ZWQgKGNvdWx0IG5vdCBkZWNvZGUgY3VzdG9tIGVycm9yKWA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIEFkZCB0aGUgaW52b2NhdGlvbiwgaWYgYXZhaWxhYmxlXG4gICAgICAgIGNvbnN0IHBhcnNlZCA9IHRoaXMucGFyc2VUcmFuc2FjdGlvbih0eCk7XG4gICAgICAgIGlmIChwYXJzZWQpIHtcbiAgICAgICAgICAgIGVycm9yLmludm9jYXRpb24gPSB7XG4gICAgICAgICAgICAgICAgbWV0aG9kOiBwYXJzZWQubmFtZSxcbiAgICAgICAgICAgICAgICBzaWduYXR1cmU6IHBhcnNlZC5zaWduYXR1cmUsXG4gICAgICAgICAgICAgICAgYXJnczogcGFyc2VkLmFyZ3NcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgRW5jb2RlcyB0aGUgcmVzdWx0IGRhdGEgKGUuZy4gZnJvbSBhbiBgYGV0aF9jYWxsYGApIGZvciB0aGVcbiAgICAgKiAgc3BlY2lmaWVkIGZ1bmN0aW9uIChzZWUgW1tnZXRGdW5jdGlvbl1dIGZvciB2YWxpZCB2YWx1ZXNcbiAgICAgKiAgZm9yICUlZnJhZ21lbnQlJSkgd2l0aCAlJXZhbHVlcyUlLlxuICAgICAqXG4gICAgICogIFRoaXMgaXMgZ2VuZXJhbGx5IG5vdCB1c2VkIGJ5IG1vc3QgZGV2ZWxvcGVycywgdW5sZXNzIHRyeWluZyB0byBtb2NrXG4gICAgICogIGEgcmVzdWx0IGZyb20gYSBDb250cmFjdC5cbiAgICAgKi9cbiAgICBlbmNvZGVGdW5jdGlvblJlc3VsdChmcmFnbWVudCwgdmFsdWVzKSB7XG4gICAgICAgIGlmICh0eXBlb2YgKGZyYWdtZW50KSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgY29uc3QgZiA9IHRoaXMuZ2V0RnVuY3Rpb24oZnJhZ21lbnQpO1xuICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoZiwgXCJ1bmtub3duIGZ1bmN0aW9uXCIsIFwiZnJhZ21lbnRcIiwgZnJhZ21lbnQpO1xuICAgICAgICAgICAgZnJhZ21lbnQgPSBmO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBoZXhsaWZ5KHRoaXMuI2FiaUNvZGVyLmVuY29kZShmcmFnbWVudC5vdXRwdXRzLCB2YWx1ZXMgfHwgW10pKTtcbiAgICB9XG4gICAgLypcbiAgICAgICAgc3BlbHVuayhpbnB1dHM6IEFycmF5PFBhcmFtVHlwZT4sIHZhbHVlczogUmVhZG9ubHlBcnJheTxhbnk+LCBwcm9jZXNzZnVuYzogKHR5cGU6IHN0cmluZywgdmFsdWU6IGFueSkgPT4gUHJvbWlzZTxhbnk+KTogUHJvbWlzZTxBcnJheTxhbnk+PiB7XG4gICAgICAgICAgICBjb25zdCBwcm9taXNlczogQXJyYXk8UHJvbWlzZTw+PiA9IFsgXTtcbiAgICAgICAgICAgIGNvbnN0IHByb2Nlc3MgPSBmdW5jdGlvbih0eXBlOiBQYXJhbVR5cGUsIHZhbHVlOiBhbnkpOiBhbnkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlLmJhc2VUeXBlID09PSBcImFycmF5XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRlc2NlbmQodHlwZS5jaGlsZFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodHlwZS4gPT09IFwiYWRkcmVzc1wiKSB7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICBcbiAgICAgICAgICAgIGNvbnN0IGRlc2NlbmQgPSBmdW5jdGlvbiAoaW5wdXRzOiBBcnJheTxQYXJhbVR5cGU+LCB2YWx1ZXM6IFJlYWRvbmx5QXJyYXk8YW55Pikge1xuICAgICAgICAgICAgICAgIGlmIChpbnB1dHMubGVuZ3RoICE9PSB2YWx1ZXMubGVuZ3RoKSB7IHRocm93IG5ldyBFcnJvcihcImxlbmd0aCBtaXNtYXRjaFwiKTsgfVxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgfTtcbiAgICBcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdDogQXJyYXk8YW55PiA9IFsgXTtcbiAgICAgICAgICAgIHZhbHVlcy5mb3JFYWNoKCh2YWx1ZSwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB0b3BpY3MucHVzaChudWxsKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHBhcmFtLmJhc2VUeXBlID09PSBcImFycmF5XCIgfHwgcGFyYW0uYmFzZVR5cGUgPT09IFwidHVwbGVcIikge1xuICAgICAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiZmlsdGVyaW5nIHdpdGggdHVwbGVzIG9yIGFycmF5cyBub3Qgc3VwcG9ydGVkXCIsIChcImNvbnRyYWN0LlwiICsgcGFyYW0ubmFtZSksIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRvcGljcy5wdXNoKHZhbHVlLm1hcCgodmFsdWUpID0+IGVuY29kZVRvcGljKHBhcmFtLCB2YWx1ZSkpKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0b3BpY3MucHVzaChlbmNvZGVUb3BpYyhwYXJhbSwgdmFsdWUpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICovXG4gICAgLy8gQ3JlYXRlIHRoZSBmaWx0ZXIgZm9yIHRoZSBldmVudCB3aXRoIHNlYXJjaCBjcml0ZXJpYSAoZS5nLiBmb3IgZXRoX2ZpbHRlckxvZylcbiAgICBlbmNvZGVGaWx0ZXJUb3BpY3MoZnJhZ21lbnQsIHZhbHVlcykge1xuICAgICAgICBpZiAodHlwZW9mIChmcmFnbWVudCkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IGYgPSB0aGlzLmdldEV2ZW50KGZyYWdtZW50KTtcbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KGYsIFwidW5rbm93biBldmVudFwiLCBcImV2ZW50RnJhZ21lbnRcIiwgZnJhZ21lbnQpO1xuICAgICAgICAgICAgZnJhZ21lbnQgPSBmO1xuICAgICAgICB9XG4gICAgICAgIGFzc2VydCh2YWx1ZXMubGVuZ3RoIDw9IGZyYWdtZW50LmlucHV0cy5sZW5ndGgsIGB0b28gbWFueSBhcmd1bWVudHMgZm9yICR7ZnJhZ21lbnQuZm9ybWF0KCl9YCwgXCJVTkVYUEVDVEVEX0FSR1VNRU5UXCIsIHsgY291bnQ6IHZhbHVlcy5sZW5ndGgsIGV4cGVjdGVkQ291bnQ6IGZyYWdtZW50LmlucHV0cy5sZW5ndGggfSk7XG4gICAgICAgIGNvbnN0IHRvcGljcyA9IFtdO1xuICAgICAgICBpZiAoIWZyYWdtZW50LmFub255bW91cykge1xuICAgICAgICAgICAgdG9waWNzLnB1c2goZnJhZ21lbnQudG9waWNIYXNoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBAVE9ETzogVXNlIHRoZSBjb2RlcnMgZm9yIHRoaXM7IHRvIHByb3Blcmx5IHN1cHBvcnQgdHVwbGVzLCBldGMuXG4gICAgICAgIGNvbnN0IGVuY29kZVRvcGljID0gKHBhcmFtLCB2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgaWYgKHBhcmFtLnR5cGUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaWQodmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocGFyYW0udHlwZSA9PT0gXCJieXRlc1wiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGtlY2NhazI1NihoZXhsaWZ5KHZhbHVlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocGFyYW0udHlwZSA9PT0gXCJib29sXCIgJiYgdHlwZW9mICh2YWx1ZSkgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSAodmFsdWUgPyBcIjB4MDFcIiA6IFwiMHgwMFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHBhcmFtLnR5cGUubWF0Y2goL151P2ludC8pKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSB0b0JlSGV4KHZhbHVlKTsgLy8gQFRPRE86IFNob3VsZCB0aGlzIHRvVHdvcz8/XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChwYXJhbS50eXBlLm1hdGNoKC9eYnl0ZXMvKSkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gemVyb1BhZEJ5dGVzKHZhbHVlLCAzMik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChwYXJhbS50eXBlID09PSBcImFkZHJlc3NcIikge1xuICAgICAgICAgICAgICAgIC8vIENoZWNrIGFkZHJlc3NlcyBhcmUgdmFsaWRcbiAgICAgICAgICAgICAgICB0aGlzLiNhYmlDb2Rlci5lbmNvZGUoW1wiYWRkcmVzc1wiXSwgW3ZhbHVlXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gemVyb1BhZFZhbHVlKGhleGxpZnkodmFsdWUpLCAzMik7XG4gICAgICAgIH07XG4gICAgICAgIHZhbHVlcy5mb3JFYWNoKCh2YWx1ZSwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHBhcmFtID0gZnJhZ21lbnQuaW5wdXRzW2luZGV4XTtcbiAgICAgICAgICAgIGlmICghcGFyYW0uaW5kZXhlZCkge1xuICAgICAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KHZhbHVlID09IG51bGwsIFwiY2Fubm90IGZpbHRlciBub24taW5kZXhlZCBwYXJhbWV0ZXJzOyBtdXN0IGJlIG51bGxcIiwgKFwiY29udHJhY3QuXCIgKyBwYXJhbS5uYW1lKSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdG9waWNzLnB1c2gobnVsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChwYXJhbS5iYXNlVHlwZSA9PT0gXCJhcnJheVwiIHx8IHBhcmFtLmJhc2VUeXBlID09PSBcInR1cGxlXCIpIHtcbiAgICAgICAgICAgICAgICBhc3NlcnRBcmd1bWVudChmYWxzZSwgXCJmaWx0ZXJpbmcgd2l0aCB0dXBsZXMgb3IgYXJyYXlzIG5vdCBzdXBwb3J0ZWRcIiwgKFwiY29udHJhY3QuXCIgKyBwYXJhbS5uYW1lKSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICB0b3BpY3MucHVzaCh2YWx1ZS5tYXAoKHZhbHVlKSA9PiBlbmNvZGVUb3BpYyhwYXJhbSwgdmFsdWUpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0b3BpY3MucHVzaChlbmNvZGVUb3BpYyhwYXJhbSwgdmFsdWUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIC8vIFRyaW0gb2ZmIHRyYWlsaW5nIG51bGxzXG4gICAgICAgIHdoaWxlICh0b3BpY3MubGVuZ3RoICYmIHRvcGljc1t0b3BpY3MubGVuZ3RoIC0gMV0gPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRvcGljcy5wb3AoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdG9waWNzO1xuICAgIH1cbiAgICBlbmNvZGVFdmVudExvZyhmcmFnbWVudCwgdmFsdWVzKSB7XG4gICAgICAgIGlmICh0eXBlb2YgKGZyYWdtZW50KSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgY29uc3QgZiA9IHRoaXMuZ2V0RXZlbnQoZnJhZ21lbnQpO1xuICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoZiwgXCJ1bmtub3duIGV2ZW50XCIsIFwiZXZlbnRGcmFnbWVudFwiLCBmcmFnbWVudCk7XG4gICAgICAgICAgICBmcmFnbWVudCA9IGY7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdG9waWNzID0gW107XG4gICAgICAgIGNvbnN0IGRhdGFUeXBlcyA9IFtdO1xuICAgICAgICBjb25zdCBkYXRhVmFsdWVzID0gW107XG4gICAgICAgIGlmICghZnJhZ21lbnQuYW5vbnltb3VzKSB7XG4gICAgICAgICAgICB0b3BpY3MucHVzaChmcmFnbWVudC50b3BpY0hhc2gpO1xuICAgICAgICB9XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KHZhbHVlcy5sZW5ndGggPT09IGZyYWdtZW50LmlucHV0cy5sZW5ndGgsIFwiZXZlbnQgYXJndW1lbnRzL3ZhbHVlcyBtaXNtYXRjaFwiLCBcInZhbHVlc1wiLCB2YWx1ZXMpO1xuICAgICAgICBmcmFnbWVudC5pbnB1dHMuZm9yRWFjaCgocGFyYW0sIGluZGV4KSA9PiB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHZhbHVlc1tpbmRleF07XG4gICAgICAgICAgICBpZiAocGFyYW0uaW5kZXhlZCkge1xuICAgICAgICAgICAgICAgIGlmIChwYXJhbS50eXBlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIHRvcGljcy5wdXNoKGlkKHZhbHVlKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHBhcmFtLnR5cGUgPT09IFwiYnl0ZXNcIikge1xuICAgICAgICAgICAgICAgICAgICB0b3BpY3MucHVzaChrZWNjYWsyNTYodmFsdWUpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocGFyYW0uYmFzZVR5cGUgPT09IFwidHVwbGVcIiB8fCBwYXJhbS5iYXNlVHlwZSA9PT0gXCJhcnJheVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEBUT0RPXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm5vdCBpbXBsZW1lbnRlZFwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRvcGljcy5wdXNoKHRoaXMuI2FiaUNvZGVyLmVuY29kZShbcGFyYW0udHlwZV0sIFt2YWx1ZV0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBkYXRhVHlwZXMucHVzaChwYXJhbSk7XG4gICAgICAgICAgICAgICAgZGF0YVZhbHVlcy5wdXNoKHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkYXRhOiB0aGlzLiNhYmlDb2Rlci5lbmNvZGUoZGF0YVR5cGVzLCBkYXRhVmFsdWVzKSxcbiAgICAgICAgICAgIHRvcGljczogdG9waWNzXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8vIERlY29kZSBhIGZpbHRlciBmb3IgdGhlIGV2ZW50IGFuZCB0aGUgc2VhcmNoIGNyaXRlcmlhXG4gICAgZGVjb2RlRXZlbnRMb2coZnJhZ21lbnQsIGRhdGEsIHRvcGljcykge1xuICAgICAgICBpZiAodHlwZW9mIChmcmFnbWVudCkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IGYgPSB0aGlzLmdldEV2ZW50KGZyYWdtZW50KTtcbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KGYsIFwidW5rbm93biBldmVudFwiLCBcImV2ZW50RnJhZ21lbnRcIiwgZnJhZ21lbnQpO1xuICAgICAgICAgICAgZnJhZ21lbnQgPSBmO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0b3BpY3MgIT0gbnVsbCAmJiAhZnJhZ21lbnQuYW5vbnltb3VzKSB7XG4gICAgICAgICAgICBjb25zdCBldmVudFRvcGljID0gZnJhZ21lbnQudG9waWNIYXNoO1xuICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoaXNIZXhTdHJpbmcodG9waWNzWzBdLCAzMikgJiYgdG9waWNzWzBdLnRvTG93ZXJDYXNlKCkgPT09IGV2ZW50VG9waWMsIFwiZnJhZ21lbnQvdG9waWMgbWlzbWF0Y2hcIiwgXCJ0b3BpY3NbMF1cIiwgdG9waWNzWzBdKTtcbiAgICAgICAgICAgIHRvcGljcyA9IHRvcGljcy5zbGljZSgxKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpbmRleGVkID0gW107XG4gICAgICAgIGNvbnN0IG5vbkluZGV4ZWQgPSBbXTtcbiAgICAgICAgY29uc3QgZHluYW1pYyA9IFtdO1xuICAgICAgICBmcmFnbWVudC5pbnB1dHMuZm9yRWFjaCgocGFyYW0sIGluZGV4KSA9PiB7XG4gICAgICAgICAgICBpZiAocGFyYW0uaW5kZXhlZCkge1xuICAgICAgICAgICAgICAgIGlmIChwYXJhbS50eXBlID09PSBcInN0cmluZ1wiIHx8IHBhcmFtLnR5cGUgPT09IFwiYnl0ZXNcIiB8fCBwYXJhbS5iYXNlVHlwZSA9PT0gXCJ0dXBsZVwiIHx8IHBhcmFtLmJhc2VUeXBlID09PSBcImFycmF5XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5kZXhlZC5wdXNoKFBhcmFtVHlwZS5mcm9tKHsgdHlwZTogXCJieXRlczMyXCIsIG5hbWU6IHBhcmFtLm5hbWUgfSkpO1xuICAgICAgICAgICAgICAgICAgICBkeW5hbWljLnB1c2godHJ1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpbmRleGVkLnB1c2gocGFyYW0pO1xuICAgICAgICAgICAgICAgICAgICBkeW5hbWljLnB1c2goZmFsc2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG5vbkluZGV4ZWQucHVzaChwYXJhbSk7XG4gICAgICAgICAgICAgICAgZHluYW1pYy5wdXNoKGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHJlc3VsdEluZGV4ZWQgPSAodG9waWNzICE9IG51bGwpID8gdGhpcy4jYWJpQ29kZXIuZGVjb2RlKGluZGV4ZWQsIGNvbmNhdCh0b3BpY3MpKSA6IG51bGw7XG4gICAgICAgIGNvbnN0IHJlc3VsdE5vbkluZGV4ZWQgPSB0aGlzLiNhYmlDb2Rlci5kZWNvZGUobm9uSW5kZXhlZCwgZGF0YSwgdHJ1ZSk7XG4gICAgICAgIC8vY29uc3QgcmVzdWx0OiAoQXJyYXk8YW55PiAmIHsgWyBrZXk6IHN0cmluZyBdOiBhbnkgfSkgPSBbIF07XG4gICAgICAgIGNvbnN0IHZhbHVlcyA9IFtdO1xuICAgICAgICBjb25zdCBrZXlzID0gW107XG4gICAgICAgIGxldCBub25JbmRleGVkSW5kZXggPSAwLCBpbmRleGVkSW5kZXggPSAwO1xuICAgICAgICBmcmFnbWVudC5pbnB1dHMuZm9yRWFjaCgocGFyYW0sIGluZGV4KSA9PiB7XG4gICAgICAgICAgICBsZXQgdmFsdWUgPSBudWxsO1xuICAgICAgICAgICAgaWYgKHBhcmFtLmluZGV4ZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0SW5kZXhlZCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gbmV3IEluZGV4ZWQobnVsbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGR5bmFtaWNbaW5kZXhdKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gbmV3IEluZGV4ZWQocmVzdWx0SW5kZXhlZFtpbmRleGVkSW5kZXgrK10pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gcmVzdWx0SW5kZXhlZFtpbmRleGVkSW5kZXgrK107XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGVycm9yO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSByZXN1bHROb25JbmRleGVkW25vbkluZGV4ZWRJbmRleCsrXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gZXJyb3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFsdWVzLnB1c2godmFsdWUpO1xuICAgICAgICAgICAga2V5cy5wdXNoKHBhcmFtLm5hbWUgfHwgbnVsbCk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gUmVzdWx0LmZyb21JdGVtcyh2YWx1ZXMsIGtleXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUGFyc2VzIGEgdHJhbnNhY3Rpb24sIGZpbmRpbmcgdGhlIG1hdGNoaW5nIGZ1bmN0aW9uIGFuZCBleHRyYWN0c1xuICAgICAqICB0aGUgcGFyYW1ldGVyIHZhbHVlcyBhbG9uZyB3aXRoIG90aGVyIHVzZWZ1bCBmdW5jdGlvbiBkZXRhaWxzLlxuICAgICAqXG4gICAgICogIElmIHRoZSBtYXRjaGluZyBmdW5jdGlvbiBjYW5ub3QgYmUgZm91bmQsIHJldHVybiBudWxsLlxuICAgICAqL1xuICAgIHBhcnNlVHJhbnNhY3Rpb24odHgpIHtcbiAgICAgICAgY29uc3QgZGF0YSA9IGdldEJ5dGVzKHR4LmRhdGEsIFwidHguZGF0YVwiKTtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBnZXRCaWdJbnQoKHR4LnZhbHVlICE9IG51bGwpID8gdHgudmFsdWUgOiAwLCBcInR4LnZhbHVlXCIpO1xuICAgICAgICBjb25zdCBmcmFnbWVudCA9IHRoaXMuZ2V0RnVuY3Rpb24oaGV4bGlmeShkYXRhLnNsaWNlKDAsIDQpKSk7XG4gICAgICAgIGlmICghZnJhZ21lbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFyZ3MgPSB0aGlzLiNhYmlDb2Rlci5kZWNvZGUoZnJhZ21lbnQuaW5wdXRzLCBkYXRhLnNsaWNlKDQpKTtcbiAgICAgICAgcmV0dXJuIG5ldyBUcmFuc2FjdGlvbkRlc2NyaXB0aW9uKGZyYWdtZW50LCBmcmFnbWVudC5zZWxlY3RvciwgYXJncywgdmFsdWUpO1xuICAgIH1cbiAgICBwYXJzZUNhbGxSZXN1bHQoZGF0YSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJAVE9ET1wiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFBhcnNlcyBhIHJlY2VpcHQgbG9nLCBmaW5kaW5nIHRoZSBtYXRjaGluZyBldmVudCBhbmQgZXh0cmFjdHNcbiAgICAgKiAgdGhlIHBhcmFtZXRlciB2YWx1ZXMgYWxvbmcgd2l0aCBvdGhlciB1c2VmdWwgZXZlbnQgZGV0YWlscy5cbiAgICAgKlxuICAgICAqICBJZiB0aGUgbWF0Y2hpbmcgZXZlbnQgY2Fubm90IGJlIGZvdW5kLCByZXR1cm5zIG51bGwuXG4gICAgICovXG4gICAgcGFyc2VMb2cobG9nKSB7XG4gICAgICAgIGNvbnN0IGZyYWdtZW50ID0gdGhpcy5nZXRFdmVudChsb2cudG9waWNzWzBdKTtcbiAgICAgICAgaWYgKCFmcmFnbWVudCB8fCBmcmFnbWVudC5hbm9ueW1vdXMpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIC8vIEBUT0RPOiBJZiBhbm9ueW1vdXMsIGFuZCB0aGUgb25seSBtZXRob2QsIGFuZCB0aGUgaW5wdXQgY291bnQgbWF0Y2hlcywgc2hvdWxkIHdlIHBhcnNlP1xuICAgICAgICAvLyAgICAgICAgUHJvYmFibHkgbm90LCBiZWNhdXNlIGp1c3QgYmVjYXVzZSBpdCBpcyB0aGUgb25seSBldmVudCBpbiB0aGUgQUJJIGRvZXNcbiAgICAgICAgLy8gICAgICAgIG5vdCBtZWFuIHdlIGhhdmUgdGhlIGZ1bGwgQUJJOyBtYXliZSBqdXN0IGEgZnJhZ21lbnQ/XG4gICAgICAgIHJldHVybiBuZXcgTG9nRGVzY3JpcHRpb24oZnJhZ21lbnQsIGZyYWdtZW50LnRvcGljSGFzaCwgdGhpcy5kZWNvZGVFdmVudExvZyhmcmFnbWVudCwgbG9nLmRhdGEsIGxvZy50b3BpY3MpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFBhcnNlcyBhIHJldmVydCBkYXRhLCBmaW5kaW5nIHRoZSBtYXRjaGluZyBlcnJvciBhbmQgZXh0cmFjdHNcbiAgICAgKiAgdGhlIHBhcmFtZXRlciB2YWx1ZXMgYWxvbmcgd2l0aCBvdGhlciB1c2VmdWwgZXJyb3IgZGV0YWlscy5cbiAgICAgKlxuICAgICAqICBJZiB0aGUgbWF0Y2hpbmcgZXJyb3IgY2Fubm90IGJlIGZvdW5kLCByZXR1cm5zIG51bGwuXG4gICAgICovXG4gICAgcGFyc2VFcnJvcihkYXRhKSB7XG4gICAgICAgIGNvbnN0IGhleERhdGEgPSBoZXhsaWZ5KGRhdGEpO1xuICAgICAgICBjb25zdCBmcmFnbWVudCA9IHRoaXMuZ2V0RXJyb3IoZGF0YVNsaWNlKGhleERhdGEsIDAsIDQpKTtcbiAgICAgICAgaWYgKCFmcmFnbWVudCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYXJncyA9IHRoaXMuI2FiaUNvZGVyLmRlY29kZShmcmFnbWVudC5pbnB1dHMsIGRhdGFTbGljZShoZXhEYXRhLCA0KSk7XG4gICAgICAgIHJldHVybiBuZXcgRXJyb3JEZXNjcmlwdGlvbihmcmFnbWVudCwgZnJhZ21lbnQuc2VsZWN0b3IsIGFyZ3MpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlcyBhIG5ldyBbW0ludGVyZmFjZV1dIGZyb20gdGhlIEFCSSAlJXZhbHVlJSUuXG4gICAgICpcbiAgICAgKiAgVGhlICUldmFsdWUlJSBtYXkgYmUgcHJvdmlkZWQgYXMgYW4gZXhpc3RpbmcgW1tJbnRlcmZhY2VdXSBvYmplY3QsXG4gICAgICogIGEgSlNPTi1lbmNvZGVkIEFCSSBvciBhbnkgSHVtYW4tUmVhZGFibGUgQUJJIGZvcm1hdC5cbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbSh2YWx1ZSkge1xuICAgICAgICAvLyBBbHJlYWR5IGFuIEludGVyZmFjZSwgd2hpY2ggaXMgaW1tdXRhYmxlXG4gICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEludGVyZmFjZSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIEpTT05cbiAgICAgICAgaWYgKHR5cGVvZiAodmFsdWUpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEludGVyZmFjZShKU09OLnBhcnNlKHZhbHVlKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQW4gSW50ZXJmYWNlOyBwb3NzaWJseSBmcm9tIGFub3RoZXIgdjYgaW5zdGFuY2VcbiAgICAgICAgaWYgKHR5cGVvZiAodmFsdWUuZm9ybWF0SnNvbikgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBJbnRlcmZhY2UodmFsdWUuZm9ybWF0SnNvbigpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBBIGxlZ2FjeSBJbnRlcmZhY2U7IGZyb20gYW4gb2xkZXIgdmVyc2lvblxuICAgICAgICBpZiAodHlwZW9mICh2YWx1ZS5mb3JtYXQpID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSW50ZXJmYWNlKHZhbHVlLmZvcm1hdChcImpzb25cIikpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEFycmF5IG9mIGZyYWdtZW50c1xuICAgICAgICByZXR1cm4gbmV3IEludGVyZmFjZSh2YWx1ZSk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW50ZXJmYWNlLmpzLm1hcCJdLCJuYW1lcyI6WyJrZWNjYWsyNTYiLCJpZCIsImNvbmNhdCIsImRhdGFTbGljZSIsImdldEJpZ0ludCIsImdldEJ5dGVzIiwiZ2V0Qnl0ZXNDb3B5IiwiaGV4bGlmeSIsInplcm9QYWRCeXRlcyIsInplcm9QYWRWYWx1ZSIsImlzSGV4U3RyaW5nIiwiZGVmaW5lUHJvcGVydGllcyIsImFzc2VydEFyZ3VtZW50IiwidG9CZUhleCIsImFzc2VydCIsIkFiaUNvZGVyIiwiY2hlY2tSZXN1bHRFcnJvcnMiLCJSZXN1bHQiLCJDb25zdHJ1Y3RvckZyYWdtZW50IiwiRXJyb3JGcmFnbWVudCIsIkV2ZW50RnJhZ21lbnQiLCJGcmFnbWVudCIsIkZ1bmN0aW9uRnJhZ21lbnQiLCJQYXJhbVR5cGUiLCJUeXBlZCIsIkxvZ0Rlc2NyaXB0aW9uIiwiY29uc3RydWN0b3IiLCJmcmFnbWVudCIsInRvcGljIiwiYXJncyIsIm5hbWUiLCJzaWduYXR1cmUiLCJmb3JtYXQiLCJUcmFuc2FjdGlvbkRlc2NyaXB0aW9uIiwic2VsZWN0b3IiLCJ2YWx1ZSIsIkVycm9yRGVzY3JpcHRpb24iLCJJbmRleGVkIiwiaXNJbmRleGVkIiwiX2lzSW5kZXhlZCIsImhhc2giLCJQYW5pY1JlYXNvbnMiLCJCdWlsdGluRXJyb3JzIiwiaW5wdXRzIiwicmVhc29uIiwibWVzc2FnZSIsIkpTT04iLCJzdHJpbmdpZnkiLCJjb2RlIiwidG9TdHJpbmciLCJJbnRlcmZhY2UiLCJlcnJvcnMiLCJldmVudHMiLCJmdW5jdGlvbnMiLCJhYmlDb2RlciIsImZyYWdtZW50cyIsImFiaSIsInBhcnNlIiwiTWFwIiwiZnJhZ3MiLCJhIiwicHVzaCIsImZyb20iLCJlcnJvciIsImNvbnNvbGUiLCJsb2ciLCJPYmplY3QiLCJmcmVlemUiLCJmYWxsYmFjayIsInJlY2VpdmUiLCJnZXRBYmlDb2RlciIsImZvckVhY2giLCJpbmRleCIsImJ1Y2tldCIsInR5cGUiLCJkZXBsb3kiLCJsZW5ndGgiLCJwYXlhYmxlIiwiaGFzIiwic2V0IiwibWluaW1hbCIsIm1hcCIsImYiLCJmb3JtYXRKc29uIiwiaiIsImRlZmF1bHRBYmlDb2RlciIsImdldEZ1bmN0aW9uIiwia2V5IiwidmFsdWVzIiwiZm9yY2VVbmlxdWUiLCJ0b0xvd2VyQ2FzZSIsImluZGV4T2YiLCJtYXRjaGluZyIsInNwbGl0IiwibGFzdFZhbHVlIiwidmFsdWVMZW5ndGgiLCJhbGxvd09wdGlvbnMiLCJpc1R5cGVkIiwiaSIsInNwbGljZSIsImJhc2VUeXBlIiwibGFzdEFyZyIsIkFycmF5IiwiaXNBcnJheSIsIm1hdGNoU3RyIiwibSIsImpvaW4iLCJyZXN1bHQiLCJnZXQiLCJnZXRGdW5jdGlvbk5hbWUiLCJoYXNGdW5jdGlvbiIsImZvckVhY2hGdW5jdGlvbiIsImNhbGxiYWNrIiwibmFtZXMiLCJrZXlzIiwic29ydCIsImIiLCJsb2NhbGVDb21wYXJlIiwiZ2V0RXZlbnQiLCJldmVudFRvcGljIiwidG9waWNIYXNoIiwiZ2V0RXZlbnROYW1lIiwiaGFzRXZlbnQiLCJmb3JFYWNoRXZlbnQiLCJnZXRFcnJvciIsImZvckVhY2hFcnJvciIsIl9kZWNvZGVQYXJhbXMiLCJwYXJhbXMiLCJkYXRhIiwiZGVjb2RlIiwiX2VuY29kZVBhcmFtcyIsImVuY29kZSIsImVuY29kZURlcGxveSIsImRlY29kZUVycm9yUmVzdWx0IiwiZW5jb2RlRXJyb3JSZXN1bHQiLCJkZWNvZGVGdW5jdGlvbkRhdGEiLCJlbmNvZGVGdW5jdGlvbkRhdGEiLCJkZWNvZGVGdW5jdGlvblJlc3VsdCIsImJ5dGVzIiwib3V0cHV0cyIsImluZm8iLCJtZXRob2QiLCJtYWtlRXJyb3IiLCJfZGF0YSIsInR4IiwiZ2V0QnVpbHRpbkNhbGxFeGNlcHRpb24iLCJjdXN0b21QcmVmaXgiLCJzdGFydHNXaXRoIiwic2xpY2UiLCJlZiIsInJldmVydCIsImUiLCJwYXJzZWQiLCJwYXJzZVRyYW5zYWN0aW9uIiwiaW52b2NhdGlvbiIsImVuY29kZUZ1bmN0aW9uUmVzdWx0IiwiZW5jb2RlRmlsdGVyVG9waWNzIiwiY291bnQiLCJleHBlY3RlZENvdW50IiwidG9waWNzIiwiYW5vbnltb3VzIiwiZW5jb2RlVG9waWMiLCJwYXJhbSIsIm1hdGNoIiwiaW5kZXhlZCIsInBvcCIsImVuY29kZUV2ZW50TG9nIiwiZGF0YVR5cGVzIiwiZGF0YVZhbHVlcyIsIkVycm9yIiwiZGVjb2RlRXZlbnRMb2ciLCJub25JbmRleGVkIiwiZHluYW1pYyIsInJlc3VsdEluZGV4ZWQiLCJyZXN1bHROb25JbmRleGVkIiwibm9uSW5kZXhlZEluZGV4IiwiaW5kZXhlZEluZGV4IiwiZnJvbUl0ZW1zIiwicGFyc2VDYWxsUmVzdWx0IiwicGFyc2VMb2ciLCJwYXJzZUVycm9yIiwiaGV4RGF0YSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.esm/abi/interface.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.esm/abi/typed.js":
/*!**************************************************!*\
  !*** ./node_modules/ethers/lib.esm/abi/typed.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Typed: () => (/* binding */ Typed)\n/* harmony export */ });\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/errors.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/properties.js\");\n/**\n *  A Typed object allows a value to have its type explicitly\n *  specified.\n *\n *  For example, in Solidity, the value ``45`` could represent a\n *  ``uint8`` or a ``uint256``. The value ``0x1234`` could represent\n *  a ``bytes2`` or ``bytes``.\n *\n *  Since JavaScript has no meaningful way to explicitly inform any\n *  APIs which what the type is, this allows transparent interoperation\n *  with Soldity.\n *\n *  @_subsection: api/abi:Typed Values\n */ \nconst _gaurd = {};\nfunction n(value, width) {\n    let signed = false;\n    if (width < 0) {\n        signed = true;\n        width *= -1;\n    }\n    // @TODO: Check range is valid for value\n    return new Typed(_gaurd, `${signed ? \"\" : \"u\"}int${width}`, value, {\n        signed,\n        width\n    });\n}\nfunction b(value, size) {\n    // @TODO: Check range is valid for value\n    return new Typed(_gaurd, `bytes${size ? size : \"\"}`, value, {\n        size\n    });\n}\nconst _typedSymbol = Symbol.for(\"_ethers_typed\");\n/**\n *  The **Typed** class to wrap values providing explicit type information.\n */ class Typed {\n    #options;\n    /**\n     *  @_ignore:\n     */ constructor(gaurd, type, value, options){\n        if (options == null) {\n            options = null;\n        }\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertPrivate)(_gaurd, gaurd, \"Typed\");\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.defineProperties)(this, {\n            _typedSymbol,\n            type,\n            value\n        });\n        this.#options = options;\n        // Check the value is valid\n        this.format();\n    }\n    /**\n     *  Format the type as a Human-Readable type.\n     */ format() {\n        if (this.type === \"array\") {\n            throw new Error(\"\");\n        } else if (this.type === \"dynamicArray\") {\n            throw new Error(\"\");\n        } else if (this.type === \"tuple\") {\n            return `tuple(${this.value.map((v)=>v.format()).join(\",\")})`;\n        }\n        return this.type;\n    }\n    /**\n     *  The default value returned by this type.\n     */ defaultValue() {\n        return 0;\n    }\n    /**\n     *  The minimum value for numeric types.\n     */ minValue() {\n        return 0;\n    }\n    /**\n     *  The maximum value for numeric types.\n     */ maxValue() {\n        return 0;\n    }\n    /**\n     *  Returns ``true`` and provides a type guard is this is a [[TypedBigInt]].\n     */ isBigInt() {\n        return !!this.type.match(/^u?int[0-9]+$/);\n    }\n    /**\n     *  Returns ``true`` and provides a type guard is this is a [[TypedData]].\n     */ isData() {\n        return this.type.startsWith(\"bytes\");\n    }\n    /**\n     *  Returns ``true`` and provides a type guard is this is a [[TypedString]].\n     */ isString() {\n        return this.type === \"string\";\n    }\n    /**\n     *  Returns the tuple name, if this is a tuple. Throws otherwise.\n     */ get tupleName() {\n        if (this.type !== \"tuple\") {\n            throw TypeError(\"not a tuple\");\n        }\n        return this.#options;\n    }\n    // Returns the length of this type as an array\n    // - `null` indicates the length is unforced, it could be dynamic\n    // - `-1` indicates the length is dynamic\n    // - any other value indicates it is a static array and is its length\n    /**\n     *  Returns the length of the array type or ``-1`` if it is dynamic.\n     *\n     *  Throws if the type is not an array.\n     */ get arrayLength() {\n        if (this.type !== \"array\") {\n            throw TypeError(\"not an array\");\n        }\n        if (this.#options === true) {\n            return -1;\n        }\n        if (this.#options === false) {\n            return this.value.length;\n        }\n        return null;\n    }\n    /**\n     *  Returns a new **Typed** of %%type%% with the %%value%%.\n     */ static from(type, value) {\n        return new Typed(_gaurd, type, value);\n    }\n    /**\n     *  Return a new ``uint8`` type for %%v%%.\n     */ static uint8(v) {\n        return n(v, 8);\n    }\n    /**\n     *  Return a new ``uint16`` type for %%v%%.\n     */ static uint16(v) {\n        return n(v, 16);\n    }\n    /**\n     *  Return a new ``uint24`` type for %%v%%.\n     */ static uint24(v) {\n        return n(v, 24);\n    }\n    /**\n     *  Return a new ``uint32`` type for %%v%%.\n     */ static uint32(v) {\n        return n(v, 32);\n    }\n    /**\n     *  Return a new ``uint40`` type for %%v%%.\n     */ static uint40(v) {\n        return n(v, 40);\n    }\n    /**\n     *  Return a new ``uint48`` type for %%v%%.\n     */ static uint48(v) {\n        return n(v, 48);\n    }\n    /**\n     *  Return a new ``uint56`` type for %%v%%.\n     */ static uint56(v) {\n        return n(v, 56);\n    }\n    /**\n     *  Return a new ``uint64`` type for %%v%%.\n     */ static uint64(v) {\n        return n(v, 64);\n    }\n    /**\n     *  Return a new ``uint72`` type for %%v%%.\n     */ static uint72(v) {\n        return n(v, 72);\n    }\n    /**\n     *  Return a new ``uint80`` type for %%v%%.\n     */ static uint80(v) {\n        return n(v, 80);\n    }\n    /**\n     *  Return a new ``uint88`` type for %%v%%.\n     */ static uint88(v) {\n        return n(v, 88);\n    }\n    /**\n     *  Return a new ``uint96`` type for %%v%%.\n     */ static uint96(v) {\n        return n(v, 96);\n    }\n    /**\n     *  Return a new ``uint104`` type for %%v%%.\n     */ static uint104(v) {\n        return n(v, 104);\n    }\n    /**\n     *  Return a new ``uint112`` type for %%v%%.\n     */ static uint112(v) {\n        return n(v, 112);\n    }\n    /**\n     *  Return a new ``uint120`` type for %%v%%.\n     */ static uint120(v) {\n        return n(v, 120);\n    }\n    /**\n     *  Return a new ``uint128`` type for %%v%%.\n     */ static uint128(v) {\n        return n(v, 128);\n    }\n    /**\n     *  Return a new ``uint136`` type for %%v%%.\n     */ static uint136(v) {\n        return n(v, 136);\n    }\n    /**\n     *  Return a new ``uint144`` type for %%v%%.\n     */ static uint144(v) {\n        return n(v, 144);\n    }\n    /**\n     *  Return a new ``uint152`` type for %%v%%.\n     */ static uint152(v) {\n        return n(v, 152);\n    }\n    /**\n     *  Return a new ``uint160`` type for %%v%%.\n     */ static uint160(v) {\n        return n(v, 160);\n    }\n    /**\n     *  Return a new ``uint168`` type for %%v%%.\n     */ static uint168(v) {\n        return n(v, 168);\n    }\n    /**\n     *  Return a new ``uint176`` type for %%v%%.\n     */ static uint176(v) {\n        return n(v, 176);\n    }\n    /**\n     *  Return a new ``uint184`` type for %%v%%.\n     */ static uint184(v) {\n        return n(v, 184);\n    }\n    /**\n     *  Return a new ``uint192`` type for %%v%%.\n     */ static uint192(v) {\n        return n(v, 192);\n    }\n    /**\n     *  Return a new ``uint200`` type for %%v%%.\n     */ static uint200(v) {\n        return n(v, 200);\n    }\n    /**\n     *  Return a new ``uint208`` type for %%v%%.\n     */ static uint208(v) {\n        return n(v, 208);\n    }\n    /**\n     *  Return a new ``uint216`` type for %%v%%.\n     */ static uint216(v) {\n        return n(v, 216);\n    }\n    /**\n     *  Return a new ``uint224`` type for %%v%%.\n     */ static uint224(v) {\n        return n(v, 224);\n    }\n    /**\n     *  Return a new ``uint232`` type for %%v%%.\n     */ static uint232(v) {\n        return n(v, 232);\n    }\n    /**\n     *  Return a new ``uint240`` type for %%v%%.\n     */ static uint240(v) {\n        return n(v, 240);\n    }\n    /**\n     *  Return a new ``uint248`` type for %%v%%.\n     */ static uint248(v) {\n        return n(v, 248);\n    }\n    /**\n     *  Return a new ``uint256`` type for %%v%%.\n     */ static uint256(v) {\n        return n(v, 256);\n    }\n    /**\n     *  Return a new ``uint256`` type for %%v%%.\n     */ static uint(v) {\n        return n(v, 256);\n    }\n    /**\n     *  Return a new ``int8`` type for %%v%%.\n     */ static int8(v) {\n        return n(v, -8);\n    }\n    /**\n     *  Return a new ``int16`` type for %%v%%.\n     */ static int16(v) {\n        return n(v, -16);\n    }\n    /**\n     *  Return a new ``int24`` type for %%v%%.\n     */ static int24(v) {\n        return n(v, -24);\n    }\n    /**\n     *  Return a new ``int32`` type for %%v%%.\n     */ static int32(v) {\n        return n(v, -32);\n    }\n    /**\n     *  Return a new ``int40`` type for %%v%%.\n     */ static int40(v) {\n        return n(v, -40);\n    }\n    /**\n     *  Return a new ``int48`` type for %%v%%.\n     */ static int48(v) {\n        return n(v, -48);\n    }\n    /**\n     *  Return a new ``int56`` type for %%v%%.\n     */ static int56(v) {\n        return n(v, -56);\n    }\n    /**\n     *  Return a new ``int64`` type for %%v%%.\n     */ static int64(v) {\n        return n(v, -64);\n    }\n    /**\n     *  Return a new ``int72`` type for %%v%%.\n     */ static int72(v) {\n        return n(v, -72);\n    }\n    /**\n     *  Return a new ``int80`` type for %%v%%.\n     */ static int80(v) {\n        return n(v, -80);\n    }\n    /**\n     *  Return a new ``int88`` type for %%v%%.\n     */ static int88(v) {\n        return n(v, -88);\n    }\n    /**\n     *  Return a new ``int96`` type for %%v%%.\n     */ static int96(v) {\n        return n(v, -96);\n    }\n    /**\n     *  Return a new ``int104`` type for %%v%%.\n     */ static int104(v) {\n        return n(v, -104);\n    }\n    /**\n     *  Return a new ``int112`` type for %%v%%.\n     */ static int112(v) {\n        return n(v, -112);\n    }\n    /**\n     *  Return a new ``int120`` type for %%v%%.\n     */ static int120(v) {\n        return n(v, -120);\n    }\n    /**\n     *  Return a new ``int128`` type for %%v%%.\n     */ static int128(v) {\n        return n(v, -128);\n    }\n    /**\n     *  Return a new ``int136`` type for %%v%%.\n     */ static int136(v) {\n        return n(v, -136);\n    }\n    /**\n     *  Return a new ``int144`` type for %%v%%.\n     */ static int144(v) {\n        return n(v, -144);\n    }\n    /**\n     *  Return a new ``int52`` type for %%v%%.\n     */ static int152(v) {\n        return n(v, -152);\n    }\n    /**\n     *  Return a new ``int160`` type for %%v%%.\n     */ static int160(v) {\n        return n(v, -160);\n    }\n    /**\n     *  Return a new ``int168`` type for %%v%%.\n     */ static int168(v) {\n        return n(v, -168);\n    }\n    /**\n     *  Return a new ``int176`` type for %%v%%.\n     */ static int176(v) {\n        return n(v, -176);\n    }\n    /**\n     *  Return a new ``int184`` type for %%v%%.\n     */ static int184(v) {\n        return n(v, -184);\n    }\n    /**\n     *  Return a new ``int92`` type for %%v%%.\n     */ static int192(v) {\n        return n(v, -192);\n    }\n    /**\n     *  Return a new ``int200`` type for %%v%%.\n     */ static int200(v) {\n        return n(v, -200);\n    }\n    /**\n     *  Return a new ``int208`` type for %%v%%.\n     */ static int208(v) {\n        return n(v, -208);\n    }\n    /**\n     *  Return a new ``int216`` type for %%v%%.\n     */ static int216(v) {\n        return n(v, -216);\n    }\n    /**\n     *  Return a new ``int224`` type for %%v%%.\n     */ static int224(v) {\n        return n(v, -224);\n    }\n    /**\n     *  Return a new ``int232`` type for %%v%%.\n     */ static int232(v) {\n        return n(v, -232);\n    }\n    /**\n     *  Return a new ``int240`` type for %%v%%.\n     */ static int240(v) {\n        return n(v, -240);\n    }\n    /**\n     *  Return a new ``int248`` type for %%v%%.\n     */ static int248(v) {\n        return n(v, -248);\n    }\n    /**\n     *  Return a new ``int256`` type for %%v%%.\n     */ static int256(v) {\n        return n(v, -256);\n    }\n    /**\n     *  Return a new ``int256`` type for %%v%%.\n     */ static int(v) {\n        return n(v, -256);\n    }\n    /**\n     *  Return a new ``bytes1`` type for %%v%%.\n     */ static bytes1(v) {\n        return b(v, 1);\n    }\n    /**\n     *  Return a new ``bytes2`` type for %%v%%.\n     */ static bytes2(v) {\n        return b(v, 2);\n    }\n    /**\n     *  Return a new ``bytes3`` type for %%v%%.\n     */ static bytes3(v) {\n        return b(v, 3);\n    }\n    /**\n     *  Return a new ``bytes4`` type for %%v%%.\n     */ static bytes4(v) {\n        return b(v, 4);\n    }\n    /**\n     *  Return a new ``bytes5`` type for %%v%%.\n     */ static bytes5(v) {\n        return b(v, 5);\n    }\n    /**\n     *  Return a new ``bytes6`` type for %%v%%.\n     */ static bytes6(v) {\n        return b(v, 6);\n    }\n    /**\n     *  Return a new ``bytes7`` type for %%v%%.\n     */ static bytes7(v) {\n        return b(v, 7);\n    }\n    /**\n     *  Return a new ``bytes8`` type for %%v%%.\n     */ static bytes8(v) {\n        return b(v, 8);\n    }\n    /**\n     *  Return a new ``bytes9`` type for %%v%%.\n     */ static bytes9(v) {\n        return b(v, 9);\n    }\n    /**\n     *  Return a new ``bytes10`` type for %%v%%.\n     */ static bytes10(v) {\n        return b(v, 10);\n    }\n    /**\n     *  Return a new ``bytes11`` type for %%v%%.\n     */ static bytes11(v) {\n        return b(v, 11);\n    }\n    /**\n     *  Return a new ``bytes12`` type for %%v%%.\n     */ static bytes12(v) {\n        return b(v, 12);\n    }\n    /**\n     *  Return a new ``bytes13`` type for %%v%%.\n     */ static bytes13(v) {\n        return b(v, 13);\n    }\n    /**\n     *  Return a new ``bytes14`` type for %%v%%.\n     */ static bytes14(v) {\n        return b(v, 14);\n    }\n    /**\n     *  Return a new ``bytes15`` type for %%v%%.\n     */ static bytes15(v) {\n        return b(v, 15);\n    }\n    /**\n     *  Return a new ``bytes16`` type for %%v%%.\n     */ static bytes16(v) {\n        return b(v, 16);\n    }\n    /**\n     *  Return a new ``bytes17`` type for %%v%%.\n     */ static bytes17(v) {\n        return b(v, 17);\n    }\n    /**\n     *  Return a new ``bytes18`` type for %%v%%.\n     */ static bytes18(v) {\n        return b(v, 18);\n    }\n    /**\n     *  Return a new ``bytes19`` type for %%v%%.\n     */ static bytes19(v) {\n        return b(v, 19);\n    }\n    /**\n     *  Return a new ``bytes20`` type for %%v%%.\n     */ static bytes20(v) {\n        return b(v, 20);\n    }\n    /**\n     *  Return a new ``bytes21`` type for %%v%%.\n     */ static bytes21(v) {\n        return b(v, 21);\n    }\n    /**\n     *  Return a new ``bytes22`` type for %%v%%.\n     */ static bytes22(v) {\n        return b(v, 22);\n    }\n    /**\n     *  Return a new ``bytes23`` type for %%v%%.\n     */ static bytes23(v) {\n        return b(v, 23);\n    }\n    /**\n     *  Return a new ``bytes24`` type for %%v%%.\n     */ static bytes24(v) {\n        return b(v, 24);\n    }\n    /**\n     *  Return a new ``bytes25`` type for %%v%%.\n     */ static bytes25(v) {\n        return b(v, 25);\n    }\n    /**\n     *  Return a new ``bytes26`` type for %%v%%.\n     */ static bytes26(v) {\n        return b(v, 26);\n    }\n    /**\n     *  Return a new ``bytes27`` type for %%v%%.\n     */ static bytes27(v) {\n        return b(v, 27);\n    }\n    /**\n     *  Return a new ``bytes28`` type for %%v%%.\n     */ static bytes28(v) {\n        return b(v, 28);\n    }\n    /**\n     *  Return a new ``bytes29`` type for %%v%%.\n     */ static bytes29(v) {\n        return b(v, 29);\n    }\n    /**\n     *  Return a new ``bytes30`` type for %%v%%.\n     */ static bytes30(v) {\n        return b(v, 30);\n    }\n    /**\n     *  Return a new ``bytes31`` type for %%v%%.\n     */ static bytes31(v) {\n        return b(v, 31);\n    }\n    /**\n     *  Return a new ``bytes32`` type for %%v%%.\n     */ static bytes32(v) {\n        return b(v, 32);\n    }\n    /**\n     *  Return a new ``address`` type for %%v%%.\n     */ static address(v) {\n        return new Typed(_gaurd, \"address\", v);\n    }\n    /**\n     *  Return a new ``bool`` type for %%v%%.\n     */ static bool(v) {\n        return new Typed(_gaurd, \"bool\", !!v);\n    }\n    /**\n     *  Return a new ``bytes`` type for %%v%%.\n     */ static bytes(v) {\n        return new Typed(_gaurd, \"bytes\", v);\n    }\n    /**\n     *  Return a new ``string`` type for %%v%%.\n     */ static string(v) {\n        return new Typed(_gaurd, \"string\", v);\n    }\n    /**\n     *  Return a new ``array`` type for %%v%%, allowing %%dynamic%% length.\n     */ static array(v, dynamic) {\n        throw new Error(\"not implemented yet\");\n        return new Typed(_gaurd, \"array\", v, dynamic);\n    }\n    /**\n     *  Return a new ``tuple`` type for %%v%%, with the optional %%name%%.\n     */ static tuple(v, name) {\n        throw new Error(\"not implemented yet\");\n        return new Typed(_gaurd, \"tuple\", v, name);\n    }\n    /**\n     *  Return a new ``uint8`` type for %%v%%.\n     */ static overrides(v) {\n        return new Typed(_gaurd, \"overrides\", Object.assign({}, v));\n    }\n    /**\n     *  Returns true only if %%value%% is a [[Typed]] instance.\n     */ static isTyped(value) {\n        return value && typeof value === \"object\" && \"_typedSymbol\" in value && value._typedSymbol === _typedSymbol;\n    }\n    /**\n     *  If the value is a [[Typed]] instance, validates the underlying value\n     *  and returns it, otherwise returns value directly.\n     *\n     *  This is useful for functions that with to accept either a [[Typed]]\n     *  object or values.\n     */ static dereference(value, type) {\n        if (Typed.isTyped(value)) {\n            if (value.type !== type) {\n                throw new Error(`invalid type: expecetd ${type}, got ${value.type}`);\n            }\n            return value.value;\n        }\n        return value;\n    }\n} //# sourceMappingURL=typed.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vYWJpL3R5cGVkLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBOzs7Ozs7Ozs7Ozs7O0NBYUMsR0FDbUU7QUFDcEUsTUFBTUUsU0FBUyxDQUFDO0FBQ2hCLFNBQVNDLEVBQUVDLEtBQUssRUFBRUMsS0FBSztJQUNuQixJQUFJQyxTQUFTO0lBQ2IsSUFBSUQsUUFBUSxHQUFHO1FBQ1hDLFNBQVM7UUFDVEQsU0FBUyxDQUFDO0lBQ2Q7SUFDQSx3Q0FBd0M7SUFDeEMsT0FBTyxJQUFJRSxNQUFNTCxRQUFRLENBQUMsRUFBRUksU0FBUyxLQUFLLElBQUksR0FBRyxFQUFFRCxNQUFNLENBQUMsRUFBRUQsT0FBTztRQUFFRTtRQUFRRDtJQUFNO0FBQ3ZGO0FBQ0EsU0FBU0csRUFBRUosS0FBSyxFQUFFSyxJQUFJO0lBQ2xCLHdDQUF3QztJQUN4QyxPQUFPLElBQUlGLE1BQU1MLFFBQVEsQ0FBQyxLQUFLLEVBQUUsT0FBU08sT0FBTyxHQUFHLENBQUMsRUFBRUwsT0FBTztRQUFFSztJQUFLO0FBQ3pFO0FBQ0EsTUFBTUMsZUFBZUMsT0FBT0MsR0FBRyxDQUFDO0FBQ2hDOztDQUVDLEdBQ00sTUFBTUw7SUFTVCxDQUFDTSxPQUFPLENBQUM7SUFLVDs7S0FFQyxHQUNEQyxZQUFZQyxLQUFLLEVBQUVDLElBQUksRUFBRVosS0FBSyxFQUFFUyxPQUFPLENBQUU7UUFDckMsSUFBSUEsV0FBVyxNQUFNO1lBQ2pCQSxVQUFVO1FBQ2Q7UUFDQWIsOERBQWFBLENBQUNFLFFBQVFhLE9BQU87UUFDN0JkLGlFQUFnQkEsQ0FBQyxJQUFJLEVBQUU7WUFBRVM7WUFBY007WUFBTVo7UUFBTTtRQUNuRCxJQUFJLENBQUMsQ0FBQ1MsT0FBTyxHQUFHQTtRQUNoQiwyQkFBMkI7UUFDM0IsSUFBSSxDQUFDSSxNQUFNO0lBQ2Y7SUFDQTs7S0FFQyxHQUNEQSxTQUFTO1FBQ0wsSUFBSSxJQUFJLENBQUNELElBQUksS0FBSyxTQUFTO1lB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QkFDckIsTUFBTSxJQUFJRSxNQUFNLENBQUMsdUJBQXVCLEVBQUVGLEtBQUssTUFBTSxFQUFFWixNQUFNWSxJQUFJLENBQUMsQ0FBQztZQUN2RTtZQUNBLE9BQU9aLE1BQU1BLEtBQUs7UUFDdEI7UUFDQSxPQUFPQTtJQUNYO0FBQ0osRUFDQSxpQ0FBaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tZWdhdmliZS1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9hYmkvdHlwZWQuanM/MmRlNCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqICBBIFR5cGVkIG9iamVjdCBhbGxvd3MgYSB2YWx1ZSB0byBoYXZlIGl0cyB0eXBlIGV4cGxpY2l0bHlcbiAqICBzcGVjaWZpZWQuXG4gKlxuICogIEZvciBleGFtcGxlLCBpbiBTb2xpZGl0eSwgdGhlIHZhbHVlIGBgNDVgYCBjb3VsZCByZXByZXNlbnQgYVxuICogIGBgdWludDhgYCBvciBhIGBgdWludDI1NmBgLiBUaGUgdmFsdWUgYGAweDEyMzRgYCBjb3VsZCByZXByZXNlbnRcbiAqICBhIGBgYnl0ZXMyYGAgb3IgYGBieXRlc2BgLlxuICpcbiAqICBTaW5jZSBKYXZhU2NyaXB0IGhhcyBubyBtZWFuaW5nZnVsIHdheSB0byBleHBsaWNpdGx5IGluZm9ybSBhbnlcbiAqICBBUElzIHdoaWNoIHdoYXQgdGhlIHR5cGUgaXMsIHRoaXMgYWxsb3dzIHRyYW5zcGFyZW50IGludGVyb3BlcmF0aW9uXG4gKiAgd2l0aCBTb2xkaXR5LlxuICpcbiAqICBAX3N1YnNlY3Rpb246IGFwaS9hYmk6VHlwZWQgVmFsdWVzXG4gKi9cbmltcG9ydCB7IGFzc2VydFByaXZhdGUsIGRlZmluZVByb3BlcnRpZXMgfSBmcm9tIFwiLi4vdXRpbHMvaW5kZXguanNcIjtcbmNvbnN0IF9nYXVyZCA9IHt9O1xuZnVuY3Rpb24gbih2YWx1ZSwgd2lkdGgpIHtcbiAgICBsZXQgc2lnbmVkID0gZmFsc2U7XG4gICAgaWYgKHdpZHRoIDwgMCkge1xuICAgICAgICBzaWduZWQgPSB0cnVlO1xuICAgICAgICB3aWR0aCAqPSAtMTtcbiAgICB9XG4gICAgLy8gQFRPRE86IENoZWNrIHJhbmdlIGlzIHZhbGlkIGZvciB2YWx1ZVxuICAgIHJldHVybiBuZXcgVHlwZWQoX2dhdXJkLCBgJHtzaWduZWQgPyBcIlwiIDogXCJ1XCJ9aW50JHt3aWR0aH1gLCB2YWx1ZSwgeyBzaWduZWQsIHdpZHRoIH0pO1xufVxuZnVuY3Rpb24gYih2YWx1ZSwgc2l6ZSkge1xuICAgIC8vIEBUT0RPOiBDaGVjayByYW5nZSBpcyB2YWxpZCBmb3IgdmFsdWVcbiAgICByZXR1cm4gbmV3IFR5cGVkKF9nYXVyZCwgYGJ5dGVzJHsoc2l6ZSkgPyBzaXplIDogXCJcIn1gLCB2YWx1ZSwgeyBzaXplIH0pO1xufVxuY29uc3QgX3R5cGVkU3ltYm9sID0gU3ltYm9sLmZvcihcIl9ldGhlcnNfdHlwZWRcIik7XG4vKipcbiAqICBUaGUgKipUeXBlZCoqIGNsYXNzIHRvIHdyYXAgdmFsdWVzIHByb3ZpZGluZyBleHBsaWNpdCB0eXBlIGluZm9ybWF0aW9uLlxuICovXG5leHBvcnQgY2xhc3MgVHlwZWQge1xuICAgIC8qKlxuICAgICAqICBUaGUgdHlwZSwgYXMgYSBTb2xpZGl0eS1jb21wYXRpYmxlIHR5cGUuXG4gICAgICovXG4gICAgdHlwZTtcbiAgICAvKipcbiAgICAgKiAgVGhlIGFjdHVhbCB2YWx1ZS5cbiAgICAgKi9cbiAgICB2YWx1ZTtcbiAgICAjb3B0aW9ucztcbiAgICAvKipcbiAgICAgKiAgQF9pZ25vcmU6XG4gICAgICovXG4gICAgX3R5cGVkU3ltYm9sO1xuICAgIC8qKlxuICAgICAqICBAX2lnbm9yZTpcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihnYXVyZCwgdHlwZSwgdmFsdWUsIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMgPT0gbnVsbCkge1xuICAgICAgICAgICAgb3B0aW9ucyA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgYXNzZXJ0UHJpdmF0ZShfZ2F1cmQsIGdhdXJkLCBcIlR5cGVkXCIpO1xuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHsgX3R5cGVkU3ltYm9sLCB0eXBlLCB2YWx1ZSB9KTtcbiAgICAgICAgdGhpcy4jb3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgIC8vIENoZWNrIHRoZSB2YWx1ZSBpcyB2YWxpZFxuICAgICAgICB0aGlzLmZvcm1hdCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgRm9ybWF0IHRoZSB0eXBlIGFzIGEgSHVtYW4tUmVhZGFibGUgdHlwZS5cbiAgICAgKi9cbiAgICBmb3JtYXQoKSB7XG4gICAgICAgIGlmICh0aGlzLnR5cGUgPT09IFwiYXJyYXlcIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiXCIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMudHlwZSA9PT0gXCJkeW5hbWljQXJyYXlcIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiXCIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMudHlwZSA9PT0gXCJ0dXBsZVwiKSB7XG4gICAgICAgICAgICByZXR1cm4gYHR1cGxlKCR7dGhpcy52YWx1ZS5tYXAoKHYpID0+IHYuZm9ybWF0KCkpLmpvaW4oXCIsXCIpfSlgO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnR5cGU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgZGVmYXVsdCB2YWx1ZSByZXR1cm5lZCBieSB0aGlzIHR5cGUuXG4gICAgICovXG4gICAgZGVmYXVsdFZhbHVlKCkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRoZSBtaW5pbXVtIHZhbHVlIGZvciBudW1lcmljIHR5cGVzLlxuICAgICAqL1xuICAgIG1pblZhbHVlKCkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRoZSBtYXhpbXVtIHZhbHVlIGZvciBudW1lcmljIHR5cGVzLlxuICAgICAqL1xuICAgIG1heFZhbHVlKCkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYGB0cnVlYGAgYW5kIHByb3ZpZGVzIGEgdHlwZSBndWFyZCBpcyB0aGlzIGlzIGEgW1tUeXBlZEJpZ0ludF1dLlxuICAgICAqL1xuICAgIGlzQmlnSW50KCkge1xuICAgICAgICByZXR1cm4gISEodGhpcy50eXBlLm1hdGNoKC9edT9pbnRbMC05XSskLykpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBgYHRydWVgYCBhbmQgcHJvdmlkZXMgYSB0eXBlIGd1YXJkIGlzIHRoaXMgaXMgYSBbW1R5cGVkRGF0YV1dLlxuICAgICAqL1xuICAgIGlzRGF0YSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHlwZS5zdGFydHNXaXRoKFwiYnl0ZXNcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGBgdHJ1ZWBgIGFuZCBwcm92aWRlcyBhIHR5cGUgZ3VhcmQgaXMgdGhpcyBpcyBhIFtbVHlwZWRTdHJpbmddXS5cbiAgICAgKi9cbiAgICBpc1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLnR5cGUgPT09IFwic3RyaW5nXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0aGUgdHVwbGUgbmFtZSwgaWYgdGhpcyBpcyBhIHR1cGxlLiBUaHJvd3Mgb3RoZXJ3aXNlLlxuICAgICAqL1xuICAgIGdldCB0dXBsZU5hbWUoKSB7XG4gICAgICAgIGlmICh0aGlzLnR5cGUgIT09IFwidHVwbGVcIikge1xuICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwibm90IGEgdHVwbGVcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuI29wdGlvbnM7XG4gICAgfVxuICAgIC8vIFJldHVybnMgdGhlIGxlbmd0aCBvZiB0aGlzIHR5cGUgYXMgYW4gYXJyYXlcbiAgICAvLyAtIGBudWxsYCBpbmRpY2F0ZXMgdGhlIGxlbmd0aCBpcyB1bmZvcmNlZCwgaXQgY291bGQgYmUgZHluYW1pY1xuICAgIC8vIC0gYC0xYCBpbmRpY2F0ZXMgdGhlIGxlbmd0aCBpcyBkeW5hbWljXG4gICAgLy8gLSBhbnkgb3RoZXIgdmFsdWUgaW5kaWNhdGVzIGl0IGlzIGEgc3RhdGljIGFycmF5IGFuZCBpcyBpdHMgbGVuZ3RoXG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdGhlIGxlbmd0aCBvZiB0aGUgYXJyYXkgdHlwZSBvciBgYC0xYGAgaWYgaXQgaXMgZHluYW1pYy5cbiAgICAgKlxuICAgICAqICBUaHJvd3MgaWYgdGhlIHR5cGUgaXMgbm90IGFuIGFycmF5LlxuICAgICAqL1xuICAgIGdldCBhcnJheUxlbmd0aCgpIHtcbiAgICAgICAgaWYgKHRoaXMudHlwZSAhPT0gXCJhcnJheVwiKSB7XG4gICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJub3QgYW4gYXJyYXlcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuI29wdGlvbnMgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy4jb3B0aW9ucyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHJldHVybiAodGhpcy52YWx1ZSkubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBhIG5ldyAqKlR5cGVkKiogb2YgJSV0eXBlJSUgd2l0aCB0aGUgJSV2YWx1ZSUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tKHR5cGUsIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBuZXcgVHlwZWQoX2dhdXJkLCB0eXBlLCB2YWx1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGB1aW50OGBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyB1aW50OCh2KSB7IHJldHVybiBuKHYsIDgpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYHVpbnQxNmBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyB1aW50MTYodikgeyByZXR1cm4gbih2LCAxNik7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgdWludDI0YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIHVpbnQyNCh2KSB7IHJldHVybiBuKHYsIDI0KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGB1aW50MzJgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgdWludDMyKHYpIHsgcmV0dXJuIG4odiwgMzIpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYHVpbnQ0MGBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyB1aW50NDAodikgeyByZXR1cm4gbih2LCA0MCk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgdWludDQ4YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIHVpbnQ0OCh2KSB7IHJldHVybiBuKHYsIDQ4KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGB1aW50NTZgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgdWludDU2KHYpIHsgcmV0dXJuIG4odiwgNTYpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYHVpbnQ2NGBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyB1aW50NjQodikgeyByZXR1cm4gbih2LCA2NCk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgdWludDcyYGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIHVpbnQ3Mih2KSB7IHJldHVybiBuKHYsIDcyKTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGB1aW50ODBgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgdWludDgwKHYpIHsgcmV0dXJuIG4odiwgODApOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYHVpbnQ4OGBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyB1aW50ODgodikgeyByZXR1cm4gbih2LCA4OCk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgdWludDk2YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIHVpbnQ5Nih2KSB7IHJldHVybiBuKHYsIDk2KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGB1aW50MTA0YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIHVpbnQxMDQodikgeyByZXR1cm4gbih2LCAxMDQpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYHVpbnQxMTJgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgdWludDExMih2KSB7IHJldHVybiBuKHYsIDExMik7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgdWludDEyMGBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyB1aW50MTIwKHYpIHsgcmV0dXJuIG4odiwgMTIwKTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGB1aW50MTI4YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIHVpbnQxMjgodikgeyByZXR1cm4gbih2LCAxMjgpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYHVpbnQxMzZgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgdWludDEzNih2KSB7IHJldHVybiBuKHYsIDEzNik7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgdWludDE0NGBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyB1aW50MTQ0KHYpIHsgcmV0dXJuIG4odiwgMTQ0KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGB1aW50MTUyYGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIHVpbnQxNTIodikgeyByZXR1cm4gbih2LCAxNTIpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYHVpbnQxNjBgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgdWludDE2MCh2KSB7IHJldHVybiBuKHYsIDE2MCk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgdWludDE2OGBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyB1aW50MTY4KHYpIHsgcmV0dXJuIG4odiwgMTY4KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGB1aW50MTc2YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIHVpbnQxNzYodikgeyByZXR1cm4gbih2LCAxNzYpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYHVpbnQxODRgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgdWludDE4NCh2KSB7IHJldHVybiBuKHYsIDE4NCk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgdWludDE5MmBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyB1aW50MTkyKHYpIHsgcmV0dXJuIG4odiwgMTkyKTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGB1aW50MjAwYGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIHVpbnQyMDAodikgeyByZXR1cm4gbih2LCAyMDApOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYHVpbnQyMDhgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgdWludDIwOCh2KSB7IHJldHVybiBuKHYsIDIwOCk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgdWludDIxNmBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyB1aW50MjE2KHYpIHsgcmV0dXJuIG4odiwgMjE2KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGB1aW50MjI0YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIHVpbnQyMjQodikgeyByZXR1cm4gbih2LCAyMjQpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYHVpbnQyMzJgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgdWludDIzMih2KSB7IHJldHVybiBuKHYsIDIzMik7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgdWludDI0MGBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyB1aW50MjQwKHYpIHsgcmV0dXJuIG4odiwgMjQwKTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGB1aW50MjQ4YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIHVpbnQyNDgodikgeyByZXR1cm4gbih2LCAyNDgpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYHVpbnQyNTZgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgdWludDI1Nih2KSB7IHJldHVybiBuKHYsIDI1Nik7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgdWludDI1NmBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyB1aW50KHYpIHsgcmV0dXJuIG4odiwgMjU2KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBpbnQ4YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGludDgodikgeyByZXR1cm4gbih2LCAtOCk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgaW50MTZgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgaW50MTYodikgeyByZXR1cm4gbih2LCAtMTYpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGludDI0YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGludDI0KHYpIHsgcmV0dXJuIG4odiwgLTI0KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBpbnQzMmBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBpbnQzMih2KSB7IHJldHVybiBuKHYsIC0zMik7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgaW50NDBgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgaW50NDAodikgeyByZXR1cm4gbih2LCAtNDApOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGludDQ4YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGludDQ4KHYpIHsgcmV0dXJuIG4odiwgLTQ4KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBpbnQ1NmBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBpbnQ1Nih2KSB7IHJldHVybiBuKHYsIC01Nik7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgaW50NjRgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgaW50NjQodikgeyByZXR1cm4gbih2LCAtNjQpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGludDcyYGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGludDcyKHYpIHsgcmV0dXJuIG4odiwgLTcyKTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBpbnQ4MGBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBpbnQ4MCh2KSB7IHJldHVybiBuKHYsIC04MCk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgaW50ODhgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgaW50ODgodikgeyByZXR1cm4gbih2LCAtODgpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGludDk2YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGludDk2KHYpIHsgcmV0dXJuIG4odiwgLTk2KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBpbnQxMDRgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgaW50MTA0KHYpIHsgcmV0dXJuIG4odiwgLTEwNCk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgaW50MTEyYGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGludDExMih2KSB7IHJldHVybiBuKHYsIC0xMTIpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGludDEyMGBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBpbnQxMjAodikgeyByZXR1cm4gbih2LCAtMTIwKTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBpbnQxMjhgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgaW50MTI4KHYpIHsgcmV0dXJuIG4odiwgLTEyOCk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgaW50MTM2YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGludDEzNih2KSB7IHJldHVybiBuKHYsIC0xMzYpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGludDE0NGBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBpbnQxNDQodikgeyByZXR1cm4gbih2LCAtMTQ0KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBpbnQ1MmBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBpbnQxNTIodikgeyByZXR1cm4gbih2LCAtMTUyKTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBpbnQxNjBgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgaW50MTYwKHYpIHsgcmV0dXJuIG4odiwgLTE2MCk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgaW50MTY4YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGludDE2OCh2KSB7IHJldHVybiBuKHYsIC0xNjgpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGludDE3NmBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBpbnQxNzYodikgeyByZXR1cm4gbih2LCAtMTc2KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBpbnQxODRgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgaW50MTg0KHYpIHsgcmV0dXJuIG4odiwgLTE4NCk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgaW50OTJgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgaW50MTkyKHYpIHsgcmV0dXJuIG4odiwgLTE5Mik7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgaW50MjAwYGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGludDIwMCh2KSB7IHJldHVybiBuKHYsIC0yMDApOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGludDIwOGBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBpbnQyMDgodikgeyByZXR1cm4gbih2LCAtMjA4KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBpbnQyMTZgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgaW50MjE2KHYpIHsgcmV0dXJuIG4odiwgLTIxNik7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgaW50MjI0YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGludDIyNCh2KSB7IHJldHVybiBuKHYsIC0yMjQpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGludDIzMmBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBpbnQyMzIodikgeyByZXR1cm4gbih2LCAtMjMyKTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBpbnQyNDBgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgaW50MjQwKHYpIHsgcmV0dXJuIG4odiwgLTI0MCk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgaW50MjQ4YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGludDI0OCh2KSB7IHJldHVybiBuKHYsIC0yNDgpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGludDI1NmBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBpbnQyNTYodikgeyByZXR1cm4gbih2LCAtMjU2KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBpbnQyNTZgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgaW50KHYpIHsgcmV0dXJuIG4odiwgLTI1Nik7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgYnl0ZXMxYGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGJ5dGVzMSh2KSB7IHJldHVybiBiKHYsIDEpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGJ5dGVzMmBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBieXRlczIodikgeyByZXR1cm4gYih2LCAyKTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBieXRlczNgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgYnl0ZXMzKHYpIHsgcmV0dXJuIGIodiwgMyk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgYnl0ZXM0YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGJ5dGVzNCh2KSB7IHJldHVybiBiKHYsIDQpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGJ5dGVzNWBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBieXRlczUodikgeyByZXR1cm4gYih2LCA1KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBieXRlczZgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgYnl0ZXM2KHYpIHsgcmV0dXJuIGIodiwgNik7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgYnl0ZXM3YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGJ5dGVzNyh2KSB7IHJldHVybiBiKHYsIDcpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGJ5dGVzOGBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBieXRlczgodikgeyByZXR1cm4gYih2LCA4KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBieXRlczlgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgYnl0ZXM5KHYpIHsgcmV0dXJuIGIodiwgOSk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgYnl0ZXMxMGBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBieXRlczEwKHYpIHsgcmV0dXJuIGIodiwgMTApOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGJ5dGVzMTFgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgYnl0ZXMxMSh2KSB7IHJldHVybiBiKHYsIDExKTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBieXRlczEyYGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGJ5dGVzMTIodikgeyByZXR1cm4gYih2LCAxMik7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgYnl0ZXMxM2BgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBieXRlczEzKHYpIHsgcmV0dXJuIGIodiwgMTMpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGJ5dGVzMTRgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgYnl0ZXMxNCh2KSB7IHJldHVybiBiKHYsIDE0KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBieXRlczE1YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGJ5dGVzMTUodikgeyByZXR1cm4gYih2LCAxNSk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgYnl0ZXMxNmBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBieXRlczE2KHYpIHsgcmV0dXJuIGIodiwgMTYpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGJ5dGVzMTdgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgYnl0ZXMxNyh2KSB7IHJldHVybiBiKHYsIDE3KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBieXRlczE4YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGJ5dGVzMTgodikgeyByZXR1cm4gYih2LCAxOCk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgYnl0ZXMxOWBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBieXRlczE5KHYpIHsgcmV0dXJuIGIodiwgMTkpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGJ5dGVzMjBgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgYnl0ZXMyMCh2KSB7IHJldHVybiBiKHYsIDIwKTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBieXRlczIxYGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGJ5dGVzMjEodikgeyByZXR1cm4gYih2LCAyMSk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgYnl0ZXMyMmBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBieXRlczIyKHYpIHsgcmV0dXJuIGIodiwgMjIpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGJ5dGVzMjNgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgYnl0ZXMyMyh2KSB7IHJldHVybiBiKHYsIDIzKTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBieXRlczI0YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGJ5dGVzMjQodikgeyByZXR1cm4gYih2LCAyNCk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgYnl0ZXMyNWBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBieXRlczI1KHYpIHsgcmV0dXJuIGIodiwgMjUpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGJ5dGVzMjZgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgYnl0ZXMyNih2KSB7IHJldHVybiBiKHYsIDI2KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBieXRlczI3YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGJ5dGVzMjcodikgeyByZXR1cm4gYih2LCAyNyk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgYnl0ZXMyOGBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBieXRlczI4KHYpIHsgcmV0dXJuIGIodiwgMjgpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGJ5dGVzMjlgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgYnl0ZXMyOSh2KSB7IHJldHVybiBiKHYsIDI5KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBieXRlczMwYGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGJ5dGVzMzAodikgeyByZXR1cm4gYih2LCAzMCk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgYnl0ZXMzMWBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBieXRlczMxKHYpIHsgcmV0dXJuIGIodiwgMzEpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGJ5dGVzMzJgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgYnl0ZXMzMih2KSB7IHJldHVybiBiKHYsIDMyKTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBhZGRyZXNzYGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGFkZHJlc3ModikgeyByZXR1cm4gbmV3IFR5cGVkKF9nYXVyZCwgXCJhZGRyZXNzXCIsIHYpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGJvb2xgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgYm9vbCh2KSB7IHJldHVybiBuZXcgVHlwZWQoX2dhdXJkLCBcImJvb2xcIiwgISF2KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBieXRlc2BgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBieXRlcyh2KSB7IHJldHVybiBuZXcgVHlwZWQoX2dhdXJkLCBcImJ5dGVzXCIsIHYpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYHN0cmluZ2BgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBzdHJpbmcodikgeyByZXR1cm4gbmV3IFR5cGVkKF9nYXVyZCwgXCJzdHJpbmdcIiwgdik7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgYXJyYXlgYCB0eXBlIGZvciAlJXYlJSwgYWxsb3dpbmcgJSVkeW5hbWljJSUgbGVuZ3RoLlxuICAgICAqL1xuICAgIHN0YXRpYyBhcnJheSh2LCBkeW5hbWljKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIm5vdCBpbXBsZW1lbnRlZCB5ZXRcIik7XG4gICAgICAgIHJldHVybiBuZXcgVHlwZWQoX2dhdXJkLCBcImFycmF5XCIsIHYsIGR5bmFtaWMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgdHVwbGVgYCB0eXBlIGZvciAlJXYlJSwgd2l0aCB0aGUgb3B0aW9uYWwgJSVuYW1lJSUuXG4gICAgICovXG4gICAgc3RhdGljIHR1cGxlKHYsIG5hbWUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibm90IGltcGxlbWVudGVkIHlldFwiKTtcbiAgICAgICAgcmV0dXJuIG5ldyBUeXBlZChfZ2F1cmQsIFwidHVwbGVcIiwgdiwgbmFtZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGB1aW50OGBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBvdmVycmlkZXModikge1xuICAgICAgICByZXR1cm4gbmV3IFR5cGVkKF9nYXVyZCwgXCJvdmVycmlkZXNcIiwgT2JqZWN0LmFzc2lnbih7fSwgdikpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0cnVlIG9ubHkgaWYgJSV2YWx1ZSUlIGlzIGEgW1tUeXBlZF1dIGluc3RhbmNlLlxuICAgICAqL1xuICAgIHN0YXRpYyBpc1R5cGVkKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiAodmFsdWVcbiAgICAgICAgICAgICYmIHR5cGVvZiAodmFsdWUpID09PSBcIm9iamVjdFwiXG4gICAgICAgICAgICAmJiBcIl90eXBlZFN5bWJvbFwiIGluIHZhbHVlXG4gICAgICAgICAgICAmJiB2YWx1ZS5fdHlwZWRTeW1ib2wgPT09IF90eXBlZFN5bWJvbCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBJZiB0aGUgdmFsdWUgaXMgYSBbW1R5cGVkXV0gaW5zdGFuY2UsIHZhbGlkYXRlcyB0aGUgdW5kZXJseWluZyB2YWx1ZVxuICAgICAqICBhbmQgcmV0dXJucyBpdCwgb3RoZXJ3aXNlIHJldHVybnMgdmFsdWUgZGlyZWN0bHkuXG4gICAgICpcbiAgICAgKiAgVGhpcyBpcyB1c2VmdWwgZm9yIGZ1bmN0aW9ucyB0aGF0IHdpdGggdG8gYWNjZXB0IGVpdGhlciBhIFtbVHlwZWRdXVxuICAgICAqICBvYmplY3Qgb3IgdmFsdWVzLlxuICAgICAqL1xuICAgIHN0YXRpYyBkZXJlZmVyZW5jZSh2YWx1ZSwgdHlwZSkge1xuICAgICAgICBpZiAoVHlwZWQuaXNUeXBlZCh2YWx1ZSkpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZS50eXBlICE9PSB0eXBlKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIHR5cGU6IGV4cGVjZXRkICR7dHlwZX0sIGdvdCAke3ZhbHVlLnR5cGV9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUudmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXR5cGVkLmpzLm1hcCJdLCJuYW1lcyI6WyJhc3NlcnRQcml2YXRlIiwiZGVmaW5lUHJvcGVydGllcyIsIl9nYXVyZCIsIm4iLCJ2YWx1ZSIsIndpZHRoIiwic2lnbmVkIiwiVHlwZWQiLCJiIiwic2l6ZSIsIl90eXBlZFN5bWJvbCIsIlN5bWJvbCIsImZvciIsIm9wdGlvbnMiLCJjb25zdHJ1Y3RvciIsImdhdXJkIiwidHlwZSIsImZvcm1hdCIsIkVycm9yIiwibWFwIiwidiIsImpvaW4iLCJkZWZhdWx0VmFsdWUiLCJtaW5WYWx1ZSIsIm1heFZhbHVlIiwiaXNCaWdJbnQiLCJtYXRjaCIsImlzRGF0YSIsInN0YXJ0c1dpdGgiLCJpc1N0cmluZyIsInR1cGxlTmFtZSIsIlR5cGVFcnJvciIsImFycmF5TGVuZ3RoIiwibGVuZ3RoIiwiZnJvbSIsInVpbnQ4IiwidWludDE2IiwidWludDI0IiwidWludDMyIiwidWludDQwIiwidWludDQ4IiwidWludDU2IiwidWludDY0IiwidWludDcyIiwidWludDgwIiwidWludDg4IiwidWludDk2IiwidWludDEwNCIsInVpbnQxMTIiLCJ1aW50MTIwIiwidWludDEyOCIsInVpbnQxMzYiLCJ1aW50MTQ0IiwidWludDE1MiIsInVpbnQxNjAiLCJ1aW50MTY4IiwidWludDE3NiIsInVpbnQxODQiLCJ1aW50MTkyIiwidWludDIwMCIsInVpbnQyMDgiLCJ1aW50MjE2IiwidWludDIyNCIsInVpbnQyMzIiLCJ1aW50MjQwIiwidWludDI0OCIsInVpbnQyNTYiLCJ1aW50IiwiaW50OCIsImludDE2IiwiaW50MjQiLCJpbnQzMiIsImludDQwIiwiaW50NDgiLCJpbnQ1NiIsImludDY0IiwiaW50NzIiLCJpbnQ4MCIsImludDg4IiwiaW50OTYiLCJpbnQxMDQiLCJpbnQxMTIiLCJpbnQxMjAiLCJpbnQxMjgiLCJpbnQxMzYiLCJpbnQxNDQiLCJpbnQxNTIiLCJpbnQxNjAiLCJpbnQxNjgiLCJpbnQxNzYiLCJpbnQxODQiLCJpbnQxOTIiLCJpbnQyMDAiLCJpbnQyMDgiLCJpbnQyMTYiLCJpbnQyMjQiLCJpbnQyMzIiLCJpbnQyNDAiLCJpbnQyNDgiLCJpbnQyNTYiLCJpbnQiLCJieXRlczEiLCJieXRlczIiLCJieXRlczMiLCJieXRlczQiLCJieXRlczUiLCJieXRlczYiLCJieXRlczciLCJieXRlczgiLCJieXRlczkiLCJieXRlczEwIiwiYnl0ZXMxMSIsImJ5dGVzMTIiLCJieXRlczEzIiwiYnl0ZXMxNCIsImJ5dGVzMTUiLCJieXRlczE2IiwiYnl0ZXMxNyIsImJ5dGVzMTgiLCJieXRlczE5IiwiYnl0ZXMyMCIsImJ5dGVzMjEiLCJieXRlczIyIiwiYnl0ZXMyMyIsImJ5dGVzMjQiLCJieXRlczI1IiwiYnl0ZXMyNiIsImJ5dGVzMjciLCJieXRlczI4IiwiYnl0ZXMyOSIsImJ5dGVzMzAiLCJieXRlczMxIiwiYnl0ZXMzMiIsImFkZHJlc3MiLCJib29sIiwiYnl0ZXMiLCJzdHJpbmciLCJhcnJheSIsImR5bmFtaWMiLCJ0dXBsZSIsIm5hbWUiLCJvdmVycmlkZXMiLCJPYmplY3QiLCJhc3NpZ24iLCJpc1R5cGVkIiwiZGVyZWZlcmVuY2UiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.esm/abi/typed.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.esm/address/address.js":
/*!********************************************************!*\
  !*** ./node_modules/ethers/lib.esm/address/address.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getAddress: () => (/* binding */ getAddress),\n/* harmony export */   getIcapAddress: () => (/* binding */ getIcapAddress)\n/* harmony export */ });\n/* harmony import */ var _crypto_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../crypto/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/crypto/keccak.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/data.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/errors.js\");\n\n\nconst BN_0 = BigInt(0);\nconst BN_36 = BigInt(36);\nfunction getChecksumAddress(address) {\n    //    if (!isHexString(address, 20)) {\n    //        logger.throwArgumentError(\"invalid address\", \"address\", address);\n    //    }\n    address = address.toLowerCase();\n    const chars = address.substring(2).split(\"\");\n    const expanded = new Uint8Array(40);\n    for(let i = 0; i < 40; i++){\n        expanded[i] = chars[i].charCodeAt(0);\n    }\n    const hashed = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBytes)((0,_crypto_index_js__WEBPACK_IMPORTED_MODULE_1__.keccak256)(expanded));\n    for(let i = 0; i < 40; i += 2){\n        if (hashed[i >> 1] >> 4 >= 8) {\n            chars[i] = chars[i].toUpperCase();\n        }\n        if ((hashed[i >> 1] & 0x0f) >= 8) {\n            chars[i + 1] = chars[i + 1].toUpperCase();\n        }\n    }\n    return \"0x\" + chars.join(\"\");\n}\n// See: https://en.wikipedia.org/wiki/International_Bank_Account_Number\n// Create lookup table\nconst ibanLookup = {};\nfor(let i = 0; i < 10; i++){\n    ibanLookup[String(i)] = String(i);\n}\nfor(let i = 0; i < 26; i++){\n    ibanLookup[String.fromCharCode(65 + i)] = String(10 + i);\n}\n// How many decimal digits can we process? (for 64-bit float, this is 15)\n// i.e. Math.floor(Math.log10(Number.MAX_SAFE_INTEGER));\nconst safeDigits = 15;\nfunction ibanChecksum(address) {\n    address = address.toUpperCase();\n    address = address.substring(4) + address.substring(0, 2) + \"00\";\n    let expanded = address.split(\"\").map((c)=>{\n        return ibanLookup[c];\n    }).join(\"\");\n    // Javascript can handle integers safely up to 15 (decimal) digits\n    while(expanded.length >= safeDigits){\n        let block = expanded.substring(0, safeDigits);\n        expanded = parseInt(block, 10) % 97 + expanded.substring(block.length);\n    }\n    let checksum = String(98 - parseInt(expanded, 10) % 97);\n    while(checksum.length < 2){\n        checksum = \"0\" + checksum;\n    }\n    return checksum;\n}\n;\nconst Base36 = function() {\n    ;\n    const result = {};\n    for(let i = 0; i < 36; i++){\n        const key = \"0123456789abcdefghijklmnopqrstuvwxyz\"[i];\n        result[key] = BigInt(i);\n    }\n    return result;\n}();\nfunction fromBase36(value) {\n    value = value.toLowerCase();\n    let result = BN_0;\n    for(let i = 0; i < value.length; i++){\n        result = result * BN_36 + Base36[value[i]];\n    }\n    return result;\n}\n/**\n *  Returns a normalized and checksumed address for %%address%%.\n *  This accepts non-checksum addresses, checksum addresses and\n *  [[getIcapAddress]] formats.\n *\n *  The checksum in Ethereum uses the capitalization (upper-case\n *  vs lower-case) of the characters within an address to encode\n *  its checksum, which offers, on average, a checksum of 15-bits.\n *\n *  If %%address%% contains both upper-case and lower-case, it is\n *  assumed to already be a checksum address and its checksum is\n *  validated, and if the address fails its expected checksum an\n *  error is thrown.\n *\n *  If you wish the checksum of %%address%% to be ignore, it should\n *  be converted to lower-case (i.e. ``.toLowercase()``) before\n *  being passed in. This should be a very rare situation though,\n *  that you wish to bypass the safegaurds in place to protect\n *  against an address that has been incorrectly copied from another\n *  source.\n *\n *  @example:\n *    // Adds the checksum (via upper-casing specific letters)\n *    getAddress(\"0x8ba1f109551bd432803012645ac136ddd64dba72\")\n *    //_result:\n *\n *    // Converts ICAP address and adds checksum\n *    getAddress(\"XE65GB6LDNXYOFTX0NSV3FUWKOWIXAMJK36\");\n *    //_result:\n *\n *    // Throws an error if an address contains mixed case,\n *    // but the checksum fails\n *    getAddress(\"0x8Ba1f109551bD432803012645Ac136ddd64DBA72\")\n *    //_error:\n */ function getAddress(address) {\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(typeof address === \"string\", \"invalid address\", \"address\", address);\n    if (address.match(/^(0x)?[0-9a-fA-F]{40}$/)) {\n        // Missing the 0x prefix\n        if (!address.startsWith(\"0x\")) {\n            address = \"0x\" + address;\n        }\n        const result = getChecksumAddress(address);\n        // It is a checksummed address with a bad checksum\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(!address.match(/([A-F].*[a-f])|([a-f].*[A-F])/) || result === address, \"bad address checksum\", \"address\", address);\n        return result;\n    }\n    // Maybe ICAP? (we only support direct mode)\n    if (address.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {\n        // It is an ICAP address with a bad checksum\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(address.substring(2, 4) === ibanChecksum(address), \"bad icap checksum\", \"address\", address);\n        let result = fromBase36(address.substring(4)).toString(16);\n        while(result.length < 40){\n            result = \"0\" + result;\n        }\n        return getChecksumAddress(\"0x\" + result);\n    }\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(false, \"invalid address\", \"address\", address);\n}\n/**\n *  The [ICAP Address format](link-icap) format is an early checksum\n *  format which attempts to be compatible with the banking\n *  industry [IBAN format](link-wiki-iban) for bank accounts.\n *\n *  It is no longer common or a recommended format.\n *\n *  @example:\n *    getIcapAddress(\"0x8ba1f109551bd432803012645ac136ddd64dba72\");\n *    //_result:\n *\n *    getIcapAddress(\"XE65GB6LDNXYOFTX0NSV3FUWKOWIXAMJK36\");\n *    //_result:\n *\n *    // Throws an error if the ICAP checksum is wrong\n *    getIcapAddress(\"XE65GB6LDNXYOFTX0NSV3FUWKOWIXAMJK37\");\n *    //_error:\n */ function getIcapAddress(address) {\n    //let base36 = _base16To36(getAddress(address).substring(2)).toUpperCase();\n    let base36 = BigInt(getAddress(address)).toString(36).toUpperCase();\n    while(base36.length < 30){\n        base36 = \"0\" + base36;\n    }\n    return \"XE\" + ibanChecksum(\"XE00\" + base36) + base36;\n} //# sourceMappingURL=address.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vYWRkcmVzcy9hZGRyZXNzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQStDO0FBQ2M7QUFDN0QsTUFBTUcsT0FBT0MsT0FBTztBQUNwQixNQUFNQyxRQUFRRCxPQUFPO0FBQ3JCLFNBQVNFLG1CQUFtQkMsT0FBTztJQUMvQixzQ0FBc0M7SUFDdEMsMkVBQTJFO0lBQzNFLE9BQU87SUFDUEEsVUFBVUEsUUFBUUMsV0FBVztJQUM3QixNQUFNQyxRQUFRRixRQUFRRyxTQUFTLENBQUMsR0FBR0MsS0FBSyxDQUFDO0lBQ3pDLE1BQU1DLFdBQVcsSUFBSUMsV0FBVztJQUNoQyxJQUFLLElBQUlDLElBQUksR0FBR0EsSUFBSSxJQUFJQSxJQUFLO1FBQ3pCRixRQUFRLENBQUNFLEVBQUUsR0FBR0wsS0FBSyxDQUFDSyxFQUFFLENBQUNDLFVBQVUsQ0FBQztJQUN0QztJQUNBLE1BQU1DLFNBQVNmLHlEQUFRQSxDQUFDRCwyREFBU0EsQ0FBQ1k7SUFDbEMsSUFBSyxJQUFJRSxJQUFJLEdBQUdBLElBQUksSUFBSUEsS0FBSyxFQUFHO1FBQzVCLElBQUksTUFBTyxDQUFDQSxLQUFLLEVBQUUsSUFBSSxLQUFNLEdBQUc7WUFDNUJMLEtBQUssQ0FBQ0ssRUFBRSxHQUFHTCxLQUFLLENBQUNLLEVBQUUsQ0FBQ0csV0FBVztRQUNuQztRQUNBLElBQUksQ0FBQ0QsTUFBTSxDQUFDRixLQUFLLEVBQUUsR0FBRyxJQUFHLEtBQU0sR0FBRztZQUM5QkwsS0FBSyxDQUFDSyxJQUFJLEVBQUUsR0FBR0wsS0FBSyxDQUFDSyxJQUFJLEVBQUUsQ0FBQ0csV0FBVztRQUMzQztJQUNKO0lBQ0EsT0FBTyxPQUFPUixNQUFNUyxJQUFJLENBQUM7QUFDN0I7QUFDQSx1RUFBdUU7QUFDdkUsc0JBQXNCO0FBQ3RCLE1BQU1DLGFBQWEsQ0FBQztBQUNwQixJQUFLLElBQUlMLElBQUksR0FBR0EsSUFBSSxJQUFJQSxJQUFLO0lBQ3pCSyxV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ZWhDLE9BQU87SUFDbEMsMkVBQTJFO0lBQzNFLElBQUlpQyxTQUFTcEMsT0FBTytCLFdBQVc1QixVQUFVK0IsUUFBUSxDQUFDLElBQUlyQixXQUFXO0lBQ2pFLE1BQU91QixPQUFPZCxNQUFNLEdBQUcsR0FBSTtRQUN2QmMsU0FBUyxNQUFNQTtJQUNuQjtJQUNBLE9BQU8sT0FBT2pCLGFBQWEsU0FBU2lCLFVBQVVBO0FBQ2xELEVBQ0EsbUNBQW1DIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbWVnYXZpYmUtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vYWRkcmVzcy9hZGRyZXNzLmpzP2ExOTciXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsga2VjY2FrMjU2IH0gZnJvbSBcIi4uL2NyeXB0by9pbmRleC5qc1wiO1xuaW1wb3J0IHsgZ2V0Qnl0ZXMsIGFzc2VydEFyZ3VtZW50IH0gZnJvbSBcIi4uL3V0aWxzL2luZGV4LmpzXCI7XG5jb25zdCBCTl8wID0gQmlnSW50KDApO1xuY29uc3QgQk5fMzYgPSBCaWdJbnQoMzYpO1xuZnVuY3Rpb24gZ2V0Q2hlY2tzdW1BZGRyZXNzKGFkZHJlc3MpIHtcbiAgICAvLyAgICBpZiAoIWlzSGV4U3RyaW5nKGFkZHJlc3MsIDIwKSkge1xuICAgIC8vICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBhZGRyZXNzXCIsIFwiYWRkcmVzc1wiLCBhZGRyZXNzKTtcbiAgICAvLyAgICB9XG4gICAgYWRkcmVzcyA9IGFkZHJlc3MudG9Mb3dlckNhc2UoKTtcbiAgICBjb25zdCBjaGFycyA9IGFkZHJlc3Muc3Vic3RyaW5nKDIpLnNwbGl0KFwiXCIpO1xuICAgIGNvbnN0IGV4cGFuZGVkID0gbmV3IFVpbnQ4QXJyYXkoNDApO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNDA7IGkrKykge1xuICAgICAgICBleHBhbmRlZFtpXSA9IGNoYXJzW2ldLmNoYXJDb2RlQXQoMCk7XG4gICAgfVxuICAgIGNvbnN0IGhhc2hlZCA9IGdldEJ5dGVzKGtlY2NhazI1NihleHBhbmRlZCkpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNDA7IGkgKz0gMikge1xuICAgICAgICBpZiAoKGhhc2hlZFtpID4+IDFdID4+IDQpID49IDgpIHtcbiAgICAgICAgICAgIGNoYXJzW2ldID0gY2hhcnNbaV0udG9VcHBlckNhc2UoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKGhhc2hlZFtpID4+IDFdICYgMHgwZikgPj0gOCkge1xuICAgICAgICAgICAgY2hhcnNbaSArIDFdID0gY2hhcnNbaSArIDFdLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFwiMHhcIiArIGNoYXJzLmpvaW4oXCJcIik7XG59XG4vLyBTZWU6IGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0ludGVybmF0aW9uYWxfQmFua19BY2NvdW50X051bWJlclxuLy8gQ3JlYXRlIGxvb2t1cCB0YWJsZVxuY29uc3QgaWJhbkxvb2t1cCA9IHt9O1xuZm9yIChsZXQgaSA9IDA7IGkgPCAxMDsgaSsrKSB7XG4gICAgaWJhbkxvb2t1cFtTdHJpbmcoaSldID0gU3RyaW5nKGkpO1xufVxuZm9yIChsZXQgaSA9IDA7IGkgPCAyNjsgaSsrKSB7XG4gICAgaWJhbkxvb2t1cFtTdHJpbmcuZnJvbUNoYXJDb2RlKDY1ICsgaSldID0gU3RyaW5nKDEwICsgaSk7XG59XG4vLyBIb3cgbWFueSBkZWNpbWFsIGRpZ2l0cyBjYW4gd2UgcHJvY2Vzcz8gKGZvciA2NC1iaXQgZmxvYXQsIHRoaXMgaXMgMTUpXG4vLyBpLmUuIE1hdGguZmxvb3IoTWF0aC5sb2cxMChOdW1iZXIuTUFYX1NBRkVfSU5URUdFUikpO1xuY29uc3Qgc2FmZURpZ2l0cyA9IDE1O1xuZnVuY3Rpb24gaWJhbkNoZWNrc3VtKGFkZHJlc3MpIHtcbiAgICBhZGRyZXNzID0gYWRkcmVzcy50b1VwcGVyQ2FzZSgpO1xuICAgIGFkZHJlc3MgPSBhZGRyZXNzLnN1YnN0cmluZyg0KSArIGFkZHJlc3Muc3Vic3RyaW5nKDAsIDIpICsgXCIwMFwiO1xuICAgIGxldCBleHBhbmRlZCA9IGFkZHJlc3Muc3BsaXQoXCJcIikubWFwKChjKSA9PiB7IHJldHVybiBpYmFuTG9va3VwW2NdOyB9KS5qb2luKFwiXCIpO1xuICAgIC8vIEphdmFzY3JpcHQgY2FuIGhhbmRsZSBpbnRlZ2VycyBzYWZlbHkgdXAgdG8gMTUgKGRlY2ltYWwpIGRpZ2l0c1xuICAgIHdoaWxlIChleHBhbmRlZC5sZW5ndGggPj0gc2FmZURpZ2l0cykge1xuICAgICAgICBsZXQgYmxvY2sgPSBleHBhbmRlZC5zdWJzdHJpbmcoMCwgc2FmZURpZ2l0cyk7XG4gICAgICAgIGV4cGFuZGVkID0gcGFyc2VJbnQoYmxvY2ssIDEwKSAlIDk3ICsgZXhwYW5kZWQuc3Vic3RyaW5nKGJsb2NrLmxlbmd0aCk7XG4gICAgfVxuICAgIGxldCBjaGVja3N1bSA9IFN0cmluZyg5OCAtIChwYXJzZUludChleHBhbmRlZCwgMTApICUgOTcpKTtcbiAgICB3aGlsZSAoY2hlY2tzdW0ubGVuZ3RoIDwgMikge1xuICAgICAgICBjaGVja3N1bSA9IFwiMFwiICsgY2hlY2tzdW07XG4gICAgfVxuICAgIHJldHVybiBjaGVja3N1bTtcbn1cbjtcbmNvbnN0IEJhc2UzNiA9IChmdW5jdGlvbiAoKSB7XG4gICAgO1xuICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMzY7IGkrKykge1xuICAgICAgICBjb25zdCBrZXkgPSBcIjAxMjM0NTY3ODlhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5elwiW2ldO1xuICAgICAgICByZXN1bHRba2V5XSA9IEJpZ0ludChpKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn0pKCk7XG5mdW5jdGlvbiBmcm9tQmFzZTM2KHZhbHVlKSB7XG4gICAgdmFsdWUgPSB2YWx1ZS50b0xvd2VyQ2FzZSgpO1xuICAgIGxldCByZXN1bHQgPSBCTl8wO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcmVzdWx0ID0gcmVzdWx0ICogQk5fMzYgKyBCYXNlMzZbdmFsdWVbaV1dO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLyoqXG4gKiAgUmV0dXJucyBhIG5vcm1hbGl6ZWQgYW5kIGNoZWNrc3VtZWQgYWRkcmVzcyBmb3IgJSVhZGRyZXNzJSUuXG4gKiAgVGhpcyBhY2NlcHRzIG5vbi1jaGVja3N1bSBhZGRyZXNzZXMsIGNoZWNrc3VtIGFkZHJlc3NlcyBhbmRcbiAqICBbW2dldEljYXBBZGRyZXNzXV0gZm9ybWF0cy5cbiAqXG4gKiAgVGhlIGNoZWNrc3VtIGluIEV0aGVyZXVtIHVzZXMgdGhlIGNhcGl0YWxpemF0aW9uICh1cHBlci1jYXNlXG4gKiAgdnMgbG93ZXItY2FzZSkgb2YgdGhlIGNoYXJhY3RlcnMgd2l0aGluIGFuIGFkZHJlc3MgdG8gZW5jb2RlXG4gKiAgaXRzIGNoZWNrc3VtLCB3aGljaCBvZmZlcnMsIG9uIGF2ZXJhZ2UsIGEgY2hlY2tzdW0gb2YgMTUtYml0cy5cbiAqXG4gKiAgSWYgJSVhZGRyZXNzJSUgY29udGFpbnMgYm90aCB1cHBlci1jYXNlIGFuZCBsb3dlci1jYXNlLCBpdCBpc1xuICogIGFzc3VtZWQgdG8gYWxyZWFkeSBiZSBhIGNoZWNrc3VtIGFkZHJlc3MgYW5kIGl0cyBjaGVja3N1bSBpc1xuICogIHZhbGlkYXRlZCwgYW5kIGlmIHRoZSBhZGRyZXNzIGZhaWxzIGl0cyBleHBlY3RlZCBjaGVja3N1bSBhblxuICogIGVycm9yIGlzIHRocm93bi5cbiAqXG4gKiAgSWYgeW91IHdpc2ggdGhlIGNoZWNrc3VtIG9mICUlYWRkcmVzcyUlIHRvIGJlIGlnbm9yZSwgaXQgc2hvdWxkXG4gKiAgYmUgY29udmVydGVkIHRvIGxvd2VyLWNhc2UgKGkuZS4gYGAudG9Mb3dlcmNhc2UoKWBgKSBiZWZvcmVcbiAqICBiZWluZyBwYXNzZWQgaW4uIFRoaXMgc2hvdWxkIGJlIGEgdmVyeSByYXJlIHNpdHVhdGlvbiB0aG91Z2gsXG4gKiAgdGhhdCB5b3Ugd2lzaCB0byBieXBhc3MgdGhlIHNhZmVnYXVyZHMgaW4gcGxhY2UgdG8gcHJvdGVjdFxuICogIGFnYWluc3QgYW4gYWRkcmVzcyB0aGF0IGhhcyBiZWVuIGluY29ycmVjdGx5IGNvcGllZCBmcm9tIGFub3RoZXJcbiAqICBzb3VyY2UuXG4gKlxuICogIEBleGFtcGxlOlxuICogICAgLy8gQWRkcyB0aGUgY2hlY2tzdW0gKHZpYSB1cHBlci1jYXNpbmcgc3BlY2lmaWMgbGV0dGVycylcbiAqICAgIGdldEFkZHJlc3MoXCIweDhiYTFmMTA5NTUxYmQ0MzI4MDMwMTI2NDVhYzEzNmRkZDY0ZGJhNzJcIilcbiAqICAgIC8vX3Jlc3VsdDpcbiAqXG4gKiAgICAvLyBDb252ZXJ0cyBJQ0FQIGFkZHJlc3MgYW5kIGFkZHMgY2hlY2tzdW1cbiAqICAgIGdldEFkZHJlc3MoXCJYRTY1R0I2TEROWFlPRlRYME5TVjNGVVdLT1dJWEFNSkszNlwiKTtcbiAqICAgIC8vX3Jlc3VsdDpcbiAqXG4gKiAgICAvLyBUaHJvd3MgYW4gZXJyb3IgaWYgYW4gYWRkcmVzcyBjb250YWlucyBtaXhlZCBjYXNlLFxuICogICAgLy8gYnV0IHRoZSBjaGVja3N1bSBmYWlsc1xuICogICAgZ2V0QWRkcmVzcyhcIjB4OEJhMWYxMDk1NTFiRDQzMjgwMzAxMjY0NUFjMTM2ZGRkNjREQkE3MlwiKVxuICogICAgLy9fZXJyb3I6XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRBZGRyZXNzKGFkZHJlc3MpIHtcbiAgICBhc3NlcnRBcmd1bWVudCh0eXBlb2YgKGFkZHJlc3MpID09PSBcInN0cmluZ1wiLCBcImludmFsaWQgYWRkcmVzc1wiLCBcImFkZHJlc3NcIiwgYWRkcmVzcyk7XG4gICAgaWYgKGFkZHJlc3MubWF0Y2goL14oMHgpP1swLTlhLWZBLUZdezQwfSQvKSkge1xuICAgICAgICAvLyBNaXNzaW5nIHRoZSAweCBwcmVmaXhcbiAgICAgICAgaWYgKCFhZGRyZXNzLnN0YXJ0c1dpdGgoXCIweFwiKSkge1xuICAgICAgICAgICAgYWRkcmVzcyA9IFwiMHhcIiArIGFkZHJlc3M7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gZ2V0Q2hlY2tzdW1BZGRyZXNzKGFkZHJlc3MpO1xuICAgICAgICAvLyBJdCBpcyBhIGNoZWNrc3VtbWVkIGFkZHJlc3Mgd2l0aCBhIGJhZCBjaGVja3N1bVxuICAgICAgICBhc3NlcnRBcmd1bWVudCghYWRkcmVzcy5tYXRjaCgvKFtBLUZdLipbYS1mXSl8KFthLWZdLipbQS1GXSkvKSB8fCByZXN1bHQgPT09IGFkZHJlc3MsIFwiYmFkIGFkZHJlc3MgY2hlY2tzdW1cIiwgXCJhZGRyZXNzXCIsIGFkZHJlc3MpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvLyBNYXliZSBJQ0FQPyAod2Ugb25seSBzdXBwb3J0IGRpcmVjdCBtb2RlKVxuICAgIGlmIChhZGRyZXNzLm1hdGNoKC9eWEVbMC05XXsyfVswLTlBLVphLXpdezMwLDMxfSQvKSkge1xuICAgICAgICAvLyBJdCBpcyBhbiBJQ0FQIGFkZHJlc3Mgd2l0aCBhIGJhZCBjaGVja3N1bVxuICAgICAgICBhc3NlcnRBcmd1bWVudChhZGRyZXNzLnN1YnN0cmluZygyLCA0KSA9PT0gaWJhbkNoZWNrc3VtKGFkZHJlc3MpLCBcImJhZCBpY2FwIGNoZWNrc3VtXCIsIFwiYWRkcmVzc1wiLCBhZGRyZXNzKTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IGZyb21CYXNlMzYoYWRkcmVzcy5zdWJzdHJpbmcoNCkpLnRvU3RyaW5nKDE2KTtcbiAgICAgICAgd2hpbGUgKHJlc3VsdC5sZW5ndGggPCA0MCkge1xuICAgICAgICAgICAgcmVzdWx0ID0gXCIwXCIgKyByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGdldENoZWNrc3VtQWRkcmVzcyhcIjB4XCIgKyByZXN1bHQpO1xuICAgIH1cbiAgICBhc3NlcnRBcmd1bWVudChmYWxzZSwgXCJpbnZhbGlkIGFkZHJlc3NcIiwgXCJhZGRyZXNzXCIsIGFkZHJlc3MpO1xufVxuLyoqXG4gKiAgVGhlIFtJQ0FQIEFkZHJlc3MgZm9ybWF0XShsaW5rLWljYXApIGZvcm1hdCBpcyBhbiBlYXJseSBjaGVja3N1bVxuICogIGZvcm1hdCB3aGljaCBhdHRlbXB0cyB0byBiZSBjb21wYXRpYmxlIHdpdGggdGhlIGJhbmtpbmdcbiAqICBpbmR1c3RyeSBbSUJBTiBmb3JtYXRdKGxpbmstd2lraS1pYmFuKSBmb3IgYmFuayBhY2NvdW50cy5cbiAqXG4gKiAgSXQgaXMgbm8gbG9uZ2VyIGNvbW1vbiBvciBhIHJlY29tbWVuZGVkIGZvcm1hdC5cbiAqXG4gKiAgQGV4YW1wbGU6XG4gKiAgICBnZXRJY2FwQWRkcmVzcyhcIjB4OGJhMWYxMDk1NTFiZDQzMjgwMzAxMjY0NWFjMTM2ZGRkNjRkYmE3MlwiKTtcbiAqICAgIC8vX3Jlc3VsdDpcbiAqXG4gKiAgICBnZXRJY2FwQWRkcmVzcyhcIlhFNjVHQjZMRE5YWU9GVFgwTlNWM0ZVV0tPV0lYQU1KSzM2XCIpO1xuICogICAgLy9fcmVzdWx0OlxuICpcbiAqICAgIC8vIFRocm93cyBhbiBlcnJvciBpZiB0aGUgSUNBUCBjaGVja3N1bSBpcyB3cm9uZ1xuICogICAgZ2V0SWNhcEFkZHJlc3MoXCJYRTY1R0I2TEROWFlPRlRYME5TVjNGVVdLT1dJWEFNSkszN1wiKTtcbiAqICAgIC8vX2Vycm9yOlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0SWNhcEFkZHJlc3MoYWRkcmVzcykge1xuICAgIC8vbGV0IGJhc2UzNiA9IF9iYXNlMTZUbzM2KGdldEFkZHJlc3MoYWRkcmVzcykuc3Vic3RyaW5nKDIpKS50b1VwcGVyQ2FzZSgpO1xuICAgIGxldCBiYXNlMzYgPSBCaWdJbnQoZ2V0QWRkcmVzcyhhZGRyZXNzKSkudG9TdHJpbmcoMzYpLnRvVXBwZXJDYXNlKCk7XG4gICAgd2hpbGUgKGJhc2UzNi5sZW5ndGggPCAzMCkge1xuICAgICAgICBiYXNlMzYgPSBcIjBcIiArIGJhc2UzNjtcbiAgICB9XG4gICAgcmV0dXJuIFwiWEVcIiArIGliYW5DaGVja3N1bShcIlhFMDBcIiArIGJhc2UzNikgKyBiYXNlMzY7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hZGRyZXNzLmpzLm1hcCJdLCJuYW1lcyI6WyJrZWNjYWsyNTYiLCJnZXRCeXRlcyIsImFzc2VydEFyZ3VtZW50IiwiQk5fMCIsIkJpZ0ludCIsIkJOXzM2IiwiZ2V0Q2hlY2tzdW1BZGRyZXNzIiwiYWRkcmVzcyIsInRvTG93ZXJDYXNlIiwiY2hhcnMiLCJzdWJzdHJpbmciLCJzcGxpdCIsImV4cGFuZGVkIiwiVWludDhBcnJheSIsImkiLCJjaGFyQ29kZUF0IiwiaGFzaGVkIiwidG9VcHBlckNhc2UiLCJqb2luIiwiaWJhbkxvb2t1cCIsIlN0cmluZyIsImZyb21DaGFyQ29kZSIsInNhZmVEaWdpdHMiLCJpYmFuQ2hlY2tzdW0iLCJtYXAiLCJjIiwibGVuZ3RoIiwiYmxvY2siLCJwYXJzZUludCIsImNoZWNrc3VtIiwiQmFzZTM2IiwicmVzdWx0Iiwia2V5IiwiZnJvbUJhc2UzNiIsInZhbHVlIiwiZ2V0QWRkcmVzcyIsIm1hdGNoIiwic3RhcnRzV2l0aCIsInRvU3RyaW5nIiwiZ2V0SWNhcEFkZHJlc3MiLCJiYXNlMzYiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.esm/address/address.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.esm/address/checks.js":
/*!*******************************************************!*\
  !*** ./node_modules/ethers/lib.esm/address/checks.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   isAddress: () => (/* binding */ isAddress),\n/* harmony export */   isAddressable: () => (/* binding */ isAddressable),\n/* harmony export */   resolveAddress: () => (/* binding */ resolveAddress)\n/* harmony export */ });\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/errors.js\");\n/* harmony import */ var _address_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./address.js */ \"(ssr)/./node_modules/ethers/lib.esm/address/address.js\");\n\n\n/**\n *  Returns true if %%value%% is an object which implements the\n *  [[Addressable]] interface.\n *\n *  @example:\n *    // Wallets and AbstractSigner sub-classes\n *    isAddressable(Wallet.createRandom())\n *    //_result:\n *\n *    // Contracts\n *    contract = new Contract(\"dai.tokens.ethers.eth\", [ ], provider)\n *    isAddressable(contract)\n *    //_result:\n */ function isAddressable(value) {\n    return value && typeof value.getAddress === \"function\";\n}\n/**\n *  Returns true if %%value%% is a valid address.\n *\n *  @example:\n *    // Valid address\n *    isAddress(\"0x8ba1f109551bD432803012645Ac136ddd64DBA72\")\n *    //_result:\n *\n *    // Valid ICAP address\n *    isAddress(\"XE65GB6LDNXYOFTX0NSV3FUWKOWIXAMJK36\")\n *    //_result:\n *\n *    // Invalid checksum\n *    isAddress(\"0x8Ba1f109551bD432803012645Ac136ddd64DBa72\")\n *    //_result:\n *\n *    // Invalid ICAP checksum\n *    isAddress(\"0x8Ba1f109551bD432803012645Ac136ddd64DBA72\")\n *    //_result:\n *\n *    // Not an address (an ENS name requires a provided and an\n *    // asynchronous API to access)\n *    isAddress(\"ricmoo.eth\")\n *    //_result:\n */ function isAddress(value) {\n    try {\n        (0,_address_js__WEBPACK_IMPORTED_MODULE_0__.getAddress)(value);\n        return true;\n    } catch (error) {}\n    return false;\n}\nasync function checkAddress(target, promise) {\n    const result = await promise;\n    if (result == null || result === \"0x0000000000000000000000000000000000000000\") {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assert)(typeof target !== \"string\", \"unconfigured name\", \"UNCONFIGURED_NAME\", {\n            value: target\n        });\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(false, \"invalid AddressLike value; did not resolve to a value address\", \"target\", target);\n    }\n    return (0,_address_js__WEBPACK_IMPORTED_MODULE_0__.getAddress)(result);\n}\n/**\n *  Resolves to an address for the %%target%%, which may be any\n *  supported address type, an [[Addressable]] or a Promise which\n *  resolves to an address.\n *\n *  If an ENS name is provided, but that name has not been correctly\n *  configured a [[UnconfiguredNameError]] is thrown.\n *\n *  @example:\n *    addr = \"0x6B175474E89094C44Da98b954EedeAC495271d0F\"\n *\n *    // Addresses are return synchronously\n *    resolveAddress(addr, provider)\n *    //_result:\n *\n *    // Address promises are resolved asynchronously\n *    resolveAddress(Promise.resolve(addr))\n *    //_result:\n *\n *    // ENS names are resolved asynchronously\n *    resolveAddress(\"dai.tokens.ethers.eth\", provider)\n *    //_result:\n *\n *    // Addressable objects are resolved asynchronously\n *    contract = new Contract(addr, [ ])\n *    resolveAddress(contract, provider)\n *    //_result:\n *\n *    // Unconfigured ENS names reject\n *    resolveAddress(\"nothing-here.ricmoo.eth\", provider)\n *    //_error:\n *\n *    // ENS names require a NameResolver object passed in\n *    // (notice the provider was omitted)\n *    resolveAddress(\"nothing-here.ricmoo.eth\")\n *    //_error:\n */ function resolveAddress(target, resolver) {\n    if (typeof target === \"string\") {\n        if (target.match(/^0x[0-9a-f]{40}$/i)) {\n            return (0,_address_js__WEBPACK_IMPORTED_MODULE_0__.getAddress)(target);\n        }\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assert)(resolver != null, \"ENS resolution requires a provider\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"resolveName\"\n        });\n        return checkAddress(target, resolver.resolveName(target));\n    } else if (isAddressable(target)) {\n        return checkAddress(target, target.getAddress());\n    } else if (target && typeof target.then === \"function\") {\n        return checkAddress(target, target);\n    }\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(false, \"unsupported addressable value\", \"target\", target);\n} //# sourceMappingURL=checks.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vYWRkcmVzcy9jaGVja3MuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBMkQ7QUFDakI7QUFDMUM7Ozs7Ozs7Ozs7Ozs7Q0FhQyxHQUNNLFNBQVNHLGNBQWNDLEtBQUs7SUFDL0IsT0FBUUEsU0FBUyxPQUFRQSxNQUFNRixVQUFVLEtBQU07QUFDbkQ7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBd0JDLEdBQ00sU0FBU0csVUFBVUQsS0FBSztJQUMzQixJQUFJO1FBQ0FGLHVEQUFVQSxDQUFDRTtRQUNYLE9BQU87SUFDWCxFQUNBLE9BQU9FLE9BQU8sQ0FBRTtJQUNoQixPQUFPO0FBQ1g7QUFDQSxlQUFlQyxhQUFhQyxNQUFNLEVBQUVDLE9BQU87SUFDdkMsTUFBTUMsU0FBUyxNQUFNRDtJQUNyQixJQUFJQyxVQUFVLFFBQVFBLFdBQVcsOENBQThDO1FBQzNFVix1REFBTUEsQ0FBQyxPQUFRUSxXQUFZLFVBQVUscUJBQXFCLHFCQUFxQjtZQUFFSixPQUFPSTtRQUFPO1FBQy9GUCwrREFBY0EsQ0FBQyxPQUFPLGlFQUFpRSxVQUFVTztJQUNyRztJQUNBLE9BQU9OLHVEQUFVQSxDQUFDUTtBQUN0QjtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FvQ0MsR0FDTSxTQUFTQyxlQUFlSCxNQUFNLEVBQUVJLFFBQVE7SUFDM0MsSUFBSSxPQUFRSixXQUFZLFVBQVU7UUFDOUIsSUFBSUEsT0FBT0ssS0FBSyxDQUFDLHNCQUFzQjtZQUNuQyxPQUFPWCx1REFBVUEsQ0FBQ007UUFDdEI7UUFDQVIsdURBQU1BLENBQUNZLFlBQVksTUFBTSxzQ0FBc0MseUJBQXlCO1lBQUVFLFdBQVc7UUFBYztRQUNuSCxPQUFPUCxhQUFhQyxRQUFRSSxTQUFTRyxXQUFXLENBQUNQO0lBQ3JELE9BQ0ssSUFBSUwsY0FBY0ssU0FBUztRQUM1QixPQUFPRCxhQUFhQyxRQUFRQSxPQUFPTixVQUFVO0lBQ2pELE9BQ0ssSUFBSU0sVUFBVSxPQUFRQSxPQUFPUSxJQUFJLEtBQU0sWUFBWTtRQUNwRCxPQUFPVCxhQUFhQyxRQUFRQTtJQUNoQztJQUNBUCwrREFBY0EsQ0FBQyxPQUFPLGlDQUFpQyxVQUFVTztBQUNyRSxFQUNBLGtDQUFrQyIsInNvdXJjZXMiOlsid2VicGFjazovL21lZ2F2aWJlLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL2FkZHJlc3MvY2hlY2tzLmpzPzg0NzIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgYXNzZXJ0LCBhc3NlcnRBcmd1bWVudCB9IGZyb20gXCIuLi91dGlscy9pbmRleC5qc1wiO1xuaW1wb3J0IHsgZ2V0QWRkcmVzcyB9IGZyb20gXCIuL2FkZHJlc3MuanNcIjtcbi8qKlxuICogIFJldHVybnMgdHJ1ZSBpZiAlJXZhbHVlJSUgaXMgYW4gb2JqZWN0IHdoaWNoIGltcGxlbWVudHMgdGhlXG4gKiAgW1tBZGRyZXNzYWJsZV1dIGludGVyZmFjZS5cbiAqXG4gKiAgQGV4YW1wbGU6XG4gKiAgICAvLyBXYWxsZXRzIGFuZCBBYnN0cmFjdFNpZ25lciBzdWItY2xhc3Nlc1xuICogICAgaXNBZGRyZXNzYWJsZShXYWxsZXQuY3JlYXRlUmFuZG9tKCkpXG4gKiAgICAvL19yZXN1bHQ6XG4gKlxuICogICAgLy8gQ29udHJhY3RzXG4gKiAgICBjb250cmFjdCA9IG5ldyBDb250cmFjdChcImRhaS50b2tlbnMuZXRoZXJzLmV0aFwiLCBbIF0sIHByb3ZpZGVyKVxuICogICAgaXNBZGRyZXNzYWJsZShjb250cmFjdClcbiAqICAgIC8vX3Jlc3VsdDpcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzQWRkcmVzc2FibGUodmFsdWUpIHtcbiAgICByZXR1cm4gKHZhbHVlICYmIHR5cGVvZiAodmFsdWUuZ2V0QWRkcmVzcykgPT09IFwiZnVuY3Rpb25cIik7XG59XG4vKipcbiAqICBSZXR1cm5zIHRydWUgaWYgJSV2YWx1ZSUlIGlzIGEgdmFsaWQgYWRkcmVzcy5cbiAqXG4gKiAgQGV4YW1wbGU6XG4gKiAgICAvLyBWYWxpZCBhZGRyZXNzXG4gKiAgICBpc0FkZHJlc3MoXCIweDhiYTFmMTA5NTUxYkQ0MzI4MDMwMTI2NDVBYzEzNmRkZDY0REJBNzJcIilcbiAqICAgIC8vX3Jlc3VsdDpcbiAqXG4gKiAgICAvLyBWYWxpZCBJQ0FQIGFkZHJlc3NcbiAqICAgIGlzQWRkcmVzcyhcIlhFNjVHQjZMRE5YWU9GVFgwTlNWM0ZVV0tPV0lYQU1KSzM2XCIpXG4gKiAgICAvL19yZXN1bHQ6XG4gKlxuICogICAgLy8gSW52YWxpZCBjaGVja3N1bVxuICogICAgaXNBZGRyZXNzKFwiMHg4QmExZjEwOTU1MWJENDMyODAzMDEyNjQ1QWMxMzZkZGQ2NERCYTcyXCIpXG4gKiAgICAvL19yZXN1bHQ6XG4gKlxuICogICAgLy8gSW52YWxpZCBJQ0FQIGNoZWNrc3VtXG4gKiAgICBpc0FkZHJlc3MoXCIweDhCYTFmMTA5NTUxYkQ0MzI4MDMwMTI2NDVBYzEzNmRkZDY0REJBNzJcIilcbiAqICAgIC8vX3Jlc3VsdDpcbiAqXG4gKiAgICAvLyBOb3QgYW4gYWRkcmVzcyAoYW4gRU5TIG5hbWUgcmVxdWlyZXMgYSBwcm92aWRlZCBhbmQgYW5cbiAqICAgIC8vIGFzeW5jaHJvbm91cyBBUEkgdG8gYWNjZXNzKVxuICogICAgaXNBZGRyZXNzKFwicmljbW9vLmV0aFwiKVxuICogICAgLy9fcmVzdWx0OlxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNBZGRyZXNzKHZhbHVlKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgZ2V0QWRkcmVzcyh2YWx1ZSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHsgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGNoZWNrQWRkcmVzcyh0YXJnZXQsIHByb21pc2UpIHtcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBwcm9taXNlO1xuICAgIGlmIChyZXN1bHQgPT0gbnVsbCB8fCByZXN1bHQgPT09IFwiMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwXCIpIHtcbiAgICAgICAgYXNzZXJ0KHR5cGVvZiAodGFyZ2V0KSAhPT0gXCJzdHJpbmdcIiwgXCJ1bmNvbmZpZ3VyZWQgbmFtZVwiLCBcIlVOQ09ORklHVVJFRF9OQU1FXCIsIHsgdmFsdWU6IHRhcmdldCB9KTtcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQoZmFsc2UsIFwiaW52YWxpZCBBZGRyZXNzTGlrZSB2YWx1ZTsgZGlkIG5vdCByZXNvbHZlIHRvIGEgdmFsdWUgYWRkcmVzc1wiLCBcInRhcmdldFwiLCB0YXJnZXQpO1xuICAgIH1cbiAgICByZXR1cm4gZ2V0QWRkcmVzcyhyZXN1bHQpO1xufVxuLyoqXG4gKiAgUmVzb2x2ZXMgdG8gYW4gYWRkcmVzcyBmb3IgdGhlICUldGFyZ2V0JSUsIHdoaWNoIG1heSBiZSBhbnlcbiAqICBzdXBwb3J0ZWQgYWRkcmVzcyB0eXBlLCBhbiBbW0FkZHJlc3NhYmxlXV0gb3IgYSBQcm9taXNlIHdoaWNoXG4gKiAgcmVzb2x2ZXMgdG8gYW4gYWRkcmVzcy5cbiAqXG4gKiAgSWYgYW4gRU5TIG5hbWUgaXMgcHJvdmlkZWQsIGJ1dCB0aGF0IG5hbWUgaGFzIG5vdCBiZWVuIGNvcnJlY3RseVxuICogIGNvbmZpZ3VyZWQgYSBbW1VuY29uZmlndXJlZE5hbWVFcnJvcl1dIGlzIHRocm93bi5cbiAqXG4gKiAgQGV4YW1wbGU6XG4gKiAgICBhZGRyID0gXCIweDZCMTc1NDc0RTg5MDk0QzQ0RGE5OGI5NTRFZWRlQUM0OTUyNzFkMEZcIlxuICpcbiAqICAgIC8vIEFkZHJlc3NlcyBhcmUgcmV0dXJuIHN5bmNocm9ub3VzbHlcbiAqICAgIHJlc29sdmVBZGRyZXNzKGFkZHIsIHByb3ZpZGVyKVxuICogICAgLy9fcmVzdWx0OlxuICpcbiAqICAgIC8vIEFkZHJlc3MgcHJvbWlzZXMgYXJlIHJlc29sdmVkIGFzeW5jaHJvbm91c2x5XG4gKiAgICByZXNvbHZlQWRkcmVzcyhQcm9taXNlLnJlc29sdmUoYWRkcikpXG4gKiAgICAvL19yZXN1bHQ6XG4gKlxuICogICAgLy8gRU5TIG5hbWVzIGFyZSByZXNvbHZlZCBhc3luY2hyb25vdXNseVxuICogICAgcmVzb2x2ZUFkZHJlc3MoXCJkYWkudG9rZW5zLmV0aGVycy5ldGhcIiwgcHJvdmlkZXIpXG4gKiAgICAvL19yZXN1bHQ6XG4gKlxuICogICAgLy8gQWRkcmVzc2FibGUgb2JqZWN0cyBhcmUgcmVzb2x2ZWQgYXN5bmNocm9ub3VzbHlcbiAqICAgIGNvbnRyYWN0ID0gbmV3IENvbnRyYWN0KGFkZHIsIFsgXSlcbiAqICAgIHJlc29sdmVBZGRyZXNzKGNvbnRyYWN0LCBwcm92aWRlcilcbiAqICAgIC8vX3Jlc3VsdDpcbiAqXG4gKiAgICAvLyBVbmNvbmZpZ3VyZWQgRU5TIG5hbWVzIHJlamVjdFxuICogICAgcmVzb2x2ZUFkZHJlc3MoXCJub3RoaW5nLWhlcmUucmljbW9vLmV0aFwiLCBwcm92aWRlcilcbiAqICAgIC8vX2Vycm9yOlxuICpcbiAqICAgIC8vIEVOUyBuYW1lcyByZXF1aXJlIGEgTmFtZVJlc29sdmVyIG9iamVjdCBwYXNzZWQgaW5cbiAqICAgIC8vIChub3RpY2UgdGhlIHByb3ZpZGVyIHdhcyBvbWl0dGVkKVxuICogICAgcmVzb2x2ZUFkZHJlc3MoXCJub3RoaW5nLWhlcmUucmljbW9vLmV0aFwiKVxuICogICAgLy9fZXJyb3I6XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZXNvbHZlQWRkcmVzcyh0YXJnZXQsIHJlc29sdmVyKSB7XG4gICAgaWYgKHR5cGVvZiAodGFyZ2V0KSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBpZiAodGFyZ2V0Lm1hdGNoKC9eMHhbMC05YS1mXXs0MH0kL2kpKSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0QWRkcmVzcyh0YXJnZXQpO1xuICAgICAgICB9XG4gICAgICAgIGFzc2VydChyZXNvbHZlciAhPSBudWxsLCBcIkVOUyByZXNvbHV0aW9uIHJlcXVpcmVzIGEgcHJvdmlkZXJcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwgeyBvcGVyYXRpb246IFwicmVzb2x2ZU5hbWVcIiB9KTtcbiAgICAgICAgcmV0dXJuIGNoZWNrQWRkcmVzcyh0YXJnZXQsIHJlc29sdmVyLnJlc29sdmVOYW1lKHRhcmdldCkpO1xuICAgIH1cbiAgICBlbHNlIGlmIChpc0FkZHJlc3NhYmxlKHRhcmdldCkpIHtcbiAgICAgICAgcmV0dXJuIGNoZWNrQWRkcmVzcyh0YXJnZXQsIHRhcmdldC5nZXRBZGRyZXNzKCkpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0YXJnZXQgJiYgdHlwZW9mICh0YXJnZXQudGhlbikgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICByZXR1cm4gY2hlY2tBZGRyZXNzKHRhcmdldCwgdGFyZ2V0KTtcbiAgICB9XG4gICAgYXNzZXJ0QXJndW1lbnQoZmFsc2UsIFwidW5zdXBwb3J0ZWQgYWRkcmVzc2FibGUgdmFsdWVcIiwgXCJ0YXJnZXRcIiwgdGFyZ2V0KTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNoZWNrcy5qcy5tYXAiXSwibmFtZXMiOlsiYXNzZXJ0IiwiYXNzZXJ0QXJndW1lbnQiLCJnZXRBZGRyZXNzIiwiaXNBZGRyZXNzYWJsZSIsInZhbHVlIiwiaXNBZGRyZXNzIiwiZXJyb3IiLCJjaGVja0FkZHJlc3MiLCJ0YXJnZXQiLCJwcm9taXNlIiwicmVzdWx0IiwicmVzb2x2ZUFkZHJlc3MiLCJyZXNvbHZlciIsIm1hdGNoIiwib3BlcmF0aW9uIiwicmVzb2x2ZU5hbWUiLCJ0aGVuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.esm/address/checks.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.esm/address/contract-address.js":
/*!*****************************************************************!*\
  !*** ./node_modules/ethers/lib.esm/address/contract-address.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getCreate2Address: () => (/* binding */ getCreate2Address),\n/* harmony export */   getCreateAddress: () => (/* binding */ getCreateAddress)\n/* harmony export */ });\n/* harmony import */ var _crypto_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../crypto/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/crypto/keccak.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/maths.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/data.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/rlp-encode.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/errors.js\");\n/* harmony import */ var _address_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./address.js */ \"(ssr)/./node_modules/ethers/lib.esm/address/address.js\");\n\n\n\n// http://ethereum.stackexchange.com/questions/760/how-is-the-address-of-an-ethereum-contract-computed\n/**\n *  Returns the address that would result from a ``CREATE`` for %%tx%%.\n *\n *  This can be used to compute the address a contract will be\n *  deployed to by an EOA when sending a deployment transaction (i.e.\n *  when the ``to`` address is ``null``).\n *\n *  This can also be used to compute the address a contract will be\n *  deployed to by a contract, by using the contract's address as the\n *  ``to`` and the contract's nonce.\n *\n *  @example\n *    from = \"0x8ba1f109551bD432803012645Ac136ddd64DBA72\";\n *    nonce = 5;\n *\n *    getCreateAddress({ from, nonce });\n *    //_result:\n */ function getCreateAddress(tx) {\n    const from = (0,_address_js__WEBPACK_IMPORTED_MODULE_0__.getAddress)(tx.from);\n    const nonce = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.getBigInt)(tx.nonce, \"tx.nonce\");\n    let nonceHex = nonce.toString(16);\n    if (nonceHex === \"0\") {\n        nonceHex = \"0x\";\n    } else if (nonceHex.length % 2) {\n        nonceHex = \"0x0\" + nonceHex;\n    } else {\n        nonceHex = \"0x\" + nonceHex;\n    }\n    return (0,_address_js__WEBPACK_IMPORTED_MODULE_0__.getAddress)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.dataSlice)((0,_crypto_index_js__WEBPACK_IMPORTED_MODULE_3__.keccak256)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_4__.encodeRlp)([\n        from,\n        nonceHex\n    ])), 12));\n}\n/**\n *  Returns the address that would result from a ``CREATE2`` operation\n *  with the given %%from%%, %%salt%% and %%initCodeHash%%.\n *\n *  To compute the %%initCodeHash%% from a contract's init code, use\n *  the [[keccak256]] function.\n *\n *  For a quick overview and example of ``CREATE2``, see [[link-ricmoo-wisps]].\n *\n *  @example\n *    // The address of the contract\n *    from = \"0x8ba1f109551bD432803012645Ac136ddd64DBA72\"\n *\n *    // The salt\n *    salt = id(\"HelloWorld\")\n *\n *    // The hash of the initCode\n *    initCode = \"0x6394198df16000526103ff60206004601c335afa6040516060f3\";\n *    initCodeHash = keccak256(initCode)\n *\n *    getCreate2Address(from, salt, initCodeHash)\n *    //_result:\n */ function getCreate2Address(_from, _salt, _initCodeHash) {\n    const from = (0,_address_js__WEBPACK_IMPORTED_MODULE_0__.getAddress)(_from);\n    const salt = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.getBytes)(_salt, \"salt\");\n    const initCodeHash = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.getBytes)(_initCodeHash, \"initCodeHash\");\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.assertArgument)(salt.length === 32, \"salt must be 32 bytes\", \"salt\", _salt);\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.assertArgument)(initCodeHash.length === 32, \"initCodeHash must be 32 bytes\", \"initCodeHash\", _initCodeHash);\n    return (0,_address_js__WEBPACK_IMPORTED_MODULE_0__.getAddress)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.dataSlice)((0,_crypto_index_js__WEBPACK_IMPORTED_MODULE_3__.keccak256)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.concat)([\n        \"0xff\",\n        from,\n        salt,\n        initCodeHash\n    ])), 12));\n} //# sourceMappingURL=contract-address.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vYWRkcmVzcy9jb250cmFjdC1hZGRyZXNzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQStDO0FBQ3VEO0FBQzVEO0FBQzFDLHNHQUFzRztBQUN0Rzs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FpQkMsR0FDTSxTQUFTUSxpQkFBaUJDLEVBQUU7SUFDL0IsTUFBTUMsT0FBT0gsdURBQVVBLENBQUNFLEdBQUdDLElBQUk7SUFDL0IsTUFBTUMsUUFBUVIsMERBQVNBLENBQUNNLEdBQUdFLEtBQUssRUFBRTtJQUNsQyxJQUFJQyxXQUFXRCxNQUFNRSxRQUFRLENBQUM7SUFDOUIsSUFBSUQsYUFBYSxLQUFLO1FBQ2xCQSxXQUFXO0lBQ2YsT0FDSyxJQUFJQSxTQUFTRSxNQUFNLEdBQUcsR0FBRztRQUMxQkYsV0FBVyxRQUFRQTtJQUN2QixPQUNLO1FBQ0RBLFdBQVcsT0FBT0E7SUFDdEI7SUFDQSxPQUFPTCx1REFBVUEsQ0FBQ0wsMERBQVNBLENBQUNGLDJEQUFTQSxDQUFDSywwREFBU0EsQ0FBQztRQUFDSztRQUFNRTtLQUFTLElBQUk7QUFDeEU7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQXNCQyxHQUNNLFNBQVNHLGtCQUFrQkMsS0FBSyxFQUFFQyxLQUFLLEVBQUVDLGFBQWE7SUFDekQsTUFBTVIsT0FBT0gsdURBQVVBLENBQUNTO0lBQ3hCLE1BQU1HLE9BQU9mLHlEQUFRQSxDQUFDYSxPQUFPO0lBQzdCLE1BQU1HLGVBQWVoQix5REFBUUEsQ0FBQ2MsZUFBZTtJQUM3Q1osK0RBQWNBLENBQUNhLEtBQUtMLE1BQU0sS0FBSyxJQUFJLHlCQUF5QixRQUFRRztJQUNwRVgsK0RBQWNBLENBQUNjLGFBQWFOLE1BQU0sS0FBSyxJQUFJLGlDQUFpQyxnQkFBZ0JJO0lBQzVGLE9BQU9YLHVEQUFVQSxDQUFDTCwwREFBU0EsQ0FBQ0YsMkRBQVNBLENBQUNDLHVEQUFNQSxDQUFDO1FBQUM7UUFBUVM7UUFBTVM7UUFBTUM7S0FBYSxJQUFJO0FBQ3ZGLEVBQ0EsNENBQTRDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbWVnYXZpYmUtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vYWRkcmVzcy9jb250cmFjdC1hZGRyZXNzLmpzP2MwYmEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsga2VjY2FrMjU2IH0gZnJvbSBcIi4uL2NyeXB0by9pbmRleC5qc1wiO1xuaW1wb3J0IHsgY29uY2F0LCBkYXRhU2xpY2UsIGdldEJpZ0ludCwgZ2V0Qnl0ZXMsIGVuY29kZVJscCwgYXNzZXJ0QXJndW1lbnQgfSBmcm9tIFwiLi4vdXRpbHMvaW5kZXguanNcIjtcbmltcG9ydCB7IGdldEFkZHJlc3MgfSBmcm9tIFwiLi9hZGRyZXNzLmpzXCI7XG4vLyBodHRwOi8vZXRoZXJldW0uc3RhY2tleGNoYW5nZS5jb20vcXVlc3Rpb25zLzc2MC9ob3ctaXMtdGhlLWFkZHJlc3Mtb2YtYW4tZXRoZXJldW0tY29udHJhY3QtY29tcHV0ZWRcbi8qKlxuICogIFJldHVybnMgdGhlIGFkZHJlc3MgdGhhdCB3b3VsZCByZXN1bHQgZnJvbSBhIGBgQ1JFQVRFYGAgZm9yICUldHglJS5cbiAqXG4gKiAgVGhpcyBjYW4gYmUgdXNlZCB0byBjb21wdXRlIHRoZSBhZGRyZXNzIGEgY29udHJhY3Qgd2lsbCBiZVxuICogIGRlcGxveWVkIHRvIGJ5IGFuIEVPQSB3aGVuIHNlbmRpbmcgYSBkZXBsb3ltZW50IHRyYW5zYWN0aW9uIChpLmUuXG4gKiAgd2hlbiB0aGUgYGB0b2BgIGFkZHJlc3MgaXMgYGBudWxsYGApLlxuICpcbiAqICBUaGlzIGNhbiBhbHNvIGJlIHVzZWQgdG8gY29tcHV0ZSB0aGUgYWRkcmVzcyBhIGNvbnRyYWN0IHdpbGwgYmVcbiAqICBkZXBsb3llZCB0byBieSBhIGNvbnRyYWN0LCBieSB1c2luZyB0aGUgY29udHJhY3QncyBhZGRyZXNzIGFzIHRoZVxuICogIGBgdG9gYCBhbmQgdGhlIGNvbnRyYWN0J3Mgbm9uY2UuXG4gKlxuICogIEBleGFtcGxlXG4gKiAgICBmcm9tID0gXCIweDhiYTFmMTA5NTUxYkQ0MzI4MDMwMTI2NDVBYzEzNmRkZDY0REJBNzJcIjtcbiAqICAgIG5vbmNlID0gNTtcbiAqXG4gKiAgICBnZXRDcmVhdGVBZGRyZXNzKHsgZnJvbSwgbm9uY2UgfSk7XG4gKiAgICAvL19yZXN1bHQ6XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRDcmVhdGVBZGRyZXNzKHR4KSB7XG4gICAgY29uc3QgZnJvbSA9IGdldEFkZHJlc3ModHguZnJvbSk7XG4gICAgY29uc3Qgbm9uY2UgPSBnZXRCaWdJbnQodHgubm9uY2UsIFwidHgubm9uY2VcIik7XG4gICAgbGV0IG5vbmNlSGV4ID0gbm9uY2UudG9TdHJpbmcoMTYpO1xuICAgIGlmIChub25jZUhleCA9PT0gXCIwXCIpIHtcbiAgICAgICAgbm9uY2VIZXggPSBcIjB4XCI7XG4gICAgfVxuICAgIGVsc2UgaWYgKG5vbmNlSGV4Lmxlbmd0aCAlIDIpIHtcbiAgICAgICAgbm9uY2VIZXggPSBcIjB4MFwiICsgbm9uY2VIZXg7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBub25jZUhleCA9IFwiMHhcIiArIG5vbmNlSGV4O1xuICAgIH1cbiAgICByZXR1cm4gZ2V0QWRkcmVzcyhkYXRhU2xpY2Uoa2VjY2FrMjU2KGVuY29kZVJscChbZnJvbSwgbm9uY2VIZXhdKSksIDEyKSk7XG59XG4vKipcbiAqICBSZXR1cm5zIHRoZSBhZGRyZXNzIHRoYXQgd291bGQgcmVzdWx0IGZyb20gYSBgYENSRUFURTJgYCBvcGVyYXRpb25cbiAqICB3aXRoIHRoZSBnaXZlbiAlJWZyb20lJSwgJSVzYWx0JSUgYW5kICUlaW5pdENvZGVIYXNoJSUuXG4gKlxuICogIFRvIGNvbXB1dGUgdGhlICUlaW5pdENvZGVIYXNoJSUgZnJvbSBhIGNvbnRyYWN0J3MgaW5pdCBjb2RlLCB1c2VcbiAqICB0aGUgW1trZWNjYWsyNTZdXSBmdW5jdGlvbi5cbiAqXG4gKiAgRm9yIGEgcXVpY2sgb3ZlcnZpZXcgYW5kIGV4YW1wbGUgb2YgYGBDUkVBVEUyYGAsIHNlZSBbW2xpbmstcmljbW9vLXdpc3BzXV0uXG4gKlxuICogIEBleGFtcGxlXG4gKiAgICAvLyBUaGUgYWRkcmVzcyBvZiB0aGUgY29udHJhY3RcbiAqICAgIGZyb20gPSBcIjB4OGJhMWYxMDk1NTFiRDQzMjgwMzAxMjY0NUFjMTM2ZGRkNjREQkE3MlwiXG4gKlxuICogICAgLy8gVGhlIHNhbHRcbiAqICAgIHNhbHQgPSBpZChcIkhlbGxvV29ybGRcIilcbiAqXG4gKiAgICAvLyBUaGUgaGFzaCBvZiB0aGUgaW5pdENvZGVcbiAqICAgIGluaXRDb2RlID0gXCIweDYzOTQxOThkZjE2MDAwNTI2MTAzZmY2MDIwNjAwNDYwMWMzMzVhZmE2MDQwNTE2MDYwZjNcIjtcbiAqICAgIGluaXRDb2RlSGFzaCA9IGtlY2NhazI1Nihpbml0Q29kZSlcbiAqXG4gKiAgICBnZXRDcmVhdGUyQWRkcmVzcyhmcm9tLCBzYWx0LCBpbml0Q29kZUhhc2gpXG4gKiAgICAvL19yZXN1bHQ6XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRDcmVhdGUyQWRkcmVzcyhfZnJvbSwgX3NhbHQsIF9pbml0Q29kZUhhc2gpIHtcbiAgICBjb25zdCBmcm9tID0gZ2V0QWRkcmVzcyhfZnJvbSk7XG4gICAgY29uc3Qgc2FsdCA9IGdldEJ5dGVzKF9zYWx0LCBcInNhbHRcIik7XG4gICAgY29uc3QgaW5pdENvZGVIYXNoID0gZ2V0Qnl0ZXMoX2luaXRDb2RlSGFzaCwgXCJpbml0Q29kZUhhc2hcIik7XG4gICAgYXNzZXJ0QXJndW1lbnQoc2FsdC5sZW5ndGggPT09IDMyLCBcInNhbHQgbXVzdCBiZSAzMiBieXRlc1wiLCBcInNhbHRcIiwgX3NhbHQpO1xuICAgIGFzc2VydEFyZ3VtZW50KGluaXRDb2RlSGFzaC5sZW5ndGggPT09IDMyLCBcImluaXRDb2RlSGFzaCBtdXN0IGJlIDMyIGJ5dGVzXCIsIFwiaW5pdENvZGVIYXNoXCIsIF9pbml0Q29kZUhhc2gpO1xuICAgIHJldHVybiBnZXRBZGRyZXNzKGRhdGFTbGljZShrZWNjYWsyNTYoY29uY2F0KFtcIjB4ZmZcIiwgZnJvbSwgc2FsdCwgaW5pdENvZGVIYXNoXSkpLCAxMikpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29udHJhY3QtYWRkcmVzcy5qcy5tYXAiXSwibmFtZXMiOlsia2VjY2FrMjU2IiwiY29uY2F0IiwiZGF0YVNsaWNlIiwiZ2V0QmlnSW50IiwiZ2V0Qnl0ZXMiLCJlbmNvZGVSbHAiLCJhc3NlcnRBcmd1bWVudCIsImdldEFkZHJlc3MiLCJnZXRDcmVhdGVBZGRyZXNzIiwidHgiLCJmcm9tIiwibm9uY2UiLCJub25jZUhleCIsInRvU3RyaW5nIiwibGVuZ3RoIiwiZ2V0Q3JlYXRlMkFkZHJlc3MiLCJfZnJvbSIsIl9zYWx0IiwiX2luaXRDb2RlSGFzaCIsInNhbHQiLCJpbml0Q29kZUhhc2giXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.esm/address/contract-address.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.esm/constants/addresses.js":
/*!************************************************************!*\
  !*** ./node_modules/ethers/lib.esm/constants/addresses.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ZeroAddress: () => (/* binding */ ZeroAddress)\n/* harmony export */ });\n/**\n *  A constant for the zero address.\n *\n *  (**i.e.** ``\"0x0000000000000000000000000000000000000000\"``)\n */ const ZeroAddress = \"0x0000000000000000000000000000000000000000\"; //# sourceMappingURL=addresses.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vY29uc3RhbnRzL2FkZHJlc3Nlcy5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7Ozs7Q0FJQyxHQUNNLE1BQU1BLGNBQWMsNkNBQTZDLENBQ3hFLHFDQUFxQyIsInNvdXJjZXMiOlsid2VicGFjazovL21lZ2F2aWJlLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL2NvbnN0YW50cy9hZGRyZXNzZXMuanM/MjMxZCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqICBBIGNvbnN0YW50IGZvciB0aGUgemVybyBhZGRyZXNzLlxuICpcbiAqICAoKippLmUuKiogYGBcIjB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMFwiYGApXG4gKi9cbmV4cG9ydCBjb25zdCBaZXJvQWRkcmVzcyA9IFwiMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwXCI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hZGRyZXNzZXMuanMubWFwIl0sIm5hbWVzIjpbIlplcm9BZGRyZXNzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.esm/constants/addresses.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.esm/constants/hashes.js":
/*!*********************************************************!*\
  !*** ./node_modules/ethers/lib.esm/constants/hashes.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ZeroHash: () => (/* binding */ ZeroHash)\n/* harmony export */ });\n/**\n *  A constant for the zero hash.\n *\n *  (**i.e.** ``\"0x0000000000000000000000000000000000000000000000000000000000000000\"``)\n */ const ZeroHash = \"0x0000000000000000000000000000000000000000000000000000000000000000\"; //# sourceMappingURL=hashes.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vY29uc3RhbnRzL2hhc2hlcy5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7Ozs7Q0FJQyxHQUNNLE1BQU1BLFdBQVcscUVBQXFFLENBQzdGLGtDQUFrQyIsInNvdXJjZXMiOlsid2VicGFjazovL21lZ2F2aWJlLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL2NvbnN0YW50cy9oYXNoZXMuanM/OTdkOSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqICBBIGNvbnN0YW50IGZvciB0aGUgemVybyBoYXNoLlxuICpcbiAqICAoKippLmUuKiogYGBcIjB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMFwiYGApXG4gKi9cbmV4cG9ydCBjb25zdCBaZXJvSGFzaCA9IFwiMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwXCI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1oYXNoZXMuanMubWFwIl0sIm5hbWVzIjpbIlplcm9IYXNoIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.esm/constants/hashes.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.esm/contract/contract.js":
/*!**********************************************************!*\
  !*** ./node_modules/ethers/lib.esm/contract/contract.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BaseContract: () => (/* binding */ BaseContract),\n/* harmony export */   Contract: () => (/* binding */ Contract),\n/* harmony export */   copyOverrides: () => (/* binding */ copyOverrides),\n/* harmony export */   resolveArgs: () => (/* binding */ resolveArgs)\n/* harmony export */ });\n/* harmony import */ var _abi_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../abi/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/abi/typed.js\");\n/* harmony import */ var _abi_index_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../abi/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/abi/interface.js\");\n/* harmony import */ var _address_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../address/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/address/checks.js\");\n/* harmony import */ var _providers_provider_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../providers/provider.js */ \"(ssr)/./node_modules/ethers/lib.esm/providers/provider.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/properties.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/errors.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/maths.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/data.js\");\n/* harmony import */ var _wrappers_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./wrappers.js */ \"(ssr)/./node_modules/ethers/lib.esm/contract/wrappers.js\");\n\n\n// import from provider.ts instead of index.ts to prevent circular dep\n// from EtherscanProvider\n\n\n\nconst BN_0 = BigInt(0);\nfunction canCall(value) {\n    return value && typeof value.call === \"function\";\n}\nfunction canEstimate(value) {\n    return value && typeof value.estimateGas === \"function\";\n}\nfunction canResolve(value) {\n    return value && typeof value.resolveName === \"function\";\n}\nfunction canSend(value) {\n    return value && typeof value.sendTransaction === \"function\";\n}\nfunction getResolver(value) {\n    if (value != null) {\n        if (canResolve(value)) {\n            return value;\n        }\n        if (value.provider) {\n            return value.provider;\n        }\n    }\n    return undefined;\n}\nclass PreparedTopicFilter {\n    #filter;\n    constructor(contract, fragment, args){\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.defineProperties)(this, {\n            fragment\n        });\n        if (fragment.inputs.length < args.length) {\n            throw new Error(\"too many arguments\");\n        }\n        // Recursively descend into args and resolve any addresses\n        const runner = getRunner(contract.runner, \"resolveName\");\n        const resolver = canResolve(runner) ? runner : null;\n        this.#filter = async function() {\n            const resolvedArgs = await Promise.all(fragment.inputs.map((param, index)=>{\n                const arg = args[index];\n                if (arg == null) {\n                    return null;\n                }\n                return param.walkAsync(args[index], (type, value)=>{\n                    if (type === \"address\") {\n                        if (Array.isArray(value)) {\n                            return Promise.all(value.map((v)=>(0,_address_index_js__WEBPACK_IMPORTED_MODULE_1__.resolveAddress)(v, resolver)));\n                        }\n                        return (0,_address_index_js__WEBPACK_IMPORTED_MODULE_1__.resolveAddress)(value, resolver);\n                    }\n                    return value;\n                });\n            }));\n            return contract.interface.encodeFilterTopics(fragment, resolvedArgs);\n        }();\n    }\n    getTopicFilter() {\n        return this.#filter;\n    }\n}\n// A = Arguments passed in as a tuple\n// R = The result type of the call (i.e. if only one return type,\n//     the qualified type, otherwise Result)\n// D = The type the default call will return (i.e. R for view/pure,\n//     TransactionResponse otherwise)\n//export interface ContractMethod<A extends Array<any> = Array<any>, R = any, D extends R | ContractTransactionResponse = ContractTransactionResponse> {\nfunction getRunner(value, feature) {\n    if (value == null) {\n        return null;\n    }\n    if (typeof value[feature] === \"function\") {\n        return value;\n    }\n    if (value.provider && typeof value.provider[feature] === \"function\") {\n        return value.provider;\n    }\n    return null;\n}\nfunction getProvider(value) {\n    if (value == null) {\n        return null;\n    }\n    return value.provider || null;\n}\n/**\n *  @_ignore:\n */ async function copyOverrides(arg, allowed) {\n    // Make sure the overrides passed in are a valid overrides object\n    const _overrides = _abi_index_js__WEBPACK_IMPORTED_MODULE_2__.Typed.dereference(arg, \"overrides\");\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(typeof _overrides === \"object\", \"invalid overrides parameter\", \"overrides\", arg);\n    // Create a shallow copy (we'll deep-ify anything needed during normalizing)\n    const overrides = (0,_providers_provider_js__WEBPACK_IMPORTED_MODULE_4__.copyRequest)(_overrides);\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(overrides.to == null || (allowed || []).indexOf(\"to\") >= 0, \"cannot override to\", \"overrides.to\", overrides.to);\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(overrides.data == null || (allowed || []).indexOf(\"data\") >= 0, \"cannot override data\", \"overrides.data\", overrides.data);\n    // Resolve any from\n    if (overrides.from) {\n        overrides.from = overrides.from;\n    }\n    return overrides;\n}\n/**\n *  @_ignore:\n */ async function resolveArgs(_runner, inputs, args) {\n    // Recursively descend into args and resolve any addresses\n    const runner = getRunner(_runner, \"resolveName\");\n    const resolver = canResolve(runner) ? runner : null;\n    return await Promise.all(inputs.map((param, index)=>{\n        return param.walkAsync(args[index], (type, value)=>{\n            value = _abi_index_js__WEBPACK_IMPORTED_MODULE_2__.Typed.dereference(value, type);\n            if (type === \"address\") {\n                return (0,_address_index_js__WEBPACK_IMPORTED_MODULE_1__.resolveAddress)(value, resolver);\n            }\n            return value;\n        });\n    }));\n}\nfunction buildWrappedFallback(contract) {\n    const populateTransaction = async function(overrides) {\n        // If an overrides was passed in, copy it and normalize the values\n        const tx = await copyOverrides(overrides, [\n            \"data\"\n        ]);\n        tx.to = await contract.getAddress();\n        if (tx.from) {\n            tx.from = await (0,_address_index_js__WEBPACK_IMPORTED_MODULE_1__.resolveAddress)(tx.from, getResolver(contract.runner));\n        }\n        const iface = contract.interface;\n        const noValue = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.getBigInt)(tx.value || BN_0, \"overrides.value\") === BN_0;\n        const noData = (tx.data || \"0x\") === \"0x\";\n        if (iface.fallback && !iface.fallback.payable && iface.receive && !noData && !noValue) {\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(false, \"cannot send data to receive or send value to non-payable fallback\", \"overrides\", overrides);\n        }\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(iface.fallback || noData, \"cannot send data to receive-only contract\", \"overrides.data\", tx.data);\n        // Only allow payable contracts to set non-zero value\n        const payable = iface.receive || iface.fallback && iface.fallback.payable;\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(payable || noValue, \"cannot send value to non-payable fallback\", \"overrides.value\", tx.value);\n        // Only allow fallback contracts to set non-empty data\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(iface.fallback || noData, \"cannot send data to receive-only contract\", \"overrides.data\", tx.data);\n        return tx;\n    };\n    const staticCall = async function(overrides) {\n        const runner = getRunner(contract.runner, \"call\");\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assert)(canCall(runner), \"contract runner does not support calling\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"call\"\n        });\n        const tx = await populateTransaction(overrides);\n        try {\n            return await runner.call(tx);\n        } catch (error) {\n            if ((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.isCallException)(error) && error.data) {\n                throw contract.interface.makeError(error.data, tx);\n            }\n            throw error;\n        }\n    };\n    const send = async function(overrides) {\n        const runner = contract.runner;\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assert)(canSend(runner), \"contract runner does not support sending transactions\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"sendTransaction\"\n        });\n        const tx = await runner.sendTransaction(await populateTransaction(overrides));\n        const provider = getProvider(contract.runner);\n        // @TODO: the provider can be null; make a custom dummy provider that will throw a\n        // meaningful error\n        return new _wrappers_js__WEBPACK_IMPORTED_MODULE_6__.ContractTransactionResponse(contract.interface, provider, tx);\n    };\n    const estimateGas = async function(overrides) {\n        const runner = getRunner(contract.runner, \"estimateGas\");\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assert)(canEstimate(runner), \"contract runner does not support gas estimation\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"estimateGas\"\n        });\n        return await runner.estimateGas(await populateTransaction(overrides));\n    };\n    const method = async (overrides)=>{\n        return await send(overrides);\n    };\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.defineProperties)(method, {\n        _contract: contract,\n        estimateGas,\n        populateTransaction,\n        send,\n        staticCall\n    });\n    return method;\n}\nfunction buildWrappedMethod(contract, key) {\n    const getFragment = function(...args) {\n        const fragment = contract.interface.getFunction(key, args);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assert)(fragment, \"no matching fragment\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"fragment\",\n            info: {\n                key,\n                args\n            }\n        });\n        return fragment;\n    };\n    const populateTransaction = async function(...args) {\n        const fragment = getFragment(...args);\n        // If an overrides was passed in, copy it and normalize the values\n        let overrides = {};\n        if (fragment.inputs.length + 1 === args.length) {\n            overrides = await copyOverrides(args.pop());\n            if (overrides.from) {\n                overrides.from = await (0,_address_index_js__WEBPACK_IMPORTED_MODULE_1__.resolveAddress)(overrides.from, getResolver(contract.runner));\n            }\n        }\n        if (fragment.inputs.length !== args.length) {\n            throw new Error(\"internal error: fragment inputs doesn't match arguments; should not happen\");\n        }\n        const resolvedArgs = await resolveArgs(contract.runner, fragment.inputs, args);\n        return Object.assign({}, overrides, await (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.resolveProperties)({\n            to: contract.getAddress(),\n            data: contract.interface.encodeFunctionData(fragment, resolvedArgs)\n        }));\n    };\n    const staticCall = async function(...args) {\n        const result = await staticCallResult(...args);\n        if (result.length === 1) {\n            return result[0];\n        }\n        return result;\n    };\n    const send = async function(...args) {\n        const runner = contract.runner;\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assert)(canSend(runner), \"contract runner does not support sending transactions\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"sendTransaction\"\n        });\n        const tx = await runner.sendTransaction(await populateTransaction(...args));\n        const provider = getProvider(contract.runner);\n        // @TODO: the provider can be null; make a custom dummy provider that will throw a\n        // meaningful error\n        return new _wrappers_js__WEBPACK_IMPORTED_MODULE_6__.ContractTransactionResponse(contract.interface, provider, tx);\n    };\n    const estimateGas = async function(...args) {\n        const runner = getRunner(contract.runner, \"estimateGas\");\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assert)(canEstimate(runner), \"contract runner does not support gas estimation\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"estimateGas\"\n        });\n        return await runner.estimateGas(await populateTransaction(...args));\n    };\n    const staticCallResult = async function(...args) {\n        const runner = getRunner(contract.runner, \"call\");\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assert)(canCall(runner), \"contract runner does not support calling\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"call\"\n        });\n        const tx = await populateTransaction(...args);\n        let result = \"0x\";\n        try {\n            result = await runner.call(tx);\n        } catch (error) {\n            if ((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.isCallException)(error) && error.data) {\n                throw contract.interface.makeError(error.data, tx);\n            }\n            throw error;\n        }\n        const fragment = getFragment(...args);\n        return contract.interface.decodeFunctionResult(fragment, result);\n    };\n    const method = async (...args)=>{\n        const fragment = getFragment(...args);\n        if (fragment.constant) {\n            return await staticCall(...args);\n        }\n        return await send(...args);\n    };\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.defineProperties)(method, {\n        name: contract.interface.getFunctionName(key),\n        _contract: contract,\n        _key: key,\n        getFragment,\n        estimateGas,\n        populateTransaction,\n        send,\n        staticCall,\n        staticCallResult\n    });\n    // Only works on non-ambiguous keys (refined fragment is always non-ambiguous)\n    Object.defineProperty(method, \"fragment\", {\n        configurable: false,\n        enumerable: true,\n        get: ()=>{\n            const fragment = contract.interface.getFunction(key);\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assert)(fragment, \"no matching fragment\", \"UNSUPPORTED_OPERATION\", {\n                operation: \"fragment\",\n                info: {\n                    key\n                }\n            });\n            return fragment;\n        }\n    });\n    return method;\n}\nfunction buildWrappedEvent(contract, key) {\n    const getFragment = function(...args) {\n        const fragment = contract.interface.getEvent(key, args);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assert)(fragment, \"no matching fragment\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"fragment\",\n            info: {\n                key,\n                args\n            }\n        });\n        return fragment;\n    };\n    const method = function(...args) {\n        return new PreparedTopicFilter(contract, getFragment(...args), args);\n    };\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.defineProperties)(method, {\n        name: contract.interface.getEventName(key),\n        _contract: contract,\n        _key: key,\n        getFragment\n    });\n    // Only works on non-ambiguous keys (refined fragment is always non-ambiguous)\n    Object.defineProperty(method, \"fragment\", {\n        configurable: false,\n        enumerable: true,\n        get: ()=>{\n            const fragment = contract.interface.getEvent(key);\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assert)(fragment, \"no matching fragment\", \"UNSUPPORTED_OPERATION\", {\n                operation: \"fragment\",\n                info: {\n                    key\n                }\n            });\n            return fragment;\n        }\n    });\n    return method;\n}\n// The combination of TypeScrype, Private Fields and Proxies makes\n// the world go boom; so we hide variables with some trickery keeping\n// a symbol attached to each BaseContract which its sub-class (even\n// via a Proxy) can reach and use to look up its internal values.\nconst internal = Symbol.for(\"_ethersInternal_contract\");\nconst internalValues = new WeakMap();\nfunction setInternal(contract, values) {\n    internalValues.set(contract[internal], values);\n}\nfunction getInternal(contract) {\n    return internalValues.get(contract[internal]);\n}\nfunction isDeferred(value) {\n    return value && typeof value === \"object\" && \"getTopicFilter\" in value && typeof value.getTopicFilter === \"function\" && value.fragment;\n}\nasync function getSubInfo(contract, event) {\n    let topics;\n    let fragment = null;\n    // Convert named events to topicHash and get the fragment for\n    // events which need deconstructing.\n    if (Array.isArray(event)) {\n        const topicHashify = function(name) {\n            if ((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_7__.isHexString)(name, 32)) {\n                return name;\n            }\n            const fragment = contract.interface.getEvent(name);\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(fragment, \"unknown fragment\", \"name\", name);\n            return fragment.topicHash;\n        };\n        // Array of Topics and Names; e.g. `[ \"0x1234...89ab\", \"Transfer(address)\" ]`\n        topics = event.map((e)=>{\n            if (e == null) {\n                return null;\n            }\n            if (Array.isArray(e)) {\n                return e.map(topicHashify);\n            }\n            return topicHashify(e);\n        });\n    } else if (event === \"*\") {\n        topics = [\n            null\n        ];\n    } else if (typeof event === \"string\") {\n        if ((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_7__.isHexString)(event, 32)) {\n            // Topic Hash\n            topics = [\n                event\n            ];\n        } else {\n            // Name or Signature; e.g. `\"Transfer\", `\"Transfer(address)\"`\n            fragment = contract.interface.getEvent(event);\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(fragment, \"unknown fragment\", \"event\", event);\n            topics = [\n                fragment.topicHash\n            ];\n        }\n    } else if (isDeferred(event)) {\n        // Deferred Topic Filter; e.g. `contract.filter.Transfer(from)`\n        topics = await event.getTopicFilter();\n    } else if (\"fragment\" in event) {\n        // ContractEvent; e.g. `contract.filter.Transfer`\n        fragment = event.fragment;\n        topics = [\n            fragment.topicHash\n        ];\n    } else {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(false, \"unknown event name\", \"event\", event);\n    }\n    // Normalize topics and sort TopicSets\n    topics = topics.map((t)=>{\n        if (t == null) {\n            return null;\n        }\n        if (Array.isArray(t)) {\n            const items = Array.from(new Set(t.map((t)=>t.toLowerCase())).values());\n            if (items.length === 1) {\n                return items[0];\n            }\n            items.sort();\n            return items;\n        }\n        return t.toLowerCase();\n    });\n    const tag = topics.map((t)=>{\n        if (t == null) {\n            return \"null\";\n        }\n        if (Array.isArray(t)) {\n            return t.join(\"|\");\n        }\n        return t;\n    }).join(\"&\");\n    return {\n        fragment,\n        tag,\n        topics\n    };\n}\nasync function hasSub(contract, event) {\n    const { subs } = getInternal(contract);\n    return subs.get((await getSubInfo(contract, event)).tag) || null;\n}\nasync function getSub(contract, operation, event) {\n    // Make sure our runner can actually subscribe to events\n    const provider = getProvider(contract.runner);\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assert)(provider, \"contract runner does not support subscribing\", \"UNSUPPORTED_OPERATION\", {\n        operation\n    });\n    const { fragment, tag, topics } = await getSubInfo(contract, event);\n    const { addr, subs } = getInternal(contract);\n    let sub = subs.get(tag);\n    if (!sub) {\n        const address = addr ? addr : contract;\n        const filter = {\n            address,\n            topics\n        };\n        const listener = (log)=>{\n            let foundFragment = fragment;\n            if (foundFragment == null) {\n                try {\n                    foundFragment = contract.interface.getEvent(log.topics[0]);\n                } catch (error) {}\n            }\n            // If fragment is null, we do not deconstruct the args to emit\n            if (foundFragment) {\n                const _foundFragment = foundFragment;\n                const args = fragment ? contract.interface.decodeEventLog(fragment, log.data, log.topics) : [];\n                emit(contract, event, args, (listener)=>{\n                    return new _wrappers_js__WEBPACK_IMPORTED_MODULE_6__.ContractEventPayload(contract, listener, event, _foundFragment, log);\n                });\n            } else {\n                emit(contract, event, [], (listener)=>{\n                    return new _wrappers_js__WEBPACK_IMPORTED_MODULE_6__.ContractUnknownEventPayload(contract, listener, event, log);\n                });\n            }\n        };\n        let starting = [];\n        const start = ()=>{\n            if (starting.length) {\n                return;\n            }\n            starting.push(provider.on(filter, listener));\n        };\n        const stop = async ()=>{\n            if (starting.length == 0) {\n                return;\n            }\n            let started = starting;\n            starting = [];\n            await Promise.all(started);\n            provider.off(filter, listener);\n        };\n        sub = {\n            tag,\n            listeners: [],\n            start,\n            stop\n        };\n        subs.set(tag, sub);\n    }\n    return sub;\n}\n// We use this to ensure one emit resolves before firing the next to\n// ensure correct ordering (note this cannot throw and just adds the\n// notice to the event queu using setTimeout).\nlet lastEmit = Promise.resolve();\nasync function _emit(contract, event, args, payloadFunc) {\n    await lastEmit;\n    const sub = await hasSub(contract, event);\n    if (!sub) {\n        return false;\n    }\n    const count = sub.listeners.length;\n    sub.listeners = sub.listeners.filter(({ listener, once })=>{\n        const passArgs = Array.from(args);\n        if (payloadFunc) {\n            passArgs.push(payloadFunc(once ? null : listener));\n        }\n        try {\n            listener.call(contract, ...passArgs);\n        } catch (error) {}\n        return !once;\n    });\n    if (sub.listeners.length === 0) {\n        sub.stop();\n        getInternal(contract).subs.delete(sub.tag);\n    }\n    return count > 0;\n}\nasync function emit(contract, event, args, payloadFunc) {\n    try {\n        await lastEmit;\n    } catch (error) {}\n    const resultPromise = _emit(contract, event, args, payloadFunc);\n    lastEmit = resultPromise;\n    return await resultPromise;\n}\nconst passProperties = [\n    \"then\"\n];\nclass BaseContract {\n    /**\n     *  Creates a new contract connected to %%target%% with the %%abi%% and\n     *  optionally connected to a %%runner%% to perform operations on behalf\n     *  of.\n     */ constructor(target, abi, runner, _deployTx){\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(typeof target === \"string\" || (0,_address_index_js__WEBPACK_IMPORTED_MODULE_1__.isAddressable)(target), \"invalid value for Contract target\", \"target\", target);\n        if (runner == null) {\n            runner = null;\n        }\n        const iface = _abi_index_js__WEBPACK_IMPORTED_MODULE_8__.Interface.from(abi);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.defineProperties)(this, {\n            target,\n            runner,\n            interface: iface\n        });\n        Object.defineProperty(this, internal, {\n            value: {}\n        });\n        let addrPromise;\n        let addr = null;\n        let deployTx = null;\n        if (_deployTx) {\n            const provider = getProvider(runner);\n            // @TODO: the provider can be null; make a custom dummy provider that will throw a\n            // meaningful error\n            deployTx = new _wrappers_js__WEBPACK_IMPORTED_MODULE_6__.ContractTransactionResponse(this.interface, provider, _deployTx);\n        }\n        let subs = new Map();\n        // Resolve the target as the address\n        if (typeof target === \"string\") {\n            if ((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_7__.isHexString)(target)) {\n                addr = target;\n                addrPromise = Promise.resolve(target);\n            } else {\n                const resolver = getRunner(runner, \"resolveName\");\n                if (!canResolve(resolver)) {\n                    throw (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.makeError)(\"contract runner does not support name resolution\", \"UNSUPPORTED_OPERATION\", {\n                        operation: \"resolveName\"\n                    });\n                }\n                addrPromise = resolver.resolveName(target).then((addr)=>{\n                    if (addr == null) {\n                        throw (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.makeError)(\"an ENS name used for a contract target must be correctly configured\", \"UNCONFIGURED_NAME\", {\n                            value: target\n                        });\n                    }\n                    getInternal(this).addr = addr;\n                    return addr;\n                });\n            }\n        } else {\n            addrPromise = target.getAddress().then((addr)=>{\n                if (addr == null) {\n                    throw new Error(\"TODO\");\n                }\n                getInternal(this).addr = addr;\n                return addr;\n            });\n        }\n        // Set our private values\n        setInternal(this, {\n            addrPromise,\n            addr,\n            deployTx,\n            subs\n        });\n        // Add the event filters\n        const filters = new Proxy({}, {\n            get: (target, prop, receiver)=>{\n                // Pass important checks (like `then` for Promise) through\n                if (typeof prop === \"symbol\" || passProperties.indexOf(prop) >= 0) {\n                    return Reflect.get(target, prop, receiver);\n                }\n                try {\n                    return this.getEvent(prop);\n                } catch (error) {\n                    if (!(0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.isError)(error, \"INVALID_ARGUMENT\") || error.argument !== \"key\") {\n                        throw error;\n                    }\n                }\n                return undefined;\n            },\n            has: (target, prop)=>{\n                // Pass important checks (like `then` for Promise) through\n                if (passProperties.indexOf(prop) >= 0) {\n                    return Reflect.has(target, prop);\n                }\n                return Reflect.has(target, prop) || this.interface.hasEvent(String(prop));\n            }\n        });\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.defineProperties)(this, {\n            filters\n        });\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.defineProperties)(this, {\n            fallback: iface.receive || iface.fallback ? buildWrappedFallback(this) : null\n        });\n        // Return a Proxy that will respond to functions\n        return new Proxy(this, {\n            get: (target, prop, receiver)=>{\n                if (typeof prop === \"symbol\" || prop in target || passProperties.indexOf(prop) >= 0) {\n                    return Reflect.get(target, prop, receiver);\n                }\n                // Undefined properties should return undefined\n                try {\n                    return target.getFunction(prop);\n                } catch (error) {\n                    if (!(0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.isError)(error, \"INVALID_ARGUMENT\") || error.argument !== \"key\") {\n                        throw error;\n                    }\n                }\n                return undefined;\n            },\n            has: (target, prop)=>{\n                if (typeof prop === \"symbol\" || prop in target || passProperties.indexOf(prop) >= 0) {\n                    return Reflect.has(target, prop);\n                }\n                return target.interface.hasFunction(prop);\n            }\n        });\n    }\n    /**\n     *  Return a new Contract instance with the same target and ABI, but\n     *  a different %%runner%%.\n     */ connect(runner) {\n        return new BaseContract(this.target, this.interface, runner);\n    }\n    /**\n     *  Return a new Contract instance with the same ABI and runner, but\n     *  a different %%target%%.\n     */ attach(target) {\n        return new BaseContract(target, this.interface, this.runner);\n    }\n    /**\n     *  Return the resolved address of this Contract.\n     */ async getAddress() {\n        return await getInternal(this).addrPromise;\n    }\n    /**\n     *  Return the deployed bytecode or null if no bytecode is found.\n     */ async getDeployedCode() {\n        const provider = getProvider(this.runner);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assert)(provider, \"runner does not support .provider\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"getDeployedCode\"\n        });\n        const code = await provider.getCode(await this.getAddress());\n        if (code === \"0x\") {\n            return null;\n        }\n        return code;\n    }\n    /**\n     *  Resolve to this Contract once the bytecode has been deployed, or\n     *  resolve immediately if already deployed.\n     */ async waitForDeployment() {\n        // We have the deployement transaction; just use that (throws if deployement fails)\n        const deployTx = this.deploymentTransaction();\n        if (deployTx) {\n            await deployTx.wait();\n            return this;\n        }\n        // Check for code\n        const code = await this.getDeployedCode();\n        if (code != null) {\n            return this;\n        }\n        // Make sure we can subscribe to a provider event\n        const provider = getProvider(this.runner);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assert)(provider != null, \"contract runner does not support .provider\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"waitForDeployment\"\n        });\n        return new Promise((resolve, reject)=>{\n            const checkCode = async ()=>{\n                try {\n                    const code = await this.getDeployedCode();\n                    if (code != null) {\n                        return resolve(this);\n                    }\n                    provider.once(\"block\", checkCode);\n                } catch (error) {\n                    reject(error);\n                }\n            };\n            checkCode();\n        });\n    }\n    /**\n     *  Return the transaction used to deploy this contract.\n     *\n     *  This is only available if this instance was returned from a\n     *  [[ContractFactory]].\n     */ deploymentTransaction() {\n        return getInternal(this).deployTx;\n    }\n    /**\n     *  Return the function for a given name. This is useful when a contract\n     *  method name conflicts with a JavaScript name such as ``prototype`` or\n     *  when using a Contract programatically.\n     */ getFunction(key) {\n        if (typeof key !== \"string\") {\n            key = key.format();\n        }\n        const func = buildWrappedMethod(this, key);\n        return func;\n    }\n    /**\n     *  Return the event for a given name. This is useful when a contract\n     *  event name conflicts with a JavaScript name such as ``prototype`` or\n     *  when using a Contract programatically.\n     */ getEvent(key) {\n        if (typeof key !== \"string\") {\n            key = key.format();\n        }\n        return buildWrappedEvent(this, key);\n    }\n    /**\n     *  @_ignore:\n     */ async queryTransaction(hash) {\n        throw new Error(\"@TODO\");\n    }\n    /*\n    // @TODO: this is a non-backwards compatible change, but will be added\n    //        in v7 and in a potential SmartContract class in an upcoming\n    //        v6 release\n    async getTransactionReceipt(hash: string): Promise<null | ContractTransactionReceipt> {\n        const provider = getProvider(this.runner);\n        assert(provider, \"contract runner does not have a provider\",\n            \"UNSUPPORTED_OPERATION\", { operation: \"queryTransaction\" });\n\n        const receipt = await provider.getTransactionReceipt(hash);\n        if (receipt == null) { return null; }\n\n        return new ContractTransactionReceipt(this.interface, provider, receipt);\n    }\n    */ /**\n     *  Provide historic access to event data for %%event%% in the range\n     *  %%fromBlock%% (default: ``0``) to %%toBlock%% (default: ``\"latest\"``)\n     *  inclusive.\n     */ async queryFilter(event, fromBlock, toBlock) {\n        if (fromBlock == null) {\n            fromBlock = 0;\n        }\n        if (toBlock == null) {\n            toBlock = \"latest\";\n        }\n        const { addr, addrPromise } = getInternal(this);\n        const address = addr ? addr : await addrPromise;\n        const { fragment, topics } = await getSubInfo(this, event);\n        const filter = {\n            address,\n            topics,\n            fromBlock,\n            toBlock\n        };\n        const provider = getProvider(this.runner);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assert)(provider, \"contract runner does not have a provider\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"queryFilter\"\n        });\n        return (await provider.getLogs(filter)).map((log)=>{\n            let foundFragment = fragment;\n            if (foundFragment == null) {\n                try {\n                    foundFragment = this.interface.getEvent(log.topics[0]);\n                } catch (error) {}\n            }\n            if (foundFragment) {\n                try {\n                    return new _wrappers_js__WEBPACK_IMPORTED_MODULE_6__.EventLog(log, this.interface, foundFragment);\n                } catch (error) {\n                    return new _wrappers_js__WEBPACK_IMPORTED_MODULE_6__.UndecodedEventLog(log, error);\n                }\n            }\n            return new _providers_provider_js__WEBPACK_IMPORTED_MODULE_4__.Log(log, provider);\n        });\n    }\n    /**\n     *  Add an event %%listener%% for the %%event%%.\n     */ async on(event, listener) {\n        const sub = await getSub(this, \"on\", event);\n        sub.listeners.push({\n            listener,\n            once: false\n        });\n        sub.start();\n        return this;\n    }\n    /**\n     *  Add an event %%listener%% for the %%event%%, but remove the listener\n     *  after it is fired once.\n     */ async once(event, listener) {\n        const sub = await getSub(this, \"once\", event);\n        sub.listeners.push({\n            listener,\n            once: true\n        });\n        sub.start();\n        return this;\n    }\n    /**\n     *  Emit an %%event%% calling all listeners with %%args%%.\n     *\n     *  Resolves to ``true`` if any listeners were called.\n     */ async emit(event, ...args) {\n        return await emit(this, event, args, null);\n    }\n    /**\n     *  Resolves to the number of listeners of %%event%% or the total number\n     *  of listeners if unspecified.\n     */ async listenerCount(event) {\n        if (event) {\n            const sub = await hasSub(this, event);\n            if (!sub) {\n                return 0;\n            }\n            return sub.listeners.length;\n        }\n        const { subs } = getInternal(this);\n        let total = 0;\n        for (const { listeners } of subs.values()){\n            total += listeners.length;\n        }\n        return total;\n    }\n    /**\n     *  Resolves to the listeners subscribed to %%event%% or all listeners\n     *  if unspecified.\n     */ async listeners(event) {\n        if (event) {\n            const sub = await hasSub(this, event);\n            if (!sub) {\n                return [];\n            }\n            return sub.listeners.map(({ listener })=>listener);\n        }\n        const { subs } = getInternal(this);\n        let result = [];\n        for (const { listeners } of subs.values()){\n            result = result.concat(listeners.map(({ listener })=>listener));\n        }\n        return result;\n    }\n    /**\n     *  Remove the %%listener%% from the listeners for %%event%% or remove\n     *  all listeners if unspecified.\n     */ async off(event, listener) {\n        const sub = await hasSub(this, event);\n        if (!sub) {\n            return this;\n        }\n        if (listener) {\n            const index = sub.listeners.map(({ listener })=>listener).indexOf(listener);\n            if (index >= 0) {\n                sub.listeners.splice(index, 1);\n            }\n        }\n        if (listener == null || sub.listeners.length === 0) {\n            sub.stop();\n            getInternal(this).subs.delete(sub.tag);\n        }\n        return this;\n    }\n    /**\n     *  Remove all the listeners for %%event%% or remove all listeners if\n     *  unspecified.\n     */ async removeAllListeners(event) {\n        if (event) {\n            const sub = await hasSub(this, event);\n            if (!sub) {\n                return this;\n            }\n            sub.stop();\n            getInternal(this).subs.delete(sub.tag);\n        } else {\n            const { subs } = getInternal(this);\n            for (const { tag, stop } of subs.values()){\n                stop();\n                subs.delete(tag);\n            }\n        }\n        return this;\n    }\n    /**\n     *  Alias for [on].\n     */ async addListener(event, listener) {\n        return await this.on(event, listener);\n    }\n    /**\n     *  Alias for [off].\n     */ async removeListener(event, listener) {\n        return await this.off(event, listener);\n    }\n    /**\n     *  Create a new Class for the %%abi%%.\n     */ static buildClass(abi) {\n        class CustomContract extends BaseContract {\n            constructor(address, runner = null){\n                super(address, abi, runner);\n            }\n        }\n        return CustomContract;\n    }\n    /**\n     *  Create a new BaseContract with a specified Interface.\n     */ static from(target, abi, runner) {\n        if (runner == null) {\n            runner = null;\n        }\n        const contract = new this(target, abi, runner);\n        return contract;\n    }\n}\nfunction _ContractBase() {\n    return BaseContract;\n}\n/**\n *  A [[BaseContract]] with no type guards on its methods or events.\n */ class Contract extends _ContractBase() {\n} //# sourceMappingURL=contract.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vY29udHJhY3QvY29udHJhY3QuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7OztBQUFtRDtBQUNpQjtBQUNwRSxzRUFBc0U7QUFDdEUseUJBQXlCO0FBQ21DO0FBQ2lHO0FBQ2pCO0FBQzVJLE1BQU1vQixPQUFPQyxPQUFPO0FBQ3BCLFNBQVNDLFFBQVFDLEtBQUs7SUFDbEIsT0FBUUEsU0FBUyxPQUFRQSxNQUFNQyxJQUFJLEtBQU07QUFDN0M7QUFDQSxTQUFTQyxZQUFZRixLQUFLO0lBQ3RCLE9BQVFBLFNBQVMsT0FBUUEsTUFBTUcsV0FBVyxLQUFNO0FBQ3BEO0FBQ0EsU0FBU0MsV0FBV0osS0FBSztJQUNyQixPQUFRQSxTQUFTLE9BQVFBLE1BQU1LLFdBQVcsS0FBTTtBQUNwRDtBQUNBLFNBQVNDLFFBQVFOLEtBQUs7SUFDbEIsT0FBUUEsU0FBUyxPQUFRQSxNQUFNTyxlQUFlLEtBQU07QUFDeEQ7QUFDQSxTQUFTQyxZQUFZUixLQUFLO0lBQ3RCLElBQUlBLFNBQVMsTUFBTTtRQUNmLElBQUlJLFdBQVdKLFFBQVE7WUFDbkIsT0FBT0E7UUFDWDtRQUNBLElBQUlBLE1BQU1TLFFBQVEsRUFBRTtZQUNoQixPQUFPVCxNQUFNUyxRQUFRO1FBQ3pCO0lBQ0o7SUFDQSxPQUFPQztBQUNYO0FBQ0EsTUFBTUM7SUFDRixDQUFDQyxNQUFNLENBQUM7SUFFUkMsWUFBWUMsUUFBUSxFQUFFQyxRQUFRLEVBQUVDLElBQUksQ0FBRTtRQUNsQ2pDLGlFQUFnQkEsQ0FBQyxJQUFJLEVBQUU7WUFBRWdDO1FBQVM7UUFDbEMsSUFBSUEsU0FBU0UsTUFBTSxDQUFDQyxNQUFNLEdBQUdGLEtBQUtFLE1BQU0sRUFBRTtZQUN0QyxNQUFNLElBQUlDLE1BQU07UUFDcEI7UUFDQSwwREFBMEQ7UUFDMUQsTUFBTUMsU0FBU0MsVUFBVVAsU0FBU00sTUFBTSxFQUFFO1FBQzFDLE1BQU1FLFdBQVdsQixXQUFXZ0IsVUFB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QUFFa0IsUUFBUSxFQUFFO1FBQ2xDLE9BQU8sTUFBTSxJQUFJLENBQUNZLEdBQUcsQ0FBQzlCLE9BQU9rQjtJQUNqQztJQUNBOztLQUVDLEdBQ0QsT0FBT21FLFdBQVd6QyxHQUFHLEVBQUU7UUFDbkIsTUFBTTBDLHVCQUF1QjVDO1lBQ3pCbEksWUFBWXlHLE9BQU8sRUFBRWxHLFNBQVMsSUFBSSxDQUFFO2dCQUNoQyxLQUFLLENBQUNrRyxTQUFTMkIsS0FBSzdIO1lBQ3hCO1FBQ0o7UUFDQSxPQUFPdUs7SUFDWDtJQUVBOztLQUVDLEdBQ0QsT0FBTzNJLEtBQUtnRyxNQUFNLEVBQUVDLEdBQUcsRUFBRTdILE1BQU0sRUFBRTtRQUM3QixJQUFJQSxVQUFVLE1BQU07WUFDaEJBLFNBQVM7UUFDYjtRQUNBLE1BQU1OLFdBQVcsSUFBSSxJQUFJLENBQUNrSSxRQUFRQyxLQUFLN0g7UUFDdkMsT0FBT047SUFDWDtBQUNKO0FBQ0EsU0FBUzhLO0lBQ0wsT0FBTzdDO0FBQ1g7QUFDQTs7Q0FFQyxHQUNNLE1BQU04QyxpQkFBaUJEO0FBQzlCLEVBQ0Esb0NBQW9DIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbWVnYXZpYmUtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vY29udHJhY3QvY29udHJhY3QuanM/MjY2MiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBJbnRlcmZhY2UsIFR5cGVkIH0gZnJvbSBcIi4uL2FiaS9pbmRleC5qc1wiO1xuaW1wb3J0IHsgaXNBZGRyZXNzYWJsZSwgcmVzb2x2ZUFkZHJlc3MgfSBmcm9tIFwiLi4vYWRkcmVzcy9pbmRleC5qc1wiO1xuLy8gaW1wb3J0IGZyb20gcHJvdmlkZXIudHMgaW5zdGVhZCBvZiBpbmRleC50cyB0byBwcmV2ZW50IGNpcmN1bGFyIGRlcFxuLy8gZnJvbSBFdGhlcnNjYW5Qcm92aWRlclxuaW1wb3J0IHsgY29weVJlcXVlc3QsIExvZyB9IGZyb20gXCIuLi9wcm92aWRlcnMvcHJvdmlkZXIuanNcIjtcbmltcG9ydCB7IGRlZmluZVByb3BlcnRpZXMsIGdldEJpZ0ludCwgaXNDYWxsRXhjZXB0aW9uLCBpc0hleFN0cmluZywgcmVzb2x2ZVByb3BlcnRpZXMsIGlzRXJyb3IsIG1ha2VFcnJvciwgYXNzZXJ0LCBhc3NlcnRBcmd1bWVudCB9IGZyb20gXCIuLi91dGlscy9pbmRleC5qc1wiO1xuaW1wb3J0IHsgQ29udHJhY3RFdmVudFBheWxvYWQsIENvbnRyYWN0VW5rbm93bkV2ZW50UGF5bG9hZCwgQ29udHJhY3RUcmFuc2FjdGlvblJlc3BvbnNlLCBFdmVudExvZywgVW5kZWNvZGVkRXZlbnRMb2cgfSBmcm9tIFwiLi93cmFwcGVycy5qc1wiO1xuY29uc3QgQk5fMCA9IEJpZ0ludCgwKTtcbmZ1bmN0aW9uIGNhbkNhbGwodmFsdWUpIHtcbiAgICByZXR1cm4gKHZhbHVlICYmIHR5cGVvZiAodmFsdWUuY2FsbCkgPT09IFwiZnVuY3Rpb25cIik7XG59XG5mdW5jdGlvbiBjYW5Fc3RpbWF0ZSh2YWx1ZSkge1xuICAgIHJldHVybiAodmFsdWUgJiYgdHlwZW9mICh2YWx1ZS5lc3RpbWF0ZUdhcykgPT09IFwiZnVuY3Rpb25cIik7XG59XG5mdW5jdGlvbiBjYW5SZXNvbHZlKHZhbHVlKSB7XG4gICAgcmV0dXJuICh2YWx1ZSAmJiB0eXBlb2YgKHZhbHVlLnJlc29sdmVOYW1lKSA9PT0gXCJmdW5jdGlvblwiKTtcbn1cbmZ1bmN0aW9uIGNhblNlbmQodmFsdWUpIHtcbiAgICByZXR1cm4gKHZhbHVlICYmIHR5cGVvZiAodmFsdWUuc2VuZFRyYW5zYWN0aW9uKSA9PT0gXCJmdW5jdGlvblwiKTtcbn1cbmZ1bmN0aW9uIGdldFJlc29sdmVyKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgaWYgKGNhblJlc29sdmUodmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbHVlLnByb3ZpZGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUucHJvdmlkZXI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cbmNsYXNzIFByZXBhcmVkVG9waWNGaWx0ZXIge1xuICAgICNmaWx0ZXI7XG4gICAgZnJhZ21lbnQ7XG4gICAgY29uc3RydWN0b3IoY29udHJhY3QsIGZyYWdtZW50LCBhcmdzKSB7XG4gICAgICAgIGRlZmluZVByb3BlcnRpZXModGhpcywgeyBmcmFnbWVudCB9KTtcbiAgICAgICAgaWYgKGZyYWdtZW50LmlucHV0cy5sZW5ndGggPCBhcmdzLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidG9vIG1hbnkgYXJndW1lbnRzXCIpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJlY3Vyc2l2ZWx5IGRlc2NlbmQgaW50byBhcmdzIGFuZCByZXNvbHZlIGFueSBhZGRyZXNzZXNcbiAgICAgICAgY29uc3QgcnVubmVyID0gZ2V0UnVubmVyKGNvbnRyYWN0LnJ1bm5lciwgXCJyZXNvbHZlTmFtZVwiKTtcbiAgICAgICAgY29uc3QgcmVzb2x2ZXIgPSBjYW5SZXNvbHZlKHJ1bm5lcikgPyBydW5uZXIgOiBudWxsO1xuICAgICAgICB0aGlzLiNmaWx0ZXIgPSAoYXN5bmMgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgY29uc3QgcmVzb2x2ZWRBcmdzID0gYXdhaXQgUHJvbWlzZS5hbGwoZnJhZ21lbnQuaW5wdXRzLm1hcCgocGFyYW0sIGluZGV4KSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgYXJnID0gYXJnc1tpbmRleF07XG4gICAgICAgICAgICAgICAgaWYgKGFyZyA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyYW0ud2Fsa0FzeW5jKGFyZ3NbaW5kZXhdLCAodHlwZSwgdmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGUgPT09IFwiYWRkcmVzc1wiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwodmFsdWUubWFwKCh2KSA9PiByZXNvbHZlQWRkcmVzcyh2LCByZXNvbHZlcikpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlQWRkcmVzcyh2YWx1ZSwgcmVzb2x2ZXIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIHJldHVybiBjb250cmFjdC5pbnRlcmZhY2UuZW5jb2RlRmlsdGVyVG9waWNzKGZyYWdtZW50LCByZXNvbHZlZEFyZ3MpO1xuICAgICAgICB9KSgpO1xuICAgIH1cbiAgICBnZXRUb3BpY0ZpbHRlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI2ZpbHRlcjtcbiAgICB9XG59XG4vLyBBID0gQXJndW1lbnRzIHBhc3NlZCBpbiBhcyBhIHR1cGxlXG4vLyBSID0gVGhlIHJlc3VsdCB0eXBlIG9mIHRoZSBjYWxsIChpLmUuIGlmIG9ubHkgb25lIHJldHVybiB0eXBlLFxuLy8gICAgIHRoZSBxdWFsaWZpZWQgdHlwZSwgb3RoZXJ3aXNlIFJlc3VsdClcbi8vIEQgPSBUaGUgdHlwZSB0aGUgZGVmYXVsdCBjYWxsIHdpbGwgcmV0dXJuIChpLmUuIFIgZm9yIHZpZXcvcHVyZSxcbi8vICAgICBUcmFuc2FjdGlvblJlc3BvbnNlIG90aGVyd2lzZSlcbi8vZXhwb3J0IGludGVyZmFjZSBDb250cmFjdE1ldGhvZDxBIGV4dGVuZHMgQXJyYXk8YW55PiA9IEFycmF5PGFueT4sIFIgPSBhbnksIEQgZXh0ZW5kcyBSIHwgQ29udHJhY3RUcmFuc2FjdGlvblJlc3BvbnNlID0gQ29udHJhY3RUcmFuc2FjdGlvblJlc3BvbnNlPiB7XG5mdW5jdGlvbiBnZXRSdW5uZXIodmFsdWUsIGZlYXR1cmUpIHtcbiAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiAodmFsdWVbZmVhdHVyZV0pID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBpZiAodmFsdWUucHJvdmlkZXIgJiYgdHlwZW9mICh2YWx1ZS5wcm92aWRlcltmZWF0dXJlXSkgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICByZXR1cm4gdmFsdWUucHJvdmlkZXI7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gZ2V0UHJvdmlkZXIodmFsdWUpIHtcbiAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlLnByb3ZpZGVyIHx8IG51bGw7XG59XG4vKipcbiAqICBAX2lnbm9yZTpcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNvcHlPdmVycmlkZXMoYXJnLCBhbGxvd2VkKSB7XG4gICAgLy8gTWFrZSBzdXJlIHRoZSBvdmVycmlkZXMgcGFzc2VkIGluIGFyZSBhIHZhbGlkIG92ZXJyaWRlcyBvYmplY3RcbiAgICBjb25zdCBfb3ZlcnJpZGVzID0gVHlwZWQuZGVyZWZlcmVuY2UoYXJnLCBcIm92ZXJyaWRlc1wiKTtcbiAgICBhc3NlcnRBcmd1bWVudCh0eXBlb2YgKF9vdmVycmlkZXMpID09PSBcIm9iamVjdFwiLCBcImludmFsaWQgb3ZlcnJpZGVzIHBhcmFtZXRlclwiLCBcIm92ZXJyaWRlc1wiLCBhcmcpO1xuICAgIC8vIENyZWF0ZSBhIHNoYWxsb3cgY29weSAod2UnbGwgZGVlcC1pZnkgYW55dGhpbmcgbmVlZGVkIGR1cmluZyBub3JtYWxpemluZylcbiAgICBjb25zdCBvdmVycmlkZXMgPSBjb3B5UmVxdWVzdChfb3ZlcnJpZGVzKTtcbiAgICBhc3NlcnRBcmd1bWVudChvdmVycmlkZXMudG8gPT0gbnVsbCB8fCAoYWxsb3dlZCB8fCBbXSkuaW5kZXhPZihcInRvXCIpID49IDAsIFwiY2Fubm90IG92ZXJyaWRlIHRvXCIsIFwib3ZlcnJpZGVzLnRvXCIsIG92ZXJyaWRlcy50byk7XG4gICAgYXNzZXJ0QXJndW1lbnQob3ZlcnJpZGVzLmRhdGEgPT0gbnVsbCB8fCAoYWxsb3dlZCB8fCBbXSkuaW5kZXhPZihcImRhdGFcIikgPj0gMCwgXCJjYW5ub3Qgb3ZlcnJpZGUgZGF0YVwiLCBcIm92ZXJyaWRlcy5kYXRhXCIsIG92ZXJyaWRlcy5kYXRhKTtcbiAgICAvLyBSZXNvbHZlIGFueSBmcm9tXG4gICAgaWYgKG92ZXJyaWRlcy5mcm9tKSB7XG4gICAgICAgIG92ZXJyaWRlcy5mcm9tID0gb3ZlcnJpZGVzLmZyb207XG4gICAgfVxuICAgIHJldHVybiBvdmVycmlkZXM7XG59XG4vKipcbiAqICBAX2lnbm9yZTpcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHJlc29sdmVBcmdzKF9ydW5uZXIsIGlucHV0cywgYXJncykge1xuICAgIC8vIFJlY3Vyc2l2ZWx5IGRlc2NlbmQgaW50byBhcmdzIGFuZCByZXNvbHZlIGFueSBhZGRyZXNzZXNcbiAgICBjb25zdCBydW5uZXIgPSBnZXRSdW5uZXIoX3J1bm5lciwgXCJyZXNvbHZlTmFtZVwiKTtcbiAgICBjb25zdCByZXNvbHZlciA9IGNhblJlc29sdmUocnVubmVyKSA/IHJ1bm5lciA6IG51bGw7XG4gICAgcmV0dXJuIGF3YWl0IFByb21pc2UuYWxsKGlucHV0cy5tYXAoKHBhcmFtLCBpbmRleCkgPT4ge1xuICAgICAgICByZXR1cm4gcGFyYW0ud2Fsa0FzeW5jKGFyZ3NbaW5kZXhdLCAodHlwZSwgdmFsdWUpID0+IHtcbiAgICAgICAgICAgIHZhbHVlID0gVHlwZWQuZGVyZWZlcmVuY2UodmFsdWUsIHR5cGUpO1xuICAgICAgICAgICAgaWYgKHR5cGUgPT09IFwiYWRkcmVzc1wiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmVBZGRyZXNzKHZhbHVlLCByZXNvbHZlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH0pO1xuICAgIH0pKTtcbn1cbmZ1bmN0aW9uIGJ1aWxkV3JhcHBlZEZhbGxiYWNrKGNvbnRyYWN0KSB7XG4gICAgY29uc3QgcG9wdWxhdGVUcmFuc2FjdGlvbiA9IGFzeW5jIGZ1bmN0aW9uIChvdmVycmlkZXMpIHtcbiAgICAgICAgLy8gSWYgYW4gb3ZlcnJpZGVzIHdhcyBwYXNzZWQgaW4sIGNvcHkgaXQgYW5kIG5vcm1hbGl6ZSB0aGUgdmFsdWVzXG4gICAgICAgIGNvbnN0IHR4ID0gKGF3YWl0IGNvcHlPdmVycmlkZXMob3ZlcnJpZGVzLCBbXCJkYXRhXCJdKSk7XG4gICAgICAgIHR4LnRvID0gYXdhaXQgY29udHJhY3QuZ2V0QWRkcmVzcygpO1xuICAgICAgICBpZiAodHguZnJvbSkge1xuICAgICAgICAgICAgdHguZnJvbSA9IGF3YWl0IHJlc29sdmVBZGRyZXNzKHR4LmZyb20sIGdldFJlc29sdmVyKGNvbnRyYWN0LnJ1bm5lcikpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGlmYWNlID0gY29udHJhY3QuaW50ZXJmYWNlO1xuICAgICAgICBjb25zdCBub1ZhbHVlID0gKGdldEJpZ0ludCgodHgudmFsdWUgfHwgQk5fMCksIFwib3ZlcnJpZGVzLnZhbHVlXCIpID09PSBCTl8wKTtcbiAgICAgICAgY29uc3Qgbm9EYXRhID0gKCh0eC5kYXRhIHx8IFwiMHhcIikgPT09IFwiMHhcIik7XG4gICAgICAgIGlmIChpZmFjZS5mYWxsYmFjayAmJiAhaWZhY2UuZmFsbGJhY2sucGF5YWJsZSAmJiBpZmFjZS5yZWNlaXZlICYmICFub0RhdGEgJiYgIW5vVmFsdWUpIHtcbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KGZhbHNlLCBcImNhbm5vdCBzZW5kIGRhdGEgdG8gcmVjZWl2ZSBvciBzZW5kIHZhbHVlIHRvIG5vbi1wYXlhYmxlIGZhbGxiYWNrXCIsIFwib3ZlcnJpZGVzXCIsIG92ZXJyaWRlcyk7XG4gICAgICAgIH1cbiAgICAgICAgYXNzZXJ0QXJndW1lbnQoaWZhY2UuZmFsbGJhY2sgfHwgbm9EYXRhLCBcImNhbm5vdCBzZW5kIGRhdGEgdG8gcmVjZWl2ZS1vbmx5IGNvbnRyYWN0XCIsIFwib3ZlcnJpZGVzLmRhdGFcIiwgdHguZGF0YSk7XG4gICAgICAgIC8vIE9ubHkgYWxsb3cgcGF5YWJsZSBjb250cmFjdHMgdG8gc2V0IG5vbi16ZXJvIHZhbHVlXG4gICAgICAgIGNvbnN0IHBheWFibGUgPSBpZmFjZS5yZWNlaXZlIHx8IChpZmFjZS5mYWxsYmFjayAmJiBpZmFjZS5mYWxsYmFjay5wYXlhYmxlKTtcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQocGF5YWJsZSB8fCBub1ZhbHVlLCBcImNhbm5vdCBzZW5kIHZhbHVlIHRvIG5vbi1wYXlhYmxlIGZhbGxiYWNrXCIsIFwib3ZlcnJpZGVzLnZhbHVlXCIsIHR4LnZhbHVlKTtcbiAgICAgICAgLy8gT25seSBhbGxvdyBmYWxsYmFjayBjb250cmFjdHMgdG8gc2V0IG5vbi1lbXB0eSBkYXRhXG4gICAgICAgIGFzc2VydEFyZ3VtZW50KGlmYWNlLmZhbGxiYWNrIHx8IG5vRGF0YSwgXCJjYW5ub3Qgc2VuZCBkYXRhIHRvIHJlY2VpdmUtb25seSBjb250cmFjdFwiLCBcIm92ZXJyaWRlcy5kYXRhXCIsIHR4LmRhdGEpO1xuICAgICAgICByZXR1cm4gdHg7XG4gICAgfTtcbiAgICBjb25zdCBzdGF0aWNDYWxsID0gYXN5bmMgZnVuY3Rpb24gKG92ZXJyaWRlcykge1xuICAgICAgICBjb25zdCBydW5uZXIgPSBnZXRSdW5uZXIoY29udHJhY3QucnVubmVyLCBcImNhbGxcIik7XG4gICAgICAgIGFzc2VydChjYW5DYWxsKHJ1bm5lciksIFwiY29udHJhY3QgcnVubmVyIGRvZXMgbm90IHN1cHBvcnQgY2FsbGluZ1wiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7IG9wZXJhdGlvbjogXCJjYWxsXCIgfSk7XG4gICAgICAgIGNvbnN0IHR4ID0gYXdhaXQgcG9wdWxhdGVUcmFuc2FjdGlvbihvdmVycmlkZXMpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHJ1bm5lci5jYWxsKHR4KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmIChpc0NhbGxFeGNlcHRpb24oZXJyb3IpICYmIGVycm9yLmRhdGEpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBjb250cmFjdC5pbnRlcmZhY2UubWFrZUVycm9yKGVycm9yLmRhdGEsIHR4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBzZW5kID0gYXN5bmMgZnVuY3Rpb24gKG92ZXJyaWRlcykge1xuICAgICAgICBjb25zdCBydW5uZXIgPSBjb250cmFjdC5ydW5uZXI7XG4gICAgICAgIGFzc2VydChjYW5TZW5kKHJ1bm5lciksIFwiY29udHJhY3QgcnVubmVyIGRvZXMgbm90IHN1cHBvcnQgc2VuZGluZyB0cmFuc2FjdGlvbnNcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwgeyBvcGVyYXRpb246IFwic2VuZFRyYW5zYWN0aW9uXCIgfSk7XG4gICAgICAgIGNvbnN0IHR4ID0gYXdhaXQgcnVubmVyLnNlbmRUcmFuc2FjdGlvbihhd2FpdCBwb3B1bGF0ZVRyYW5zYWN0aW9uKG92ZXJyaWRlcykpO1xuICAgICAgICBjb25zdCBwcm92aWRlciA9IGdldFByb3ZpZGVyKGNvbnRyYWN0LnJ1bm5lcik7XG4gICAgICAgIC8vIEBUT0RPOiB0aGUgcHJvdmlkZXIgY2FuIGJlIG51bGw7IG1ha2UgYSBjdXN0b20gZHVtbXkgcHJvdmlkZXIgdGhhdCB3aWxsIHRocm93IGFcbiAgICAgICAgLy8gbWVhbmluZ2Z1bCBlcnJvclxuICAgICAgICByZXR1cm4gbmV3IENvbnRyYWN0VHJhbnNhY3Rpb25SZXNwb25zZShjb250cmFjdC5pbnRlcmZhY2UsIHByb3ZpZGVyLCB0eCk7XG4gICAgfTtcbiAgICBjb25zdCBlc3RpbWF0ZUdhcyA9IGFzeW5jIGZ1bmN0aW9uIChvdmVycmlkZXMpIHtcbiAgICAgICAgY29uc3QgcnVubmVyID0gZ2V0UnVubmVyKGNvbnRyYWN0LnJ1bm5lciwgXCJlc3RpbWF0ZUdhc1wiKTtcbiAgICAgICAgYXNzZXJ0KGNhbkVzdGltYXRlKHJ1bm5lciksIFwiY29udHJhY3QgcnVubmVyIGRvZXMgbm90IHN1cHBvcnQgZ2FzIGVzdGltYXRpb25cIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwgeyBvcGVyYXRpb246IFwiZXN0aW1hdGVHYXNcIiB9KTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHJ1bm5lci5lc3RpbWF0ZUdhcyhhd2FpdCBwb3B1bGF0ZVRyYW5zYWN0aW9uKG92ZXJyaWRlcykpO1xuICAgIH07XG4gICAgY29uc3QgbWV0aG9kID0gYXN5bmMgKG92ZXJyaWRlcykgPT4ge1xuICAgICAgICByZXR1cm4gYXdhaXQgc2VuZChvdmVycmlkZXMpO1xuICAgIH07XG4gICAgZGVmaW5lUHJvcGVydGllcyhtZXRob2QsIHtcbiAgICAgICAgX2NvbnRyYWN0OiBjb250cmFjdCxcbiAgICAgICAgZXN0aW1hdGVHYXMsXG4gICAgICAgIHBvcHVsYXRlVHJhbnNhY3Rpb24sXG4gICAgICAgIHNlbmQsIHN0YXRpY0NhbGxcbiAgICB9KTtcbiAgICByZXR1cm4gbWV0aG9kO1xufVxuZnVuY3Rpb24gYnVpbGRXcmFwcGVkTWV0aG9kKGNvbnRyYWN0LCBrZXkpIHtcbiAgICBjb25zdCBnZXRGcmFnbWVudCA9IGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gICAgICAgIGNvbnN0IGZyYWdtZW50ID0gY29udHJhY3QuaW50ZXJmYWNlLmdldEZ1bmN0aW9uKGtleSwgYXJncyk7XG4gICAgICAgIGFzc2VydChmcmFnbWVudCwgXCJubyBtYXRjaGluZyBmcmFnbWVudFwiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7XG4gICAgICAgICAgICBvcGVyYXRpb246IFwiZnJhZ21lbnRcIixcbiAgICAgICAgICAgIGluZm86IHsga2V5LCBhcmdzIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBmcmFnbWVudDtcbiAgICB9O1xuICAgIGNvbnN0IHBvcHVsYXRlVHJhbnNhY3Rpb24gPSBhc3luYyBmdW5jdGlvbiAoLi4uYXJncykge1xuICAgICAgICBjb25zdCBmcmFnbWVudCA9IGdldEZyYWdtZW50KC4uLmFyZ3MpO1xuICAgICAgICAvLyBJZiBhbiBvdmVycmlkZXMgd2FzIHBhc3NlZCBpbiwgY29weSBpdCBhbmQgbm9ybWFsaXplIHRoZSB2YWx1ZXNcbiAgICAgICAgbGV0IG92ZXJyaWRlcyA9IHt9O1xuICAgICAgICBpZiAoZnJhZ21lbnQuaW5wdXRzLmxlbmd0aCArIDEgPT09IGFyZ3MubGVuZ3RoKSB7XG4gICAgICAgICAgICBvdmVycmlkZXMgPSBhd2FpdCBjb3B5T3ZlcnJpZGVzKGFyZ3MucG9wKCkpO1xuICAgICAgICAgICAgaWYgKG92ZXJyaWRlcy5mcm9tKSB7XG4gICAgICAgICAgICAgICAgb3ZlcnJpZGVzLmZyb20gPSBhd2FpdCByZXNvbHZlQWRkcmVzcyhvdmVycmlkZXMuZnJvbSwgZ2V0UmVzb2x2ZXIoY29udHJhY3QucnVubmVyKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZyYWdtZW50LmlucHV0cy5sZW5ndGggIT09IGFyZ3MubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnRlcm5hbCBlcnJvcjogZnJhZ21lbnQgaW5wdXRzIGRvZXNuJ3QgbWF0Y2ggYXJndW1lbnRzOyBzaG91bGQgbm90IGhhcHBlblwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXNvbHZlZEFyZ3MgPSBhd2FpdCByZXNvbHZlQXJncyhjb250cmFjdC5ydW5uZXIsIGZyYWdtZW50LmlucHV0cywgYXJncyk7XG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBvdmVycmlkZXMsIGF3YWl0IHJlc29sdmVQcm9wZXJ0aWVzKHtcbiAgICAgICAgICAgIHRvOiBjb250cmFjdC5nZXRBZGRyZXNzKCksXG4gICAgICAgICAgICBkYXRhOiBjb250cmFjdC5pbnRlcmZhY2UuZW5jb2RlRnVuY3Rpb25EYXRhKGZyYWdtZW50LCByZXNvbHZlZEFyZ3MpXG4gICAgICAgIH0pKTtcbiAgICB9O1xuICAgIGNvbnN0IHN0YXRpY0NhbGwgPSBhc3luYyBmdW5jdGlvbiAoLi4uYXJncykge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBzdGF0aWNDYWxsUmVzdWx0KC4uLmFyZ3MpO1xuICAgICAgICBpZiAocmVzdWx0Lmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdFswXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgY29uc3Qgc2VuZCA9IGFzeW5jIGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gICAgICAgIGNvbnN0IHJ1bm5lciA9IGNvbnRyYWN0LnJ1bm5lcjtcbiAgICAgICAgYXNzZXJ0KGNhblNlbmQocnVubmVyKSwgXCJjb250cmFjdCBydW5uZXIgZG9lcyBub3Qgc3VwcG9ydCBzZW5kaW5nIHRyYW5zYWN0aW9uc1wiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7IG9wZXJhdGlvbjogXCJzZW5kVHJhbnNhY3Rpb25cIiB9KTtcbiAgICAgICAgY29uc3QgdHggPSBhd2FpdCBydW5uZXIuc2VuZFRyYW5zYWN0aW9uKGF3YWl0IHBvcHVsYXRlVHJhbnNhY3Rpb24oLi4uYXJncykpO1xuICAgICAgICBjb25zdCBwcm92aWRlciA9IGdldFByb3ZpZGVyKGNvbnRyYWN0LnJ1bm5lcik7XG4gICAgICAgIC8vIEBUT0RPOiB0aGUgcHJvdmlkZXIgY2FuIGJlIG51bGw7IG1ha2UgYSBjdXN0b20gZHVtbXkgcHJvdmlkZXIgdGhhdCB3aWxsIHRocm93IGFcbiAgICAgICAgLy8gbWVhbmluZ2Z1bCBlcnJvclxuICAgICAgICByZXR1cm4gbmV3IENvbnRyYWN0VHJhbnNhY3Rpb25SZXNwb25zZShjb250cmFjdC5pbnRlcmZhY2UsIHByb3ZpZGVyLCB0eCk7XG4gICAgfTtcbiAgICBjb25zdCBlc3RpbWF0ZUdhcyA9IGFzeW5jIGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gICAgICAgIGNvbnN0IHJ1bm5lciA9IGdldFJ1bm5lcihjb250cmFjdC5ydW5uZXIsIFwiZXN0aW1hdGVHYXNcIik7XG4gICAgICAgIGFzc2VydChjYW5Fc3RpbWF0ZShydW5uZXIpLCBcImNvbnRyYWN0IHJ1bm5lciBkb2VzIG5vdCBzdXBwb3J0IGdhcyBlc3RpbWF0aW9uXCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHsgb3BlcmF0aW9uOiBcImVzdGltYXRlR2FzXCIgfSk7XG4gICAgICAgIHJldHVybiBhd2FpdCBydW5uZXIuZXN0aW1hdGVHYXMoYXdhaXQgcG9wdWxhdGVUcmFuc2FjdGlvbiguLi5hcmdzKSk7XG4gICAgfTtcbiAgICBjb25zdCBzdGF0aWNDYWxsUmVzdWx0ID0gYXN5bmMgZnVuY3Rpb24gKC4uLmFyZ3MpIHtcbiAgICAgICAgY29uc3QgcnVubmVyID0gZ2V0UnVubmVyKGNvbnRyYWN0LnJ1bm5lciwgXCJjYWxsXCIpO1xuICAgICAgICBhc3NlcnQoY2FuQ2FsbChydW5uZXIpLCBcImNvbnRyYWN0IHJ1bm5lciBkb2VzIG5vdCBzdXBwb3J0IGNhbGxpbmdcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwgeyBvcGVyYXRpb246IFwiY2FsbFwiIH0pO1xuICAgICAgICBjb25zdCB0eCA9IGF3YWl0IHBvcHVsYXRlVHJhbnNhY3Rpb24oLi4uYXJncyk7XG4gICAgICAgIGxldCByZXN1bHQgPSBcIjB4XCI7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXN1bHQgPSBhd2FpdCBydW5uZXIuY2FsbCh0eCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoaXNDYWxsRXhjZXB0aW9uKGVycm9yKSAmJiBlcnJvci5kYXRhKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgY29udHJhY3QuaW50ZXJmYWNlLm1ha2VFcnJvcihlcnJvci5kYXRhLCB0eCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmcmFnbWVudCA9IGdldEZyYWdtZW50KC4uLmFyZ3MpO1xuICAgICAgICByZXR1cm4gY29udHJhY3QuaW50ZXJmYWNlLmRlY29kZUZ1bmN0aW9uUmVzdWx0KGZyYWdtZW50LCByZXN1bHQpO1xuICAgIH07XG4gICAgY29uc3QgbWV0aG9kID0gYXN5bmMgKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgY29uc3QgZnJhZ21lbnQgPSBnZXRGcmFnbWVudCguLi5hcmdzKTtcbiAgICAgICAgaWYgKGZyYWdtZW50LmNvbnN0YW50KSB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgc3RhdGljQ2FsbCguLi5hcmdzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXdhaXQgc2VuZCguLi5hcmdzKTtcbiAgICB9O1xuICAgIGRlZmluZVByb3BlcnRpZXMobWV0aG9kLCB7XG4gICAgICAgIG5hbWU6IGNvbnRyYWN0LmludGVyZmFjZS5nZXRGdW5jdGlvbk5hbWUoa2V5KSxcbiAgICAgICAgX2NvbnRyYWN0OiBjb250cmFjdCwgX2tleToga2V5LFxuICAgICAgICBnZXRGcmFnbWVudCxcbiAgICAgICAgZXN0aW1hdGVHYXMsXG4gICAgICAgIHBvcHVsYXRlVHJhbnNhY3Rpb24sXG4gICAgICAgIHNlbmQsIHN0YXRpY0NhbGwsIHN0YXRpY0NhbGxSZXN1bHQsXG4gICAgfSk7XG4gICAgLy8gT25seSB3b3JrcyBvbiBub24tYW1iaWd1b3VzIGtleXMgKHJlZmluZWQgZnJhZ21lbnQgaXMgYWx3YXlzIG5vbi1hbWJpZ3VvdXMpXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG1ldGhvZCwgXCJmcmFnbWVudFwiLCB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGdldDogKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZnJhZ21lbnQgPSBjb250cmFjdC5pbnRlcmZhY2UuZ2V0RnVuY3Rpb24oa2V5KTtcbiAgICAgICAgICAgIGFzc2VydChmcmFnbWVudCwgXCJubyBtYXRjaGluZyBmcmFnbWVudFwiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7XG4gICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBcImZyYWdtZW50XCIsXG4gICAgICAgICAgICAgICAgaW5mbzogeyBrZXkgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gZnJhZ21lbnQ7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gbWV0aG9kO1xufVxuZnVuY3Rpb24gYnVpbGRXcmFwcGVkRXZlbnQoY29udHJhY3QsIGtleSkge1xuICAgIGNvbnN0IGdldEZyYWdtZW50ID0gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcbiAgICAgICAgY29uc3QgZnJhZ21lbnQgPSBjb250cmFjdC5pbnRlcmZhY2UuZ2V0RXZlbnQoa2V5LCBhcmdzKTtcbiAgICAgICAgYXNzZXJ0KGZyYWdtZW50LCBcIm5vIG1hdGNoaW5nIGZyYWdtZW50XCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHtcbiAgICAgICAgICAgIG9wZXJhdGlvbjogXCJmcmFnbWVudFwiLFxuICAgICAgICAgICAgaW5mbzogeyBrZXksIGFyZ3MgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGZyYWdtZW50O1xuICAgIH07XG4gICAgY29uc3QgbWV0aG9kID0gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcmVwYXJlZFRvcGljRmlsdGVyKGNvbnRyYWN0LCBnZXRGcmFnbWVudCguLi5hcmdzKSwgYXJncyk7XG4gICAgfTtcbiAgICBkZWZpbmVQcm9wZXJ0aWVzKG1ldGhvZCwge1xuICAgICAgICBuYW1lOiBjb250cmFjdC5pbnRlcmZhY2UuZ2V0RXZlbnROYW1lKGtleSksXG4gICAgICAgIF9jb250cmFjdDogY29udHJhY3QsIF9rZXk6IGtleSxcbiAgICAgICAgZ2V0RnJhZ21lbnRcbiAgICB9KTtcbiAgICAvLyBPbmx5IHdvcmtzIG9uIG5vbi1hbWJpZ3VvdXMga2V5cyAocmVmaW5lZCBmcmFnbWVudCBpcyBhbHdheXMgbm9uLWFtYmlndW91cylcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobWV0aG9kLCBcImZyYWdtZW50XCIsIHtcbiAgICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgZ2V0OiAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBmcmFnbWVudCA9IGNvbnRyYWN0LmludGVyZmFjZS5nZXRFdmVudChrZXkpO1xuICAgICAgICAgICAgYXNzZXJ0KGZyYWdtZW50LCBcIm5vIG1hdGNoaW5nIGZyYWdtZW50XCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHtcbiAgICAgICAgICAgICAgICBvcGVyYXRpb246IFwiZnJhZ21lbnRcIixcbiAgICAgICAgICAgICAgICBpbmZvOiB7IGtleSB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBmcmFnbWVudDtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBtZXRob2Q7XG59XG4vLyBUaGUgY29tYmluYXRpb24gb2YgVHlwZVNjcnlwZSwgUHJpdmF0ZSBGaWVsZHMgYW5kIFByb3hpZXMgbWFrZXNcbi8vIHRoZSB3b3JsZCBnbyBib29tOyBzbyB3ZSBoaWRlIHZhcmlhYmxlcyB3aXRoIHNvbWUgdHJpY2tlcnkga2VlcGluZ1xuLy8gYSBzeW1ib2wgYXR0YWNoZWQgdG8gZWFjaCBCYXNlQ29udHJhY3Qgd2hpY2ggaXRzIHN1Yi1jbGFzcyAoZXZlblxuLy8gdmlhIGEgUHJveHkpIGNhbiByZWFjaCBhbmQgdXNlIHRvIGxvb2sgdXAgaXRzIGludGVybmFsIHZhbHVlcy5cbmNvbnN0IGludGVybmFsID0gU3ltYm9sLmZvcihcIl9ldGhlcnNJbnRlcm5hbF9jb250cmFjdFwiKTtcbmNvbnN0IGludGVybmFsVmFsdWVzID0gbmV3IFdlYWtNYXAoKTtcbmZ1bmN0aW9uIHNldEludGVybmFsKGNvbnRyYWN0LCB2YWx1ZXMpIHtcbiAgICBpbnRlcm5hbFZhbHVlcy5zZXQoY29udHJhY3RbaW50ZXJuYWxdLCB2YWx1ZXMpO1xufVxuZnVuY3Rpb24gZ2V0SW50ZXJuYWwoY29udHJhY3QpIHtcbiAgICByZXR1cm4gaW50ZXJuYWxWYWx1ZXMuZ2V0KGNvbnRyYWN0W2ludGVybmFsXSk7XG59XG5mdW5jdGlvbiBpc0RlZmVycmVkKHZhbHVlKSB7XG4gICAgcmV0dXJuICh2YWx1ZSAmJiB0eXBlb2YgKHZhbHVlKSA9PT0gXCJvYmplY3RcIiAmJiAoXCJnZXRUb3BpY0ZpbHRlclwiIGluIHZhbHVlKSAmJlxuICAgICAgICAodHlwZW9mICh2YWx1ZS5nZXRUb3BpY0ZpbHRlcikgPT09IFwiZnVuY3Rpb25cIikgJiYgdmFsdWUuZnJhZ21lbnQpO1xufVxuYXN5bmMgZnVuY3Rpb24gZ2V0U3ViSW5mbyhjb250cmFjdCwgZXZlbnQpIHtcbiAgICBsZXQgdG9waWNzO1xuICAgIGxldCBmcmFnbWVudCA9IG51bGw7XG4gICAgLy8gQ29udmVydCBuYW1lZCBldmVudHMgdG8gdG9waWNIYXNoIGFuZCBnZXQgdGhlIGZyYWdtZW50IGZvclxuICAgIC8vIGV2ZW50cyB3aGljaCBuZWVkIGRlY29uc3RydWN0aW5nLlxuICAgIGlmIChBcnJheS5pc0FycmF5KGV2ZW50KSkge1xuICAgICAgICBjb25zdCB0b3BpY0hhc2hpZnkgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgaWYgKGlzSGV4U3RyaW5nKG5hbWUsIDMyKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuYW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZnJhZ21lbnQgPSBjb250cmFjdC5pbnRlcmZhY2UuZ2V0RXZlbnQobmFtZSk7XG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudChmcmFnbWVudCwgXCJ1bmtub3duIGZyYWdtZW50XCIsIFwibmFtZVwiLCBuYW1lKTtcbiAgICAgICAgICAgIHJldHVybiBmcmFnbWVudC50b3BpY0hhc2g7XG4gICAgICAgIH07XG4gICAgICAgIC8vIEFycmF5IG9mIFRvcGljcyBhbmQgTmFtZXM7IGUuZy4gYFsgXCIweDEyMzQuLi44OWFiXCIsIFwiVHJhbnNmZXIoYWRkcmVzcylcIiBdYFxuICAgICAgICB0b3BpY3MgPSBldmVudC5tYXAoKGUpID0+IHtcbiAgICAgICAgICAgIGlmIChlID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGUubWFwKHRvcGljSGFzaGlmeSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdG9waWNIYXNoaWZ5KGUpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZXZlbnQgPT09IFwiKlwiKSB7XG4gICAgICAgIHRvcGljcyA9IFtudWxsXTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIChldmVudCkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgaWYgKGlzSGV4U3RyaW5nKGV2ZW50LCAzMikpIHtcbiAgICAgICAgICAgIC8vIFRvcGljIEhhc2hcbiAgICAgICAgICAgIHRvcGljcyA9IFtldmVudF07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBOYW1lIG9yIFNpZ25hdHVyZTsgZS5nLiBgXCJUcmFuc2ZlclwiLCBgXCJUcmFuc2ZlcihhZGRyZXNzKVwiYFxuICAgICAgICAgICAgZnJhZ21lbnQgPSBjb250cmFjdC5pbnRlcmZhY2UuZ2V0RXZlbnQoZXZlbnQpO1xuICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoZnJhZ21lbnQsIFwidW5rbm93biBmcmFnbWVudFwiLCBcImV2ZW50XCIsIGV2ZW50KTtcbiAgICAgICAgICAgIHRvcGljcyA9IFtmcmFnbWVudC50b3BpY0hhc2hdO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzRGVmZXJyZWQoZXZlbnQpKSB7XG4gICAgICAgIC8vIERlZmVycmVkIFRvcGljIEZpbHRlcjsgZS5nLiBgY29udHJhY3QuZmlsdGVyLlRyYW5zZmVyKGZyb20pYFxuICAgICAgICB0b3BpY3MgPSBhd2FpdCBldmVudC5nZXRUb3BpY0ZpbHRlcigpO1xuICAgIH1cbiAgICBlbHNlIGlmIChcImZyYWdtZW50XCIgaW4gZXZlbnQpIHtcbiAgICAgICAgLy8gQ29udHJhY3RFdmVudDsgZS5nLiBgY29udHJhY3QuZmlsdGVyLlRyYW5zZmVyYFxuICAgICAgICBmcmFnbWVudCA9IGV2ZW50LmZyYWdtZW50O1xuICAgICAgICB0b3BpY3MgPSBbZnJhZ21lbnQudG9waWNIYXNoXTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KGZhbHNlLCBcInVua25vd24gZXZlbnQgbmFtZVwiLCBcImV2ZW50XCIsIGV2ZW50KTtcbiAgICB9XG4gICAgLy8gTm9ybWFsaXplIHRvcGljcyBhbmQgc29ydCBUb3BpY1NldHNcbiAgICB0b3BpY3MgPSB0b3BpY3MubWFwKCh0KSA9PiB7XG4gICAgICAgIGlmICh0ID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHQpKSB7XG4gICAgICAgICAgICBjb25zdCBpdGVtcyA9IEFycmF5LmZyb20obmV3IFNldCh0Lm1hcCgodCkgPT4gdC50b0xvd2VyQ2FzZSgpKSkudmFsdWVzKCkpO1xuICAgICAgICAgICAgaWYgKGl0ZW1zLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpdGVtc1swXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGl0ZW1zLnNvcnQoKTtcbiAgICAgICAgICAgIHJldHVybiBpdGVtcztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdC50b0xvd2VyQ2FzZSgpO1xuICAgIH0pO1xuICAgIGNvbnN0IHRhZyA9IHRvcGljcy5tYXAoKHQpID0+IHtcbiAgICAgICAgaWYgKHQgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIFwibnVsbFwiO1xuICAgICAgICB9XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHQpKSB7XG4gICAgICAgICAgICByZXR1cm4gdC5qb2luKFwifFwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdDtcbiAgICB9KS5qb2luKFwiJlwiKTtcbiAgICByZXR1cm4geyBmcmFnbWVudCwgdGFnLCB0b3BpY3MgfTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGhhc1N1Yihjb250cmFjdCwgZXZlbnQpIHtcbiAgICBjb25zdCB7IHN1YnMgfSA9IGdldEludGVybmFsKGNvbnRyYWN0KTtcbiAgICByZXR1cm4gc3Vicy5nZXQoKGF3YWl0IGdldFN1YkluZm8oY29udHJhY3QsIGV2ZW50KSkudGFnKSB8fCBudWxsO1xufVxuYXN5bmMgZnVuY3Rpb24gZ2V0U3ViKGNvbnRyYWN0LCBvcGVyYXRpb24sIGV2ZW50KSB7XG4gICAgLy8gTWFrZSBzdXJlIG91ciBydW5uZXIgY2FuIGFjdHVhbGx5IHN1YnNjcmliZSB0byBldmVudHNcbiAgICBjb25zdCBwcm92aWRlciA9IGdldFByb3ZpZGVyKGNvbnRyYWN0LnJ1bm5lcik7XG4gICAgYXNzZXJ0KHByb3ZpZGVyLCBcImNvbnRyYWN0IHJ1bm5lciBkb2VzIG5vdCBzdXBwb3J0IHN1YnNjcmliaW5nXCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHsgb3BlcmF0aW9uIH0pO1xuICAgIGNvbnN0IHsgZnJhZ21lbnQsIHRhZywgdG9waWNzIH0gPSBhd2FpdCBnZXRTdWJJbmZvKGNvbnRyYWN0LCBldmVudCk7XG4gICAgY29uc3QgeyBhZGRyLCBzdWJzIH0gPSBnZXRJbnRlcm5hbChjb250cmFjdCk7XG4gICAgbGV0IHN1YiA9IHN1YnMuZ2V0KHRhZyk7XG4gICAgaWYgKCFzdWIpIHtcbiAgICAgICAgY29uc3QgYWRkcmVzcyA9IChhZGRyID8gYWRkciA6IGNvbnRyYWN0KTtcbiAgICAgICAgY29uc3QgZmlsdGVyID0geyBhZGRyZXNzLCB0b3BpY3MgfTtcbiAgICAgICAgY29uc3QgbGlzdGVuZXIgPSAobG9nKSA9PiB7XG4gICAgICAgICAgICBsZXQgZm91bmRGcmFnbWVudCA9IGZyYWdtZW50O1xuICAgICAgICAgICAgaWYgKGZvdW5kRnJhZ21lbnQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGZvdW5kRnJhZ21lbnQgPSBjb250cmFjdC5pbnRlcmZhY2UuZ2V0RXZlbnQobG9nLnRvcGljc1swXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikgeyB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBJZiBmcmFnbWVudCBpcyBudWxsLCB3ZSBkbyBub3QgZGVjb25zdHJ1Y3QgdGhlIGFyZ3MgdG8gZW1pdFxuICAgICAgICAgICAgaWYgKGZvdW5kRnJhZ21lbnQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBfZm91bmRGcmFnbWVudCA9IGZvdW5kRnJhZ21lbnQ7XG4gICAgICAgICAgICAgICAgY29uc3QgYXJncyA9IGZyYWdtZW50ID8gY29udHJhY3QuaW50ZXJmYWNlLmRlY29kZUV2ZW50TG9nKGZyYWdtZW50LCBsb2cuZGF0YSwgbG9nLnRvcGljcykgOiBbXTtcbiAgICAgICAgICAgICAgICBlbWl0KGNvbnRyYWN0LCBldmVudCwgYXJncywgKGxpc3RlbmVyKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQ29udHJhY3RFdmVudFBheWxvYWQoY29udHJhY3QsIGxpc3RlbmVyLCBldmVudCwgX2ZvdW5kRnJhZ21lbnQsIGxvZyk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBlbWl0KGNvbnRyYWN0LCBldmVudCwgW10sIChsaXN0ZW5lcikgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IENvbnRyYWN0VW5rbm93bkV2ZW50UGF5bG9hZChjb250cmFjdCwgbGlzdGVuZXIsIGV2ZW50LCBsb2cpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBsZXQgc3RhcnRpbmcgPSBbXTtcbiAgICAgICAgY29uc3Qgc3RhcnQgPSAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoc3RhcnRpbmcubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RhcnRpbmcucHVzaChwcm92aWRlci5vbihmaWx0ZXIsIGxpc3RlbmVyKSk7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHN0b3AgPSBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoc3RhcnRpbmcubGVuZ3RoID09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgc3RhcnRlZCA9IHN0YXJ0aW5nO1xuICAgICAgICAgICAgc3RhcnRpbmcgPSBbXTtcbiAgICAgICAgICAgIGF3YWl0IFByb21pc2UuYWxsKHN0YXJ0ZWQpO1xuICAgICAgICAgICAgcHJvdmlkZXIub2ZmKGZpbHRlciwgbGlzdGVuZXIpO1xuICAgICAgICB9O1xuICAgICAgICBzdWIgPSB7IHRhZywgbGlzdGVuZXJzOiBbXSwgc3RhcnQsIHN0b3AgfTtcbiAgICAgICAgc3Vicy5zZXQodGFnLCBzdWIpO1xuICAgIH1cbiAgICByZXR1cm4gc3ViO1xufVxuLy8gV2UgdXNlIHRoaXMgdG8gZW5zdXJlIG9uZSBlbWl0IHJlc29sdmVzIGJlZm9yZSBmaXJpbmcgdGhlIG5leHQgdG9cbi8vIGVuc3VyZSBjb3JyZWN0IG9yZGVyaW5nIChub3RlIHRoaXMgY2Fubm90IHRocm93IGFuZCBqdXN0IGFkZHMgdGhlXG4vLyBub3RpY2UgdG8gdGhlIGV2ZW50IHF1ZXUgdXNpbmcgc2V0VGltZW91dCkuXG5sZXQgbGFzdEVtaXQgPSBQcm9taXNlLnJlc29sdmUoKTtcbmFzeW5jIGZ1bmN0aW9uIF9lbWl0KGNvbnRyYWN0LCBldmVudCwgYXJncywgcGF5bG9hZEZ1bmMpIHtcbiAgICBhd2FpdCBsYXN0RW1pdDtcbiAgICBjb25zdCBzdWIgPSBhd2FpdCBoYXNTdWIoY29udHJhY3QsIGV2ZW50KTtcbiAgICBpZiAoIXN1Yikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IGNvdW50ID0gc3ViLmxpc3RlbmVycy5sZW5ndGg7XG4gICAgc3ViLmxpc3RlbmVycyA9IHN1Yi5saXN0ZW5lcnMuZmlsdGVyKCh7IGxpc3RlbmVyLCBvbmNlIH0pID0+IHtcbiAgICAgICAgY29uc3QgcGFzc0FyZ3MgPSBBcnJheS5mcm9tKGFyZ3MpO1xuICAgICAgICBpZiAocGF5bG9hZEZ1bmMpIHtcbiAgICAgICAgICAgIHBhc3NBcmdzLnB1c2gocGF5bG9hZEZ1bmMob25jZSA/IG51bGwgOiBsaXN0ZW5lcikpO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBsaXN0ZW5lci5jYWxsKGNvbnRyYWN0LCAuLi5wYXNzQXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7IH1cbiAgICAgICAgcmV0dXJuICFvbmNlO1xuICAgIH0pO1xuICAgIGlmIChzdWIubGlzdGVuZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBzdWIuc3RvcCgpO1xuICAgICAgICBnZXRJbnRlcm5hbChjb250cmFjdCkuc3Vicy5kZWxldGUoc3ViLnRhZyk7XG4gICAgfVxuICAgIHJldHVybiAoY291bnQgPiAwKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGVtaXQoY29udHJhY3QsIGV2ZW50LCBhcmdzLCBwYXlsb2FkRnVuYykge1xuICAgIHRyeSB7XG4gICAgICAgIGF3YWl0IGxhc3RFbWl0O1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHsgfVxuICAgIGNvbnN0IHJlc3VsdFByb21pc2UgPSBfZW1pdChjb250cmFjdCwgZXZlbnQsIGFyZ3MsIHBheWxvYWRGdW5jKTtcbiAgICBsYXN0RW1pdCA9IHJlc3VsdFByb21pc2U7XG4gICAgcmV0dXJuIGF3YWl0IHJlc3VsdFByb21pc2U7XG59XG5jb25zdCBwYXNzUHJvcGVydGllcyA9IFtcInRoZW5cIl07XG5leHBvcnQgY2xhc3MgQmFzZUNvbnRyYWN0IHtcbiAgICAvKipcbiAgICAgKiAgVGhlIHRhcmdldCB0byBjb25uZWN0IHRvLlxuICAgICAqXG4gICAgICogIFRoaXMgY2FuIGJlIGFuIGFkZHJlc3MsIEVOUyBuYW1lIG9yIGFueSBbW0FkZHJlc3NhYmxlXV0sIHN1Y2ggYXNcbiAgICAgKiAgYW5vdGhlciBjb250cmFjdC4gVG8gZ2V0IHRoZSByZXNvdmxlZCBhZGRyZXNzLCB1c2UgdGhlIGBgZ2V0QWRkcmVzc2BgXG4gICAgICogIG1ldGhvZC5cbiAgICAgKi9cbiAgICB0YXJnZXQ7XG4gICAgLyoqXG4gICAgICogIFRoZSBjb250cmFjdCBJbnRlcmZhY2UuXG4gICAgICovXG4gICAgaW50ZXJmYWNlO1xuICAgIC8qKlxuICAgICAqICBUaGUgY29ubmVjdGVkIHJ1bm5lci4gVGhpcyBpcyBnZW5lcmFsbHkgYSBbW1Byb3ZpZGVyXV0gb3IgYVxuICAgICAqICBbW1NpZ25lcl1dLCB3aGljaCBkaWN0YXRlcyB3aGF0IG9wZXJhdGlvbnMgYXJlIHN1cHBvcnRlZC5cbiAgICAgKlxuICAgICAqICBGb3IgZXhhbXBsZSwgYSAqKkNvbnRyYWN0KiogY29ubmVjdGVkIHRvIGEgW1tQcm92aWRlcl1dIG1heVxuICAgICAqICBvbmx5IGV4ZWN1dGUgcmVhZC1vbmx5IG9wZXJhdGlvbnMuXG4gICAgICovXG4gICAgcnVubmVyO1xuICAgIC8qKlxuICAgICAqICBBbGwgdGhlIEV2ZW50cyBhdmFpbGFibGUgb24gdGhpcyBjb250cmFjdC5cbiAgICAgKi9cbiAgICBmaWx0ZXJzO1xuICAgIC8qKlxuICAgICAqICBAX2lnbm9yZTpcbiAgICAgKi9cbiAgICBbaW50ZXJuYWxdO1xuICAgIC8qKlxuICAgICAqICBUaGUgZmFsbGJhY2sgb3IgcmVjZWl2ZSBmdW5jdGlvbiBpZiBhbnkuXG4gICAgICovXG4gICAgZmFsbGJhY2s7XG4gICAgLyoqXG4gICAgICogIENyZWF0ZXMgYSBuZXcgY29udHJhY3QgY29ubmVjdGVkIHRvICUldGFyZ2V0JSUgd2l0aCB0aGUgJSVhYmklJSBhbmRcbiAgICAgKiAgb3B0aW9uYWxseSBjb25uZWN0ZWQgdG8gYSAlJXJ1bm5lciUlIHRvIHBlcmZvcm0gb3BlcmF0aW9ucyBvbiBiZWhhbGZcbiAgICAgKiAgb2YuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IodGFyZ2V0LCBhYmksIHJ1bm5lciwgX2RlcGxveVR4KSB7XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KHR5cGVvZiAodGFyZ2V0KSA9PT0gXCJzdHJpbmdcIiB8fCBpc0FkZHJlc3NhYmxlKHRhcmdldCksIFwiaW52YWxpZCB2YWx1ZSBmb3IgQ29udHJhY3QgdGFyZ2V0XCIsIFwidGFyZ2V0XCIsIHRhcmdldCk7XG4gICAgICAgIGlmIChydW5uZXIgPT0gbnVsbCkge1xuICAgICAgICAgICAgcnVubmVyID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpZmFjZSA9IEludGVyZmFjZS5mcm9tKGFiaSk7XG4gICAgICAgIGRlZmluZVByb3BlcnRpZXModGhpcywgeyB0YXJnZXQsIHJ1bm5lciwgaW50ZXJmYWNlOiBpZmFjZSB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIGludGVybmFsLCB7IHZhbHVlOiB7fSB9KTtcbiAgICAgICAgbGV0IGFkZHJQcm9taXNlO1xuICAgICAgICBsZXQgYWRkciA9IG51bGw7XG4gICAgICAgIGxldCBkZXBsb3lUeCA9IG51bGw7XG4gICAgICAgIGlmIChfZGVwbG95VHgpIHtcbiAgICAgICAgICAgIGNvbnN0IHByb3ZpZGVyID0gZ2V0UHJvdmlkZXIocnVubmVyKTtcbiAgICAgICAgICAgIC8vIEBUT0RPOiB0aGUgcHJvdmlkZXIgY2FuIGJlIG51bGw7IG1ha2UgYSBjdXN0b20gZHVtbXkgcHJvdmlkZXIgdGhhdCB3aWxsIHRocm93IGFcbiAgICAgICAgICAgIC8vIG1lYW5pbmdmdWwgZXJyb3JcbiAgICAgICAgICAgIGRlcGxveVR4ID0gbmV3IENvbnRyYWN0VHJhbnNhY3Rpb25SZXNwb25zZSh0aGlzLmludGVyZmFjZSwgcHJvdmlkZXIsIF9kZXBsb3lUeCk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHN1YnMgPSBuZXcgTWFwKCk7XG4gICAgICAgIC8vIFJlc29sdmUgdGhlIHRhcmdldCBhcyB0aGUgYWRkcmVzc1xuICAgICAgICBpZiAodHlwZW9mICh0YXJnZXQpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBpZiAoaXNIZXhTdHJpbmcodGFyZ2V0KSkge1xuICAgICAgICAgICAgICAgIGFkZHIgPSB0YXJnZXQ7XG4gICAgICAgICAgICAgICAgYWRkclByb21pc2UgPSBQcm9taXNlLnJlc29sdmUodGFyZ2V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc29sdmVyID0gZ2V0UnVubmVyKHJ1bm5lciwgXCJyZXNvbHZlTmFtZVwiKTtcbiAgICAgICAgICAgICAgICBpZiAoIWNhblJlc29sdmUocmVzb2x2ZXIpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG1ha2VFcnJvcihcImNvbnRyYWN0IHJ1bm5lciBkb2VzIG5vdCBzdXBwb3J0IG5hbWUgcmVzb2x1dGlvblwiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcGVyYXRpb246IFwicmVzb2x2ZU5hbWVcIlxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYWRkclByb21pc2UgPSByZXNvbHZlci5yZXNvbHZlTmFtZSh0YXJnZXQpLnRoZW4oKGFkZHIpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFkZHIgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbWFrZUVycm9yKFwiYW4gRU5TIG5hbWUgdXNlZCBmb3IgYSBjb250cmFjdCB0YXJnZXQgbXVzdCBiZSBjb3JyZWN0bHkgY29uZmlndXJlZFwiLCBcIlVOQ09ORklHVVJFRF9OQU1FXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdGFyZ2V0XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBnZXRJbnRlcm5hbCh0aGlzKS5hZGRyID0gYWRkcjtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFkZHI7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBhZGRyUHJvbWlzZSA9IHRhcmdldC5nZXRBZGRyZXNzKCkudGhlbigoYWRkcikgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChhZGRyID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVE9ET1wiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZ2V0SW50ZXJuYWwodGhpcykuYWRkciA9IGFkZHI7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFkZHI7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTZXQgb3VyIHByaXZhdGUgdmFsdWVzXG4gICAgICAgIHNldEludGVybmFsKHRoaXMsIHsgYWRkclByb21pc2UsIGFkZHIsIGRlcGxveVR4LCBzdWJzIH0pO1xuICAgICAgICAvLyBBZGQgdGhlIGV2ZW50IGZpbHRlcnNcbiAgICAgICAgY29uc3QgZmlsdGVycyA9IG5ldyBQcm94eSh7fSwge1xuICAgICAgICAgICAgZ2V0OiAodGFyZ2V0LCBwcm9wLCByZWNlaXZlcikgPT4ge1xuICAgICAgICAgICAgICAgIC8vIFBhc3MgaW1wb3J0YW50IGNoZWNrcyAobGlrZSBgdGhlbmAgZm9yIFByb21pc2UpIHRocm91Z2hcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIChwcm9wKSA9PT0gXCJzeW1ib2xcIiB8fCBwYXNzUHJvcGVydGllcy5pbmRleE9mKHByb3ApID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFJlZmxlY3QuZ2V0KHRhcmdldCwgcHJvcCwgcmVjZWl2ZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRFdmVudChwcm9wKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghaXNFcnJvcihlcnJvciwgXCJJTlZBTElEX0FSR1VNRU5UXCIpIHx8IGVycm9yLmFyZ3VtZW50ICE9PSBcImtleVwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGhhczogKHRhcmdldCwgcHJvcCkgPT4ge1xuICAgICAgICAgICAgICAgIC8vIFBhc3MgaW1wb3J0YW50IGNoZWNrcyAobGlrZSBgdGhlbmAgZm9yIFByb21pc2UpIHRocm91Z2hcbiAgICAgICAgICAgICAgICBpZiAocGFzc1Byb3BlcnRpZXMuaW5kZXhPZihwcm9wKSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBSZWZsZWN0Lmhhcyh0YXJnZXQsIHByb3ApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gUmVmbGVjdC5oYXModGFyZ2V0LCBwcm9wKSB8fCB0aGlzLmludGVyZmFjZS5oYXNFdmVudChTdHJpbmcocHJvcCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7IGZpbHRlcnMgfSk7XG4gICAgICAgIGRlZmluZVByb3BlcnRpZXModGhpcywge1xuICAgICAgICAgICAgZmFsbGJhY2s6ICgoaWZhY2UucmVjZWl2ZSB8fCBpZmFjZS5mYWxsYmFjaykgPyAoYnVpbGRXcmFwcGVkRmFsbGJhY2sodGhpcykpIDogbnVsbClcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIFJldHVybiBhIFByb3h5IHRoYXQgd2lsbCByZXNwb25kIHRvIGZ1bmN0aW9uc1xuICAgICAgICByZXR1cm4gbmV3IFByb3h5KHRoaXMsIHtcbiAgICAgICAgICAgIGdldDogKHRhcmdldCwgcHJvcCwgcmVjZWl2ZXIpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIChwcm9wKSA9PT0gXCJzeW1ib2xcIiB8fCBwcm9wIGluIHRhcmdldCB8fCBwYXNzUHJvcGVydGllcy5pbmRleE9mKHByb3ApID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFJlZmxlY3QuZ2V0KHRhcmdldCwgcHJvcCwgcmVjZWl2ZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBVbmRlZmluZWQgcHJvcGVydGllcyBzaG91bGQgcmV0dXJuIHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0YXJnZXQuZ2V0RnVuY3Rpb24ocHJvcCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWlzRXJyb3IoZXJyb3IsIFwiSU5WQUxJRF9BUkdVTUVOVFwiKSB8fCBlcnJvci5hcmd1bWVudCAhPT0gXCJrZXlcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBoYXM6ICh0YXJnZXQsIHByb3ApID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIChwcm9wKSA9PT0gXCJzeW1ib2xcIiB8fCBwcm9wIGluIHRhcmdldCB8fCBwYXNzUHJvcGVydGllcy5pbmRleE9mKHByb3ApID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFJlZmxlY3QuaGFzKHRhcmdldCwgcHJvcCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0YXJnZXQuaW50ZXJmYWNlLmhhc0Z1bmN0aW9uKHByb3ApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBDb250cmFjdCBpbnN0YW5jZSB3aXRoIHRoZSBzYW1lIHRhcmdldCBhbmQgQUJJLCBidXRcbiAgICAgKiAgYSBkaWZmZXJlbnQgJSVydW5uZXIlJS5cbiAgICAgKi9cbiAgICBjb25uZWN0KHJ1bm5lcikge1xuICAgICAgICByZXR1cm4gbmV3IEJhc2VDb250cmFjdCh0aGlzLnRhcmdldCwgdGhpcy5pbnRlcmZhY2UsIHJ1bm5lcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgQ29udHJhY3QgaW5zdGFuY2Ugd2l0aCB0aGUgc2FtZSBBQkkgYW5kIHJ1bm5lciwgYnV0XG4gICAgICogIGEgZGlmZmVyZW50ICUldGFyZ2V0JSUuXG4gICAgICovXG4gICAgYXR0YWNoKHRhcmdldCkge1xuICAgICAgICByZXR1cm4gbmV3IEJhc2VDb250cmFjdCh0YXJnZXQsIHRoaXMuaW50ZXJmYWNlLCB0aGlzLnJ1bm5lcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gdGhlIHJlc29sdmVkIGFkZHJlc3Mgb2YgdGhpcyBDb250cmFjdC5cbiAgICAgKi9cbiAgICBhc3luYyBnZXRBZGRyZXNzKCkgeyByZXR1cm4gYXdhaXQgZ2V0SW50ZXJuYWwodGhpcykuYWRkclByb21pc2U7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIHRoZSBkZXBsb3llZCBieXRlY29kZSBvciBudWxsIGlmIG5vIGJ5dGVjb2RlIGlzIGZvdW5kLlxuICAgICAqL1xuICAgIGFzeW5jIGdldERlcGxveWVkQ29kZSgpIHtcbiAgICAgICAgY29uc3QgcHJvdmlkZXIgPSBnZXRQcm92aWRlcih0aGlzLnJ1bm5lcik7XG4gICAgICAgIGFzc2VydChwcm92aWRlciwgXCJydW5uZXIgZG9lcyBub3Qgc3VwcG9ydCAucHJvdmlkZXJcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwgeyBvcGVyYXRpb246IFwiZ2V0RGVwbG95ZWRDb2RlXCIgfSk7XG4gICAgICAgIGNvbnN0IGNvZGUgPSBhd2FpdCBwcm92aWRlci5nZXRDb2RlKGF3YWl0IHRoaXMuZ2V0QWRkcmVzcygpKTtcbiAgICAgICAgaWYgKGNvZGUgPT09IFwiMHhcIikge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvZGU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXNvbHZlIHRvIHRoaXMgQ29udHJhY3Qgb25jZSB0aGUgYnl0ZWNvZGUgaGFzIGJlZW4gZGVwbG95ZWQsIG9yXG4gICAgICogIHJlc29sdmUgaW1tZWRpYXRlbHkgaWYgYWxyZWFkeSBkZXBsb3llZC5cbiAgICAgKi9cbiAgICBhc3luYyB3YWl0Rm9yRGVwbG95bWVudCgpIHtcbiAgICAgICAgLy8gV2UgaGF2ZSB0aGUgZGVwbG95ZW1lbnQgdHJhbnNhY3Rpb247IGp1c3QgdXNlIHRoYXQgKHRocm93cyBpZiBkZXBsb3llbWVudCBmYWlscylcbiAgICAgICAgY29uc3QgZGVwbG95VHggPSB0aGlzLmRlcGxveW1lbnRUcmFuc2FjdGlvbigpO1xuICAgICAgICBpZiAoZGVwbG95VHgpIHtcbiAgICAgICAgICAgIGF3YWl0IGRlcGxveVR4LndhaXQoKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIC8vIENoZWNrIGZvciBjb2RlXG4gICAgICAgIGNvbnN0IGNvZGUgPSBhd2FpdCB0aGlzLmdldERlcGxveWVkQ29kZSgpO1xuICAgICAgICBpZiAoY29kZSAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICAvLyBNYWtlIHN1cmUgd2UgY2FuIHN1YnNjcmliZSB0byBhIHByb3ZpZGVyIGV2ZW50XG4gICAgICAgIGNvbnN0IHByb3ZpZGVyID0gZ2V0UHJvdmlkZXIodGhpcy5ydW5uZXIpO1xuICAgICAgICBhc3NlcnQocHJvdmlkZXIgIT0gbnVsbCwgXCJjb250cmFjdCBydW5uZXIgZG9lcyBub3Qgc3VwcG9ydCAucHJvdmlkZXJcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwgeyBvcGVyYXRpb246IFwid2FpdEZvckRlcGxveW1lbnRcIiB9KTtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGNoZWNrQ29kZSA9IGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjb2RlID0gYXdhaXQgdGhpcy5nZXREZXBsb3llZENvZGUoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvZGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUodGhpcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXIub25jZShcImJsb2NrXCIsIGNoZWNrQ29kZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjaGVja0NvZGUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gdGhlIHRyYW5zYWN0aW9uIHVzZWQgdG8gZGVwbG95IHRoaXMgY29udHJhY3QuXG4gICAgICpcbiAgICAgKiAgVGhpcyBpcyBvbmx5IGF2YWlsYWJsZSBpZiB0aGlzIGluc3RhbmNlIHdhcyByZXR1cm5lZCBmcm9tIGFcbiAgICAgKiAgW1tDb250cmFjdEZhY3RvcnldXS5cbiAgICAgKi9cbiAgICBkZXBsb3ltZW50VHJhbnNhY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBnZXRJbnRlcm5hbCh0aGlzKS5kZXBsb3lUeDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiB0aGUgZnVuY3Rpb24gZm9yIGEgZ2l2ZW4gbmFtZS4gVGhpcyBpcyB1c2VmdWwgd2hlbiBhIGNvbnRyYWN0XG4gICAgICogIG1ldGhvZCBuYW1lIGNvbmZsaWN0cyB3aXRoIGEgSmF2YVNjcmlwdCBuYW1lIHN1Y2ggYXMgYGBwcm90b3R5cGVgYCBvclxuICAgICAqICB3aGVuIHVzaW5nIGEgQ29udHJhY3QgcHJvZ3JhbWF0aWNhbGx5LlxuICAgICAqL1xuICAgIGdldEZ1bmN0aW9uKGtleSkge1xuICAgICAgICBpZiAodHlwZW9mIChrZXkpICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBrZXkgPSBrZXkuZm9ybWF0KCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZnVuYyA9IGJ1aWxkV3JhcHBlZE1ldGhvZCh0aGlzLCBrZXkpO1xuICAgICAgICByZXR1cm4gZnVuYztcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiB0aGUgZXZlbnQgZm9yIGEgZ2l2ZW4gbmFtZS4gVGhpcyBpcyB1c2VmdWwgd2hlbiBhIGNvbnRyYWN0XG4gICAgICogIGV2ZW50IG5hbWUgY29uZmxpY3RzIHdpdGggYSBKYXZhU2NyaXB0IG5hbWUgc3VjaCBhcyBgYHByb3RvdHlwZWBgIG9yXG4gICAgICogIHdoZW4gdXNpbmcgYSBDb250cmFjdCBwcm9ncmFtYXRpY2FsbHkuXG4gICAgICovXG4gICAgZ2V0RXZlbnQoa2V5KSB7XG4gICAgICAgIGlmICh0eXBlb2YgKGtleSkgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGtleSA9IGtleS5mb3JtYXQoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYnVpbGRXcmFwcGVkRXZlbnQodGhpcywga2V5KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIEBfaWdub3JlOlxuICAgICAqL1xuICAgIGFzeW5jIHF1ZXJ5VHJhbnNhY3Rpb24oaGFzaCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJAVE9ET1wiKTtcbiAgICB9XG4gICAgLypcbiAgICAvLyBAVE9ETzogdGhpcyBpcyBhIG5vbi1iYWNrd2FyZHMgY29tcGF0aWJsZSBjaGFuZ2UsIGJ1dCB3aWxsIGJlIGFkZGVkXG4gICAgLy8gICAgICAgIGluIHY3IGFuZCBpbiBhIHBvdGVudGlhbCBTbWFydENvbnRyYWN0IGNsYXNzIGluIGFuIHVwY29taW5nXG4gICAgLy8gICAgICAgIHY2IHJlbGVhc2VcbiAgICBhc3luYyBnZXRUcmFuc2FjdGlvblJlY2VpcHQoaGFzaDogc3RyaW5nKTogUHJvbWlzZTxudWxsIHwgQ29udHJhY3RUcmFuc2FjdGlvblJlY2VpcHQ+IHtcbiAgICAgICAgY29uc3QgcHJvdmlkZXIgPSBnZXRQcm92aWRlcih0aGlzLnJ1bm5lcik7XG4gICAgICAgIGFzc2VydChwcm92aWRlciwgXCJjb250cmFjdCBydW5uZXIgZG9lcyBub3QgaGF2ZSBhIHByb3ZpZGVyXCIsXG4gICAgICAgICAgICBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7IG9wZXJhdGlvbjogXCJxdWVyeVRyYW5zYWN0aW9uXCIgfSk7XG5cbiAgICAgICAgY29uc3QgcmVjZWlwdCA9IGF3YWl0IHByb3ZpZGVyLmdldFRyYW5zYWN0aW9uUmVjZWlwdChoYXNoKTtcbiAgICAgICAgaWYgKHJlY2VpcHQgPT0gbnVsbCkgeyByZXR1cm4gbnVsbDsgfVxuXG4gICAgICAgIHJldHVybiBuZXcgQ29udHJhY3RUcmFuc2FjdGlvblJlY2VpcHQodGhpcy5pbnRlcmZhY2UsIHByb3ZpZGVyLCByZWNlaXB0KTtcbiAgICB9XG4gICAgKi9cbiAgICAvKipcbiAgICAgKiAgUHJvdmlkZSBoaXN0b3JpYyBhY2Nlc3MgdG8gZXZlbnQgZGF0YSBmb3IgJSVldmVudCUlIGluIHRoZSByYW5nZVxuICAgICAqICAlJWZyb21CbG9jayUlIChkZWZhdWx0OiBgYDBgYCkgdG8gJSV0b0Jsb2NrJSUgKGRlZmF1bHQ6IGBgXCJsYXRlc3RcImBgKVxuICAgICAqICBpbmNsdXNpdmUuXG4gICAgICovXG4gICAgYXN5bmMgcXVlcnlGaWx0ZXIoZXZlbnQsIGZyb21CbG9jaywgdG9CbG9jaykge1xuICAgICAgICBpZiAoZnJvbUJsb2NrID09IG51bGwpIHtcbiAgICAgICAgICAgIGZyb21CbG9jayA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRvQmxvY2sgPT0gbnVsbCkge1xuICAgICAgICAgICAgdG9CbG9jayA9IFwibGF0ZXN0XCI7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBhZGRyLCBhZGRyUHJvbWlzZSB9ID0gZ2V0SW50ZXJuYWwodGhpcyk7XG4gICAgICAgIGNvbnN0IGFkZHJlc3MgPSAoYWRkciA/IGFkZHIgOiAoYXdhaXQgYWRkclByb21pc2UpKTtcbiAgICAgICAgY29uc3QgeyBmcmFnbWVudCwgdG9waWNzIH0gPSBhd2FpdCBnZXRTdWJJbmZvKHRoaXMsIGV2ZW50KTtcbiAgICAgICAgY29uc3QgZmlsdGVyID0geyBhZGRyZXNzLCB0b3BpY3MsIGZyb21CbG9jaywgdG9CbG9jayB9O1xuICAgICAgICBjb25zdCBwcm92aWRlciA9IGdldFByb3ZpZGVyKHRoaXMucnVubmVyKTtcbiAgICAgICAgYXNzZXJ0KHByb3ZpZGVyLCBcImNvbnRyYWN0IHJ1bm5lciBkb2VzIG5vdCBoYXZlIGEgcHJvdmlkZXJcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwgeyBvcGVyYXRpb246IFwicXVlcnlGaWx0ZXJcIiB9KTtcbiAgICAgICAgcmV0dXJuIChhd2FpdCBwcm92aWRlci5nZXRMb2dzKGZpbHRlcikpLm1hcCgobG9nKSA9PiB7XG4gICAgICAgICAgICBsZXQgZm91bmRGcmFnbWVudCA9IGZyYWdtZW50O1xuICAgICAgICAgICAgaWYgKGZvdW5kRnJhZ21lbnQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGZvdW5kRnJhZ21lbnQgPSB0aGlzLmludGVyZmFjZS5nZXRFdmVudChsb2cudG9waWNzWzBdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7IH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmb3VuZEZyYWdtZW50KSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBFdmVudExvZyhsb2csIHRoaXMuaW50ZXJmYWNlLCBmb3VuZEZyYWdtZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVW5kZWNvZGVkRXZlbnRMb2cobG9nLCBlcnJvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBMb2cobG9nLCBwcm92aWRlcik7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQWRkIGFuIGV2ZW50ICUlbGlzdGVuZXIlJSBmb3IgdGhlICUlZXZlbnQlJS5cbiAgICAgKi9cbiAgICBhc3luYyBvbihldmVudCwgbGlzdGVuZXIpIHtcbiAgICAgICAgY29uc3Qgc3ViID0gYXdhaXQgZ2V0U3ViKHRoaXMsIFwib25cIiwgZXZlbnQpO1xuICAgICAgICBzdWIubGlzdGVuZXJzLnB1c2goeyBsaXN0ZW5lciwgb25jZTogZmFsc2UgfSk7XG4gICAgICAgIHN1Yi5zdGFydCgpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogIEFkZCBhbiBldmVudCAlJWxpc3RlbmVyJSUgZm9yIHRoZSAlJWV2ZW50JSUsIGJ1dCByZW1vdmUgdGhlIGxpc3RlbmVyXG4gICAgICogIGFmdGVyIGl0IGlzIGZpcmVkIG9uY2UuXG4gICAgICovXG4gICAgYXN5bmMgb25jZShldmVudCwgbGlzdGVuZXIpIHtcbiAgICAgICAgY29uc3Qgc3ViID0gYXdhaXQgZ2V0U3ViKHRoaXMsIFwib25jZVwiLCBldmVudCk7XG4gICAgICAgIHN1Yi5saXN0ZW5lcnMucHVzaCh7IGxpc3RlbmVyLCBvbmNlOiB0cnVlIH0pO1xuICAgICAgICBzdWIuc3RhcnQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBFbWl0IGFuICUlZXZlbnQlJSBjYWxsaW5nIGFsbCBsaXN0ZW5lcnMgd2l0aCAlJWFyZ3MlJS5cbiAgICAgKlxuICAgICAqICBSZXNvbHZlcyB0byBgYHRydWVgYCBpZiBhbnkgbGlzdGVuZXJzIHdlcmUgY2FsbGVkLlxuICAgICAqL1xuICAgIGFzeW5jIGVtaXQoZXZlbnQsIC4uLmFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IGVtaXQodGhpcywgZXZlbnQsIGFyZ3MsIG51bGwpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmVzb2x2ZXMgdG8gdGhlIG51bWJlciBvZiBsaXN0ZW5lcnMgb2YgJSVldmVudCUlIG9yIHRoZSB0b3RhbCBudW1iZXJcbiAgICAgKiAgb2YgbGlzdGVuZXJzIGlmIHVuc3BlY2lmaWVkLlxuICAgICAqL1xuICAgIGFzeW5jIGxpc3RlbmVyQ291bnQoZXZlbnQpIHtcbiAgICAgICAgaWYgKGV2ZW50KSB7XG4gICAgICAgICAgICBjb25zdCBzdWIgPSBhd2FpdCBoYXNTdWIodGhpcywgZXZlbnQpO1xuICAgICAgICAgICAgaWYgKCFzdWIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzdWIubGlzdGVuZXJzLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IHN1YnMgfSA9IGdldEludGVybmFsKHRoaXMpO1xuICAgICAgICBsZXQgdG90YWwgPSAwO1xuICAgICAgICBmb3IgKGNvbnN0IHsgbGlzdGVuZXJzIH0gb2Ygc3Vicy52YWx1ZXMoKSkge1xuICAgICAgICAgICAgdG90YWwgKz0gbGlzdGVuZXJzLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdG90YWw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXNvbHZlcyB0byB0aGUgbGlzdGVuZXJzIHN1YnNjcmliZWQgdG8gJSVldmVudCUlIG9yIGFsbCBsaXN0ZW5lcnNcbiAgICAgKiAgaWYgdW5zcGVjaWZpZWQuXG4gICAgICovXG4gICAgYXN5bmMgbGlzdGVuZXJzKGV2ZW50KSB7XG4gICAgICAgIGlmIChldmVudCkge1xuICAgICAgICAgICAgY29uc3Qgc3ViID0gYXdhaXQgaGFzU3ViKHRoaXMsIGV2ZW50KTtcbiAgICAgICAgICAgIGlmICghc3ViKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHN1Yi5saXN0ZW5lcnMubWFwKCh7IGxpc3RlbmVyIH0pID0+IGxpc3RlbmVyKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IHN1YnMgfSA9IGdldEludGVybmFsKHRoaXMpO1xuICAgICAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgICAgIGZvciAoY29uc3QgeyBsaXN0ZW5lcnMgfSBvZiBzdWJzLnZhbHVlcygpKSB7XG4gICAgICAgICAgICByZXN1bHQgPSByZXN1bHQuY29uY2F0KGxpc3RlbmVycy5tYXAoKHsgbGlzdGVuZXIgfSkgPT4gbGlzdGVuZXIpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmVtb3ZlIHRoZSAlJWxpc3RlbmVyJSUgZnJvbSB0aGUgbGlzdGVuZXJzIGZvciAlJWV2ZW50JSUgb3IgcmVtb3ZlXG4gICAgICogIGFsbCBsaXN0ZW5lcnMgaWYgdW5zcGVjaWZpZWQuXG4gICAgICovXG4gICAgYXN5bmMgb2ZmKGV2ZW50LCBsaXN0ZW5lcikge1xuICAgICAgICBjb25zdCBzdWIgPSBhd2FpdCBoYXNTdWIodGhpcywgZXZlbnQpO1xuICAgICAgICBpZiAoIXN1Yikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxpc3RlbmVyKSB7XG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IHN1Yi5saXN0ZW5lcnMubWFwKCh7IGxpc3RlbmVyIH0pID0+IGxpc3RlbmVyKS5pbmRleE9mKGxpc3RlbmVyKTtcbiAgICAgICAgICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgc3ViLmxpc3RlbmVycy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChsaXN0ZW5lciA9PSBudWxsIHx8IHN1Yi5saXN0ZW5lcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBzdWIuc3RvcCgpO1xuICAgICAgICAgICAgZ2V0SW50ZXJuYWwodGhpcykuc3Vicy5kZWxldGUoc3ViLnRhZyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZW1vdmUgYWxsIHRoZSBsaXN0ZW5lcnMgZm9yICUlZXZlbnQlJSBvciByZW1vdmUgYWxsIGxpc3RlbmVycyBpZlxuICAgICAqICB1bnNwZWNpZmllZC5cbiAgICAgKi9cbiAgICBhc3luYyByZW1vdmVBbGxMaXN0ZW5lcnMoZXZlbnQpIHtcbiAgICAgICAgaWYgKGV2ZW50KSB7XG4gICAgICAgICAgICBjb25zdCBzdWIgPSBhd2FpdCBoYXNTdWIodGhpcywgZXZlbnQpO1xuICAgICAgICAgICAgaWYgKCFzdWIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN1Yi5zdG9wKCk7XG4gICAgICAgICAgICBnZXRJbnRlcm5hbCh0aGlzKS5zdWJzLmRlbGV0ZShzdWIudGFnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHsgc3VicyB9ID0gZ2V0SW50ZXJuYWwodGhpcyk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHsgdGFnLCBzdG9wIH0gb2Ygc3Vicy52YWx1ZXMoKSkge1xuICAgICAgICAgICAgICAgIHN0b3AoKTtcbiAgICAgICAgICAgICAgICBzdWJzLmRlbGV0ZSh0YWcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQWxpYXMgZm9yIFtvbl0uXG4gICAgICovXG4gICAgYXN5bmMgYWRkTGlzdGVuZXIoZXZlbnQsIGxpc3RlbmVyKSB7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLm9uKGV2ZW50LCBsaXN0ZW5lcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBBbGlhcyBmb3IgW29mZl0uXG4gICAgICovXG4gICAgYXN5bmMgcmVtb3ZlTGlzdGVuZXIoZXZlbnQsIGxpc3RlbmVyKSB7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLm9mZihldmVudCwgbGlzdGVuZXIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlIGEgbmV3IENsYXNzIGZvciB0aGUgJSVhYmklJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgYnVpbGRDbGFzcyhhYmkpIHtcbiAgICAgICAgY2xhc3MgQ3VzdG9tQ29udHJhY3QgZXh0ZW5kcyBCYXNlQ29udHJhY3Qge1xuICAgICAgICAgICAgY29uc3RydWN0b3IoYWRkcmVzcywgcnVubmVyID0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHN1cGVyKGFkZHJlc3MsIGFiaSwgcnVubmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gQ3VzdG9tQ29udHJhY3Q7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlIGEgbmV3IEJhc2VDb250cmFjdCB3aXRoIGEgc3BlY2lmaWVkIEludGVyZmFjZS5cbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbSh0YXJnZXQsIGFiaSwgcnVubmVyKSB7XG4gICAgICAgIGlmIChydW5uZXIgPT0gbnVsbCkge1xuICAgICAgICAgICAgcnVubmVyID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjb250cmFjdCA9IG5ldyB0aGlzKHRhcmdldCwgYWJpLCBydW5uZXIpO1xuICAgICAgICByZXR1cm4gY29udHJhY3Q7XG4gICAgfVxufVxuZnVuY3Rpb24gX0NvbnRyYWN0QmFzZSgpIHtcbiAgICByZXR1cm4gQmFzZUNvbnRyYWN0O1xufVxuLyoqXG4gKiAgQSBbW0Jhc2VDb250cmFjdF1dIHdpdGggbm8gdHlwZSBndWFyZHMgb24gaXRzIG1ldGhvZHMgb3IgZXZlbnRzLlxuICovXG5leHBvcnQgY2xhc3MgQ29udHJhY3QgZXh0ZW5kcyBfQ29udHJhY3RCYXNlKCkge1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29udHJhY3QuanMubWFwIl0sIm5hbWVzIjpbIkludGVyZmFjZSIsIlR5cGVkIiwiaXNBZGRyZXNzYWJsZSIsInJlc29sdmVBZGRyZXNzIiwiY29weVJlcXVlc3QiLCJMb2ciLCJkZWZpbmVQcm9wZXJ0aWVzIiwiZ2V0QmlnSW50IiwiaXNDYWxsRXhjZXB0aW9uIiwiaXNIZXhTdHJpbmciLCJyZXNvbHZlUHJvcGVydGllcyIsImlzRXJyb3IiLCJtYWtlRXJyb3IiLCJhc3NlcnQiLCJhc3NlcnRBcmd1bWVudCIsIkNvbnRyYWN0RXZlbnRQYXlsb2FkIiwiQ29udHJhY3RVbmtub3duRXZlbnRQYXlsb2FkIiwiQ29udHJhY3RUcmFuc2FjdGlvblJlc3BvbnNlIiwiRXZlbnRMb2ciLCJVbmRlY29kZWRFdmVudExvZyIsIkJOXzAiLCJCaWdJbnQiLCJjYW5DYWxsIiwidmFsdWUiLCJjYWxsIiwiY2FuRXN0aW1hdGUiLCJlc3RpbWF0ZUdhcyIsImNhblJlc29sdmUiLCJyZXNvbHZlTmFtZSIsImNhblNlbmQiLCJzZW5kVHJhbnNhY3Rpb24iLCJnZXRSZXNvbHZlciIsInByb3ZpZGVyIiwidW5kZWZpbmVkIiwiUHJlcGFyZWRUb3BpY0ZpbHRlciIsImZpbHRlciIsImNvbnN0cnVjdG9yIiwiY29udHJhY3QiLCJmcmFnbWVudCIsImFyZ3MiLCJpbnB1dHMiLCJsZW5ndGgiLCJFcnJvciIsInJ1bm5lciIsImdldFJ1bm5lciIsInJlc29sdmVyIiwicmVzb2x2ZWRBcmdzIiwiUHJvbWlzZSIsImFsbCIsIm1hcCIsInBhcmFtIiwiaW5kZXgiLCJhcmciLCJ3YWxrQXN5bmMiLCJ0eXBlIiwiQXJyYXkiLCJpc0FycmF5IiwidiIsImludGVyZmFjZSIsImVuY29kZUZpbHRlclRvcGljcyIsImdldFRvcGljRmlsdGVyIiwiZmVhdHVyZSIsImdldFByb3ZpZGVyIiwiY29weU92ZXJyaWRlcyIsImFsbG93ZWQiLCJfb3ZlcnJpZGVzIiwiZGVyZWZlcmVuY2UiLCJvdmVycmlkZXMiLCJ0byIsImluZGV4T2YiLCJkYXRhIiwiZnJvbSIsInJlc29sdmVBcmdzIiwiX3J1bm5lciIsImJ1aWxkV3JhcHBlZEZhbGxiYWNrIiwicG9wdWxhdGVUcmFuc2FjdGlvbiIsInR4IiwiZ2V0QWRkcmVzcyIsImlmYWNlIiwibm9WYWx1ZSIsIm5vRGF0YSIsImZhbGxiYWNrIiwicGF5YWJsZSIsInJlY2VpdmUiLCJzdGF0aWNDYWxsIiwib3BlcmF0aW9uIiwiZXJyb3IiLCJzZW5kIiwibWV0aG9kIiwiX2NvbnRyYWN0IiwiYnVpbGRXcmFwcGVkTWV0aG9kIiwia2V5IiwiZ2V0RnJhZ21lbnQiLCJnZXRGdW5jdGlvbiIsImluZm8iLCJwb3AiLCJPYmplY3QiLCJhc3NpZ24iLCJlbmNvZGVGdW5jdGlvbkRhdGEiLCJyZXN1bHQiLCJzdGF0aWNDYWxsUmVzdWx0IiwiZGVjb2RlRnVuY3Rpb25SZXN1bHQiLCJjb25zdGFudCIsIm5hbWUiLCJnZXRGdW5jdGlvbk5hbWUiLCJfa2V5IiwiZGVmaW5lUHJvcGVydHkiLCJjb25maWd1cmFibGUiLCJlbnVtZXJhYmxlIiwiZ2V0IiwiYnVpbGRXcmFwcGVkRXZlbnQiLCJnZXRFdmVudCIsImdldEV2ZW50TmFtZSIsImludGVybmFsIiwiU3ltYm9sIiwiZm9yIiwiaW50ZXJuYWxWYWx1ZXMiLCJXZWFrTWFwIiwic2V0SW50ZXJuYWwiLCJ2YWx1ZXMiLCJzZXQiLCJnZXRJbnRlcm5hbCIsImlzRGVmZXJyZWQiLCJnZXRTdWJJbmZvIiwiZXZlbnQiLCJ0b3BpY3MiLCJ0b3BpY0hhc2hpZnkiLCJ0b3BpY0hhc2giLCJlIiwidCIsIml0ZW1zIiwiU2V0IiwidG9Mb3dlckNhc2UiLCJzb3J0IiwidGFnIiwiam9pbiIsImhhc1N1YiIsInN1YnMiLCJnZXRTdWIiLCJhZGRyIiwic3ViIiwiYWRkcmVzcyIsImxpc3RlbmVyIiwibG9nIiwiZm91bmRGcmFnbWVudCIsIl9mb3VuZEZyYWdtZW50IiwiZGVjb2RlRXZlbnRMb2ciLCJlbWl0Iiwic3RhcnRpbmciLCJzdGFydCIsInB1c2giLCJvbiIsInN0b3AiLCJzdGFydGVkIiwib2ZmIiwibGlzdGVuZXJzIiwibGFzdEVtaXQiLCJyZXNvbHZlIiwiX2VtaXQiLCJwYXlsb2FkRnVuYyIsImNvdW50Iiwib25jZSIsInBhc3NBcmdzIiwiZGVsZXRlIiwicmVzdWx0UHJvbWlzZSIsInBhc3NQcm9wZXJ0aWVzIiwiQmFzZUNvbnRyYWN0IiwidGFyZ2V0IiwiYWJpIiwiX2RlcGxveVR4IiwiYWRkclByb21pc2UiLCJkZXBsb3lUeCIsIk1hcCIsInRoZW4iLCJmaWx0ZXJzIiwiUHJveHkiLCJwcm9wIiwicmVjZWl2ZXIiLCJSZWZsZWN0IiwiYXJndW1lbnQiLCJoYXMiLCJoYXNFdmVudCIsIlN0cmluZyIsImhhc0Z1bmN0aW9uIiwiY29ubmVjdCIsImF0dGFjaCIsImdldERlcGxveWVkQ29kZSIsImNvZGUiLCJnZXRDb2RlIiwid2FpdEZvckRlcGxveW1lbnQiLCJkZXBsb3ltZW50VHJhbnNhY3Rpb24iLCJ3YWl0IiwicmVqZWN0IiwiY2hlY2tDb2RlIiwiZm9ybWF0IiwiZnVuYyIsInF1ZXJ5VHJhbnNhY3Rpb24iLCJoYXNoIiwicXVlcnlGaWx0ZXIiLCJmcm9tQmxvY2siLCJ0b0Jsb2NrIiwiZ2V0TG9ncyIsImxpc3RlbmVyQ291bnQiLCJ0b3RhbCIsImNvbmNhdCIsInNwbGljZSIsInJlbW92ZUFsbExpc3RlbmVycyIsImFkZExpc3RlbmVyIiwicmVtb3ZlTGlzdGVuZXIiLCJidWlsZENsYXNzIiwiQ3VzdG9tQ29udHJhY3QiLCJfQ29udHJhY3RCYXNlIiwiQ29udHJhY3QiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.esm/contract/contract.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.esm/contract/wrappers.js":
/*!**********************************************************!*\
  !*** ./node_modules/ethers/lib.esm/contract/wrappers.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ContractEventPayload: () => (/* binding */ ContractEventPayload),\n/* harmony export */   ContractTransactionReceipt: () => (/* binding */ ContractTransactionReceipt),\n/* harmony export */   ContractTransactionResponse: () => (/* binding */ ContractTransactionResponse),\n/* harmony export */   ContractUnknownEventPayload: () => (/* binding */ ContractUnknownEventPayload),\n/* harmony export */   EventLog: () => (/* binding */ EventLog),\n/* harmony export */   UndecodedEventLog: () => (/* binding */ UndecodedEventLog)\n/* harmony export */ });\n/* harmony import */ var _providers_provider_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../providers/provider.js */ \"(ssr)/./node_modules/ethers/lib.esm/providers/provider.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/properties.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/events.js\");\n// import from provider.ts instead of index.ts to prevent circular dep\n// from EtherscanProvider\n\n\n/**\n *  An **EventLog** contains additional properties parsed from the [[Log]].\n */ class EventLog extends _providers_provider_js__WEBPACK_IMPORTED_MODULE_0__.Log {\n    /**\n     * @_ignore:\n     */ constructor(log, iface, fragment){\n        super(log, log.provider);\n        const args = iface.decodeEventLog(fragment, log.data, log.topics);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.defineProperties)(this, {\n            args,\n            fragment,\n            interface: iface\n        });\n    }\n    /**\n     *  The name of the event.\n     */ get eventName() {\n        return this.fragment.name;\n    }\n    /**\n     *  The signature of the event.\n     */ get eventSignature() {\n        return this.fragment.format();\n    }\n}\n/**\n *  An **EventLog** contains additional properties parsed from the [[Log]].\n */ class UndecodedEventLog extends _providers_provider_js__WEBPACK_IMPORTED_MODULE_0__.Log {\n    /**\n     * @_ignore:\n     */ constructor(log, error){\n        super(log, log.provider);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.defineProperties)(this, {\n            error\n        });\n    }\n}\n/**\n *  A **ContractTransactionReceipt** includes the parsed logs from a\n *  [[TransactionReceipt]].\n */ class ContractTransactionReceipt extends _providers_provider_js__WEBPACK_IMPORTED_MODULE_0__.TransactionReceipt {\n    #iface;\n    /**\n     *  @_ignore:\n     */ constructor(iface, provider, tx){\n        super(tx, provider);\n        this.#iface = iface;\n    }\n    /**\n     *  The parsed logs for any [[Log]] which has a matching event in the\n     *  Contract ABI.\n     */ get logs() {\n        return super.logs.map((log)=>{\n            const fragment = log.topics.length ? this.#iface.getEvent(log.topics[0]) : null;\n            if (fragment) {\n                try {\n                    return new EventLog(log, this.#iface, fragment);\n                } catch (error) {\n                    return new UndecodedEventLog(log, error);\n                }\n            }\n            return log;\n        });\n    }\n}\n/**\n *  A **ContractTransactionResponse** will return a\n *  [[ContractTransactionReceipt]] when waited on.\n */ class ContractTransactionResponse extends _providers_provider_js__WEBPACK_IMPORTED_MODULE_0__.TransactionResponse {\n    #iface;\n    /**\n     *  @_ignore:\n     */ constructor(iface, provider, tx){\n        super(tx, provider);\n        this.#iface = iface;\n    }\n    /**\n     *  Resolves once this transaction has been mined and has\n     *  %%confirms%% blocks including it (default: ``1``) with an\n     *  optional %%timeout%%.\n     *\n     *  This can resolve to ``null`` only if %%confirms%% is ``0``\n     *  and the transaction has not been mined, otherwise this will\n     *  wait until enough confirmations have completed.\n     */ async wait(confirms, timeout) {\n        const receipt = await super.wait(confirms, timeout);\n        if (receipt == null) {\n            return null;\n        }\n        return new ContractTransactionReceipt(this.#iface, this.provider, receipt);\n    }\n}\n/**\n *  A **ContractUnknownEventPayload** is included as the last parameter to\n *  Contract Events when the event does not match any events in the ABI.\n */ class ContractUnknownEventPayload extends _utils_index_js__WEBPACK_IMPORTED_MODULE_2__.EventPayload {\n    /**\n     *  @_event:\n     */ constructor(contract, listener, filter, log){\n        super(contract, listener, filter);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.defineProperties)(this, {\n            log\n        });\n    }\n    /**\n     *  Resolves to the block the event occured in.\n     */ async getBlock() {\n        return await this.log.getBlock();\n    }\n    /**\n     *  Resolves to the transaction the event occured in.\n     */ async getTransaction() {\n        return await this.log.getTransaction();\n    }\n    /**\n     *  Resolves to the transaction receipt the event occured in.\n     */ async getTransactionReceipt() {\n        return await this.log.getTransactionReceipt();\n    }\n}\n/**\n *  A **ContractEventPayload** is included as the last parameter to\n *  Contract Events when the event is known.\n */ class ContractEventPayload extends ContractUnknownEventPayload {\n    /**\n     *  @_ignore:\n     */ constructor(contract, listener, filter, fragment, _log){\n        super(contract, listener, filter, new EventLog(_log, contract.interface, fragment));\n        const args = contract.interface.decodeEventLog(fragment, this.log.data, this.log.topics);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.defineProperties)(this, {\n            args,\n            fragment\n        });\n    }\n    /**\n     *  The event name.\n     */ get eventName() {\n        return this.fragment.name;\n    }\n    /**\n     *  The event signature.\n     */ get eventSignature() {\n        return this.fragment.format();\n    }\n} //# sourceMappingURL=wrappers.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vY29udHJhY3Qvd3JhcHBlcnMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQUEsc0VBQXNFO0FBQ3RFLHlCQUF5QjtBQUMrRDtBQUNyQjtBQUNuRTs7Q0FFQyxHQUNNLE1BQU1LLGlCQUFpQkwsdURBQUdBO0lBYTdCOztLQUVDLEdBQ0RNLFlBQVlDLEdBQUcsRUFBRUMsS0FBSyxFQUFFQyxRQUFRLENBQUU7UUFDOUIsS0FBSyxDQUFDRixLQUFLQSxJQUFJRyxRQUFRO1FBQ3ZCLE1BQU1DLE9BQU9ILE1BQU1JLGNBQWMsQ0FBQ0gsVUFBVUYsSUFBSU0sSUFBSSxFQUFFTixJQUFJTyxNQUFNO1FBQ2hFWCxpRUFBZ0JBLENBQUMsSUFBSSxFQUFFO1lBQUVRO1lBQU1GO1lBQVVNLFdBQVdQO1FBQU07SUFDOUQ7SUFDQTs7S0FFQyxHQUNELElBQUlRLFlBQVk7UUFBRSxPQUFPLElBQUksQ0FBQ1AsUUFBUSxDQUFDUSxJQUFJO0lBQUU7SUFDN0M7O0tBRUMsR0FDRCxJQUFJQyxpQkFBaUI7UUFBRSxPQUFPLElBQUksQ0FBQ1QsUUFBUSxDQUFDVSxNQUFNO0lBQUk7QUFDMUQ7QUFDQTs7Q0FFQyxHQUNNLE1BQU1DLDBCQUEwQnBCLHVEQUFHQTtJQUt0Qzs7S0FFQyxHQUNETSxZQUFZQyxHQUFHLEVBQUVjLEtBQUssQ0FBRTtRQUNwQixLQUFLLENBQUNkLEtBQUtBLElBQUlHLFFBQVE7UUFDdkJQLGlFQUFnQkEsQ0FBQyxJQUFJLEVBQUU7WUFBRWtCO1FBQU07SUFDbkM7QUFDSjtBQUNBOzs7Q0FHQyxHQUNNLE1BQU1DLG1DQUFtQ3JCLHNFQUFrQkE7SUFDOUQsQ0FBQ08sS0FBSyxDQUFDO0lBQ1A7O0tBRUMsR0FDREYsWUFBWUUsS0FBSyxFQUFFRSxRQUFRLEVBQUVhLEVBQUUsQ0FBRTtRQUM3QixLQUFLLENBQUNBLElBQUliO1FBQ1YsSUFBSSxDQUFDLENBQUNGLEtBQUssR0FBR0E7SUFDbEI7SUFDQTs7O0tBR0MsR0FDRCxJQUFJZ0IsT0FBTztRQUNQLE9BQU8sS0FBSyxDQUFDQSxLQUFLQyxHQUFHLENBQUMsQ0FBQ2xCO1lBQ25CLE1BQU1FLFdBQVdGLElBQUlPLE1BQU0sQ0FBQ1ksTUFBTSxHQUFHLElBQUksQ0FBQyxDQUFDbEIsS0FBSyxDQUFDbUIsUUFBUSxDQUFDcEIsSUFBSU8sTUFBTSxDQUFDLEVBQUUsSUFBSTtZQUMzRSxJQUFJTCxVQUFVO2dCQUNWLElBQUk7b0JBQ0EsT0FBTyxJQUFJSixTQUFTRSxLQUFLLElBQUksQ0FBQyxDQUFDQyxLQUFLLEVBQUVDO2dCQUMxQyxFQUNBLE9BQU9ZLE9BQU87b0JBQ1YsT0FBTyxJQUFJRCxrQkFBa0JiLEtBQUtjO2dCQUN0QztZQUNKO1lBQ0EsT0FBT2Q7UUFDWDtJQUNKO0FBQ0o7QUFDQTs7O0NBR0MsR0FDTSxNQUFNcUIsb0NBQW9DMUIsdUVBQW1CQTtJQUNoRSxDQUFDTSxLQUFLLENBQUM7SUFDUDs7S0FFQyxHQUNERixZQUFZRSxLQUFLLEVBQUVFLFFBQVEsRUFBRWEsRUFBRSxDQUFFO1FBQzdCLEtBQUssQ0FBQ0EsSUFBSWI7UUFDVixJQUFJLENBQUMsQ0FBQ0YsS0FBSyxHQUFHQTtJQUNsQjtJQUNBOzs7Ozs7OztLQVFDLEdBQ0QsTUFBTXFCLEtBQUtDLFFBQVEsRUFBRUMsT0FBTyxFQUFFO1FBQzFCLE1BQU1DLFVBQVUsTUFBTSxLQUFLLENBQUNILEtBQUtDLFVBQVVDO1FBQzNDLElBQUlDLFdBQVcsTUFBTTtZQUNqQixPQUFPO1FBQ1g7UUFDQSxPQUFPLElBQUlWLDJCQUEyQixJQUFJLENBQUMsQ0FBQ2QsS0FBSyxFQUFFLElBQUksQ0FBQ0UsUUFBUSxFQUFFc0I7SUFDdEU7QUFDSjtBQUNBOzs7Q0FHQyxHQUNNLE1BQU1DLG9DQUFvQzdCLHlEQUFZQTtJQUt6RDs7S0FFQyxHQUNERSxZQUFZNEIsUUFBUSxFQUFFQyxRQUFRLEVBQUVDLE1BQU0sRUFBRTdCLEdBQUcsQ0FBRTtRQUN6QyxLQUFLLENBQUMyQixVQUFVQyxVQUFVQztRQUMxQmpDLGlFQUFnQkEsQ0FBQyxJQUFJLEVBQUU7WUFBRUk7UUFBSTtJQUNqQztJQUNBOztLQUVDLEdBQ0QsTUFBTThCLFdBQVc7UUFDYixPQUFPLE1BQU0sSUFBSSxDQUFDOUIsR0FBRyxDQUFDOEIsUUFBUTtJQUNsQztJQUNBOztLQUVDLEdBQ0QsTUFBTUMsaUJBQWlCO1FBQ25CLE9BQU8sTUFBTSxJQUFJLENBQUMvQixHQUFHLENBQUMrQixjQUFjO0lBQ3hDO0lBQ0E7O0tBRUMsR0FDRCxNQUFNQyx3QkFBd0I7UUFDMUIsT0FBTyxNQUFNLElBQUksQ0FBQ2hDLEdBQUcsQ0FBQ2dDLHFCQUFxQjtJQUMvQztBQUNKO0FBQ0E7OztDQUdDLEdBQ00sTUFBTUMsNkJBQTZCUDtJQUN0Qzs7S0FFQyxHQUNEM0IsWUFBWTRCLFFBQVEsRUFBRUMsUUFBUSxFQUFFQyxNQUFNLEVBQUUzQixRQUFRLEVBQUVnQyxJQUFJLENBQUU7UUFDcEQsS0FBSyxDQUFDUCxVQUFVQyxVQUFVQyxRQUFRLElBQUkvQixTQUFTb0MsTUFBTVAsU0FBU25CLFNBQVMsRUFBRU47UUFDekUsTUFBTUUsT0FBT3VCLFNBQVNuQixTQUFTLENBQUNILGNBQWMsQ0FBQ0gsVUFBVSxJQUFJLENBQUNGLEdBQUcsQ0FBQ00sSUFBSSxFQUFFLElBQUksQ0FBQ04sR0FBRyxDQUFDTyxNQUFNO1FBQ3ZGWCxpRUFBZ0JBLENBQUMsSUFBSSxFQUFFO1lBQUVRO1lBQU1GO1FBQVM7SUFDNUM7SUFDQTs7S0FFQyxHQUNELElBQUlPLFlBQVk7UUFDWixPQUFPLElBQUksQ0FBQ1AsUUFBUSxDQUFDUSxJQUFJO0lBQzdCO0lBQ0E7O0tBRUMsR0FDRCxJQUFJQyxpQkFBaUI7UUFDakIsT0FBTyxJQUFJLENBQUNULFFBQVEsQ0FBQ1UsTUFBTTtJQUMvQjtBQUNKLEVBQ0Esb0NBQW9DIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbWVnYXZpYmUtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vY29udHJhY3Qvd3JhcHBlcnMuanM/ZTA2MCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBpbXBvcnQgZnJvbSBwcm92aWRlci50cyBpbnN0ZWFkIG9mIGluZGV4LnRzIHRvIHByZXZlbnQgY2lyY3VsYXIgZGVwXG4vLyBmcm9tIEV0aGVyc2NhblByb3ZpZGVyXG5pbXBvcnQgeyBMb2csIFRyYW5zYWN0aW9uUmVjZWlwdCwgVHJhbnNhY3Rpb25SZXNwb25zZSB9IGZyb20gXCIuLi9wcm92aWRlcnMvcHJvdmlkZXIuanNcIjtcbmltcG9ydCB7IGRlZmluZVByb3BlcnRpZXMsIEV2ZW50UGF5bG9hZCB9IGZyb20gXCIuLi91dGlscy9pbmRleC5qc1wiO1xuLyoqXG4gKiAgQW4gKipFdmVudExvZyoqIGNvbnRhaW5zIGFkZGl0aW9uYWwgcHJvcGVydGllcyBwYXJzZWQgZnJvbSB0aGUgW1tMb2ddXS5cbiAqL1xuZXhwb3J0IGNsYXNzIEV2ZW50TG9nIGV4dGVuZHMgTG9nIHtcbiAgICAvKipcbiAgICAgKiAgVGhlIENvbnRyYWN0IEludGVyZmFjZS5cbiAgICAgKi9cbiAgICBpbnRlcmZhY2U7XG4gICAgLyoqXG4gICAgICogIFRoZSBtYXRjaGluZyBldmVudC5cbiAgICAgKi9cbiAgICBmcmFnbWVudDtcbiAgICAvKipcbiAgICAgKiAgVGhlIHBhcnNlZCBhcmd1bWVudHMgcGFzc2VkIHRvIHRoZSBldmVudCBieSBgYGVtaXRgYC5cbiAgICAgKi9cbiAgICBhcmdzO1xuICAgIC8qKlxuICAgICAqIEBfaWdub3JlOlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGxvZywgaWZhY2UsIGZyYWdtZW50KSB7XG4gICAgICAgIHN1cGVyKGxvZywgbG9nLnByb3ZpZGVyKTtcbiAgICAgICAgY29uc3QgYXJncyA9IGlmYWNlLmRlY29kZUV2ZW50TG9nKGZyYWdtZW50LCBsb2cuZGF0YSwgbG9nLnRvcGljcyk7XG4gICAgICAgIGRlZmluZVByb3BlcnRpZXModGhpcywgeyBhcmdzLCBmcmFnbWVudCwgaW50ZXJmYWNlOiBpZmFjZSB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRoZSBuYW1lIG9mIHRoZSBldmVudC5cbiAgICAgKi9cbiAgICBnZXQgZXZlbnROYW1lKCkgeyByZXR1cm4gdGhpcy5mcmFnbWVudC5uYW1lOyB9XG4gICAgLyoqXG4gICAgICogIFRoZSBzaWduYXR1cmUgb2YgdGhlIGV2ZW50LlxuICAgICAqL1xuICAgIGdldCBldmVudFNpZ25hdHVyZSgpIHsgcmV0dXJuIHRoaXMuZnJhZ21lbnQuZm9ybWF0KCk7IH1cbn1cbi8qKlxuICogIEFuICoqRXZlbnRMb2cqKiBjb250YWlucyBhZGRpdGlvbmFsIHByb3BlcnRpZXMgcGFyc2VkIGZyb20gdGhlIFtbTG9nXV0uXG4gKi9cbmV4cG9ydCBjbGFzcyBVbmRlY29kZWRFdmVudExvZyBleHRlbmRzIExvZyB7XG4gICAgLyoqXG4gICAgICogIFRoZSBlcnJvciBlbmNvdW50ZWQgd2hlbiB0cnlpbmcgdG8gZGVjb2RlIHRoZSBsb2cuXG4gICAgICovXG4gICAgZXJyb3I7XG4gICAgLyoqXG4gICAgICogQF9pZ25vcmU6XG4gICAgICovXG4gICAgY29uc3RydWN0b3IobG9nLCBlcnJvcikge1xuICAgICAgICBzdXBlcihsb2csIGxvZy5wcm92aWRlcik7XG4gICAgICAgIGRlZmluZVByb3BlcnRpZXModGhpcywgeyBlcnJvciB9KTtcbiAgICB9XG59XG4vKipcbiAqICBBICoqQ29udHJhY3RUcmFuc2FjdGlvblJlY2VpcHQqKiBpbmNsdWRlcyB0aGUgcGFyc2VkIGxvZ3MgZnJvbSBhXG4gKiAgW1tUcmFuc2FjdGlvblJlY2VpcHRdXS5cbiAqL1xuZXhwb3J0IGNsYXNzIENvbnRyYWN0VHJhbnNhY3Rpb25SZWNlaXB0IGV4dGVuZHMgVHJhbnNhY3Rpb25SZWNlaXB0IHtcbiAgICAjaWZhY2U7XG4gICAgLyoqXG4gICAgICogIEBfaWdub3JlOlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGlmYWNlLCBwcm92aWRlciwgdHgpIHtcbiAgICAgICAgc3VwZXIodHgsIHByb3ZpZGVyKTtcbiAgICAgICAgdGhpcy4jaWZhY2UgPSBpZmFjZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRoZSBwYXJzZWQgbG9ncyBmb3IgYW55IFtbTG9nXV0gd2hpY2ggaGFzIGEgbWF0Y2hpbmcgZXZlbnQgaW4gdGhlXG4gICAgICogIENvbnRyYWN0IEFCSS5cbiAgICAgKi9cbiAgICBnZXQgbG9ncygpIHtcbiAgICAgICAgcmV0dXJuIHN1cGVyLmxvZ3MubWFwKChsb2cpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGZyYWdtZW50ID0gbG9nLnRvcGljcy5sZW5ndGggPyB0aGlzLiNpZmFjZS5nZXRFdmVudChsb2cudG9waWNzWzBdKSA6IG51bGw7XG4gICAgICAgICAgICBpZiAoZnJhZ21lbnQpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEV2ZW50TG9nKGxvZywgdGhpcy4jaWZhY2UsIGZyYWdtZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVW5kZWNvZGVkRXZlbnRMb2cobG9nLCBlcnJvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGxvZztcbiAgICAgICAgfSk7XG4gICAgfVxufVxuLyoqXG4gKiAgQSAqKkNvbnRyYWN0VHJhbnNhY3Rpb25SZXNwb25zZSoqIHdpbGwgcmV0dXJuIGFcbiAqICBbW0NvbnRyYWN0VHJhbnNhY3Rpb25SZWNlaXB0XV0gd2hlbiB3YWl0ZWQgb24uXG4gKi9cbmV4cG9ydCBjbGFzcyBDb250cmFjdFRyYW5zYWN0aW9uUmVzcG9uc2UgZXh0ZW5kcyBUcmFuc2FjdGlvblJlc3BvbnNlIHtcbiAgICAjaWZhY2U7XG4gICAgLyoqXG4gICAgICogIEBfaWdub3JlOlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGlmYWNlLCBwcm92aWRlciwgdHgpIHtcbiAgICAgICAgc3VwZXIodHgsIHByb3ZpZGVyKTtcbiAgICAgICAgdGhpcy4jaWZhY2UgPSBpZmFjZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJlc29sdmVzIG9uY2UgdGhpcyB0cmFuc2FjdGlvbiBoYXMgYmVlbiBtaW5lZCBhbmQgaGFzXG4gICAgICogICUlY29uZmlybXMlJSBibG9ja3MgaW5jbHVkaW5nIGl0IChkZWZhdWx0OiBgYDFgYCkgd2l0aCBhblxuICAgICAqICBvcHRpb25hbCAlJXRpbWVvdXQlJS5cbiAgICAgKlxuICAgICAqICBUaGlzIGNhbiByZXNvbHZlIHRvIGBgbnVsbGBgIG9ubHkgaWYgJSVjb25maXJtcyUlIGlzIGBgMGBgXG4gICAgICogIGFuZCB0aGUgdHJhbnNhY3Rpb24gaGFzIG5vdCBiZWVuIG1pbmVkLCBvdGhlcndpc2UgdGhpcyB3aWxsXG4gICAgICogIHdhaXQgdW50aWwgZW5vdWdoIGNvbmZpcm1hdGlvbnMgaGF2ZSBjb21wbGV0ZWQuXG4gICAgICovXG4gICAgYXN5bmMgd2FpdChjb25maXJtcywgdGltZW91dCkge1xuICAgICAgICBjb25zdCByZWNlaXB0ID0gYXdhaXQgc3VwZXIud2FpdChjb25maXJtcywgdGltZW91dCk7XG4gICAgICAgIGlmIChyZWNlaXB0ID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgQ29udHJhY3RUcmFuc2FjdGlvblJlY2VpcHQodGhpcy4jaWZhY2UsIHRoaXMucHJvdmlkZXIsIHJlY2VpcHQpO1xuICAgIH1cbn1cbi8qKlxuICogIEEgKipDb250cmFjdFVua25vd25FdmVudFBheWxvYWQqKiBpcyBpbmNsdWRlZCBhcyB0aGUgbGFzdCBwYXJhbWV0ZXIgdG9cbiAqICBDb250cmFjdCBFdmVudHMgd2hlbiB0aGUgZXZlbnQgZG9lcyBub3QgbWF0Y2ggYW55IGV2ZW50cyBpbiB0aGUgQUJJLlxuICovXG5leHBvcnQgY2xhc3MgQ29udHJhY3RVbmtub3duRXZlbnRQYXlsb2FkIGV4dGVuZHMgRXZlbnRQYXlsb2FkIHtcbiAgICAvKipcbiAgICAgKiAgVGhlIGxvZyB3aXRoIG5vIG1hdGNoaW5nIGV2ZW50cy5cbiAgICAgKi9cbiAgICBsb2c7XG4gICAgLyoqXG4gICAgICogIEBfZXZlbnQ6XG4gICAgICovXG4gICAgY29uc3RydWN0b3IoY29udHJhY3QsIGxpc3RlbmVyLCBmaWx0ZXIsIGxvZykge1xuICAgICAgICBzdXBlcihjb250cmFjdCwgbGlzdGVuZXIsIGZpbHRlcik7XG4gICAgICAgIGRlZmluZVByb3BlcnRpZXModGhpcywgeyBsb2cgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXNvbHZlcyB0byB0aGUgYmxvY2sgdGhlIGV2ZW50IG9jY3VyZWQgaW4uXG4gICAgICovXG4gICAgYXN5bmMgZ2V0QmxvY2soKSB7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmxvZy5nZXRCbG9jaygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmVzb2x2ZXMgdG8gdGhlIHRyYW5zYWN0aW9uIHRoZSBldmVudCBvY2N1cmVkIGluLlxuICAgICAqL1xuICAgIGFzeW5jIGdldFRyYW5zYWN0aW9uKCkge1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5sb2cuZ2V0VHJhbnNhY3Rpb24oKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJlc29sdmVzIHRvIHRoZSB0cmFuc2FjdGlvbiByZWNlaXB0IHRoZSBldmVudCBvY2N1cmVkIGluLlxuICAgICAqL1xuICAgIGFzeW5jIGdldFRyYW5zYWN0aW9uUmVjZWlwdCgpIHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMubG9nLmdldFRyYW5zYWN0aW9uUmVjZWlwdCgpO1xuICAgIH1cbn1cbi8qKlxuICogIEEgKipDb250cmFjdEV2ZW50UGF5bG9hZCoqIGlzIGluY2x1ZGVkIGFzIHRoZSBsYXN0IHBhcmFtZXRlciB0b1xuICogIENvbnRyYWN0IEV2ZW50cyB3aGVuIHRoZSBldmVudCBpcyBrbm93bi5cbiAqL1xuZXhwb3J0IGNsYXNzIENvbnRyYWN0RXZlbnRQYXlsb2FkIGV4dGVuZHMgQ29udHJhY3RVbmtub3duRXZlbnRQYXlsb2FkIHtcbiAgICAvKipcbiAgICAgKiAgQF9pZ25vcmU6XG4gICAgICovXG4gICAgY29uc3RydWN0b3IoY29udHJhY3QsIGxpc3RlbmVyLCBmaWx0ZXIsIGZyYWdtZW50LCBfbG9nKSB7XG4gICAgICAgIHN1cGVyKGNvbnRyYWN0LCBsaXN0ZW5lciwgZmlsdGVyLCBuZXcgRXZlbnRMb2coX2xvZywgY29udHJhY3QuaW50ZXJmYWNlLCBmcmFnbWVudCkpO1xuICAgICAgICBjb25zdCBhcmdzID0gY29udHJhY3QuaW50ZXJmYWNlLmRlY29kZUV2ZW50TG9nKGZyYWdtZW50LCB0aGlzLmxvZy5kYXRhLCB0aGlzLmxvZy50b3BpY3MpO1xuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHsgYXJncywgZnJhZ21lbnQgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgZXZlbnQgbmFtZS5cbiAgICAgKi9cbiAgICBnZXQgZXZlbnROYW1lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5mcmFnbWVudC5uYW1lO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhlIGV2ZW50IHNpZ25hdHVyZS5cbiAgICAgKi9cbiAgICBnZXQgZXZlbnRTaWduYXR1cmUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZyYWdtZW50LmZvcm1hdCgpO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXdyYXBwZXJzLmpzLm1hcCJdLCJuYW1lcyI6WyJMb2ciLCJUcmFuc2FjdGlvblJlY2VpcHQiLCJUcmFuc2FjdGlvblJlc3BvbnNlIiwiZGVmaW5lUHJvcGVydGllcyIsIkV2ZW50UGF5bG9hZCIsIkV2ZW50TG9nIiwiY29uc3RydWN0b3IiLCJsb2ciLCJpZmFjZSIsImZyYWdtZW50IiwicHJvdmlkZXIiLCJhcmdzIiwiZGVjb2RlRXZlbnRMb2ciLCJkYXRhIiwidG9waWNzIiwiaW50ZXJmYWNlIiwiZXZlbnROYW1lIiwibmFtZSIsImV2ZW50U2lnbmF0dXJlIiwiZm9ybWF0IiwiVW5kZWNvZGVkRXZlbnRMb2ciLCJlcnJvciIsIkNvbnRyYWN0VHJhbnNhY3Rpb25SZWNlaXB0IiwidHgiLCJsb2dzIiwibWFwIiwibGVuZ3RoIiwiZ2V0RXZlbnQiLCJDb250cmFjdFRyYW5zYWN0aW9uUmVzcG9uc2UiLCJ3YWl0IiwiY29uZmlybXMiLCJ0aW1lb3V0IiwicmVjZWlwdCIsIkNvbnRyYWN0VW5rbm93bkV2ZW50UGF5bG9hZCIsImNvbnRyYWN0IiwibGlzdGVuZXIiLCJmaWx0ZXIiLCJnZXRCbG9jayIsImdldFRyYW5zYWN0aW9uIiwiZ2V0VHJhbnNhY3Rpb25SZWNlaXB0IiwiQ29udHJhY3RFdmVudFBheWxvYWQiLCJfbG9nIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.esm/contract/wrappers.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.esm/crypto/keccak.js":
/*!******************************************************!*\
  !*** ./node_modules/ethers/lib.esm/crypto/keccak.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   keccak256: () => (/* binding */ keccak256)\n/* harmony export */ });\n/* harmony import */ var _noble_hashes_sha3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @noble/hashes/sha3 */ \"(ssr)/./node_modules/@noble/hashes/esm/sha3.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/data.js\");\n/**\n *  Cryptographic hashing functions\n *\n *  @_subsection: api/crypto:Hash Functions [about-crypto-hashing]\n */ \n\nlet locked = false;\nconst _keccak256 = function(data) {\n    return (0,_noble_hashes_sha3__WEBPACK_IMPORTED_MODULE_0__.keccak_256)(data);\n};\nlet __keccak256 = _keccak256;\n/**\n *  Compute the cryptographic KECCAK256 hash of %%data%%.\n *\n *  The %%data%% **must** be a data representation, to compute the\n *  hash of UTF-8 data use the [[id]] function.\n *\n *  @returns DataHexstring\n *  @example:\n *    keccak256(\"0x\")\n *    //_result:\n *\n *    keccak256(\"0x1337\")\n *    //_result:\n *\n *    keccak256(new Uint8Array([ 0x13, 0x37 ]))\n *    //_result:\n *\n *    // Strings are assumed to be DataHexString, otherwise it will\n *    // throw. To hash UTF-8 data, see the note above.\n *    keccak256(\"Hello World\")\n *    //_error:\n */ function keccak256(_data) {\n    const data = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.getBytes)(_data, \"data\");\n    return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.hexlify)(__keccak256(data));\n}\nkeccak256._ = _keccak256;\nkeccak256.lock = function() {\n    locked = true;\n};\nkeccak256.register = function(func) {\n    if (locked) {\n        throw new TypeError(\"keccak256 is locked\");\n    }\n    __keccak256 = func;\n};\nObject.freeze(keccak256); //# sourceMappingURL=keccak.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vY3J5cHRvL2tlY2Nhay5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTs7OztDQUlDLEdBQytDO0FBQ007QUFDdEQsSUFBSUcsU0FBUztBQUNiLE1BQU1DLGFBQWEsU0FBVUMsSUFBSTtJQUM3QixPQUFPTCw4REFBVUEsQ0FBQ0s7QUFDdEI7QUFDQSxJQUFJQyxjQUFjRjtBQUNsQjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBcUJDLEdBQ00sU0FBU0csVUFBVUMsS0FBSztJQUMzQixNQUFNSCxPQUFPSix5REFBUUEsQ0FBQ08sT0FBTztJQUM3QixPQUFPTix3REFBT0EsQ0FBQ0ksWUFBWUQ7QUFDL0I7QUFDQUUsVUFBVUUsQ0FBQyxHQUFHTDtBQUNkRyxVQUFVRyxJQUFJLEdBQUc7SUFBY1AsU0FBUztBQUFNO0FBQzlDSSxVQUFVSSxRQUFRLEdBQUcsU0FBVUMsSUFBSTtJQUMvQixJQUFJVCxRQUFRO1FBQ1IsTUFBTSxJQUFJVSxVQUFVO0lBQ3hCO0lBQ0FQLGNBQWNNO0FBQ2xCO0FBQ0FFLE9BQU9DLE1BQU0sQ0FBQ1IsWUFDZCxrQ0FBa0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tZWdhdmliZS1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9jcnlwdG8va2VjY2FrLmpzPzEzODEiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiAgQ3J5cHRvZ3JhcGhpYyBoYXNoaW5nIGZ1bmN0aW9uc1xuICpcbiAqICBAX3N1YnNlY3Rpb246IGFwaS9jcnlwdG86SGFzaCBGdW5jdGlvbnMgW2Fib3V0LWNyeXB0by1oYXNoaW5nXVxuICovXG5pbXBvcnQgeyBrZWNjYWtfMjU2IH0gZnJvbSBcIkBub2JsZS9oYXNoZXMvc2hhM1wiO1xuaW1wb3J0IHsgZ2V0Qnl0ZXMsIGhleGxpZnkgfSBmcm9tIFwiLi4vdXRpbHMvaW5kZXguanNcIjtcbmxldCBsb2NrZWQgPSBmYWxzZTtcbmNvbnN0IF9rZWNjYWsyNTYgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHJldHVybiBrZWNjYWtfMjU2KGRhdGEpO1xufTtcbmxldCBfX2tlY2NhazI1NiA9IF9rZWNjYWsyNTY7XG4vKipcbiAqICBDb21wdXRlIHRoZSBjcnlwdG9ncmFwaGljIEtFQ0NBSzI1NiBoYXNoIG9mICUlZGF0YSUlLlxuICpcbiAqICBUaGUgJSVkYXRhJSUgKiptdXN0KiogYmUgYSBkYXRhIHJlcHJlc2VudGF0aW9uLCB0byBjb21wdXRlIHRoZVxuICogIGhhc2ggb2YgVVRGLTggZGF0YSB1c2UgdGhlIFtbaWRdXSBmdW5jdGlvbi5cbiAqXG4gKiAgQHJldHVybnMgRGF0YUhleHN0cmluZ1xuICogIEBleGFtcGxlOlxuICogICAga2VjY2FrMjU2KFwiMHhcIilcbiAqICAgIC8vX3Jlc3VsdDpcbiAqXG4gKiAgICBrZWNjYWsyNTYoXCIweDEzMzdcIilcbiAqICAgIC8vX3Jlc3VsdDpcbiAqXG4gKiAgICBrZWNjYWsyNTYobmV3IFVpbnQ4QXJyYXkoWyAweDEzLCAweDM3IF0pKVxuICogICAgLy9fcmVzdWx0OlxuICpcbiAqICAgIC8vIFN0cmluZ3MgYXJlIGFzc3VtZWQgdG8gYmUgRGF0YUhleFN0cmluZywgb3RoZXJ3aXNlIGl0IHdpbGxcbiAqICAgIC8vIHRocm93LiBUbyBoYXNoIFVURi04IGRhdGEsIHNlZSB0aGUgbm90ZSBhYm92ZS5cbiAqICAgIGtlY2NhazI1NihcIkhlbGxvIFdvcmxkXCIpXG4gKiAgICAvL19lcnJvcjpcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGtlY2NhazI1NihfZGF0YSkge1xuICAgIGNvbnN0IGRhdGEgPSBnZXRCeXRlcyhfZGF0YSwgXCJkYXRhXCIpO1xuICAgIHJldHVybiBoZXhsaWZ5KF9fa2VjY2FrMjU2KGRhdGEpKTtcbn1cbmtlY2NhazI1Ni5fID0gX2tlY2NhazI1NjtcbmtlY2NhazI1Ni5sb2NrID0gZnVuY3Rpb24gKCkgeyBsb2NrZWQgPSB0cnVlOyB9O1xua2VjY2FrMjU2LnJlZ2lzdGVyID0gZnVuY3Rpb24gKGZ1bmMpIHtcbiAgICBpZiAobG9ja2VkKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJrZWNjYWsyNTYgaXMgbG9ja2VkXCIpO1xuICAgIH1cbiAgICBfX2tlY2NhazI1NiA9IGZ1bmM7XG59O1xuT2JqZWN0LmZyZWV6ZShrZWNjYWsyNTYpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9a2VjY2FrLmpzLm1hcCJdLCJuYW1lcyI6WyJrZWNjYWtfMjU2IiwiZ2V0Qnl0ZXMiLCJoZXhsaWZ5IiwibG9ja2VkIiwiX2tlY2NhazI1NiIsImRhdGEiLCJfX2tlY2NhazI1NiIsImtlY2NhazI1NiIsIl9kYXRhIiwiXyIsImxvY2siLCJyZWdpc3RlciIsImZ1bmMiLCJUeXBlRXJyb3IiLCJPYmplY3QiLCJmcmVlemUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.esm/crypto/keccak.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.esm/crypto/sha2.js":
/*!****************************************************!*\
  !*** ./node_modules/ethers/lib.esm/crypto/sha2.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   sha256: () => (/* binding */ sha256),\n/* harmony export */   sha512: () => (/* binding */ sha512)\n/* harmony export */ });\n/* harmony import */ var _crypto_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./crypto.js */ \"crypto\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/data.js\");\n\n\nconst _sha256 = function(data) {\n    return (0,_crypto_js__WEBPACK_IMPORTED_MODULE_0__.createHash)(\"sha256\").update(data).digest();\n};\nconst _sha512 = function(data) {\n    return (0,_crypto_js__WEBPACK_IMPORTED_MODULE_0__.createHash)(\"sha512\").update(data).digest();\n};\nlet __sha256 = _sha256;\nlet __sha512 = _sha512;\nlet locked256 = false, locked512 = false;\n/**\n *  Compute the cryptographic SHA2-256 hash of %%data%%.\n *\n *  @_docloc: api/crypto:Hash Functions\n *  @returns DataHexstring\n *\n *  @example:\n *    sha256(\"0x\")\n *    //_result:\n *\n *    sha256(\"0x1337\")\n *    //_result:\n *\n *    sha256(new Uint8Array([ 0x13, 0x37 ]))\n *    //_result:\n *\n */ function sha256(_data) {\n    const data = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.getBytes)(_data, \"data\");\n    return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.hexlify)(__sha256(data));\n}\nsha256._ = _sha256;\nsha256.lock = function() {\n    locked256 = true;\n};\nsha256.register = function(func) {\n    if (locked256) {\n        throw new Error(\"sha256 is locked\");\n    }\n    __sha256 = func;\n};\nObject.freeze(sha256);\n/**\n *  Compute the cryptographic SHA2-512 hash of %%data%%.\n *\n *  @_docloc: api/crypto:Hash Functions\n *  @returns DataHexstring\n *\n *  @example:\n *    sha512(\"0x\")\n *    //_result:\n *\n *    sha512(\"0x1337\")\n *    //_result:\n *\n *    sha512(new Uint8Array([ 0x13, 0x37 ]))\n *    //_result:\n */ function sha512(_data) {\n    const data = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.getBytes)(_data, \"data\");\n    return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.hexlify)(__sha512(data));\n}\nsha512._ = _sha512;\nsha512.lock = function() {\n    locked512 = true;\n};\nsha512.register = function(func) {\n    if (locked512) {\n        throw new Error(\"sha512 is locked\");\n    }\n    __sha512 = func;\n};\nObject.freeze(sha256); //# sourceMappingURL=sha2.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vY3J5cHRvL3NoYTIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUF5QztBQUNhO0FBQ3RELE1BQU1HLFVBQVUsU0FBVUMsSUFBSTtJQUMxQixPQUFPSixzREFBVUEsQ0FBQyxVQUFVSyxNQUFNLENBQUNELE1BQU1FLE1BQU07QUFDbkQ7QUFDQSxNQUFNQyxVQUFVLFNBQVVILElBQUk7SUFDMUIsT0FBT0osc0RBQVVBLENBQUMsVUFBVUssTUFBTSxDQUFDRCxNQUFNRSxNQUFNO0FBQ25EO0FBQ0EsSUFBSUUsV0FBV0w7QUFDZixJQUFJTSxXQUFXRjtBQUNmLElBQUlHLFlBQVksT0FBT0MsWUFBWTtBQUNuQzs7Ozs7Ozs7Ozs7Ozs7OztDQWdCQyxHQUNNLFNBQVNDLE9BQU9DLEtBQUs7SUFDeEIsTUFBTVQsT0FBT0gseURBQVFBLENBQUNZLE9BQU87SUFDN0IsT0FBT1gsd0RBQU9BLENBQUNNLFNBQVNKO0FBQzVCO0FBQ0FRLE9BQU9FLENBQUMsR0FBR1g7QUFDWFMsT0FBT0csSUFBSSxHQUFHO0lBQWNMLFlBQVk7QUFBTTtBQUM5Q0UsT0FBT0ksUUFBUSxHQUFHLFNBQVVDLElBQUk7SUFDNUIsSUFBSVAsV0FBVztRQUNYLE1BQU0sSUFBSVEsTUFBTTtJQUNwQjtJQUNBVixXQUFXUztBQUNmO0FBQ0FFLE9BQU9DLE1BQU0sQ0FBQ1I7QUFDZDs7Ozs7Ozs7Ozs7Ozs7O0NBZUMsR0FDTSxTQUFTUyxPQUFPUixLQUFLO0lBQ3hCLE1BQU1ULE9BQU9ILHlEQUFRQSxDQUFDWSxPQUFPO0lBQzdCLE9BQU9YLHdEQUFPQSxDQUFDTyxTQUFTTDtBQUM1QjtBQUNBaUIsT0FBT1AsQ0FBQyxHQUFHUDtBQUNYYyxPQUFPTixJQUFJLEdBQUc7SUFBY0osWUFBWTtBQUFNO0FBQzlDVSxPQUFPTCxRQUFRLEdBQUcsU0FBVUMsSUFBSTtJQUM1QixJQUFJTixXQUFXO1FBQ1gsTUFBTSxJQUFJTyxNQUFNO0lBQ3BCO0lBQ0FULFdBQVdRO0FBQ2Y7QUFDQUUsT0FBT0MsTUFBTSxDQUFDUixTQUNkLGdDQUFnQyIsInNvdXJjZXMiOlsid2VicGFjazovL21lZ2F2aWJlLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL2NyeXB0by9zaGEyLmpzPzJmNWMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgY3JlYXRlSGFzaCB9IGZyb20gXCIuL2NyeXB0by5qc1wiO1xuaW1wb3J0IHsgZ2V0Qnl0ZXMsIGhleGxpZnkgfSBmcm9tIFwiLi4vdXRpbHMvaW5kZXguanNcIjtcbmNvbnN0IF9zaGEyNTYgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHJldHVybiBjcmVhdGVIYXNoKFwic2hhMjU2XCIpLnVwZGF0ZShkYXRhKS5kaWdlc3QoKTtcbn07XG5jb25zdCBfc2hhNTEyID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICByZXR1cm4gY3JlYXRlSGFzaChcInNoYTUxMlwiKS51cGRhdGUoZGF0YSkuZGlnZXN0KCk7XG59O1xubGV0IF9fc2hhMjU2ID0gX3NoYTI1NjtcbmxldCBfX3NoYTUxMiA9IF9zaGE1MTI7XG5sZXQgbG9ja2VkMjU2ID0gZmFsc2UsIGxvY2tlZDUxMiA9IGZhbHNlO1xuLyoqXG4gKiAgQ29tcHV0ZSB0aGUgY3J5cHRvZ3JhcGhpYyBTSEEyLTI1NiBoYXNoIG9mICUlZGF0YSUlLlxuICpcbiAqICBAX2RvY2xvYzogYXBpL2NyeXB0bzpIYXNoIEZ1bmN0aW9uc1xuICogIEByZXR1cm5zIERhdGFIZXhzdHJpbmdcbiAqXG4gKiAgQGV4YW1wbGU6XG4gKiAgICBzaGEyNTYoXCIweFwiKVxuICogICAgLy9fcmVzdWx0OlxuICpcbiAqICAgIHNoYTI1NihcIjB4MTMzN1wiKVxuICogICAgLy9fcmVzdWx0OlxuICpcbiAqICAgIHNoYTI1NihuZXcgVWludDhBcnJheShbIDB4MTMsIDB4MzcgXSkpXG4gKiAgICAvL19yZXN1bHQ6XG4gKlxuICovXG5leHBvcnQgZnVuY3Rpb24gc2hhMjU2KF9kYXRhKSB7XG4gICAgY29uc3QgZGF0YSA9IGdldEJ5dGVzKF9kYXRhLCBcImRhdGFcIik7XG4gICAgcmV0dXJuIGhleGxpZnkoX19zaGEyNTYoZGF0YSkpO1xufVxuc2hhMjU2Ll8gPSBfc2hhMjU2O1xuc2hhMjU2LmxvY2sgPSBmdW5jdGlvbiAoKSB7IGxvY2tlZDI1NiA9IHRydWU7IH07XG5zaGEyNTYucmVnaXN0ZXIgPSBmdW5jdGlvbiAoZnVuYykge1xuICAgIGlmIChsb2NrZWQyNTYpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwic2hhMjU2IGlzIGxvY2tlZFwiKTtcbiAgICB9XG4gICAgX19zaGEyNTYgPSBmdW5jO1xufTtcbk9iamVjdC5mcmVlemUoc2hhMjU2KTtcbi8qKlxuICogIENvbXB1dGUgdGhlIGNyeXB0b2dyYXBoaWMgU0hBMi01MTIgaGFzaCBvZiAlJWRhdGElJS5cbiAqXG4gKiAgQF9kb2Nsb2M6IGFwaS9jcnlwdG86SGFzaCBGdW5jdGlvbnNcbiAqICBAcmV0dXJucyBEYXRhSGV4c3RyaW5nXG4gKlxuICogIEBleGFtcGxlOlxuICogICAgc2hhNTEyKFwiMHhcIilcbiAqICAgIC8vX3Jlc3VsdDpcbiAqXG4gKiAgICBzaGE1MTIoXCIweDEzMzdcIilcbiAqICAgIC8vX3Jlc3VsdDpcbiAqXG4gKiAgICBzaGE1MTIobmV3IFVpbnQ4QXJyYXkoWyAweDEzLCAweDM3IF0pKVxuICogICAgLy9fcmVzdWx0OlxuICovXG5leHBvcnQgZnVuY3Rpb24gc2hhNTEyKF9kYXRhKSB7XG4gICAgY29uc3QgZGF0YSA9IGdldEJ5dGVzKF9kYXRhLCBcImRhdGFcIik7XG4gICAgcmV0dXJuIGhleGxpZnkoX19zaGE1MTIoZGF0YSkpO1xufVxuc2hhNTEyLl8gPSBfc2hhNTEyO1xuc2hhNTEyLmxvY2sgPSBmdW5jdGlvbiAoKSB7IGxvY2tlZDUxMiA9IHRydWU7IH07XG5zaGE1MTIucmVnaXN0ZXIgPSBmdW5jdGlvbiAoZnVuYykge1xuICAgIGlmIChsb2NrZWQ1MTIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwic2hhNTEyIGlzIGxvY2tlZFwiKTtcbiAgICB9XG4gICAgX19zaGE1MTIgPSBmdW5jO1xufTtcbk9iamVjdC5mcmVlemUoc2hhMjU2KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNoYTIuanMubWFwIl0sIm5hbWVzIjpbImNyZWF0ZUhhc2giLCJnZXRCeXRlcyIsImhleGxpZnkiLCJfc2hhMjU2IiwiZGF0YSIsInVwZGF0ZSIsImRpZ2VzdCIsIl9zaGE1MTIiLCJfX3NoYTI1NiIsIl9fc2hhNTEyIiwibG9ja2VkMjU2IiwibG9ja2VkNTEyIiwic2hhMjU2IiwiX2RhdGEiLCJfIiwibG9jayIsInJlZ2lzdGVyIiwiZnVuYyIsIkVycm9yIiwiT2JqZWN0IiwiZnJlZXplIiwic2hhNTEyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.esm/crypto/sha2.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.esm/crypto/signature.js":
/*!*********************************************************!*\
  !*** ./node_modules/ethers/lib.esm/crypto/signature.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Signature: () => (/* binding */ Signature)\n/* harmony export */ });\n/* harmony import */ var _constants_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../constants/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/constants/hashes.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/data.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/maths.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/errors.js\");\n\n\n// Constants\nconst BN_0 = BigInt(0);\nconst BN_1 = BigInt(1);\nconst BN_2 = BigInt(2);\nconst BN_27 = BigInt(27);\nconst BN_28 = BigInt(28);\nconst BN_35 = BigInt(35);\nconst _guard = {};\nfunction toUint256(value) {\n    return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.zeroPadValue)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.toBeArray)(value), 32);\n}\n/**\n *  A Signature  @TODO\n *\n *\n *  @_docloc: api/crypto:Signing\n */ class Signature {\n    #r;\n    #s;\n    #v;\n    #networkV;\n    /**\n     *  The ``r`` value for a signature.\n     *\n     *  This represents the ``x`` coordinate of a \"reference\" or\n     *  challenge point, from which the ``y`` can be computed.\n     */ get r() {\n        return this.#r;\n    }\n    set r(value) {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.dataLength)(value) === 32, \"invalid r\", \"value\", value);\n        this.#r = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(value);\n    }\n    /**\n     *  The ``s`` value for a signature.\n     */ get s() {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(parseInt(this.#s.substring(0, 3)) < 8, \"non-canonical s; use ._s\", \"s\", this.#s);\n        return this.#s;\n    }\n    set s(_value) {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.dataLength)(_value) === 32, \"invalid s\", \"value\", _value);\n        this.#s = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(_value);\n    }\n    /**\n     *  Return the s value, unchecked for EIP-2 compliance.\n     *\n     *  This should generally not be used and is for situations where\n     *  a non-canonical S value might be relevant, such as Frontier blocks\n     *  that were mined prior to EIP-2 or invalid Authorization List\n     *  signatures.\n     */ get _s() {\n        return this.#s;\n    }\n    /**\n     *  Returns true if the Signature is valid for [[link-eip-2]] signatures.\n     */ isValid() {\n        return parseInt(this.#s.substring(0, 3)) < 8;\n    }\n    /**\n     *  The ``v`` value for a signature.\n     *\n     *  Since a given ``x`` value for ``r`` has two possible values for\n     *  its correspondin ``y``, the ``v`` indicates which of the two ``y``\n     *  values to use.\n     *\n     *  It is normalized to the values ``27`` or ``28`` for legacy\n     *  purposes.\n     */ get v() {\n        return this.#v;\n    }\n    set v(value) {\n        const v = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.getNumber)(value, \"value\");\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(v === 27 || v === 28, \"invalid v\", \"v\", value);\n        this.#v = v;\n    }\n    /**\n     *  The EIP-155 ``v`` for legacy transactions. For non-legacy\n     *  transactions, this value is ``null``.\n     */ get networkV() {\n        return this.#networkV;\n    }\n    /**\n     *  The chain ID for EIP-155 legacy transactions. For non-legacy\n     *  transactions, this value is ``null``.\n     */ get legacyChainId() {\n        const v = this.networkV;\n        if (v == null) {\n            return null;\n        }\n        return Signature.getChainId(v);\n    }\n    /**\n     *  The ``yParity`` for the signature.\n     *\n     *  See ``v`` for more details on how this value is used.\n     */ get yParity() {\n        return this.v === 27 ? 0 : 1;\n    }\n    /**\n     *  The [[link-eip-2098]] compact representation of the ``yParity``\n     *  and ``s`` compacted into a single ``bytes32``.\n     */ get yParityAndS() {\n        // The EIP-2098 compact representation\n        const yParityAndS = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBytes)(this.s);\n        if (this.yParity) {\n            yParityAndS[0] |= 0x80;\n        }\n        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(yParityAndS);\n    }\n    /**\n     *  The [[link-eip-2098]] compact representation.\n     */ get compactSerialized() {\n        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.concat)([\n            this.r,\n            this.yParityAndS\n        ]);\n    }\n    /**\n     *  The serialized representation.\n     */ get serialized() {\n        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.concat)([\n            this.r,\n            this.s,\n            this.yParity ? \"0x1c\" : \"0x1b\"\n        ]);\n    }\n    /**\n     *  @private\n     */ constructor(guard, r, s, v){\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertPrivate)(guard, _guard, \"Signature\");\n        this.#r = r;\n        this.#s = s;\n        this.#v = v;\n        this.#networkV = null;\n    }\n    [Symbol.for(\"nodejs.util.inspect.custom\")]() {\n        return `Signature { r: \"${this.r}\", s: \"${this._s}\"${this.isValid() ? \"\" : ', valid: \"false\"'}, yParity: ${this.yParity}, networkV: ${this.networkV} }`;\n    }\n    /**\n     *  Returns a new identical [[Signature]].\n     */ clone() {\n        const clone = new Signature(_guard, this.r, this._s, this.v);\n        if (this.networkV) {\n            clone.#networkV = this.networkV;\n        }\n        return clone;\n    }\n    /**\n     *  Returns a representation that is compatible with ``JSON.stringify``.\n     */ toJSON() {\n        const networkV = this.networkV;\n        return {\n            _type: \"signature\",\n            networkV: networkV != null ? networkV.toString() : null,\n            r: this.r,\n            s: this._s,\n            v: this.v\n        };\n    }\n    /**\n     *  Compute the chain ID from the ``v`` in a legacy EIP-155 transactions.\n     *\n     *  @example:\n     *    Signature.getChainId(45)\n     *    //_result:\n     *\n     *    Signature.getChainId(46)\n     *    //_result:\n     */ static getChainId(v) {\n        const bv = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.getBigInt)(v, \"v\");\n        // The v is not an EIP-155 v, so it is the unspecified chain ID\n        if (bv == BN_27 || bv == BN_28) {\n            return BN_0;\n        }\n        // Bad value for an EIP-155 v\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(bv >= BN_35, \"invalid EIP-155 v\", \"v\", v);\n        return (bv - BN_35) / BN_2;\n    }\n    /**\n     *  Compute the ``v`` for a chain ID for a legacy EIP-155 transactions.\n     *\n     *  Legacy transactions which use [[link-eip-155]] hijack the ``v``\n     *  property to include the chain ID.\n     *\n     *  @example:\n     *    Signature.getChainIdV(5, 27)\n     *    //_result:\n     *\n     *    Signature.getChainIdV(5, 28)\n     *    //_result:\n     *\n     */ static getChainIdV(chainId, v) {\n        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.getBigInt)(chainId) * BN_2 + BigInt(35 + v - 27);\n    }\n    /**\n     *  Compute the normalized legacy transaction ``v`` from a ``yParirty``,\n     *  a legacy transaction ``v`` or a legacy [[link-eip-155]] transaction.\n     *\n     *  @example:\n     *    // The values 0 and 1 imply v is actually yParity\n     *    Signature.getNormalizedV(0)\n     *    //_result:\n     *\n     *    // Legacy non-EIP-1559 transaction (i.e. 27 or 28)\n     *    Signature.getNormalizedV(27)\n     *    //_result:\n     *\n     *    // Legacy EIP-155 transaction (i.e. >= 35)\n     *    Signature.getNormalizedV(46)\n     *    //_result:\n     *\n     *    // Invalid values throw\n     *    Signature.getNormalizedV(5)\n     *    //_error:\n     */ static getNormalizedV(v) {\n        const bv = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.getBigInt)(v);\n        if (bv === BN_0 || bv === BN_27) {\n            return 27;\n        }\n        if (bv === BN_1 || bv === BN_28) {\n            return 28;\n        }\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(bv >= BN_35, \"invalid v\", \"v\", v);\n        // Otherwise, EIP-155 v means odd is 27 and even is 28\n        return bv & BN_1 ? 27 : 28;\n    }\n    /**\n     *  Creates a new [[Signature]].\n     *\n     *  If no %%sig%% is provided, a new [[Signature]] is created\n     *  with default values.\n     *\n     *  If %%sig%% is a string, it is parsed.\n     */ static from(sig) {\n        function assertError(check, message) {\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(check, message, \"signature\", sig);\n        }\n        ;\n        if (sig == null) {\n            return new Signature(_guard, _constants_index_js__WEBPACK_IMPORTED_MODULE_3__.ZeroHash, _constants_index_js__WEBPACK_IMPORTED_MODULE_3__.ZeroHash, 27);\n        }\n        if (typeof sig === \"string\") {\n            const bytes = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBytes)(sig, \"signature\");\n            if (bytes.length === 64) {\n                const r = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(bytes.slice(0, 32));\n                const s = bytes.slice(32, 64);\n                const v = s[0] & 0x80 ? 28 : 27;\n                s[0] &= 0x7f;\n                return new Signature(_guard, r, (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(s), v);\n            }\n            if (bytes.length === 65) {\n                const r = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(bytes.slice(0, 32));\n                const s = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(bytes.slice(32, 64));\n                const v = Signature.getNormalizedV(bytes[64]);\n                return new Signature(_guard, r, s, v);\n            }\n            assertError(false, \"invalid raw signature length\");\n        }\n        if (sig instanceof Signature) {\n            return sig.clone();\n        }\n        // Get r\n        const _r = sig.r;\n        assertError(_r != null, \"missing r\");\n        const r = toUint256(_r);\n        // Get s; by any means necessary (we check consistency below)\n        const s = function(s, yParityAndS) {\n            if (s != null) {\n                return toUint256(s);\n            }\n            if (yParityAndS != null) {\n                assertError((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.isHexString)(yParityAndS, 32), \"invalid yParityAndS\");\n                const bytes = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBytes)(yParityAndS);\n                bytes[0] &= 0x7f;\n                return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(bytes);\n            }\n            assertError(false, \"missing s\");\n        }(sig.s, sig.yParityAndS);\n        // Get v; by any means necessary (we check consistency below)\n        const { networkV, v } = function(_v, yParityAndS, yParity) {\n            if (_v != null) {\n                const v = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.getBigInt)(_v);\n                return {\n                    networkV: v >= BN_35 ? v : undefined,\n                    v: Signature.getNormalizedV(v)\n                };\n            }\n            if (yParityAndS != null) {\n                assertError((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.isHexString)(yParityAndS, 32), \"invalid yParityAndS\");\n                return {\n                    v: (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBytes)(yParityAndS)[0] & 0x80 ? 28 : 27\n                };\n            }\n            if (yParity != null) {\n                switch((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.getNumber)(yParity, \"sig.yParity\")){\n                    case 0:\n                        return {\n                            v: 27\n                        };\n                    case 1:\n                        return {\n                            v: 28\n                        };\n                }\n                assertError(false, \"invalid yParity\");\n            }\n            assertError(false, \"missing v\");\n        }(sig.v, sig.yParityAndS, sig.yParity);\n        const result = new Signature(_guard, r, s, v);\n        if (networkV) {\n            result.#networkV = networkV;\n        }\n        // If multiple of v, yParity, yParityAndS we given, check they match\n        assertError(sig.yParity == null || (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.getNumber)(sig.yParity, \"sig.yParity\") === result.yParity, \"yParity mismatch\");\n        assertError(sig.yParityAndS == null || sig.yParityAndS === result.yParityAndS, \"yParityAndS mismatch\");\n        return result;\n    }\n} //# sourceMappingURL=signature.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vY3J5cHRvL3NpZ25hdHVyZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFpRDtBQUNvSDtBQUNySyxZQUFZO0FBQ1osTUFBTVksT0FBT0MsT0FBTztBQUNwQixNQUFNQyxPQUFPRCxPQUFPO0FBQ3BCLE1BQU1FLE9BQU9GLE9BQU87QUFDcEIsTUFBTUcsUUFBUUgsT0FBTztBQUNyQixNQUFNSSxRQUFRSixPQUFPO0FBQ3JCLE1BQU1LLFFBQVFMLE9BQU87QUFDckIsTUFBTU0sU0FBUyxDQUFDO0FBQ2hCLFNBQVNDLFVBQVVDLEtBQUs7SUFDcEIsT0FBT1osNkRBQVlBLENBQUNGLDBEQUFTQSxDQUFDYyxRQUFRO0FBQzFDO0FBQ0E7Ozs7O0NBS0MsR0FDTSxNQUFNQztJQUNULENBQUNDLENBQUMsQ0FBQztJQUNILENBQUNDLENBQUMsQ0FBQztJQUNILENBQUNDLENBQUMsQ0FBQztJQUNILENBQUNDLFFBQVEsQ0FBQztJQUNWOzs7OztLQUtDLEdBQ0QsSUFBSUgsSUFBSTtRQUFFLE9BQU8sSUFBSSxDQUFDLENBQUNBLENBQUM7SUFBRTtJQUMxQixJQUFJQSxFQUFFRixLQUFLLEVBQUU7UUFDVFgsK0RBQWNBLENBQUNSLDJEQUFVQSxDQUFDbUIsV0FBVyxJQUFJLGFBQWEsU0FBU0E7UUFDL0QsSUFBSSxDQUFDLENBQUNFLENBQUMsR0FBR2pCLHdEQUFPQSxDQUFDZTtJQUN0QjtJQUNBOztLQUVDLEdBQ0QsSUFBSUcsSUFBSTtRQUNKZCwrREFBY0EsQ0FBQ2lCLFNBQVMsSUFBSSxDQUFDLENBQUNILENBQUMsQ0FBQ0ksU0FBUyxDQUFDLEdBQUcsTUFBTSxHQUFHLDRCQUE0QixLQUFLLElBQUksQ0FBQyxDQUFDSixDQUFDO1FBQzlGLE9BQU8sSUFBSSxDQUFDLENBQUNBLENBQUM7SUFDbEI7SUFDQSxJQUFJQSxFQUFFSyxNQUFNLEVBQUU7UUFDVm5CLCtEQUFjQSxDQUFDUiwyREFBVUEsQ0FBQzJCLFlB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QzNCO2dCQUNBMkIsWUFBWSxPQUFPO1lBQ3ZCO1lBQ0FBLFlBQVksT0FBTztRQUN2QixFQUFHRCxJQUFJMUIsQ0FBQyxFQUFFMEIsSUFBSWhCLFdBQVcsRUFBRWdCLElBQUlqQixPQUFPO1FBQ3RDLE1BQU0yQixTQUFTLElBQUl2QyxVQUFVSCxRQUFRSSxHQUFHQyxHQUFHQztRQUMzQyxJQUFJQyxVQUFVO1lBQ1ZtQyxPQUFPLENBQUNuQyxRQUFRLEdBQUdBO1FBQ3ZCO1FBQ0Esb0VBQW9FO1FBQ3BFMEIsWUFBWUQsSUFBSWpCLE9BQU8sSUFBSSxRQUFRN0IsMERBQVNBLENBQUM4QyxJQUFJakIsT0FBTyxFQUFFLG1CQUFtQjJCLE9BQU8zQixPQUFPLEVBQUU7UUFDN0ZrQixZQUFZRCxJQUFJaEIsV0FBVyxJQUFJLFFBQVFnQixJQUFJaEIsV0FBVyxLQUFLMEIsT0FBTzFCLFdBQVcsRUFBRTtRQUMvRSxPQUFPMEI7SUFDWDtBQUNKLEVBQ0EscUNBQXFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbWVnYXZpYmUtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vY3J5cHRvL3NpZ25hdHVyZS5qcz9jMDE0Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFplcm9IYXNoIH0gZnJvbSBcIi4uL2NvbnN0YW50cy9pbmRleC5qc1wiO1xuaW1wb3J0IHsgY29uY2F0LCBkYXRhTGVuZ3RoLCBnZXRCaWdJbnQsIGdldEJ5dGVzLCBnZXROdW1iZXIsIGhleGxpZnksIHRvQmVBcnJheSwgaXNIZXhTdHJpbmcsIHplcm9QYWRWYWx1ZSwgYXNzZXJ0QXJndW1lbnQsIGFzc2VydFByaXZhdGUgfSBmcm9tIFwiLi4vdXRpbHMvaW5kZXguanNcIjtcbi8vIENvbnN0YW50c1xuY29uc3QgQk5fMCA9IEJpZ0ludCgwKTtcbmNvbnN0IEJOXzEgPSBCaWdJbnQoMSk7XG5jb25zdCBCTl8yID0gQmlnSW50KDIpO1xuY29uc3QgQk5fMjcgPSBCaWdJbnQoMjcpO1xuY29uc3QgQk5fMjggPSBCaWdJbnQoMjgpO1xuY29uc3QgQk5fMzUgPSBCaWdJbnQoMzUpO1xuY29uc3QgX2d1YXJkID0ge307XG5mdW5jdGlvbiB0b1VpbnQyNTYodmFsdWUpIHtcbiAgICByZXR1cm4gemVyb1BhZFZhbHVlKHRvQmVBcnJheSh2YWx1ZSksIDMyKTtcbn1cbi8qKlxuICogIEEgU2lnbmF0dXJlICBAVE9ET1xuICpcbiAqXG4gKiAgQF9kb2Nsb2M6IGFwaS9jcnlwdG86U2lnbmluZ1xuICovXG5leHBvcnQgY2xhc3MgU2lnbmF0dXJlIHtcbiAgICAjcjtcbiAgICAjcztcbiAgICAjdjtcbiAgICAjbmV0d29ya1Y7XG4gICAgLyoqXG4gICAgICogIFRoZSBgYHJgYCB2YWx1ZSBmb3IgYSBzaWduYXR1cmUuXG4gICAgICpcbiAgICAgKiAgVGhpcyByZXByZXNlbnRzIHRoZSBgYHhgYCBjb29yZGluYXRlIG9mIGEgXCJyZWZlcmVuY2VcIiBvclxuICAgICAqICBjaGFsbGVuZ2UgcG9pbnQsIGZyb20gd2hpY2ggdGhlIGBgeWBgIGNhbiBiZSBjb21wdXRlZC5cbiAgICAgKi9cbiAgICBnZXQgcigpIHsgcmV0dXJuIHRoaXMuI3I7IH1cbiAgICBzZXQgcih2YWx1ZSkge1xuICAgICAgICBhc3NlcnRBcmd1bWVudChkYXRhTGVuZ3RoKHZhbHVlKSA9PT0gMzIsIFwiaW52YWxpZCByXCIsIFwidmFsdWVcIiwgdmFsdWUpO1xuICAgICAgICB0aGlzLiNyID0gaGV4bGlmeSh2YWx1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgYGBzYGAgdmFsdWUgZm9yIGEgc2lnbmF0dXJlLlxuICAgICAqL1xuICAgIGdldCBzKCkge1xuICAgICAgICBhc3NlcnRBcmd1bWVudChwYXJzZUludCh0aGlzLiNzLnN1YnN0cmluZygwLCAzKSkgPCA4LCBcIm5vbi1jYW5vbmljYWwgczsgdXNlIC5fc1wiLCBcInNcIiwgdGhpcy4jcyk7XG4gICAgICAgIHJldHVybiB0aGlzLiNzO1xuICAgIH1cbiAgICBzZXQgcyhfdmFsdWUpIHtcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQoZGF0YUxlbmd0aChfdmFsdWUpID09PSAzMiwgXCJpbnZhbGlkIHNcIiwgXCJ2YWx1ZVwiLCBfdmFsdWUpO1xuICAgICAgICB0aGlzLiNzID0gaGV4bGlmeShfdmFsdWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIHRoZSBzIHZhbHVlLCB1bmNoZWNrZWQgZm9yIEVJUC0yIGNvbXBsaWFuY2UuXG4gICAgICpcbiAgICAgKiAgVGhpcyBzaG91bGQgZ2VuZXJhbGx5IG5vdCBiZSB1c2VkIGFuZCBpcyBmb3Igc2l0dWF0aW9ucyB3aGVyZVxuICAgICAqICBhIG5vbi1jYW5vbmljYWwgUyB2YWx1ZSBtaWdodCBiZSByZWxldmFudCwgc3VjaCBhcyBGcm9udGllciBibG9ja3NcbiAgICAgKiAgdGhhdCB3ZXJlIG1pbmVkIHByaW9yIHRvIEVJUC0yIG9yIGludmFsaWQgQXV0aG9yaXphdGlvbiBMaXN0XG4gICAgICogIHNpZ25hdHVyZXMuXG4gICAgICovXG4gICAgZ2V0IF9zKCkgeyByZXR1cm4gdGhpcy4jczsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRydWUgaWYgdGhlIFNpZ25hdHVyZSBpcyB2YWxpZCBmb3IgW1tsaW5rLWVpcC0yXV0gc2lnbmF0dXJlcy5cbiAgICAgKi9cbiAgICBpc1ZhbGlkKCkge1xuICAgICAgICByZXR1cm4gKHBhcnNlSW50KHRoaXMuI3Muc3Vic3RyaW5nKDAsIDMpKSA8IDgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhlIGBgdmBgIHZhbHVlIGZvciBhIHNpZ25hdHVyZS5cbiAgICAgKlxuICAgICAqICBTaW5jZSBhIGdpdmVuIGBgeGBgIHZhbHVlIGZvciBgYHJgYCBoYXMgdHdvIHBvc3NpYmxlIHZhbHVlcyBmb3JcbiAgICAgKiAgaXRzIGNvcnJlc3BvbmRpbiBgYHlgYCwgdGhlIGBgdmBgIGluZGljYXRlcyB3aGljaCBvZiB0aGUgdHdvIGBgeWBgXG4gICAgICogIHZhbHVlcyB0byB1c2UuXG4gICAgICpcbiAgICAgKiAgSXQgaXMgbm9ybWFsaXplZCB0byB0aGUgdmFsdWVzIGBgMjdgYCBvciBgYDI4YGAgZm9yIGxlZ2FjeVxuICAgICAqICBwdXJwb3Nlcy5cbiAgICAgKi9cbiAgICBnZXQgdigpIHsgcmV0dXJuIHRoaXMuI3Y7IH1cbiAgICBzZXQgdih2YWx1ZSkge1xuICAgICAgICBjb25zdCB2ID0gZ2V0TnVtYmVyKHZhbHVlLCBcInZhbHVlXCIpO1xuICAgICAgICBhc3NlcnRBcmd1bWVudCh2ID09PSAyNyB8fCB2ID09PSAyOCwgXCJpbnZhbGlkIHZcIiwgXCJ2XCIsIHZhbHVlKTtcbiAgICAgICAgdGhpcy4jdiA9IHY7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgRUlQLTE1NSBgYHZgYCBmb3IgbGVnYWN5IHRyYW5zYWN0aW9ucy4gRm9yIG5vbi1sZWdhY3lcbiAgICAgKiAgdHJhbnNhY3Rpb25zLCB0aGlzIHZhbHVlIGlzIGBgbnVsbGBgLlxuICAgICAqL1xuICAgIGdldCBuZXR3b3JrVigpIHsgcmV0dXJuIHRoaXMuI25ldHdvcmtWOyB9XG4gICAgLyoqXG4gICAgICogIFRoZSBjaGFpbiBJRCBmb3IgRUlQLTE1NSBsZWdhY3kgdHJhbnNhY3Rpb25zLiBGb3Igbm9uLWxlZ2FjeVxuICAgICAqICB0cmFuc2FjdGlvbnMsIHRoaXMgdmFsdWUgaXMgYGBudWxsYGAuXG4gICAgICovXG4gICAgZ2V0IGxlZ2FjeUNoYWluSWQoKSB7XG4gICAgICAgIGNvbnN0IHYgPSB0aGlzLm5ldHdvcmtWO1xuICAgICAgICBpZiAodiA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gU2lnbmF0dXJlLmdldENoYWluSWQodik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgYGB5UGFyaXR5YGAgZm9yIHRoZSBzaWduYXR1cmUuXG4gICAgICpcbiAgICAgKiAgU2VlIGBgdmBgIGZvciBtb3JlIGRldGFpbHMgb24gaG93IHRoaXMgdmFsdWUgaXMgdXNlZC5cbiAgICAgKi9cbiAgICBnZXQgeVBhcml0eSgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLnYgPT09IDI3KSA/IDAgOiAxO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhlIFtbbGluay1laXAtMjA5OF1dIGNvbXBhY3QgcmVwcmVzZW50YXRpb24gb2YgdGhlIGBgeVBhcml0eWBgXG4gICAgICogIGFuZCBgYHNgYCBjb21wYWN0ZWQgaW50byBhIHNpbmdsZSBgYGJ5dGVzMzJgYC5cbiAgICAgKi9cbiAgICBnZXQgeVBhcml0eUFuZFMoKSB7XG4gICAgICAgIC8vIFRoZSBFSVAtMjA5OCBjb21wYWN0IHJlcHJlc2VudGF0aW9uXG4gICAgICAgIGNvbnN0IHlQYXJpdHlBbmRTID0gZ2V0Qnl0ZXModGhpcy5zKTtcbiAgICAgICAgaWYgKHRoaXMueVBhcml0eSkge1xuICAgICAgICAgICAgeVBhcml0eUFuZFNbMF0gfD0gMHg4MDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaGV4bGlmeSh5UGFyaXR5QW5kUyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgW1tsaW5rLWVpcC0yMDk4XV0gY29tcGFjdCByZXByZXNlbnRhdGlvbi5cbiAgICAgKi9cbiAgICBnZXQgY29tcGFjdFNlcmlhbGl6ZWQoKSB7XG4gICAgICAgIHJldHVybiBjb25jYXQoW3RoaXMuciwgdGhpcy55UGFyaXR5QW5kU10pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhlIHNlcmlhbGl6ZWQgcmVwcmVzZW50YXRpb24uXG4gICAgICovXG4gICAgZ2V0IHNlcmlhbGl6ZWQoKSB7XG4gICAgICAgIHJldHVybiBjb25jYXQoW3RoaXMuciwgdGhpcy5zLCAodGhpcy55UGFyaXR5ID8gXCIweDFjXCIgOiBcIjB4MWJcIildKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIEBwcml2YXRlXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoZ3VhcmQsIHIsIHMsIHYpIHtcbiAgICAgICAgYXNzZXJ0UHJpdmF0ZShndWFyZCwgX2d1YXJkLCBcIlNpZ25hdHVyZVwiKTtcbiAgICAgICAgdGhpcy4jciA9IHI7XG4gICAgICAgIHRoaXMuI3MgPSBzO1xuICAgICAgICB0aGlzLiN2ID0gdjtcbiAgICAgICAgdGhpcy4jbmV0d29ya1YgPSBudWxsO1xuICAgIH1cbiAgICBbU3ltYm9sLmZvcignbm9kZWpzLnV0aWwuaW5zcGVjdC5jdXN0b20nKV0oKSB7XG4gICAgICAgIHJldHVybiBgU2lnbmF0dXJlIHsgcjogXCIke3RoaXMucn1cIiwgczogXCIke3RoaXMuX3N9XCIke3RoaXMuaXNWYWxpZCgpID8gXCJcIiA6ICcsIHZhbGlkOiBcImZhbHNlXCInfSwgeVBhcml0eTogJHt0aGlzLnlQYXJpdHl9LCBuZXR3b3JrVjogJHt0aGlzLm5ldHdvcmtWfSB9YDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYSBuZXcgaWRlbnRpY2FsIFtbU2lnbmF0dXJlXV0uXG4gICAgICovXG4gICAgY2xvbmUoKSB7XG4gICAgICAgIGNvbnN0IGNsb25lID0gbmV3IFNpZ25hdHVyZShfZ3VhcmQsIHRoaXMuciwgdGhpcy5fcywgdGhpcy52KTtcbiAgICAgICAgaWYgKHRoaXMubmV0d29ya1YpIHtcbiAgICAgICAgICAgIGNsb25lLiNuZXR3b3JrViA9IHRoaXMubmV0d29ya1Y7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNsb25lO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBhIHJlcHJlc2VudGF0aW9uIHRoYXQgaXMgY29tcGF0aWJsZSB3aXRoIGBgSlNPTi5zdHJpbmdpZnlgYC5cbiAgICAgKi9cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIGNvbnN0IG5ldHdvcmtWID0gdGhpcy5uZXR3b3JrVjtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIF90eXBlOiBcInNpZ25hdHVyZVwiLFxuICAgICAgICAgICAgbmV0d29ya1Y6ICgobmV0d29ya1YgIT0gbnVsbCkgPyBuZXR3b3JrVi50b1N0cmluZygpIDogbnVsbCksXG4gICAgICAgICAgICByOiB0aGlzLnIsIHM6IHRoaXMuX3MsIHY6IHRoaXMudixcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIENvbXB1dGUgdGhlIGNoYWluIElEIGZyb20gdGhlIGBgdmBgIGluIGEgbGVnYWN5IEVJUC0xNTUgdHJhbnNhY3Rpb25zLlxuICAgICAqXG4gICAgICogIEBleGFtcGxlOlxuICAgICAqICAgIFNpZ25hdHVyZS5nZXRDaGFpbklkKDQ1KVxuICAgICAqICAgIC8vX3Jlc3VsdDpcbiAgICAgKlxuICAgICAqICAgIFNpZ25hdHVyZS5nZXRDaGFpbklkKDQ2KVxuICAgICAqICAgIC8vX3Jlc3VsdDpcbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0Q2hhaW5JZCh2KSB7XG4gICAgICAgIGNvbnN0IGJ2ID0gZ2V0QmlnSW50KHYsIFwidlwiKTtcbiAgICAgICAgLy8gVGhlIHYgaXMgbm90IGFuIEVJUC0xNTUgdiwgc28gaXQgaXMgdGhlIHVuc3BlY2lmaWVkIGNoYWluIElEXG4gICAgICAgIGlmICgoYnYgPT0gQk5fMjcpIHx8IChidiA9PSBCTl8yOCkpIHtcbiAgICAgICAgICAgIHJldHVybiBCTl8wO1xuICAgICAgICB9XG4gICAgICAgIC8vIEJhZCB2YWx1ZSBmb3IgYW4gRUlQLTE1NSB2XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KGJ2ID49IEJOXzM1LCBcImludmFsaWQgRUlQLTE1NSB2XCIsIFwidlwiLCB2KTtcbiAgICAgICAgcmV0dXJuIChidiAtIEJOXzM1KSAvIEJOXzI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBDb21wdXRlIHRoZSBgYHZgYCBmb3IgYSBjaGFpbiBJRCBmb3IgYSBsZWdhY3kgRUlQLTE1NSB0cmFuc2FjdGlvbnMuXG4gICAgICpcbiAgICAgKiAgTGVnYWN5IHRyYW5zYWN0aW9ucyB3aGljaCB1c2UgW1tsaW5rLWVpcC0xNTVdXSBoaWphY2sgdGhlIGBgdmBgXG4gICAgICogIHByb3BlcnR5IHRvIGluY2x1ZGUgdGhlIGNoYWluIElELlxuICAgICAqXG4gICAgICogIEBleGFtcGxlOlxuICAgICAqICAgIFNpZ25hdHVyZS5nZXRDaGFpbklkVig1LCAyNylcbiAgICAgKiAgICAvL19yZXN1bHQ6XG4gICAgICpcbiAgICAgKiAgICBTaWduYXR1cmUuZ2V0Q2hhaW5JZFYoNSwgMjgpXG4gICAgICogICAgLy9fcmVzdWx0OlxuICAgICAqXG4gICAgICovXG4gICAgc3RhdGljIGdldENoYWluSWRWKGNoYWluSWQsIHYpIHtcbiAgICAgICAgcmV0dXJuIChnZXRCaWdJbnQoY2hhaW5JZCkgKiBCTl8yKSArIEJpZ0ludCgzNSArIHYgLSAyNyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBDb21wdXRlIHRoZSBub3JtYWxpemVkIGxlZ2FjeSB0cmFuc2FjdGlvbiBgYHZgYCBmcm9tIGEgYGB5UGFyaXJ0eWBgLFxuICAgICAqICBhIGxlZ2FjeSB0cmFuc2FjdGlvbiBgYHZgYCBvciBhIGxlZ2FjeSBbW2xpbmstZWlwLTE1NV1dIHRyYW5zYWN0aW9uLlxuICAgICAqXG4gICAgICogIEBleGFtcGxlOlxuICAgICAqICAgIC8vIFRoZSB2YWx1ZXMgMCBhbmQgMSBpbXBseSB2IGlzIGFjdHVhbGx5IHlQYXJpdHlcbiAgICAgKiAgICBTaWduYXR1cmUuZ2V0Tm9ybWFsaXplZFYoMClcbiAgICAgKiAgICAvL19yZXN1bHQ6XG4gICAgICpcbiAgICAgKiAgICAvLyBMZWdhY3kgbm9uLUVJUC0xNTU5IHRyYW5zYWN0aW9uIChpLmUuIDI3IG9yIDI4KVxuICAgICAqICAgIFNpZ25hdHVyZS5nZXROb3JtYWxpemVkVigyNylcbiAgICAgKiAgICAvL19yZXN1bHQ6XG4gICAgICpcbiAgICAgKiAgICAvLyBMZWdhY3kgRUlQLTE1NSB0cmFuc2FjdGlvbiAoaS5lLiA+PSAzNSlcbiAgICAgKiAgICBTaWduYXR1cmUuZ2V0Tm9ybWFsaXplZFYoNDYpXG4gICAgICogICAgLy9fcmVzdWx0OlxuICAgICAqXG4gICAgICogICAgLy8gSW52YWxpZCB2YWx1ZXMgdGhyb3dcbiAgICAgKiAgICBTaWduYXR1cmUuZ2V0Tm9ybWFsaXplZFYoNSlcbiAgICAgKiAgICAvL19lcnJvcjpcbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0Tm9ybWFsaXplZFYodikge1xuICAgICAgICBjb25zdCBidiA9IGdldEJpZ0ludCh2KTtcbiAgICAgICAgaWYgKGJ2ID09PSBCTl8wIHx8IGJ2ID09PSBCTl8yNykge1xuICAgICAgICAgICAgcmV0dXJuIDI3O1xuICAgICAgICB9XG4gICAgICAgIGlmIChidiA9PT0gQk5fMSB8fCBidiA9PT0gQk5fMjgpIHtcbiAgICAgICAgICAgIHJldHVybiAyODtcbiAgICAgICAgfVxuICAgICAgICBhc3NlcnRBcmd1bWVudChidiA+PSBCTl8zNSwgXCJpbnZhbGlkIHZcIiwgXCJ2XCIsIHYpO1xuICAgICAgICAvLyBPdGhlcndpc2UsIEVJUC0xNTUgdiBtZWFucyBvZGQgaXMgMjcgYW5kIGV2ZW4gaXMgMjhcbiAgICAgICAgcmV0dXJuIChidiAmIEJOXzEpID8gMjcgOiAyODtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIENyZWF0ZXMgYSBuZXcgW1tTaWduYXR1cmVdXS5cbiAgICAgKlxuICAgICAqICBJZiBubyAlJXNpZyUlIGlzIHByb3ZpZGVkLCBhIG5ldyBbW1NpZ25hdHVyZV1dIGlzIGNyZWF0ZWRcbiAgICAgKiAgd2l0aCBkZWZhdWx0IHZhbHVlcy5cbiAgICAgKlxuICAgICAqICBJZiAlJXNpZyUlIGlzIGEgc3RyaW5nLCBpdCBpcyBwYXJzZWQuXG4gICAgICovXG4gICAgc3RhdGljIGZyb20oc2lnKSB7XG4gICAgICAgIGZ1bmN0aW9uIGFzc2VydEVycm9yKGNoZWNrLCBtZXNzYWdlKSB7XG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudChjaGVjaywgbWVzc2FnZSwgXCJzaWduYXR1cmVcIiwgc2lnKTtcbiAgICAgICAgfVxuICAgICAgICA7XG4gICAgICAgIGlmIChzaWcgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBTaWduYXR1cmUoX2d1YXJkLCBaZXJvSGFzaCwgWmVyb0hhc2gsIDI3KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIChzaWcpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBjb25zdCBieXRlcyA9IGdldEJ5dGVzKHNpZywgXCJzaWduYXR1cmVcIik7XG4gICAgICAgICAgICBpZiAoYnl0ZXMubGVuZ3RoID09PSA2NCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHIgPSBoZXhsaWZ5KGJ5dGVzLnNsaWNlKDAsIDMyKSk7XG4gICAgICAgICAgICAgICAgY29uc3QgcyA9IGJ5dGVzLnNsaWNlKDMyLCA2NCk7XG4gICAgICAgICAgICAgICAgY29uc3QgdiA9IChzWzBdICYgMHg4MCkgPyAyOCA6IDI3O1xuICAgICAgICAgICAgICAgIHNbMF0gJj0gMHg3ZjtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFNpZ25hdHVyZShfZ3VhcmQsIHIsIGhleGxpZnkocyksIHYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGJ5dGVzLmxlbmd0aCA9PT0gNjUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCByID0gaGV4bGlmeShieXRlcy5zbGljZSgwLCAzMikpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHMgPSBoZXhsaWZ5KGJ5dGVzLnNsaWNlKDMyLCA2NCkpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHYgPSBTaWduYXR1cmUuZ2V0Tm9ybWFsaXplZFYoYnl0ZXNbNjRdKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFNpZ25hdHVyZShfZ3VhcmQsIHIsIHMsIHYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXNzZXJ0RXJyb3IoZmFsc2UsIFwiaW52YWxpZCByYXcgc2lnbmF0dXJlIGxlbmd0aFwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2lnIGluc3RhbmNlb2YgU2lnbmF0dXJlKSB7XG4gICAgICAgICAgICByZXR1cm4gc2lnLmNsb25lKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gR2V0IHJcbiAgICAgICAgY29uc3QgX3IgPSBzaWcucjtcbiAgICAgICAgYXNzZXJ0RXJyb3IoX3IgIT0gbnVsbCwgXCJtaXNzaW5nIHJcIik7XG4gICAgICAgIGNvbnN0IHIgPSB0b1VpbnQyNTYoX3IpO1xuICAgICAgICAvLyBHZXQgczsgYnkgYW55IG1lYW5zIG5lY2Vzc2FyeSAod2UgY2hlY2sgY29uc2lzdGVuY3kgYmVsb3cpXG4gICAgICAgIGNvbnN0IHMgPSAoZnVuY3Rpb24gKHMsIHlQYXJpdHlBbmRTKSB7XG4gICAgICAgICAgICBpZiAocyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRvVWludDI1NihzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh5UGFyaXR5QW5kUyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgYXNzZXJ0RXJyb3IoaXNIZXhTdHJpbmcoeVBhcml0eUFuZFMsIDMyKSwgXCJpbnZhbGlkIHlQYXJpdHlBbmRTXCIpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGJ5dGVzID0gZ2V0Qnl0ZXMoeVBhcml0eUFuZFMpO1xuICAgICAgICAgICAgICAgIGJ5dGVzWzBdICY9IDB4N2Y7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGhleGxpZnkoYnl0ZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXNzZXJ0RXJyb3IoZmFsc2UsIFwibWlzc2luZyBzXCIpO1xuICAgICAgICB9KShzaWcucywgc2lnLnlQYXJpdHlBbmRTKTtcbiAgICAgICAgLy8gR2V0IHY7IGJ5IGFueSBtZWFucyBuZWNlc3NhcnkgKHdlIGNoZWNrIGNvbnNpc3RlbmN5IGJlbG93KVxuICAgICAgICBjb25zdCB7IG5ldHdvcmtWLCB2IH0gPSAoZnVuY3Rpb24gKF92LCB5UGFyaXR5QW5kUywgeVBhcml0eSkge1xuICAgICAgICAgICAgaWYgKF92ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB2ID0gZ2V0QmlnSW50KF92KTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBuZXR3b3JrVjogKCh2ID49IEJOXzM1KSA/IHYgOiB1bmRlZmluZWQpLFxuICAgICAgICAgICAgICAgICAgICB2OiBTaWduYXR1cmUuZ2V0Tm9ybWFsaXplZFYodilcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHlQYXJpdHlBbmRTICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBhc3NlcnRFcnJvcihpc0hleFN0cmluZyh5UGFyaXR5QW5kUywgMzIpLCBcImludmFsaWQgeVBhcml0eUFuZFNcIik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgdjogKChnZXRCeXRlcyh5UGFyaXR5QW5kUylbMF0gJiAweDgwKSA/IDI4IDogMjcpIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoeVBhcml0eSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChnZXROdW1iZXIoeVBhcml0eSwgXCJzaWcueVBhcml0eVwiKSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6IHJldHVybiB7IHY6IDI3IH07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTogcmV0dXJuIHsgdjogMjggfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYXNzZXJ0RXJyb3IoZmFsc2UsIFwiaW52YWxpZCB5UGFyaXR5XCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXNzZXJ0RXJyb3IoZmFsc2UsIFwibWlzc2luZyB2XCIpO1xuICAgICAgICB9KShzaWcudiwgc2lnLnlQYXJpdHlBbmRTLCBzaWcueVBhcml0eSk7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBTaWduYXR1cmUoX2d1YXJkLCByLCBzLCB2KTtcbiAgICAgICAgaWYgKG5ldHdvcmtWKSB7XG4gICAgICAgICAgICByZXN1bHQuI25ldHdvcmtWID0gbmV0d29ya1Y7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgbXVsdGlwbGUgb2YgdiwgeVBhcml0eSwgeVBhcml0eUFuZFMgd2UgZ2l2ZW4sIGNoZWNrIHRoZXkgbWF0Y2hcbiAgICAgICAgYXNzZXJ0RXJyb3Ioc2lnLnlQYXJpdHkgPT0gbnVsbCB8fCBnZXROdW1iZXIoc2lnLnlQYXJpdHksIFwic2lnLnlQYXJpdHlcIikgPT09IHJlc3VsdC55UGFyaXR5LCBcInlQYXJpdHkgbWlzbWF0Y2hcIik7XG4gICAgICAgIGFzc2VydEVycm9yKHNpZy55UGFyaXR5QW5kUyA9PSBudWxsIHx8IHNpZy55UGFyaXR5QW5kUyA9PT0gcmVzdWx0LnlQYXJpdHlBbmRTLCBcInlQYXJpdHlBbmRTIG1pc21hdGNoXCIpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNpZ25hdHVyZS5qcy5tYXAiXSwibmFtZXMiOlsiWmVyb0hhc2giLCJjb25jYXQiLCJkYXRhTGVuZ3RoIiwiZ2V0QmlnSW50IiwiZ2V0Qnl0ZXMiLCJnZXROdW1iZXIiLCJoZXhsaWZ5IiwidG9CZUFycmF5IiwiaXNIZXhTdHJpbmciLCJ6ZXJvUGFkVmFsdWUiLCJhc3NlcnRBcmd1bWVudCIsImFzc2VydFByaXZhdGUiLCJCTl8wIiwiQmlnSW50IiwiQk5fMSIsIkJOXzIiLCJCTl8yNyIsIkJOXzI4IiwiQk5fMzUiLCJfZ3VhcmQiLCJ0b1VpbnQyNTYiLCJ2YWx1ZSIsIlNpZ25hdHVyZSIsInIiLCJzIiwidiIsIm5ldHdvcmtWIiwicGFyc2VJbnQiLCJzdWJzdHJpbmciLCJfdmFsdWUiLCJfcyIsImlzVmFsaWQiLCJsZWdhY3lDaGFpbklkIiwiZ2V0Q2hhaW5JZCIsInlQYXJpdHkiLCJ5UGFyaXR5QW5kUyIsImNvbXBhY3RTZXJpYWxpemVkIiwic2VyaWFsaXplZCIsImNvbnN0cnVjdG9yIiwiZ3VhcmQiLCJTeW1ib2wiLCJmb3IiLCJjbG9uZSIsInRvSlNPTiIsIl90eXBlIiwidG9TdHJpbmciLCJidiIsImdldENoYWluSWRWIiwiY2hhaW5JZCIsImdldE5vcm1hbGl6ZWRWIiwiZnJvbSIsInNpZyIsImFzc2VydEVycm9yIiwiY2hlY2siLCJtZXNzYWdlIiwiYnl0ZXMiLCJsZW5ndGgiLCJzbGljZSIsIl9yIiwiX3YiLCJ1bmRlZmluZWQiLCJyZXN1bHQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.esm/crypto/signature.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.esm/crypto/signing-key.js":
/*!***********************************************************!*\
  !*** ./node_modules/ethers/lib.esm/crypto/signing-key.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SigningKey: () => (/* binding */ SigningKey)\n/* harmony export */ });\n/* harmony import */ var _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @noble/curves/secp256k1 */ \"(ssr)/./node_modules/@noble/curves/esm/secp256k1.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/errors.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/data.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/maths.js\");\n/* harmony import */ var _signature_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./signature.js */ \"(ssr)/./node_modules/ethers/lib.esm/crypto/signature.js\");\n/**\n *  Add details about signing here.\n *\n *  @_subsection: api/crypto:Signing  [about-signing]\n */ \n\n\n/**\n *  A **SigningKey** provides high-level access to the elliptic curve\n *  cryptography (ECC) operations and key management.\n */ class SigningKey {\n    #privateKey;\n    /**\n     *  Creates a new **SigningKey** for %%privateKey%%.\n     */ constructor(privateKey){\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.dataLength)(privateKey) === 32, \"invalid private key\", \"privateKey\", \"[REDACTED]\");\n        this.#privateKey = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.hexlify)(privateKey);\n    }\n    /**\n     *  The private key.\n     */ get privateKey() {\n        return this.#privateKey;\n    }\n    /**\n     *  The uncompressed public key.\n     *\n     * This will always begin with the prefix ``0x04`` and be 132\n     * characters long (the ``0x`` prefix and 130 hexadecimal nibbles).\n     */ get publicKey() {\n        return SigningKey.computePublicKey(this.#privateKey);\n    }\n    /**\n     *  The compressed public key.\n     *\n     *  This will always begin with either the prefix ``0x02`` or ``0x03``\n     *  and be 68 characters long (the ``0x`` prefix and 33 hexadecimal\n     *  nibbles)\n     */ get compressedPublicKey() {\n        return SigningKey.computePublicKey(this.#privateKey, true);\n    }\n    /**\n     *  Return the signature of the signed %%digest%%.\n     */ sign(digest) {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.dataLength)(digest) === 32, \"invalid digest length\", \"digest\", digest);\n        const sig = _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_2__.secp256k1.sign((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.getBytesCopy)(digest), (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.getBytesCopy)(this.#privateKey), {\n            lowS: true\n        });\n        return _signature_js__WEBPACK_IMPORTED_MODULE_3__.Signature.from({\n            r: (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_4__.toBeHex)(sig.r, 32),\n            s: (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_4__.toBeHex)(sig.s, 32),\n            v: sig.recovery ? 0x1c : 0x1b\n        });\n    }\n    /**\n     *  Returns the [[link-wiki-ecdh]] shared secret between this\n     *  private key and the %%other%% key.\n     *\n     *  The %%other%% key may be any type of key, a raw public key,\n     *  a compressed/uncompressed pubic key or aprivate key.\n     *\n     *  Best practice is usually to use a cryptographic hash on the\n     *  returned value before using it as a symetric secret.\n     *\n     *  @example:\n     *    sign1 = new SigningKey(id(\"some-secret-1\"))\n     *    sign2 = new SigningKey(id(\"some-secret-2\"))\n     *\n     *    // Notice that privA.computeSharedSecret(pubB)...\n     *    sign1.computeSharedSecret(sign2.publicKey)\n     *    //_result:\n     *\n     *    // ...is equal to privB.computeSharedSecret(pubA).\n     *    sign2.computeSharedSecret(sign1.publicKey)\n     *    //_result:\n     */ computeSharedSecret(other) {\n        const pubKey = SigningKey.computePublicKey(other);\n        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.hexlify)(_noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_2__.secp256k1.getSharedSecret((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.getBytesCopy)(this.#privateKey), (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.getBytes)(pubKey), false));\n    }\n    /**\n     *  Compute the public key for %%key%%, optionally %%compressed%%.\n     *\n     *  The %%key%% may be any type of key, a raw public key, a\n     *  compressed/uncompressed public key or private key.\n     *\n     *  @example:\n     *    sign = new SigningKey(id(\"some-secret\"));\n     *\n     *    // Compute the uncompressed public key for a private key\n     *    SigningKey.computePublicKey(sign.privateKey)\n     *    //_result:\n     *\n     *    // Compute the compressed public key for a private key\n     *    SigningKey.computePublicKey(sign.privateKey, true)\n     *    //_result:\n     *\n     *    // Compute the uncompressed public key\n     *    SigningKey.computePublicKey(sign.publicKey, false);\n     *    //_result:\n     *\n     *    // Compute the Compressed a public key\n     *    SigningKey.computePublicKey(sign.publicKey, true);\n     *    //_result:\n     */ static computePublicKey(key, compressed) {\n        let bytes = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.getBytes)(key, \"key\");\n        // private key\n        if (bytes.length === 32) {\n            const pubKey = _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_2__.secp256k1.getPublicKey(bytes, !!compressed);\n            return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.hexlify)(pubKey);\n        }\n        // raw public key; use uncompressed key with 0x04 prefix\n        if (bytes.length === 64) {\n            const pub = new Uint8Array(65);\n            pub[0] = 0x04;\n            pub.set(bytes, 1);\n            bytes = pub;\n        }\n        const point = _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_2__.secp256k1.ProjectivePoint.fromHex(bytes);\n        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.hexlify)(point.toRawBytes(compressed));\n    }\n    /**\n     *  Returns the public key for the private key which produced the\n     *  %%signature%% for the given %%digest%%.\n     *\n     *  @example:\n     *    key = new SigningKey(id(\"some-secret\"))\n     *    digest = id(\"hello world\")\n     *    sig = key.sign(digest)\n     *\n     *    // Notice the signer public key...\n     *    key.publicKey\n     *    //_result:\n     *\n     *    // ...is equal to the recovered public key\n     *    SigningKey.recoverPublicKey(digest, sig)\n     *    //_result:\n     *\n     */ static recoverPublicKey(digest, signature) {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.dataLength)(digest) === 32, \"invalid digest length\", \"digest\", digest);\n        const sig = _signature_js__WEBPACK_IMPORTED_MODULE_3__.Signature.from(signature);\n        let secpSig = _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_2__.secp256k1.Signature.fromCompact((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.getBytesCopy)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.concat)([\n            sig.r,\n            sig.s\n        ])));\n        secpSig = secpSig.addRecoveryBit(sig.yParity);\n        const pubKey = secpSig.recoverPublicKey((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.getBytesCopy)(digest));\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(pubKey != null, \"invalid signature for digest\", \"signature\", signature);\n        return \"0x\" + pubKey.toHex(false);\n    }\n    /**\n     *  Returns the point resulting from adding the ellipic curve points\n     *  %%p0%% and %%p1%%.\n     *\n     *  This is not a common function most developers should require, but\n     *  can be useful for certain privacy-specific techniques.\n     *\n     *  For example, it is used by [[HDNodeWallet]] to compute child\n     *  addresses from parent public keys and chain codes.\n     */ static addPoints(p0, p1, compressed) {\n        const pub0 = _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_2__.secp256k1.ProjectivePoint.fromHex(SigningKey.computePublicKey(p0).substring(2));\n        const pub1 = _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_2__.secp256k1.ProjectivePoint.fromHex(SigningKey.computePublicKey(p1).substring(2));\n        return \"0x\" + pub0.add(pub1).toHex(!!compressed);\n    }\n} //# sourceMappingURL=signing-key.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vY3J5cHRvL3NpZ25pbmcta2V5LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFBOzs7O0NBSUMsR0FDbUQ7QUFDNkQ7QUFDdEU7QUFDM0M7OztDQUdDLEdBQ00sTUFBTVM7SUFDVCxDQUFDQyxVQUFVLENBQUM7SUFDWjs7S0FFQyxHQUNEQyxZQUFZRCxVQUFVLENBQUU7UUFDcEJILCtEQUFjQSxDQUFDTCwyREFBVUEsQ0FBQ1EsZ0JBQWdCLElBQUksdUJBQXVCLGNBQWM7UUFDbkYsSUFBSSxDQUFDLENBQUNBLFVBQVUsR0FBR0wsd0RBQU9BLENBQUNLO0lBQy9CO0lBQ0E7O0tBRUMsR0FDRCxJQUFJQSxhQUFhO1FBQUUsT0FBTyxJQUFJLENBQUMsQ0FBQ0EsVUFBVTtJQUFFO0lBQzVDOzs7OztLQUtDLEdBQ0QsSUFBSUUsWUFBWTtRQUFFLE9BQU9ILFdBQVdJLGdCQUFnQixDQUFDLElBQUksQ0FBQyxDQUFDSCxVQUFVO0lBQUc7SUFDeEU7Ozs7OztLQU1DLEdBQ0QsSUFBSUksc0JBQXNCO1FBQUUsT0FBT0wsV0FBV0ksZ0JBQWdCLENBQUMsSUFBSSxDQUFDLENBQUNILFVBQVUsRUFBRTtJQUFPO0lBQ3hGOztLQUVDLEdBQ0RLLEtBQUtDLE1BQU0sRUFBRTtRQUNUVCwrREFBY0EsQ0FBQ0wsMkRBQVVBLENBQUNjLFlBQVksSUFBSSx5QkFBeUIsVUFBVUE7UUFDN0UsTUFBTUMsTUFBTWpCLDhEQUFTQSxDQUFDZSxJQUFJLENBQUNYLDZEQUFZQSxDQUFDWSxTQUFTWiw2REFBWUEsQ0FBQyxJQUFJLENBQUMsQ0FBQ00sVUFBVSxHQUFHO1lBQzdFUSxNQUFNO1FBQ1Y7UUFDQSxPQUFPVixvREFBU0EsQ0FBQ1csSUFBSSxDQUFDO1lBQ2xCQyxHQUFHZCx3REFBT0EsQ0FBQ1csSUFBSUcsQ0FBQyxFQUFFO1lBQ2xCQyxHQUFHZix3REFBT0EsQ0FBQ1csSUFBSUksQ0FBQyxFQUFFO1lBQ2xCQyxHQUFJTCxJQUFJTSxRQUFRLEdBQUcsT0FBTztRQUM5QjtJQUNKO0lBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztLQXFCQyxHQUNEQyxvQkFBb0JDLEtBQUssRUFBRTtRQUN2QixNQUFNQyxTQUFTakIsV0FBV0ksZ0JBQWdCLENBQUNZO1FBQzNDLE9BQU9wQix3REFBT0EsQ0FBQ0wsOERBQVNBLENBQUMyQixlQUFlLENBQUN2Qiw2REFBWUEsQ0FBQyxJQUFJLENBQUMsQ0FBQ00sVUFBVSxHQUFHUCx5REFBUUEsQ0FBQ3VCLFNBQVM7SUFDL0Y7SUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0tBd0JDLEdBQ0QsT0FBT2IsaUJBQWlCZSxHQUFHLEVBQUVDLFVBQVUsRUFBRTtRQUNyQyxJQUFJQyxRQUFRM0IseURBQVFBLENBQUN5QixLQUFLO1FBQzFCLGNBQWM7UUFDZCxJQUFJRSxNQUFNQyxNQUFNLEtBQUssSUFBSTtZQUNyQixNQUFNTCxTQUFTMUIsOERBQVNBLENBQUNnQyxZQUFZLENBQUNGLE9BQU8sQ0FBQyxDQUFDRDtZQUMvQyxPQUFPeEIsd0RBQU9BLENBQUNxQjtRQUNuQjtRQUNBLHdEQUF3RDtRQUN4RCxJQUFJSSxNQUFNQyxNQUFNLEtBQUssSUFBSTtZQUNyQixNQUFNRSxNQUFNLElBQUlDLFdBQVc7WUFDM0JELEdBQUcsQ0FBQyxFQUFFLEdBQUc7WUFDVEEsSUFBSUUsR0FBRyxDQUFDTCxPQUFPO1lBQ2ZBLFFBQVFHO1FBQ1o7UUFDQSxNQUFNRyxRQUFRcEMsOERBQVNBLENBQUNxQyxlQUFlLENBQUNDLE9BQU8sQ0FBQ1I7UUFDaEQsT0FBT3pCLHdEQUFPQSxDQUFDK0IsTUFBTUcsVUFBVSxDQUFDVjtJQUNwQztJQUNBOzs7Ozs7Ozs7Ozs7Ozs7OztLQWlCQyxHQUNELE9BQU9XLGlCQUFpQnhCLE1BQU0sRUFBRXlCLFNBQVMsRUFBRTtRQUN2Q2xDLCtEQUFjQSxDQUFDTCwyREFBVUEsQ0FBQ2MsWUFBWSxJQUFJLHlCQUF5QixVQUFVQTtRQUM3RSxNQUFNQyxNQUFNVCxvREFBU0EsQ0FBQ1csSUFBSSxDQUFDc0I7UUFDM0IsSUFBSUMsVUFBVTFDLDhEQUFTQSxDQUFDUSxTQUFTLENBQUNtQyxXQUFXLENBQUN2Qyw2REFBWUEsQ0FBQ0gsdURBQU1BLENBQUM7WUFBQ2dCLElBQUlHLENBQUM7WUFBRUgsSUFBSUksQ0FBQztTQUFDO1FBQ2hGcUIsVUFBVUEsUUFBUUUsY0FBYyxDQUFDM0IsSUFBSTRCLE9BQU87UUFDNUMsTUFBTW5CLFNBQVNnQixRQUFRRixnQkFBZ0IsQ0FBQ3BDLDZEQUFZQSxDQUFDWTtRQUNyRFQsK0RBQWNBLENBQUNtQixVQUFVLE1BQU0sZ0NBQWdDLGFBQWFlO1FBQzVFLE9BQU8sT0FBT2YsT0FBT29CLEtBQUssQ0FBQztJQUMvQjtJQUNBOzs7Ozs7Ozs7S0FTQyxHQUNELE9BQU9DLFVBQVVDLEVBQUUsRUFBRUMsRUFBRSxFQUFFcEIsVUFBVSxFQUFFO1FBQ2pDLE1BQU1xQixPQUFPbEQsOERBQVNBLENBQUNxQyxlQUFlLENBQUNDLE9BQU8sQ0FBQzdCLFdBQVdJLGdCQUFnQixDQUFDbUMsSUFBSUcsU0FBUyxDQUFDO1FBQ3pGLE1BQU1DLE9BQU9wRCw4REFBU0EsQ0FBQ3FDLGVBQWUsQ0FBQ0MsT0FBTyxDQUFDN0IsV0FBV0ksZ0JBQWdCLENBQUNvQyxJQUFJRSxTQUFTLENBQUM7UUFDekYsT0FBTyxPQUFPRCxLQUFLRyxHQUFHLENBQUNELE1BQU1OLEtBQUssQ0FBQyxDQUFDLENBQUNqQjtJQUN6QztBQUNKLEVBQ0EsdUNBQXVDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbWVnYXZpYmUtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vY3J5cHRvL3NpZ25pbmcta2V5LmpzPzQ4ZWYiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiAgQWRkIGRldGFpbHMgYWJvdXQgc2lnbmluZyBoZXJlLlxuICpcbiAqICBAX3N1YnNlY3Rpb246IGFwaS9jcnlwdG86U2lnbmluZyAgW2Fib3V0LXNpZ25pbmddXG4gKi9cbmltcG9ydCB7IHNlY3AyNTZrMSB9IGZyb20gXCJAbm9ibGUvY3VydmVzL3NlY3AyNTZrMVwiO1xuaW1wb3J0IHsgY29uY2F0LCBkYXRhTGVuZ3RoLCBnZXRCeXRlcywgZ2V0Qnl0ZXNDb3B5LCBoZXhsaWZ5LCB0b0JlSGV4LCBhc3NlcnRBcmd1bWVudCB9IGZyb20gXCIuLi91dGlscy9pbmRleC5qc1wiO1xuaW1wb3J0IHsgU2lnbmF0dXJlIH0gZnJvbSBcIi4vc2lnbmF0dXJlLmpzXCI7XG4vKipcbiAqICBBICoqU2lnbmluZ0tleSoqIHByb3ZpZGVzIGhpZ2gtbGV2ZWwgYWNjZXNzIHRvIHRoZSBlbGxpcHRpYyBjdXJ2ZVxuICogIGNyeXB0b2dyYXBoeSAoRUNDKSBvcGVyYXRpb25zIGFuZCBrZXkgbWFuYWdlbWVudC5cbiAqL1xuZXhwb3J0IGNsYXNzIFNpZ25pbmdLZXkge1xuICAgICNwcml2YXRlS2V5O1xuICAgIC8qKlxuICAgICAqICBDcmVhdGVzIGEgbmV3ICoqU2lnbmluZ0tleSoqIGZvciAlJXByaXZhdGVLZXklJS5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlS2V5KSB7XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KGRhdGFMZW5ndGgocHJpdmF0ZUtleSkgPT09IDMyLCBcImludmFsaWQgcHJpdmF0ZSBrZXlcIiwgXCJwcml2YXRlS2V5XCIsIFwiW1JFREFDVEVEXVwiKTtcbiAgICAgICAgdGhpcy4jcHJpdmF0ZUtleSA9IGhleGxpZnkocHJpdmF0ZUtleSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgcHJpdmF0ZSBrZXkuXG4gICAgICovXG4gICAgZ2V0IHByaXZhdGVLZXkoKSB7IHJldHVybiB0aGlzLiNwcml2YXRlS2V5OyB9XG4gICAgLyoqXG4gICAgICogIFRoZSB1bmNvbXByZXNzZWQgcHVibGljIGtleS5cbiAgICAgKlxuICAgICAqIFRoaXMgd2lsbCBhbHdheXMgYmVnaW4gd2l0aCB0aGUgcHJlZml4IGBgMHgwNGBgIGFuZCBiZSAxMzJcbiAgICAgKiBjaGFyYWN0ZXJzIGxvbmcgKHRoZSBgYDB4YGAgcHJlZml4IGFuZCAxMzAgaGV4YWRlY2ltYWwgbmliYmxlcykuXG4gICAgICovXG4gICAgZ2V0IHB1YmxpY0tleSgpIHsgcmV0dXJuIFNpZ25pbmdLZXkuY29tcHV0ZVB1YmxpY0tleSh0aGlzLiNwcml2YXRlS2V5KTsgfVxuICAgIC8qKlxuICAgICAqICBUaGUgY29tcHJlc3NlZCBwdWJsaWMga2V5LlxuICAgICAqXG4gICAgICogIFRoaXMgd2lsbCBhbHdheXMgYmVnaW4gd2l0aCBlaXRoZXIgdGhlIHByZWZpeCBgYDB4MDJgYCBvciBgYDB4MDNgYFxuICAgICAqICBhbmQgYmUgNjggY2hhcmFjdGVycyBsb25nICh0aGUgYGAweGBgIHByZWZpeCBhbmQgMzMgaGV4YWRlY2ltYWxcbiAgICAgKiAgbmliYmxlcylcbiAgICAgKi9cbiAgICBnZXQgY29tcHJlc3NlZFB1YmxpY0tleSgpIHsgcmV0dXJuIFNpZ25pbmdLZXkuY29tcHV0ZVB1YmxpY0tleSh0aGlzLiNwcml2YXRlS2V5LCB0cnVlKTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gdGhlIHNpZ25hdHVyZSBvZiB0aGUgc2lnbmVkICUlZGlnZXN0JSUuXG4gICAgICovXG4gICAgc2lnbihkaWdlc3QpIHtcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQoZGF0YUxlbmd0aChkaWdlc3QpID09PSAzMiwgXCJpbnZhbGlkIGRpZ2VzdCBsZW5ndGhcIiwgXCJkaWdlc3RcIiwgZGlnZXN0KTtcbiAgICAgICAgY29uc3Qgc2lnID0gc2VjcDI1NmsxLnNpZ24oZ2V0Qnl0ZXNDb3B5KGRpZ2VzdCksIGdldEJ5dGVzQ29weSh0aGlzLiNwcml2YXRlS2V5KSwge1xuICAgICAgICAgICAgbG93UzogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIFNpZ25hdHVyZS5mcm9tKHtcbiAgICAgICAgICAgIHI6IHRvQmVIZXgoc2lnLnIsIDMyKSxcbiAgICAgICAgICAgIHM6IHRvQmVIZXgoc2lnLnMsIDMyKSxcbiAgICAgICAgICAgIHY6IChzaWcucmVjb3ZlcnkgPyAweDFjIDogMHgxYilcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRoZSBbW2xpbmstd2lraS1lY2RoXV0gc2hhcmVkIHNlY3JldCBiZXR3ZWVuIHRoaXNcbiAgICAgKiAgcHJpdmF0ZSBrZXkgYW5kIHRoZSAlJW90aGVyJSUga2V5LlxuICAgICAqXG4gICAgICogIFRoZSAlJW90aGVyJSUga2V5IG1heSBiZSBhbnkgdHlwZSBvZiBrZXksIGEgcmF3IHB1YmxpYyBrZXksXG4gICAgICogIGEgY29tcHJlc3NlZC91bmNvbXByZXNzZWQgcHViaWMga2V5IG9yIGFwcml2YXRlIGtleS5cbiAgICAgKlxuICAgICAqICBCZXN0IHByYWN0aWNlIGlzIHVzdWFsbHkgdG8gdXNlIGEgY3J5cHRvZ3JhcGhpYyBoYXNoIG9uIHRoZVxuICAgICAqICByZXR1cm5lZCB2YWx1ZSBiZWZvcmUgdXNpbmcgaXQgYXMgYSBzeW1ldHJpYyBzZWNyZXQuXG4gICAgICpcbiAgICAgKiAgQGV4YW1wbGU6XG4gICAgICogICAgc2lnbjEgPSBuZXcgU2lnbmluZ0tleShpZChcInNvbWUtc2VjcmV0LTFcIikpXG4gICAgICogICAgc2lnbjIgPSBuZXcgU2lnbmluZ0tleShpZChcInNvbWUtc2VjcmV0LTJcIikpXG4gICAgICpcbiAgICAgKiAgICAvLyBOb3RpY2UgdGhhdCBwcml2QS5jb21wdXRlU2hhcmVkU2VjcmV0KHB1YkIpLi4uXG4gICAgICogICAgc2lnbjEuY29tcHV0ZVNoYXJlZFNlY3JldChzaWduMi5wdWJsaWNLZXkpXG4gICAgICogICAgLy9fcmVzdWx0OlxuICAgICAqXG4gICAgICogICAgLy8gLi4uaXMgZXF1YWwgdG8gcHJpdkIuY29tcHV0ZVNoYXJlZFNlY3JldChwdWJBKS5cbiAgICAgKiAgICBzaWduMi5jb21wdXRlU2hhcmVkU2VjcmV0KHNpZ24xLnB1YmxpY0tleSlcbiAgICAgKiAgICAvL19yZXN1bHQ6XG4gICAgICovXG4gICAgY29tcHV0ZVNoYXJlZFNlY3JldChvdGhlcikge1xuICAgICAgICBjb25zdCBwdWJLZXkgPSBTaWduaW5nS2V5LmNvbXB1dGVQdWJsaWNLZXkob3RoZXIpO1xuICAgICAgICByZXR1cm4gaGV4bGlmeShzZWNwMjU2azEuZ2V0U2hhcmVkU2VjcmV0KGdldEJ5dGVzQ29weSh0aGlzLiNwcml2YXRlS2V5KSwgZ2V0Qnl0ZXMocHViS2V5KSwgZmFsc2UpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIENvbXB1dGUgdGhlIHB1YmxpYyBrZXkgZm9yICUla2V5JSUsIG9wdGlvbmFsbHkgJSVjb21wcmVzc2VkJSUuXG4gICAgICpcbiAgICAgKiAgVGhlICUla2V5JSUgbWF5IGJlIGFueSB0eXBlIG9mIGtleSwgYSByYXcgcHVibGljIGtleSwgYVxuICAgICAqICBjb21wcmVzc2VkL3VuY29tcHJlc3NlZCBwdWJsaWMga2V5IG9yIHByaXZhdGUga2V5LlxuICAgICAqXG4gICAgICogIEBleGFtcGxlOlxuICAgICAqICAgIHNpZ24gPSBuZXcgU2lnbmluZ0tleShpZChcInNvbWUtc2VjcmV0XCIpKTtcbiAgICAgKlxuICAgICAqICAgIC8vIENvbXB1dGUgdGhlIHVuY29tcHJlc3NlZCBwdWJsaWMga2V5IGZvciBhIHByaXZhdGUga2V5XG4gICAgICogICAgU2lnbmluZ0tleS5jb21wdXRlUHVibGljS2V5KHNpZ24ucHJpdmF0ZUtleSlcbiAgICAgKiAgICAvL19yZXN1bHQ6XG4gICAgICpcbiAgICAgKiAgICAvLyBDb21wdXRlIHRoZSBjb21wcmVzc2VkIHB1YmxpYyBrZXkgZm9yIGEgcHJpdmF0ZSBrZXlcbiAgICAgKiAgICBTaWduaW5nS2V5LmNvbXB1dGVQdWJsaWNLZXkoc2lnbi5wcml2YXRlS2V5LCB0cnVlKVxuICAgICAqICAgIC8vX3Jlc3VsdDpcbiAgICAgKlxuICAgICAqICAgIC8vIENvbXB1dGUgdGhlIHVuY29tcHJlc3NlZCBwdWJsaWMga2V5XG4gICAgICogICAgU2lnbmluZ0tleS5jb21wdXRlUHVibGljS2V5KHNpZ24ucHVibGljS2V5LCBmYWxzZSk7XG4gICAgICogICAgLy9fcmVzdWx0OlxuICAgICAqXG4gICAgICogICAgLy8gQ29tcHV0ZSB0aGUgQ29tcHJlc3NlZCBhIHB1YmxpYyBrZXlcbiAgICAgKiAgICBTaWduaW5nS2V5LmNvbXB1dGVQdWJsaWNLZXkoc2lnbi5wdWJsaWNLZXksIHRydWUpO1xuICAgICAqICAgIC8vX3Jlc3VsdDpcbiAgICAgKi9cbiAgICBzdGF0aWMgY29tcHV0ZVB1YmxpY0tleShrZXksIGNvbXByZXNzZWQpIHtcbiAgICAgICAgbGV0IGJ5dGVzID0gZ2V0Qnl0ZXMoa2V5LCBcImtleVwiKTtcbiAgICAgICAgLy8gcHJpdmF0ZSBrZXlcbiAgICAgICAgaWYgKGJ5dGVzLmxlbmd0aCA9PT0gMzIpIHtcbiAgICAgICAgICAgIGNvbnN0IHB1YktleSA9IHNlY3AyNTZrMS5nZXRQdWJsaWNLZXkoYnl0ZXMsICEhY29tcHJlc3NlZCk7XG4gICAgICAgICAgICByZXR1cm4gaGV4bGlmeShwdWJLZXkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHJhdyBwdWJsaWMga2V5OyB1c2UgdW5jb21wcmVzc2VkIGtleSB3aXRoIDB4MDQgcHJlZml4XG4gICAgICAgIGlmIChieXRlcy5sZW5ndGggPT09IDY0KSB7XG4gICAgICAgICAgICBjb25zdCBwdWIgPSBuZXcgVWludDhBcnJheSg2NSk7XG4gICAgICAgICAgICBwdWJbMF0gPSAweDA0O1xuICAgICAgICAgICAgcHViLnNldChieXRlcywgMSk7XG4gICAgICAgICAgICBieXRlcyA9IHB1YjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwb2ludCA9IHNlY3AyNTZrMS5Qcm9qZWN0aXZlUG9pbnQuZnJvbUhleChieXRlcyk7XG4gICAgICAgIHJldHVybiBoZXhsaWZ5KHBvaW50LnRvUmF3Qnl0ZXMoY29tcHJlc3NlZCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0aGUgcHVibGljIGtleSBmb3IgdGhlIHByaXZhdGUga2V5IHdoaWNoIHByb2R1Y2VkIHRoZVxuICAgICAqICAlJXNpZ25hdHVyZSUlIGZvciB0aGUgZ2l2ZW4gJSVkaWdlc3QlJS5cbiAgICAgKlxuICAgICAqICBAZXhhbXBsZTpcbiAgICAgKiAgICBrZXkgPSBuZXcgU2lnbmluZ0tleShpZChcInNvbWUtc2VjcmV0XCIpKVxuICAgICAqICAgIGRpZ2VzdCA9IGlkKFwiaGVsbG8gd29ybGRcIilcbiAgICAgKiAgICBzaWcgPSBrZXkuc2lnbihkaWdlc3QpXG4gICAgICpcbiAgICAgKiAgICAvLyBOb3RpY2UgdGhlIHNpZ25lciBwdWJsaWMga2V5Li4uXG4gICAgICogICAga2V5LnB1YmxpY0tleVxuICAgICAqICAgIC8vX3Jlc3VsdDpcbiAgICAgKlxuICAgICAqICAgIC8vIC4uLmlzIGVxdWFsIHRvIHRoZSByZWNvdmVyZWQgcHVibGljIGtleVxuICAgICAqICAgIFNpZ25pbmdLZXkucmVjb3ZlclB1YmxpY0tleShkaWdlc3QsIHNpZylcbiAgICAgKiAgICAvL19yZXN1bHQ6XG4gICAgICpcbiAgICAgKi9cbiAgICBzdGF0aWMgcmVjb3ZlclB1YmxpY0tleShkaWdlc3QsIHNpZ25hdHVyZSkge1xuICAgICAgICBhc3NlcnRBcmd1bWVudChkYXRhTGVuZ3RoKGRpZ2VzdCkgPT09IDMyLCBcImludmFsaWQgZGlnZXN0IGxlbmd0aFwiLCBcImRpZ2VzdFwiLCBkaWdlc3QpO1xuICAgICAgICBjb25zdCBzaWcgPSBTaWduYXR1cmUuZnJvbShzaWduYXR1cmUpO1xuICAgICAgICBsZXQgc2VjcFNpZyA9IHNlY3AyNTZrMS5TaWduYXR1cmUuZnJvbUNvbXBhY3QoZ2V0Qnl0ZXNDb3B5KGNvbmNhdChbc2lnLnIsIHNpZy5zXSkpKTtcbiAgICAgICAgc2VjcFNpZyA9IHNlY3BTaWcuYWRkUmVjb3ZlcnlCaXQoc2lnLnlQYXJpdHkpO1xuICAgICAgICBjb25zdCBwdWJLZXkgPSBzZWNwU2lnLnJlY292ZXJQdWJsaWNLZXkoZ2V0Qnl0ZXNDb3B5KGRpZ2VzdCkpO1xuICAgICAgICBhc3NlcnRBcmd1bWVudChwdWJLZXkgIT0gbnVsbCwgXCJpbnZhbGlkIHNpZ25hdHVyZSBmb3IgZGlnZXN0XCIsIFwic2lnbmF0dXJlXCIsIHNpZ25hdHVyZSk7XG4gICAgICAgIHJldHVybiBcIjB4XCIgKyBwdWJLZXkudG9IZXgoZmFsc2UpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0aGUgcG9pbnQgcmVzdWx0aW5nIGZyb20gYWRkaW5nIHRoZSBlbGxpcGljIGN1cnZlIHBvaW50c1xuICAgICAqICAlJXAwJSUgYW5kICUlcDElJS5cbiAgICAgKlxuICAgICAqICBUaGlzIGlzIG5vdCBhIGNvbW1vbiBmdW5jdGlvbiBtb3N0IGRldmVsb3BlcnMgc2hvdWxkIHJlcXVpcmUsIGJ1dFxuICAgICAqICBjYW4gYmUgdXNlZnVsIGZvciBjZXJ0YWluIHByaXZhY3ktc3BlY2lmaWMgdGVjaG5pcXVlcy5cbiAgICAgKlxuICAgICAqICBGb3IgZXhhbXBsZSwgaXQgaXMgdXNlZCBieSBbW0hETm9kZVdhbGxldF1dIHRvIGNvbXB1dGUgY2hpbGRcbiAgICAgKiAgYWRkcmVzc2VzIGZyb20gcGFyZW50IHB1YmxpYyBrZXlzIGFuZCBjaGFpbiBjb2Rlcy5cbiAgICAgKi9cbiAgICBzdGF0aWMgYWRkUG9pbnRzKHAwLCBwMSwgY29tcHJlc3NlZCkge1xuICAgICAgICBjb25zdCBwdWIwID0gc2VjcDI1NmsxLlByb2plY3RpdmVQb2ludC5mcm9tSGV4KFNpZ25pbmdLZXkuY29tcHV0ZVB1YmxpY0tleShwMCkuc3Vic3RyaW5nKDIpKTtcbiAgICAgICAgY29uc3QgcHViMSA9IHNlY3AyNTZrMS5Qcm9qZWN0aXZlUG9pbnQuZnJvbUhleChTaWduaW5nS2V5LmNvbXB1dGVQdWJsaWNLZXkocDEpLnN1YnN0cmluZygyKSk7XG4gICAgICAgIHJldHVybiBcIjB4XCIgKyBwdWIwLmFkZChwdWIxKS50b0hleCghIWNvbXByZXNzZWQpO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNpZ25pbmcta2V5LmpzLm1hcCJdLCJuYW1lcyI6WyJzZWNwMjU2azEiLCJjb25jYXQiLCJkYXRhTGVuZ3RoIiwiZ2V0Qnl0ZXMiLCJnZXRCeXRlc0NvcHkiLCJoZXhsaWZ5IiwidG9CZUhleCIsImFzc2VydEFyZ3VtZW50IiwiU2lnbmF0dXJlIiwiU2lnbmluZ0tleSIsInByaXZhdGVLZXkiLCJjb25zdHJ1Y3RvciIsInB1YmxpY0tleSIsImNvbXB1dGVQdWJsaWNLZXkiLCJjb21wcmVzc2VkUHVibGljS2V5Iiwic2lnbiIsImRpZ2VzdCIsInNpZyIsImxvd1MiLCJmcm9tIiwiciIsInMiLCJ2IiwicmVjb3ZlcnkiLCJjb21wdXRlU2hhcmVkU2VjcmV0Iiwib3RoZXIiLCJwdWJLZXkiLCJnZXRTaGFyZWRTZWNyZXQiLCJrZXkiLCJjb21wcmVzc2VkIiwiYnl0ZXMiLCJsZW5ndGgiLCJnZXRQdWJsaWNLZXkiLCJwdWIiLCJVaW50OEFycmF5Iiwic2V0IiwicG9pbnQiLCJQcm9qZWN0aXZlUG9pbnQiLCJmcm9tSGV4IiwidG9SYXdCeXRlcyIsInJlY292ZXJQdWJsaWNLZXkiLCJzaWduYXR1cmUiLCJzZWNwU2lnIiwiZnJvbUNvbXBhY3QiLCJhZGRSZWNvdmVyeUJpdCIsInlQYXJpdHkiLCJ0b0hleCIsImFkZFBvaW50cyIsInAwIiwicDEiLCJwdWIwIiwic3Vic3RyaW5nIiwicHViMSIsImFkZCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.esm/crypto/signing-key.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.esm/hash/id.js":
/*!************************************************!*\
  !*** ./node_modules/ethers/lib.esm/hash/id.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   id: () => (/* binding */ id)\n/* harmony export */ });\n/* harmony import */ var _crypto_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../crypto/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/crypto/keccak.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/utf8.js\");\n\n\n/**\n *  A simple hashing function which operates on UTF-8 strings to\n *  compute an 32-byte identifier.\n *\n *  This simply computes the [UTF-8 bytes](toUtf8Bytes) and computes\n *  the [[keccak256]].\n *\n *  @example:\n *    id(\"hello world\")\n *    //_result:\n */ function id(value) {\n    return (0,_crypto_index_js__WEBPACK_IMPORTED_MODULE_0__.keccak256)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.toUtf8Bytes)(value));\n} //# sourceMappingURL=id.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vaGFzaC9pZC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBK0M7QUFDQztBQUNoRDs7Ozs7Ozs7OztDQVVDLEdBQ00sU0FBU0UsR0FBR0MsS0FBSztJQUNwQixPQUFPSCwyREFBU0EsQ0FBQ0MsNERBQVdBLENBQUNFO0FBQ2pDLEVBQ0EsOEJBQThCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbWVnYXZpYmUtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vaGFzaC9pZC5qcz81NDUwIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGtlY2NhazI1NiB9IGZyb20gXCIuLi9jcnlwdG8vaW5kZXguanNcIjtcbmltcG9ydCB7IHRvVXRmOEJ5dGVzIH0gZnJvbSBcIi4uL3V0aWxzL2luZGV4LmpzXCI7XG4vKipcbiAqICBBIHNpbXBsZSBoYXNoaW5nIGZ1bmN0aW9uIHdoaWNoIG9wZXJhdGVzIG9uIFVURi04IHN0cmluZ3MgdG9cbiAqICBjb21wdXRlIGFuIDMyLWJ5dGUgaWRlbnRpZmllci5cbiAqXG4gKiAgVGhpcyBzaW1wbHkgY29tcHV0ZXMgdGhlIFtVVEYtOCBieXRlc10odG9VdGY4Qnl0ZXMpIGFuZCBjb21wdXRlc1xuICogIHRoZSBbW2tlY2NhazI1Nl1dLlxuICpcbiAqICBAZXhhbXBsZTpcbiAqICAgIGlkKFwiaGVsbG8gd29ybGRcIilcbiAqICAgIC8vX3Jlc3VsdDpcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlkKHZhbHVlKSB7XG4gICAgcmV0dXJuIGtlY2NhazI1Nih0b1V0ZjhCeXRlcyh2YWx1ZSkpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aWQuanMubWFwIl0sIm5hbWVzIjpbImtlY2NhazI1NiIsInRvVXRmOEJ5dGVzIiwiaWQiLCJ2YWx1ZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.esm/hash/id.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.esm/hash/namehash.js":
/*!******************************************************!*\
  !*** ./node_modules/ethers/lib.esm/hash/namehash.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   dnsEncode: () => (/* binding */ dnsEncode),\n/* harmony export */   ensNormalize: () => (/* binding */ ensNormalize),\n/* harmony export */   isValidName: () => (/* binding */ isValidName),\n/* harmony export */   namehash: () => (/* binding */ namehash)\n/* harmony export */ });\n/* harmony import */ var _crypto_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../crypto/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/crypto/keccak.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/errors.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/utf8.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/data.js\");\n/* harmony import */ var _adraffy_ens_normalize__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @adraffy/ens-normalize */ \"(ssr)/./node_modules/@adraffy/ens-normalize/dist/index.mjs\");\n\n\n\nconst Zeros = new Uint8Array(32);\nZeros.fill(0);\nfunction checkComponent(comp) {\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(comp.length !== 0, \"invalid ENS name; empty component\", \"comp\", comp);\n    return comp;\n}\nfunction ensNameSplit(name) {\n    const bytes = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.toUtf8Bytes)(ensNormalize(name));\n    const comps = [];\n    if (name.length === 0) {\n        return comps;\n    }\n    let last = 0;\n    for(let i = 0; i < bytes.length; i++){\n        const d = bytes[i];\n        // A separator (i.e. \".\"); copy this component\n        if (d === 0x2e) {\n            comps.push(checkComponent(bytes.slice(last, i)));\n            last = i + 1;\n        }\n    }\n    // There was a stray separator at the end of the name\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(last < bytes.length, \"invalid ENS name; empty component\", \"name\", name);\n    comps.push(checkComponent(bytes.slice(last)));\n    return comps;\n}\n/**\n *  Returns the ENS %%name%% normalized.\n */ function ensNormalize(name) {\n    try {\n        if (name.length === 0) {\n            throw new Error(\"empty label\");\n        }\n        return (0,_adraffy_ens_normalize__WEBPACK_IMPORTED_MODULE_0__.ens_normalize)(name);\n    } catch (error) {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(false, `invalid ENS name (${error.message})`, \"name\", name);\n    }\n}\n/**\n *  Returns ``true`` if %%name%% is a valid ENS name.\n */ function isValidName(name) {\n    try {\n        return ensNameSplit(name).length !== 0;\n    } catch (error) {}\n    return false;\n}\n/**\n *  Returns the [[link-namehash]] for %%name%%.\n */ function namehash(name) {\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(typeof name === \"string\", \"invalid ENS name; not a string\", \"name\", name);\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(name.length, `invalid ENS name (empty label)`, \"name\", name);\n    let result = Zeros;\n    const comps = ensNameSplit(name);\n    while(comps.length){\n        result = (0,_crypto_index_js__WEBPACK_IMPORTED_MODULE_3__.keccak256)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_4__.concat)([\n            result,\n            (0,_crypto_index_js__WEBPACK_IMPORTED_MODULE_3__.keccak256)(comps.pop())\n        ]));\n    }\n    return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_4__.hexlify)(result);\n}\n/**\n *  Returns the DNS encoded %%name%%.\n *\n *  This is used for various parts of ENS name resolution, such\n *  as the wildcard resolution.\n */ function dnsEncode(name, _maxLength) {\n    const length = _maxLength != null ? _maxLength : 63;\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(length <= 255, \"DNS encoded label cannot exceed 255\", \"length\", length);\n    return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_4__.hexlify)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_4__.concat)(ensNameSplit(name).map((comp)=>{\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(comp.length <= length, `label ${JSON.stringify(name)} exceeds ${length} bytes`, \"name\", name);\n        const bytes = new Uint8Array(comp.length + 1);\n        bytes.set(comp, 1);\n        bytes[0] = bytes.length - 1;\n        return bytes;\n    }))) + \"00\";\n} //# sourceMappingURL=namehash.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vaGFzaC9uYW1laGFzaC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFBK0M7QUFDa0M7QUFDMUI7QUFDdkQsTUFBTU0sUUFBUSxJQUFJQyxXQUFXO0FBQzdCRCxNQUFNRSxJQUFJLENBQUM7QUFDWCxTQUFTQyxlQUFlQyxJQUFJO0lBQ3hCUCwrREFBY0EsQ0FBQ08sS0FBS0MsTUFBTSxLQUFLLEdBQUcscUNBQXFDLFFBQVFEO0lBQy9FLE9BQU9BO0FBQ1g7QUFDQSxTQUFTRSxhQUFhQyxJQUFJO0lBQ3RCLE1BQU1DLFFBQVFWLDREQUFXQSxDQUFDVyxhQUFhRjtJQUN2QyxNQUFNRyxRQUFRLEVBQUU7SUFDaEIsSUFBSUgsS0FBS0YsTUFBTSxLQUFLLEdBQUc7UUFDbkIsT0FBT0s7SUFDWDtJQUNBLElBQUlDLE9BQU87SUFDWCxJQUFLLElBQUlDLElBQUksR0FBR0EsSUFBSUosTUFBTUgsTUFBTSxFQUFFTyxJQUFLO1FBQ25DLE1BQU1DLElBQUlMLEtBQUssQ0FBQ0ksRUFBRTtRQUNsQiw4Q0FBOEM7UUFDOUMsSUFBSUMsTUFBTSxNQUFNO1lBQ1pILE1BQU1JLElBQUksQ0FBQ1gsZUFBZUssTUFBTU8sS0FBSyxDQUFDSixNQUFNQztZQUM1Q0QsT0FBT0MsSUFBSTtRQUNmO0lBQ0o7SUFDQSxxREFBcUQ7SUFDckRmLCtEQUFjQSxDQUFDYyxPQUFPSCxNQUFNSCxNQUFNLEVBQUUscUNBQXFDLFFBQVFFO0lBQ2pGRyxNQUFNSSxJQUFJLENBQUNYLGVBQWVLLE1BQU1PLEtBQUssQ0FBQ0o7SUFDdEMsT0FBT0Q7QUFDWDtBQUNBOztDQUVDLEdBQ00sU0FBU0QsYUFBYUYsSUFBSTtJQUM3QixJQUFJO1FBQ0EsSUFBSUEsS0FBS0YsTUFBTSxLQUFLLEdBQUc7WUFDbkIsTUFBTSxJQUFJVyxNQUFNO1FBQ3BCO1FBQ0EsT0FBT2pCLHFFQUFhQSxDQUFDUTtJQUN6QixFQUNBLE9BQU9VLE9BQU87UUFDVnBCLCtEQUFjQSxDQUFDLE9BQU8sQ0FBQyxrQkFBa0IsRUFBRW9CLE1BQU1DLE9BQU8sQ0FBQyxDQUFDLENBQUMsRUFBRSxRQUFRWDtJQUN6RTtBQUNKO0FBQ0E7O0NBRUMsR0FDTSxTQUFTWSxZQUFZWixJQUFJO0lBQzVCLElBQUk7UUFDQSxPQUFRRCxhQUFhQyxNQUFNRixNQUFNLEtBQUs7SUFDMUMsRUFDQSxPQUFPWSxPQUFPLENBQUU7SUFDaEIsT0FBTztBQUNYO0FBQ0E7O0NBRUMsR0FDTSxTQUFTRyxTQUFTYixJQUFJO0lBQ3pCViwrREFBY0EsQ0FBQyxPQUFRVSxTQUFVLFVBQVUsa0NBQWtDLFFBQVFBO0lBQ3JGViwrREFBY0EsQ0FBQ1UsS0FBS0YsTUFBTSxFQUFFLENBQUMsOEJBQThCLENBQUMsRUFBRSxRQUFRRTtJQUN0RSxJQUFJYyxTQUFTckI7SUFDYixNQUFNVSxRQUFRSixhQUFhQztJQUMzQixNQUFPRyxNQUFNTCxNQUFNLENBQUU7UUFDakJnQixTQUFTM0IsMkRBQVNBLENBQUNDLHVEQUFNQSxDQUFDO1lBQUMwQjtZQUFRM0IsMkRBQVNBLENBQUVnQixNQUFNWSxHQUFHO1NBQUs7SUFDaEU7SUFDQSxPQUFPMUIsd0RBQU9BLENBQUN5QjtBQUNuQjtBQUNBOzs7OztDQUtDLEdBQ00sU0FBU0UsVUFBVWhCLElBQUksRUFBRWlCLFVBQVU7SUFDdEMsTUFBTW5CLFNBQVMsY0FBZSxPQUFRbUIsYUFBYTtJQUNuRDNCLCtEQUFjQSxDQUFDUSxVQUFVLEtBQUssdUNBQXVDLFVBQVVBO0lBQy9FLE9BQU9ULHdEQUFPQSxDQUFDRCx1REFBTUEsQ0FBQ1csYUFBYUMsTUFBTWtCLEdBQUcsQ0FBQyxDQUFDckI7UUFDMUNQLCtEQUFjQSxDQUFDTyxLQUFLQyxNQUFNLElBQUlBLFFBQVEsQ0FBQyxNQUFNLEVBQUVxQixLQUFLQyxTQUFTLENBQUNwQixNQUFNLFNBQVMsRUFBRUYsT0FBTyxNQUFNLENBQUMsRUFBRSxRQUFRRTtRQUN2RyxNQUFNQyxRQUFRLElBQUlQLFdBQVdHLEtBQUtDLE1BQU0sR0FBRztRQUMzQ0csTUFBTW9CLEdBQUcsQ0FBQ3hCLE1BQU07UUFDaEJJLEtBQUssQ0FBQyxFQUFFLEdBQUdBLE1BQU1ILE1BQU0sR0FBRztRQUMxQixPQUFPRztJQUNYLE9BQU87QUFDWCxFQUNBLG9DQUFvQyIsInNvdXJjZXMiOlsid2VicGFjazovL21lZ2F2aWJlLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL2hhc2gvbmFtZWhhc2guanM/ZTUwOCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBrZWNjYWsyNTYgfSBmcm9tIFwiLi4vY3J5cHRvL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBjb25jYXQsIGhleGxpZnksIGFzc2VydEFyZ3VtZW50LCB0b1V0ZjhCeXRlcyB9IGZyb20gXCIuLi91dGlscy9pbmRleC5qc1wiO1xuaW1wb3J0IHsgZW5zX25vcm1hbGl6ZSB9IGZyb20gXCJAYWRyYWZmeS9lbnMtbm9ybWFsaXplXCI7XG5jb25zdCBaZXJvcyA9IG5ldyBVaW50OEFycmF5KDMyKTtcblplcm9zLmZpbGwoMCk7XG5mdW5jdGlvbiBjaGVja0NvbXBvbmVudChjb21wKSB7XG4gICAgYXNzZXJ0QXJndW1lbnQoY29tcC5sZW5ndGggIT09IDAsIFwiaW52YWxpZCBFTlMgbmFtZTsgZW1wdHkgY29tcG9uZW50XCIsIFwiY29tcFwiLCBjb21wKTtcbiAgICByZXR1cm4gY29tcDtcbn1cbmZ1bmN0aW9uIGVuc05hbWVTcGxpdChuYW1lKSB7XG4gICAgY29uc3QgYnl0ZXMgPSB0b1V0ZjhCeXRlcyhlbnNOb3JtYWxpemUobmFtZSkpO1xuICAgIGNvbnN0IGNvbXBzID0gW107XG4gICAgaWYgKG5hbWUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBjb21wcztcbiAgICB9XG4gICAgbGV0IGxhc3QgPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgZCA9IGJ5dGVzW2ldO1xuICAgICAgICAvLyBBIHNlcGFyYXRvciAoaS5lLiBcIi5cIik7IGNvcHkgdGhpcyBjb21wb25lbnRcbiAgICAgICAgaWYgKGQgPT09IDB4MmUpIHtcbiAgICAgICAgICAgIGNvbXBzLnB1c2goY2hlY2tDb21wb25lbnQoYnl0ZXMuc2xpY2UobGFzdCwgaSkpKTtcbiAgICAgICAgICAgIGxhc3QgPSBpICsgMTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBUaGVyZSB3YXMgYSBzdHJheSBzZXBhcmF0b3IgYXQgdGhlIGVuZCBvZiB0aGUgbmFtZVxuICAgIGFzc2VydEFyZ3VtZW50KGxhc3QgPCBieXRlcy5sZW5ndGgsIFwiaW52YWxpZCBFTlMgbmFtZTsgZW1wdHkgY29tcG9uZW50XCIsIFwibmFtZVwiLCBuYW1lKTtcbiAgICBjb21wcy5wdXNoKGNoZWNrQ29tcG9uZW50KGJ5dGVzLnNsaWNlKGxhc3QpKSk7XG4gICAgcmV0dXJuIGNvbXBzO1xufVxuLyoqXG4gKiAgUmV0dXJucyB0aGUgRU5TICUlbmFtZSUlIG5vcm1hbGl6ZWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlbnNOb3JtYWxpemUobmFtZSkge1xuICAgIHRyeSB7XG4gICAgICAgIGlmIChuYW1lLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZW1wdHkgbGFiZWxcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVuc19ub3JtYWxpemUobmFtZSk7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICBhc3NlcnRBcmd1bWVudChmYWxzZSwgYGludmFsaWQgRU5TIG5hbWUgKCR7ZXJyb3IubWVzc2FnZX0pYCwgXCJuYW1lXCIsIG5hbWUpO1xuICAgIH1cbn1cbi8qKlxuICogIFJldHVybnMgYGB0cnVlYGAgaWYgJSVuYW1lJSUgaXMgYSB2YWxpZCBFTlMgbmFtZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzVmFsaWROYW1lKG5hbWUpIHtcbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gKGVuc05hbWVTcGxpdChuYW1lKS5sZW5ndGggIT09IDApO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHsgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbi8qKlxuICogIFJldHVybnMgdGhlIFtbbGluay1uYW1laGFzaF1dIGZvciAlJW5hbWUlJS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG5hbWVoYXNoKG5hbWUpIHtcbiAgICBhc3NlcnRBcmd1bWVudCh0eXBlb2YgKG5hbWUpID09PSBcInN0cmluZ1wiLCBcImludmFsaWQgRU5TIG5hbWU7IG5vdCBhIHN0cmluZ1wiLCBcIm5hbWVcIiwgbmFtZSk7XG4gICAgYXNzZXJ0QXJndW1lbnQobmFtZS5sZW5ndGgsIGBpbnZhbGlkIEVOUyBuYW1lIChlbXB0eSBsYWJlbClgLCBcIm5hbWVcIiwgbmFtZSk7XG4gICAgbGV0IHJlc3VsdCA9IFplcm9zO1xuICAgIGNvbnN0IGNvbXBzID0gZW5zTmFtZVNwbGl0KG5hbWUpO1xuICAgIHdoaWxlIChjb21wcy5sZW5ndGgpIHtcbiAgICAgICAgcmVzdWx0ID0ga2VjY2FrMjU2KGNvbmNhdChbcmVzdWx0LCBrZWNjYWsyNTYoKGNvbXBzLnBvcCgpKSldKSk7XG4gICAgfVxuICAgIHJldHVybiBoZXhsaWZ5KHJlc3VsdCk7XG59XG4vKipcbiAqICBSZXR1cm5zIHRoZSBETlMgZW5jb2RlZCAlJW5hbWUlJS5cbiAqXG4gKiAgVGhpcyBpcyB1c2VkIGZvciB2YXJpb3VzIHBhcnRzIG9mIEVOUyBuYW1lIHJlc29sdXRpb24sIHN1Y2hcbiAqICBhcyB0aGUgd2lsZGNhcmQgcmVzb2x1dGlvbi5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRuc0VuY29kZShuYW1lLCBfbWF4TGVuZ3RoKSB7XG4gICAgY29uc3QgbGVuZ3RoID0gKF9tYXhMZW5ndGggIT0gbnVsbCkgPyBfbWF4TGVuZ3RoIDogNjM7XG4gICAgYXNzZXJ0QXJndW1lbnQobGVuZ3RoIDw9IDI1NSwgXCJETlMgZW5jb2RlZCBsYWJlbCBjYW5ub3QgZXhjZWVkIDI1NVwiLCBcImxlbmd0aFwiLCBsZW5ndGgpO1xuICAgIHJldHVybiBoZXhsaWZ5KGNvbmNhdChlbnNOYW1lU3BsaXQobmFtZSkubWFwKChjb21wKSA9PiB7XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KGNvbXAubGVuZ3RoIDw9IGxlbmd0aCwgYGxhYmVsICR7SlNPTi5zdHJpbmdpZnkobmFtZSl9IGV4Y2VlZHMgJHtsZW5ndGh9IGJ5dGVzYCwgXCJuYW1lXCIsIG5hbWUpO1xuICAgICAgICBjb25zdCBieXRlcyA9IG5ldyBVaW50OEFycmF5KGNvbXAubGVuZ3RoICsgMSk7XG4gICAgICAgIGJ5dGVzLnNldChjb21wLCAxKTtcbiAgICAgICAgYnl0ZXNbMF0gPSBieXRlcy5sZW5ndGggLSAxO1xuICAgICAgICByZXR1cm4gYnl0ZXM7XG4gICAgfSkpKSArIFwiMDBcIjtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW5hbWVoYXNoLmpzLm1hcCJdLCJuYW1lcyI6WyJrZWNjYWsyNTYiLCJjb25jYXQiLCJoZXhsaWZ5IiwiYXNzZXJ0QXJndW1lbnQiLCJ0b1V0ZjhCeXRlcyIsImVuc19ub3JtYWxpemUiLCJaZXJvcyIsIlVpbnQ4QXJyYXkiLCJmaWxsIiwiY2hlY2tDb21wb25lbnQiLCJjb21wIiwibGVuZ3RoIiwiZW5zTmFtZVNwbGl0IiwibmFtZSIsImJ5dGVzIiwiZW5zTm9ybWFsaXplIiwiY29tcHMiLCJsYXN0IiwiaSIsImQiLCJwdXNoIiwic2xpY2UiLCJFcnJvciIsImVycm9yIiwibWVzc2FnZSIsImlzVmFsaWROYW1lIiwibmFtZWhhc2giLCJyZXN1bHQiLCJwb3AiLCJkbnNFbmNvZGUiLCJfbWF4TGVuZ3RoIiwibWFwIiwiSlNPTiIsInN0cmluZ2lmeSIsInNldCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.esm/hash/namehash.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.esm/hash/typed-data.js":
/*!********************************************************!*\
  !*** ./node_modules/ethers/lib.esm/hash/typed-data.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   TypedDataEncoder: () => (/* binding */ TypedDataEncoder),\n/* harmony export */   verifyTypedData: () => (/* binding */ verifyTypedData)\n/* harmony export */ });\n/* harmony import */ var _address_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../address/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/address/address.js\");\n/* harmony import */ var _crypto_index_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../crypto/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/crypto/keccak.js\");\n/* harmony import */ var _transaction_index_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../transaction/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/transaction/address.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/data.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/maths.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/errors.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/properties.js\");\n/* harmony import */ var _id_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./id.js */ \"(ssr)/./node_modules/ethers/lib.esm/hash/id.js\");\n//import { TypedDataDomain, TypedDataField } from \"@ethersproject/providerabstract-signer\";\n\n\n\n\n\nconst padding = new Uint8Array(32);\npadding.fill(0);\nconst BN__1 = BigInt(-1);\nconst BN_0 = BigInt(0);\nconst BN_1 = BigInt(1);\nconst BN_MAX_UINT256 = BigInt(\"0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\");\n;\n;\nfunction hexPadRight(value) {\n    const bytes = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBytes)(value);\n    const padOffset = bytes.length % 32;\n    if (padOffset) {\n        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.concat)([\n            bytes,\n            padding.slice(padOffset)\n        ]);\n    }\n    return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(bytes);\n}\nconst hexTrue = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.toBeHex)(BN_1, 32);\nconst hexFalse = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.toBeHex)(BN_0, 32);\nconst domainFieldTypes = {\n    name: \"string\",\n    version: \"string\",\n    chainId: \"uint256\",\n    verifyingContract: \"address\",\n    salt: \"bytes32\"\n};\nconst domainFieldNames = [\n    \"name\",\n    \"version\",\n    \"chainId\",\n    \"verifyingContract\",\n    \"salt\"\n];\nfunction checkString(key) {\n    return function(value) {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(typeof value === \"string\", `invalid domain value for ${JSON.stringify(key)}`, `domain.${key}`, value);\n        return value;\n    };\n}\nconst domainChecks = {\n    name: checkString(\"name\"),\n    version: checkString(\"version\"),\n    chainId: function(_value) {\n        const value = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.getBigInt)(_value, \"domain.chainId\");\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(value >= 0, \"invalid chain ID\", \"domain.chainId\", _value);\n        if (Number.isSafeInteger(value)) {\n            return Number(value);\n        }\n        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.toQuantity)(value);\n    },\n    verifyingContract: function(value) {\n        try {\n            return (0,_address_index_js__WEBPACK_IMPORTED_MODULE_3__.getAddress)(value).toLowerCase();\n        } catch (error) {}\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(false, `invalid domain value \"verifyingContract\"`, \"domain.verifyingContract\", value);\n    },\n    salt: function(value) {\n        const bytes = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBytes)(value, \"domain.salt\");\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(bytes.length === 32, `invalid domain value \"salt\"`, \"domain.salt\", value);\n        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(bytes);\n    }\n};\nfunction getBaseEncoder(type) {\n    // intXX and uintXX\n    {\n        const match = type.match(/^(u?)int(\\d+)$/);\n        if (match) {\n            const signed = match[1] === \"\";\n            const width = parseInt(match[2]);\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(width % 8 === 0 && width !== 0 && width <= 256 && match[2] === String(width), \"invalid numeric width\", \"type\", type);\n            const boundsUpper = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.mask)(BN_MAX_UINT256, signed ? width - 1 : width);\n            const boundsLower = signed ? (boundsUpper + BN_1) * BN__1 : BN_0;\n            return function(_value) {\n                const value = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.getBigInt)(_value, \"value\");\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(value >= boundsLower && value <= boundsUpper, `value out-of-bounds for ${type}`, \"value\", value);\n                return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.toBeHex)(signed ? (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.toTwos)(value, 256) : value, 32);\n            };\n        }\n    }\n    // bytesXX\n    {\n        const match = type.match(/^bytes(\\d+)$/);\n        if (match) {\n            const width = parseInt(match[1]);\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(width !== 0 && width <= 32 && match[1] === String(width), \"invalid bytes width\", \"type\", type);\n            return function(value) {\n                const bytes = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBytes)(value);\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(bytes.length === width, `invalid length for ${type}`, \"value\", value);\n                return hexPadRight(value);\n            };\n        }\n    }\n    switch(type){\n        case \"address\":\n            return function(value) {\n                return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.zeroPadValue)((0,_address_index_js__WEBPACK_IMPORTED_MODULE_3__.getAddress)(value), 32);\n            };\n        case \"bool\":\n            return function(value) {\n                return !value ? hexFalse : hexTrue;\n            };\n        case \"bytes\":\n            return function(value) {\n                return (0,_crypto_index_js__WEBPACK_IMPORTED_MODULE_4__.keccak256)(value);\n            };\n        case \"string\":\n            return function(value) {\n                return (0,_id_js__WEBPACK_IMPORTED_MODULE_5__.id)(value);\n            };\n    }\n    return null;\n}\nfunction encodeType(name, fields) {\n    return `${name}(${fields.map(({ name, type })=>type + \" \" + name).join(\",\")})`;\n}\n// foo[][3] => { base: \"foo\", index: \"[][3]\", array: {\n//     base: \"foo\", prefix: \"foo[]\", count: 3 } }\nfunction splitArray(type) {\n    const match = type.match(/^([^\\x5b]*)((\\x5b\\d*\\x5d)*)(\\x5b(\\d*)\\x5d)$/);\n    if (match) {\n        return {\n            base: match[1],\n            index: match[2] + match[4],\n            array: {\n                base: match[1],\n                prefix: match[1] + match[2],\n                count: match[5] ? parseInt(match[5]) : -1\n            }\n        };\n    }\n    return {\n        base: type\n    };\n}\n/**\n *  A **TypedDataEncode** prepares and encodes [[link-eip-712]] payloads\n *  for signed typed data.\n *\n *  This is useful for those that wish to compute various components of a\n *  typed data hash, primary types, or sub-components, but generally the\n *  higher level [[Signer-signTypedData]] is more useful.\n */ class TypedDataEncoder {\n    #types;\n    /**\n     *  The types.\n     */ get types() {\n        return JSON.parse(this.#types);\n    }\n    #fullTypes;\n    #encoderCache;\n    /**\n     *  Create a new **TypedDataEncoder** for %%types%%.\n     *\n     *  This performs all necessary checking that types are valid and\n     *  do not violate the [[link-eip-712]] structural constraints as\n     *  well as computes the [[primaryType]].\n     */ constructor(_types){\n        this.#fullTypes = new Map();\n        this.#encoderCache = new Map();\n        // Link struct types to their direct child structs\n        const links = new Map();\n        // Link structs to structs which contain them as a child\n        const parents = new Map();\n        // Link all subtypes within a given struct\n        const subtypes = new Map();\n        const types = {};\n        Object.keys(_types).forEach((type)=>{\n            types[type] = _types[type].map(({ name, type })=>{\n                // Normalize the base type (unless name conflict)\n                let { base, index } = splitArray(type);\n                if (base === \"int\" && !_types[\"int\"]) {\n                    base = \"int256\";\n                }\n                if (base === \"uint\" && !_types[\"uint\"]) {\n                    base = \"uint256\";\n                }\n                return {\n                    name,\n                    type: base + (index || \"\")\n                };\n            });\n            links.set(type, new Set());\n            parents.set(type, []);\n            subtypes.set(type, new Set());\n        });\n        this.#types = JSON.stringify(types);\n        for(const name in types){\n            const uniqueNames = new Set();\n            for (const field of types[name]){\n                // Check each field has a unique name\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(!uniqueNames.has(field.name), `duplicate variable name ${JSON.stringify(field.name)} in ${JSON.stringify(name)}`, \"types\", _types);\n                uniqueNames.add(field.name);\n                // Get the base type (drop any array specifiers)\n                const baseType = splitArray(field.type).base;\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(baseType !== name, `circular type reference to ${JSON.stringify(baseType)}`, \"types\", _types);\n                // Is this a base encoding type?\n                const encoder = getBaseEncoder(baseType);\n                if (encoder) {\n                    continue;\n                }\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(parents.has(baseType), `unknown type ${JSON.stringify(baseType)}`, \"types\", _types);\n                // Add linkage\n                parents.get(baseType).push(name);\n                links.get(name).add(baseType);\n            }\n        }\n        // Deduce the primary type\n        const primaryTypes = Array.from(parents.keys()).filter((n)=>parents.get(n).length === 0);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(primaryTypes.length !== 0, \"missing primary type\", \"types\", _types);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(primaryTypes.length === 1, `ambiguous primary types or unused types: ${primaryTypes.map((t)=>JSON.stringify(t)).join(\", \")}`, \"types\", _types);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_6__.defineProperties)(this, {\n            primaryType: primaryTypes[0]\n        });\n        // Check for circular type references\n        function checkCircular(type, found) {\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(!found.has(type), `circular type reference to ${JSON.stringify(type)}`, \"types\", _types);\n            found.add(type);\n            for (const child of links.get(type)){\n                if (!parents.has(child)) {\n                    continue;\n                }\n                // Recursively check children\n                checkCircular(child, found);\n                // Mark all ancestors as having this decendant\n                for (const subtype of found){\n                    subtypes.get(subtype).add(child);\n                }\n            }\n            found.delete(type);\n        }\n        checkCircular(this.primaryType, new Set());\n        // Compute each fully describe type\n        for (const [name, set] of subtypes){\n            const st = Array.from(set);\n            st.sort();\n            this.#fullTypes.set(name, encodeType(name, types[name]) + st.map((t)=>encodeType(t, types[t])).join(\"\"));\n        }\n    }\n    /**\n     *  Returnthe encoder for the specific %%type%%.\n     */ getEncoder(type) {\n        let encoder = this.#encoderCache.get(type);\n        if (!encoder) {\n            encoder = this.#getEncoder(type);\n            this.#encoderCache.set(type, encoder);\n        }\n        return encoder;\n    }\n    #getEncoder(type) {\n        // Basic encoder type (address, bool, uint256, etc)\n        {\n            const encoder = getBaseEncoder(type);\n            if (encoder) {\n                return encoder;\n            }\n        }\n        // Array\n        const array = splitArray(type).array;\n        if (array) {\n            const subtype = array.prefix;\n            const subEncoder = this.getEncoder(subtype);\n            return (value)=>{\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(array.count === -1 || array.count === value.length, `array length mismatch; expected length ${array.count}`, \"value\", value);\n                let result = value.map(subEncoder);\n                if (this.#fullTypes.has(subtype)) {\n                    result = result.map(_crypto_index_js__WEBPACK_IMPORTED_MODULE_4__.keccak256);\n                }\n                return (0,_crypto_index_js__WEBPACK_IMPORTED_MODULE_4__.keccak256)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.concat)(result));\n            };\n        }\n        // Struct\n        const fields = this.types[type];\n        if (fields) {\n            const encodedType = (0,_id_js__WEBPACK_IMPORTED_MODULE_5__.id)(this.#fullTypes.get(type));\n            return (value)=>{\n                const values = fields.map(({ name, type })=>{\n                    const result = this.getEncoder(type)(value[name]);\n                    if (this.#fullTypes.has(type)) {\n                        return (0,_crypto_index_js__WEBPACK_IMPORTED_MODULE_4__.keccak256)(result);\n                    }\n                    return result;\n                });\n                values.unshift(encodedType);\n                return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.concat)(values);\n            };\n        }\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(false, `unknown type: ${type}`, \"type\", type);\n    }\n    /**\n     *  Return the full type for %%name%%.\n     */ encodeType(name) {\n        const result = this.#fullTypes.get(name);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(result, `unknown type: ${JSON.stringify(name)}`, \"name\", name);\n        return result;\n    }\n    /**\n     *  Return the encoded %%value%% for the %%type%%.\n     */ encodeData(type, value) {\n        return this.getEncoder(type)(value);\n    }\n    /**\n     *  Returns the hash of %%value%% for the type of %%name%%.\n     */ hashStruct(name, value) {\n        return (0,_crypto_index_js__WEBPACK_IMPORTED_MODULE_4__.keccak256)(this.encodeData(name, value));\n    }\n    /**\n     *  Return the fulled encoded %%value%% for the [[types]].\n     */ encode(value) {\n        return this.encodeData(this.primaryType, value);\n    }\n    /**\n     *  Return the hash of the fully encoded %%value%% for the [[types]].\n     */ hash(value) {\n        return this.hashStruct(this.primaryType, value);\n    }\n    /**\n     *  @_ignore:\n     */ _visit(type, value, callback) {\n        // Basic encoder type (address, bool, uint256, etc)\n        {\n            const encoder = getBaseEncoder(type);\n            if (encoder) {\n                return callback(type, value);\n            }\n        }\n        // Array\n        const array = splitArray(type).array;\n        if (array) {\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(array.count === -1 || array.count === value.length, `array length mismatch; expected length ${array.count}`, \"value\", value);\n            return value.map((v)=>this._visit(array.prefix, v, callback));\n        }\n        // Struct\n        const fields = this.types[type];\n        if (fields) {\n            return fields.reduce((accum, { name, type })=>{\n                accum[name] = this._visit(type, value[name], callback);\n                return accum;\n            }, {});\n        }\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(false, `unknown type: ${type}`, \"type\", type);\n    }\n    /**\n     *  Call %%calback%% for each value in %%value%%, passing the type and\n     *  component within %%value%%.\n     *\n     *  This is useful for replacing addresses or other transformation that\n     *  may be desired on each component, based on its type.\n     */ visit(value, callback) {\n        return this._visit(this.primaryType, value, callback);\n    }\n    /**\n     *  Create a new **TypedDataEncoder** for %%types%%.\n     */ static from(types) {\n        return new TypedDataEncoder(types);\n    }\n    /**\n     *  Return the primary type for %%types%%.\n     */ static getPrimaryType(types) {\n        return TypedDataEncoder.from(types).primaryType;\n    }\n    /**\n     *  Return the hashed struct for %%value%% using %%types%% and %%name%%.\n     */ static hashStruct(name, types, value) {\n        return TypedDataEncoder.from(types).hashStruct(name, value);\n    }\n    /**\n     *  Return the domain hash for %%domain%%.\n     */ static hashDomain(domain) {\n        const domainFields = [];\n        for(const name in domain){\n            if (domain[name] == null) {\n                continue;\n            }\n            const type = domainFieldTypes[name];\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(type, `invalid typed-data domain key: ${JSON.stringify(name)}`, \"domain\", domain);\n            domainFields.push({\n                name,\n                type\n            });\n        }\n        domainFields.sort((a, b)=>{\n            return domainFieldNames.indexOf(a.name) - domainFieldNames.indexOf(b.name);\n        });\n        return TypedDataEncoder.hashStruct(\"EIP712Domain\", {\n            EIP712Domain: domainFields\n        }, domain);\n    }\n    /**\n     *  Return the fully encoded [[link-eip-712]] %%value%% for %%types%% with %%domain%%.\n     */ static encode(domain, types, value) {\n        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.concat)([\n            \"0x1901\",\n            TypedDataEncoder.hashDomain(domain),\n            TypedDataEncoder.from(types).hash(value)\n        ]);\n    }\n    /**\n     *  Return the hash of the fully encoded [[link-eip-712]] %%value%% for %%types%% with %%domain%%.\n     */ static hash(domain, types, value) {\n        return (0,_crypto_index_js__WEBPACK_IMPORTED_MODULE_4__.keccak256)(TypedDataEncoder.encode(domain, types, value));\n    }\n    // Replaces all address types with ENS names with their looked up address\n    /**\n     * Resolves to the value from resolving all addresses in %%value%% for\n     * %%types%% and the %%domain%%.\n     */ static async resolveNames(domain, types, value, resolveName) {\n        // Make a copy to isolate it from the object passed in\n        domain = Object.assign({}, domain);\n        // Allow passing null to ignore value\n        for(const key in domain){\n            if (domain[key] == null) {\n                delete domain[key];\n            }\n        }\n        // Look up all ENS names\n        const ensCache = {};\n        // Do we need to look up the domain's verifyingContract?\n        if (domain.verifyingContract && !(0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.isHexString)(domain.verifyingContract, 20)) {\n            ensCache[domain.verifyingContract] = \"0x\";\n        }\n        // We are going to use the encoder to visit all the base values\n        const encoder = TypedDataEncoder.from(types);\n        // Get a list of all the addresses\n        encoder.visit(value, (type, value)=>{\n            if (type === \"address\" && !(0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.isHexString)(value, 20)) {\n                ensCache[value] = \"0x\";\n            }\n            return value;\n        });\n        // Lookup each name\n        for(const name in ensCache){\n            ensCache[name] = await resolveName(name);\n        }\n        // Replace the domain verifyingContract if needed\n        if (domain.verifyingContract && ensCache[domain.verifyingContract]) {\n            domain.verifyingContract = ensCache[domain.verifyingContract];\n        }\n        // Replace all ENS names with their address\n        value = encoder.visit(value, (type, value)=>{\n            if (type === \"address\" && ensCache[value]) {\n                return ensCache[value];\n            }\n            return value;\n        });\n        return {\n            domain,\n            value\n        };\n    }\n    /**\n     *  Returns the JSON-encoded payload expected by nodes which implement\n     *  the JSON-RPC [[link-eip-712]] method.\n     */ static getPayload(domain, types, value) {\n        // Validate the domain fields\n        TypedDataEncoder.hashDomain(domain);\n        // Derive the EIP712Domain Struct reference type\n        const domainValues = {};\n        const domainTypes = [];\n        domainFieldNames.forEach((name)=>{\n            const value = domain[name];\n            if (value == null) {\n                return;\n            }\n            domainValues[name] = domainChecks[name](value);\n            domainTypes.push({\n                name,\n                type: domainFieldTypes[name]\n            });\n        });\n        const encoder = TypedDataEncoder.from(types);\n        // Get the normalized types\n        types = encoder.types;\n        const typesWithDomain = Object.assign({}, types);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(typesWithDomain.EIP712Domain == null, \"types must not contain EIP712Domain type\", \"types.EIP712Domain\", types);\n        typesWithDomain.EIP712Domain = domainTypes;\n        // Validate the data structures and types\n        encoder.encode(value);\n        return {\n            types: typesWithDomain,\n            domain: domainValues,\n            primaryType: encoder.primaryType,\n            message: encoder.visit(value, (type, value)=>{\n                // bytes\n                if (type.match(/^bytes(\\d*)/)) {\n                    return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBytes)(value));\n                }\n                // uint or int\n                if (type.match(/^u?int/)) {\n                    return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.getBigInt)(value).toString();\n                }\n                switch(type){\n                    case \"address\":\n                        return value.toLowerCase();\n                    case \"bool\":\n                        return !!value;\n                    case \"string\":\n                        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(typeof value === \"string\", \"invalid string\", \"value\", value);\n                        return value;\n                }\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(false, \"unsupported type\", \"type\", type);\n            })\n        };\n    }\n}\n/**\n *  Compute the address used to sign the typed data for the %%signature%%.\n */ function verifyTypedData(domain, types, value, signature) {\n    return (0,_transaction_index_js__WEBPACK_IMPORTED_MODULE_7__.recoverAddress)(TypedDataEncoder.hash(domain, types, value), signature);\n} //# sourceMappingURL=typed-data.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vaGFzaC90eXBlZC1kYXRhLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFBQSwyRkFBMkY7QUFDMUM7QUFDRjtBQUNVO0FBQ2dIO0FBQzVJO0FBQzdCLE1BQU1nQixVQUFVLElBQUlDLFdBQVc7QUFDL0JELFFBQVFFLElBQUksQ0FBQztBQUNiLE1BQU1DLFFBQVFDLE9BQU8sQ0FBQztBQUN0QixNQUFNQyxPQUFPRCxPQUFPO0FBQ3BCLE1BQU1FLE9BQU9GLE9BQU87QUFDcEIsTUFBTUcsaUJBQWlCSCxPQUFPOzs7QUFHOUIsU0FBU0ksWUFBWUMsS0FBSztJQUN0QixNQUFNQyxRQUFRcEIseURBQVFBLENBQUNtQjtJQUN2QixNQUFNRSxZQUFZRCxNQUFNRSxNQUFNLEdBQUc7SUFDakMsSUFBSUQsV0FBVztRQUNYLE9BQU94Qix1REFBTUEsQ0FBQztZQUFDdUI7WUFBT1YsUUFBUWEsS0FBSyxDQUFDRjtTQUFXO0lBQ25EO0lBQ0EsT0FBT3BCLHdEQUFPQSxDQUFDbUI7QUFDbkI7QUFDQSxNQUFNSSxVQUFVcEIsd0RBQU9BLENBQUNZLE1BQU07QUFDOUIsTUFBTVMsV0FBV3JCLHdEQUFPQSxDQUFDVyxNQUFNO0FBQy9CLE1BQU1XLG1CQUFtQjtJQUNyQkMsTUFBTTtJQUNOQyxTQUFTO0lBQ1RDLFNBQVM7SUFDVEMsbUJBQW1CO0lBQ25CQyxNQUFNO0FBQ1Y7QUFDQSxNQUFNQyxtQkFBbUI7SUFDckI7SUFBUTtJQUFXO0lBQVc7SUFBcUI7Q0FDdEQ7QUFDRCxTQUFTQyxZQUFZQyxHQUFHO0lBQ3BCLE9BQU8sU0FBVWYsS0FBSztRQUNsQlgsK0RBQWNBLENBQUMsT0FBUVcsVUFBVyxVQUFVLENBQUMseUJBQXlCLEVBQUVnQixLQUFLQyxTQUFTLENBQUNGLEtBQUssQ0FBQyxFQUFFLENBQUMsT0FBTyxFQUFFQSxJQUFJLENBQUMsRUFBRWY7UUFDaEgsT0FBT0E7SUFDWDtBQUNKO0FBQ0EsTUFBTWtC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QVFvSDtBQUN2RSxFQUNBLHNDQUFzQyIsInNvdXJjZXMiOlsid2VicGFjazovL21lZ2F2aWJlLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL2hhc2gvdHlwZWQtZGF0YS5qcz8yMWU5Il0sInNvdXJjZXNDb250ZW50IjpbIi8vaW1wb3J0IHsgVHlwZWREYXRhRG9tYWluLCBUeXBlZERhdGFGaWVsZCB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9wcm92aWRlcmFic3RyYWN0LXNpZ25lclwiO1xuaW1wb3J0IHsgZ2V0QWRkcmVzcyB9IGZyb20gXCIuLi9hZGRyZXNzL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBrZWNjYWsyNTYgfSBmcm9tIFwiLi4vY3J5cHRvL2luZGV4LmpzXCI7XG5pbXBvcnQgeyByZWNvdmVyQWRkcmVzcyB9IGZyb20gXCIuLi90cmFuc2FjdGlvbi9pbmRleC5qc1wiO1xuaW1wb3J0IHsgY29uY2F0LCBkZWZpbmVQcm9wZXJ0aWVzLCBnZXRCaWdJbnQsIGdldEJ5dGVzLCBoZXhsaWZ5LCBpc0hleFN0cmluZywgbWFzaywgdG9CZUhleCwgdG9RdWFudGl0eSwgdG9Ud29zLCB6ZXJvUGFkVmFsdWUsIGFzc2VydEFyZ3VtZW50IH0gZnJvbSBcIi4uL3V0aWxzL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBpZCB9IGZyb20gXCIuL2lkLmpzXCI7XG5jb25zdCBwYWRkaW5nID0gbmV3IFVpbnQ4QXJyYXkoMzIpO1xucGFkZGluZy5maWxsKDApO1xuY29uc3QgQk5fXzEgPSBCaWdJbnQoLTEpO1xuY29uc3QgQk5fMCA9IEJpZ0ludCgwKTtcbmNvbnN0IEJOXzEgPSBCaWdJbnQoMSk7XG5jb25zdCBCTl9NQVhfVUlOVDI1NiA9IEJpZ0ludChcIjB4ZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZlwiKTtcbjtcbjtcbmZ1bmN0aW9uIGhleFBhZFJpZ2h0KHZhbHVlKSB7XG4gICAgY29uc3QgYnl0ZXMgPSBnZXRCeXRlcyh2YWx1ZSk7XG4gICAgY29uc3QgcGFkT2Zmc2V0ID0gYnl0ZXMubGVuZ3RoICUgMzI7XG4gICAgaWYgKHBhZE9mZnNldCkge1xuICAgICAgICByZXR1cm4gY29uY2F0KFtieXRlcywgcGFkZGluZy5zbGljZShwYWRPZmZzZXQpXSk7XG4gICAgfVxuICAgIHJldHVybiBoZXhsaWZ5KGJ5dGVzKTtcbn1cbmNvbnN0IGhleFRydWUgPSB0b0JlSGV4KEJOXzEsIDMyKTtcbmNvbnN0IGhleEZhbHNlID0gdG9CZUhleChCTl8wLCAzMik7XG5jb25zdCBkb21haW5GaWVsZFR5cGVzID0ge1xuICAgIG5hbWU6IFwic3RyaW5nXCIsXG4gICAgdmVyc2lvbjogXCJzdHJpbmdcIixcbiAgICBjaGFpbklkOiBcInVpbnQyNTZcIixcbiAgICB2ZXJpZnlpbmdDb250cmFjdDogXCJhZGRyZXNzXCIsXG4gICAgc2FsdDogXCJieXRlczMyXCJcbn07XG5jb25zdCBkb21haW5GaWVsZE5hbWVzID0gW1xuICAgIFwibmFtZVwiLCBcInZlcnNpb25cIiwgXCJjaGFpbklkXCIsIFwidmVyaWZ5aW5nQ29udHJhY3RcIiwgXCJzYWx0XCJcbl07XG5mdW5jdGlvbiBjaGVja1N0cmluZyhrZXkpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KHR5cGVvZiAodmFsdWUpID09PSBcInN0cmluZ1wiLCBgaW52YWxpZCBkb21haW4gdmFsdWUgZm9yICR7SlNPTi5zdHJpbmdpZnkoa2V5KX1gLCBgZG9tYWluLiR7a2V5fWAsIHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH07XG59XG5jb25zdCBkb21haW5DaGVja3MgPSB7XG4gICAgbmFtZTogY2hlY2tTdHJpbmcoXCJuYW1lXCIpLFxuICAgIHZlcnNpb246IGNoZWNrU3RyaW5nKFwidmVyc2lvblwiKSxcbiAgICBjaGFpbklkOiBmdW5jdGlvbiAoX3ZhbHVlKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gZ2V0QmlnSW50KF92YWx1ZSwgXCJkb21haW4uY2hhaW5JZFwiKTtcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQodmFsdWUgPj0gMCwgXCJpbnZhbGlkIGNoYWluIElEXCIsIFwiZG9tYWluLmNoYWluSWRcIiwgX3ZhbHVlKTtcbiAgICAgICAgaWYgKE51bWJlci5pc1NhZmVJbnRlZ2VyKHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIE51bWJlcih2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRvUXVhbnRpdHkodmFsdWUpO1xuICAgIH0sXG4gICAgdmVyaWZ5aW5nQ29udHJhY3Q6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGdldEFkZHJlc3ModmFsdWUpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7IH1cbiAgICAgICAgYXNzZXJ0QXJndW1lbnQoZmFsc2UsIGBpbnZhbGlkIGRvbWFpbiB2YWx1ZSBcInZlcmlmeWluZ0NvbnRyYWN0XCJgLCBcImRvbWFpbi52ZXJpZnlpbmdDb250cmFjdFwiLCB2YWx1ZSk7XG4gICAgfSxcbiAgICBzYWx0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgY29uc3QgYnl0ZXMgPSBnZXRCeXRlcyh2YWx1ZSwgXCJkb21haW4uc2FsdFwiKTtcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQoYnl0ZXMubGVuZ3RoID09PSAzMiwgYGludmFsaWQgZG9tYWluIHZhbHVlIFwic2FsdFwiYCwgXCJkb21haW4uc2FsdFwiLCB2YWx1ZSk7XG4gICAgICAgIHJldHVybiBoZXhsaWZ5KGJ5dGVzKTtcbiAgICB9XG59O1xuZnVuY3Rpb24gZ2V0QmFzZUVuY29kZXIodHlwZSkge1xuICAgIC8vIGludFhYIGFuZCB1aW50WFhcbiAgICB7XG4gICAgICAgIGNvbnN0IG1hdGNoID0gdHlwZS5tYXRjaCgvXih1PylpbnQoXFxkKykkLyk7XG4gICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgY29uc3Qgc2lnbmVkID0gKG1hdGNoWzFdID09PSBcIlwiKTtcbiAgICAgICAgICAgIGNvbnN0IHdpZHRoID0gcGFyc2VJbnQobWF0Y2hbMl0pO1xuICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQod2lkdGggJSA4ID09PSAwICYmIHdpZHRoICE9PSAwICYmIHdpZHRoIDw9IDI1NiAmJiBtYXRjaFsyXSA9PT0gU3RyaW5nKHdpZHRoKSwgXCJpbnZhbGlkIG51bWVyaWMgd2lkdGhcIiwgXCJ0eXBlXCIsIHR5cGUpO1xuICAgICAgICAgICAgY29uc3QgYm91bmRzVXBwZXIgPSBtYXNrKEJOX01BWF9VSU5UMjU2LCBzaWduZWQgPyAod2lkdGggLSAxKSA6IHdpZHRoKTtcbiAgICAgICAgICAgIGNvbnN0IGJvdW5kc0xvd2VyID0gc2lnbmVkID8gKChib3VuZHNVcHBlciArIEJOXzEpICogQk5fXzEpIDogQk5fMDtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoX3ZhbHVlKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBnZXRCaWdJbnQoX3ZhbHVlLCBcInZhbHVlXCIpO1xuICAgICAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KHZhbHVlID49IGJvdW5kc0xvd2VyICYmIHZhbHVlIDw9IGJvdW5kc1VwcGVyLCBgdmFsdWUgb3V0LW9mLWJvdW5kcyBmb3IgJHt0eXBlfWAsIFwidmFsdWVcIiwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0b0JlSGV4KHNpZ25lZCA/IHRvVHdvcyh2YWx1ZSwgMjU2KSA6IHZhbHVlLCAzMik7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIGJ5dGVzWFhcbiAgICB7XG4gICAgICAgIGNvbnN0IG1hdGNoID0gdHlwZS5tYXRjaCgvXmJ5dGVzKFxcZCspJC8pO1xuICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgIGNvbnN0IHdpZHRoID0gcGFyc2VJbnQobWF0Y2hbMV0pO1xuICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQod2lkdGggIT09IDAgJiYgd2lkdGggPD0gMzIgJiYgbWF0Y2hbMV0gPT09IFN0cmluZyh3aWR0aCksIFwiaW52YWxpZCBieXRlcyB3aWR0aFwiLCBcInR5cGVcIiwgdHlwZSk7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYnl0ZXMgPSBnZXRCeXRlcyh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoYnl0ZXMubGVuZ3RoID09PSB3aWR0aCwgYGludmFsaWQgbGVuZ3RoIGZvciAke3R5cGV9YCwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGhleFBhZFJpZ2h0KHZhbHVlKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgXCJhZGRyZXNzXCI6IHJldHVybiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiB6ZXJvUGFkVmFsdWUoZ2V0QWRkcmVzcyh2YWx1ZSksIDMyKTtcbiAgICAgICAgfTtcbiAgICAgICAgY2FzZSBcImJvb2xcIjogcmV0dXJuIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuICgoIXZhbHVlKSA/IGhleEZhbHNlIDogaGV4VHJ1ZSk7XG4gICAgICAgIH07XG4gICAgICAgIGNhc2UgXCJieXRlc1wiOiByZXR1cm4gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4ga2VjY2FrMjU2KHZhbHVlKTtcbiAgICAgICAgfTtcbiAgICAgICAgY2FzZSBcInN0cmluZ1wiOiByZXR1cm4gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gaWQodmFsdWUpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGVuY29kZVR5cGUobmFtZSwgZmllbGRzKSB7XG4gICAgcmV0dXJuIGAke25hbWV9KCR7ZmllbGRzLm1hcCgoeyBuYW1lLCB0eXBlIH0pID0+ICh0eXBlICsgXCIgXCIgKyBuYW1lKSkuam9pbihcIixcIil9KWA7XG59XG4vLyBmb29bXVszXSA9PiB7IGJhc2U6IFwiZm9vXCIsIGluZGV4OiBcIltdWzNdXCIsIGFycmF5OiB7XG4vLyAgICAgYmFzZTogXCJmb29cIiwgcHJlZml4OiBcImZvb1tdXCIsIGNvdW50OiAzIH0gfVxuZnVuY3Rpb24gc3BsaXRBcnJheSh0eXBlKSB7XG4gICAgY29uc3QgbWF0Y2ggPSB0eXBlLm1hdGNoKC9eKFteXFx4NWJdKikoKFxceDViXFxkKlxceDVkKSopKFxceDViKFxcZCopXFx4NWQpJC8pO1xuICAgIGlmIChtYXRjaCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYmFzZTogbWF0Y2hbMV0sXG4gICAgICAgICAgICBpbmRleDogKG1hdGNoWzJdICsgbWF0Y2hbNF0pLFxuICAgICAgICAgICAgYXJyYXk6IHtcbiAgICAgICAgICAgICAgICBiYXNlOiBtYXRjaFsxXSxcbiAgICAgICAgICAgICAgICBwcmVmaXg6IChtYXRjaFsxXSArIG1hdGNoWzJdKSxcbiAgICAgICAgICAgICAgICBjb3VudDogKG1hdGNoWzVdID8gcGFyc2VJbnQobWF0Y2hbNV0pIDogLTEpLFxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4geyBiYXNlOiB0eXBlIH07XG59XG4vKipcbiAqICBBICoqVHlwZWREYXRhRW5jb2RlKiogcHJlcGFyZXMgYW5kIGVuY29kZXMgW1tsaW5rLWVpcC03MTJdXSBwYXlsb2Fkc1xuICogIGZvciBzaWduZWQgdHlwZWQgZGF0YS5cbiAqXG4gKiAgVGhpcyBpcyB1c2VmdWwgZm9yIHRob3NlIHRoYXQgd2lzaCB0byBjb21wdXRlIHZhcmlvdXMgY29tcG9uZW50cyBvZiBhXG4gKiAgdHlwZWQgZGF0YSBoYXNoLCBwcmltYXJ5IHR5cGVzLCBvciBzdWItY29tcG9uZW50cywgYnV0IGdlbmVyYWxseSB0aGVcbiAqICBoaWdoZXIgbGV2ZWwgW1tTaWduZXItc2lnblR5cGVkRGF0YV1dIGlzIG1vcmUgdXNlZnVsLlxuICovXG5leHBvcnQgY2xhc3MgVHlwZWREYXRhRW5jb2RlciB7XG4gICAgLyoqXG4gICAgICogIFRoZSBwcmltYXJ5IHR5cGUgZm9yIHRoZSBzdHJ1Y3R1cmVkIFtbdHlwZXNdXS5cbiAgICAgKlxuICAgICAqICBUaGlzIGlzIGRlcml2ZWQgYXV0b21hdGljYWxseSBmcm9tIHRoZSBbW3R5cGVzXV0sIHNpbmNlIG5vXG4gICAgICogIHJlY3Vyc2lvbiBpcyBwb3NzaWJsZSwgb25jZSB0aGUgREFHIGZvciB0aGUgdHlwZXMgaXMgY29uc3R1cmN0ZWRcbiAgICAgKiAgaW50ZXJuYWxseSwgdGhlIHByaW1hcnkgdHlwZSBtdXN0IGJlIHRoZSBvbmx5IHJlbWFpbmluZyB0eXBlIHdpdGhcbiAgICAgKiAgbm8gcGFyZW50IG5vZGVzLlxuICAgICAqL1xuICAgIHByaW1hcnlUeXBlO1xuICAgICN0eXBlcztcbiAgICAvKipcbiAgICAgKiAgVGhlIHR5cGVzLlxuICAgICAqL1xuICAgIGdldCB0eXBlcygpIHtcbiAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UodGhpcy4jdHlwZXMpO1xuICAgIH1cbiAgICAjZnVsbFR5cGVzO1xuICAgICNlbmNvZGVyQ2FjaGU7XG4gICAgLyoqXG4gICAgICogIENyZWF0ZSBhIG5ldyAqKlR5cGVkRGF0YUVuY29kZXIqKiBmb3IgJSV0eXBlcyUlLlxuICAgICAqXG4gICAgICogIFRoaXMgcGVyZm9ybXMgYWxsIG5lY2Vzc2FyeSBjaGVja2luZyB0aGF0IHR5cGVzIGFyZSB2YWxpZCBhbmRcbiAgICAgKiAgZG8gbm90IHZpb2xhdGUgdGhlIFtbbGluay1laXAtNzEyXV0gc3RydWN0dXJhbCBjb25zdHJhaW50cyBhc1xuICAgICAqICB3ZWxsIGFzIGNvbXB1dGVzIHRoZSBbW3ByaW1hcnlUeXBlXV0uXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoX3R5cGVzKSB7XG4gICAgICAgIHRoaXMuI2Z1bGxUeXBlcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy4jZW5jb2RlckNhY2hlID0gbmV3IE1hcCgpO1xuICAgICAgICAvLyBMaW5rIHN0cnVjdCB0eXBlcyB0byB0aGVpciBkaXJlY3QgY2hpbGQgc3RydWN0c1xuICAgICAgICBjb25zdCBsaW5rcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgLy8gTGluayBzdHJ1Y3RzIHRvIHN0cnVjdHMgd2hpY2ggY29udGFpbiB0aGVtIGFzIGEgY2hpbGRcbiAgICAgICAgY29uc3QgcGFyZW50cyA9IG5ldyBNYXAoKTtcbiAgICAgICAgLy8gTGluayBhbGwgc3VidHlwZXMgd2l0aGluIGEgZ2l2ZW4gc3RydWN0XG4gICAgICAgIGNvbnN0IHN1YnR5cGVzID0gbmV3IE1hcCgpO1xuICAgICAgICBjb25zdCB0eXBlcyA9IHt9O1xuICAgICAgICBPYmplY3Qua2V5cyhfdHlwZXMpLmZvckVhY2goKHR5cGUpID0+IHtcbiAgICAgICAgICAgIHR5cGVzW3R5cGVdID0gX3R5cGVzW3R5cGVdLm1hcCgoeyBuYW1lLCB0eXBlIH0pID0+IHtcbiAgICAgICAgICAgICAgICAvLyBOb3JtYWxpemUgdGhlIGJhc2UgdHlwZSAodW5sZXNzIG5hbWUgY29uZmxpY3QpXG4gICAgICAgICAgICAgICAgbGV0IHsgYmFzZSwgaW5kZXggfSA9IHNwbGl0QXJyYXkodHlwZSk7XG4gICAgICAgICAgICAgICAgaWYgKGJhc2UgPT09IFwiaW50XCIgJiYgIV90eXBlc1tcImludFwiXSkge1xuICAgICAgICAgICAgICAgICAgICBiYXNlID0gXCJpbnQyNTZcIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGJhc2UgPT09IFwidWludFwiICYmICFfdHlwZXNbXCJ1aW50XCJdKSB7XG4gICAgICAgICAgICAgICAgICAgIGJhc2UgPSBcInVpbnQyNTZcIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgbmFtZSwgdHlwZTogKGJhc2UgKyAoaW5kZXggfHwgXCJcIikpIH07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGxpbmtzLnNldCh0eXBlLCBuZXcgU2V0KCkpO1xuICAgICAgICAgICAgcGFyZW50cy5zZXQodHlwZSwgW10pO1xuICAgICAgICAgICAgc3VidHlwZXMuc2V0KHR5cGUsIG5ldyBTZXQoKSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLiN0eXBlcyA9IEpTT04uc3RyaW5naWZ5KHR5cGVzKTtcbiAgICAgICAgZm9yIChjb25zdCBuYW1lIGluIHR5cGVzKSB7XG4gICAgICAgICAgICBjb25zdCB1bmlxdWVOYW1lcyA9IG5ldyBTZXQoKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgZmllbGQgb2YgdHlwZXNbbmFtZV0pIHtcbiAgICAgICAgICAgICAgICAvLyBDaGVjayBlYWNoIGZpZWxkIGhhcyBhIHVuaXF1ZSBuYW1lXG4gICAgICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoIXVuaXF1ZU5hbWVzLmhhcyhmaWVsZC5uYW1lKSwgYGR1cGxpY2F0ZSB2YXJpYWJsZSBuYW1lICR7SlNPTi5zdHJpbmdpZnkoZmllbGQubmFtZSl9IGluICR7SlNPTi5zdHJpbmdpZnkobmFtZSl9YCwgXCJ0eXBlc1wiLCBfdHlwZXMpO1xuICAgICAgICAgICAgICAgIHVuaXF1ZU5hbWVzLmFkZChmaWVsZC5uYW1lKTtcbiAgICAgICAgICAgICAgICAvLyBHZXQgdGhlIGJhc2UgdHlwZSAoZHJvcCBhbnkgYXJyYXkgc3BlY2lmaWVycylcbiAgICAgICAgICAgICAgICBjb25zdCBiYXNlVHlwZSA9IHNwbGl0QXJyYXkoZmllbGQudHlwZSkuYmFzZTtcbiAgICAgICAgICAgICAgICBhc3NlcnRBcmd1bWVudChiYXNlVHlwZSAhPT0gbmFtZSwgYGNpcmN1bGFyIHR5cGUgcmVmZXJlbmNlIHRvICR7SlNPTi5zdHJpbmdpZnkoYmFzZVR5cGUpfWAsIFwidHlwZXNcIiwgX3R5cGVzKTtcbiAgICAgICAgICAgICAgICAvLyBJcyB0aGlzIGEgYmFzZSBlbmNvZGluZyB0eXBlP1xuICAgICAgICAgICAgICAgIGNvbnN0IGVuY29kZXIgPSBnZXRCYXNlRW5jb2RlcihiYXNlVHlwZSk7XG4gICAgICAgICAgICAgICAgaWYgKGVuY29kZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KHBhcmVudHMuaGFzKGJhc2VUeXBlKSwgYHVua25vd24gdHlwZSAke0pTT04uc3RyaW5naWZ5KGJhc2VUeXBlKX1gLCBcInR5cGVzXCIsIF90eXBlcyk7XG4gICAgICAgICAgICAgICAgLy8gQWRkIGxpbmthZ2VcbiAgICAgICAgICAgICAgICBwYXJlbnRzLmdldChiYXNlVHlwZSkucHVzaChuYW1lKTtcbiAgICAgICAgICAgICAgICBsaW5rcy5nZXQobmFtZSkuYWRkKGJhc2VUeXBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBEZWR1Y2UgdGhlIHByaW1hcnkgdHlwZVxuICAgICAgICBjb25zdCBwcmltYXJ5VHlwZXMgPSBBcnJheS5mcm9tKHBhcmVudHMua2V5cygpKS5maWx0ZXIoKG4pID0+IChwYXJlbnRzLmdldChuKS5sZW5ndGggPT09IDApKTtcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQocHJpbWFyeVR5cGVzLmxlbmd0aCAhPT0gMCwgXCJtaXNzaW5nIHByaW1hcnkgdHlwZVwiLCBcInR5cGVzXCIsIF90eXBlcyk7XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KHByaW1hcnlUeXBlcy5sZW5ndGggPT09IDEsIGBhbWJpZ3VvdXMgcHJpbWFyeSB0eXBlcyBvciB1bnVzZWQgdHlwZXM6ICR7cHJpbWFyeVR5cGVzLm1hcCgodCkgPT4gKEpTT04uc3RyaW5naWZ5KHQpKSkuam9pbihcIiwgXCIpfWAsIFwidHlwZXNcIiwgX3R5cGVzKTtcbiAgICAgICAgZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7IHByaW1hcnlUeXBlOiBwcmltYXJ5VHlwZXNbMF0gfSk7XG4gICAgICAgIC8vIENoZWNrIGZvciBjaXJjdWxhciB0eXBlIHJlZmVyZW5jZXNcbiAgICAgICAgZnVuY3Rpb24gY2hlY2tDaXJjdWxhcih0eXBlLCBmb3VuZCkge1xuICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoIWZvdW5kLmhhcyh0eXBlKSwgYGNpcmN1bGFyIHR5cGUgcmVmZXJlbmNlIHRvICR7SlNPTi5zdHJpbmdpZnkodHlwZSl9YCwgXCJ0eXBlc1wiLCBfdHlwZXMpO1xuICAgICAgICAgICAgZm91bmQuYWRkKHR5cGUpO1xuICAgICAgICAgICAgZm9yIChjb25zdCBjaGlsZCBvZiBsaW5rcy5nZXQodHlwZSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXBhcmVudHMuaGFzKGNoaWxkKSkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gUmVjdXJzaXZlbHkgY2hlY2sgY2hpbGRyZW5cbiAgICAgICAgICAgICAgICBjaGVja0NpcmN1bGFyKGNoaWxkLCBmb3VuZCk7XG4gICAgICAgICAgICAgICAgLy8gTWFyayBhbGwgYW5jZXN0b3JzIGFzIGhhdmluZyB0aGlzIGRlY2VuZGFudFxuICAgICAgICAgICAgICAgIGZvciAoY29uc3Qgc3VidHlwZSBvZiBmb3VuZCkge1xuICAgICAgICAgICAgICAgICAgICBzdWJ0eXBlcy5nZXQoc3VidHlwZSkuYWRkKGNoaWxkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3VuZC5kZWxldGUodHlwZSk7XG4gICAgICAgIH1cbiAgICAgICAgY2hlY2tDaXJjdWxhcih0aGlzLnByaW1hcnlUeXBlLCBuZXcgU2V0KCkpO1xuICAgICAgICAvLyBDb21wdXRlIGVhY2ggZnVsbHkgZGVzY3JpYmUgdHlwZVxuICAgICAgICBmb3IgKGNvbnN0IFtuYW1lLCBzZXRdIG9mIHN1YnR5cGVzKSB7XG4gICAgICAgICAgICBjb25zdCBzdCA9IEFycmF5LmZyb20oc2V0KTtcbiAgICAgICAgICAgIHN0LnNvcnQoKTtcbiAgICAgICAgICAgIHRoaXMuI2Z1bGxUeXBlcy5zZXQobmFtZSwgZW5jb2RlVHlwZShuYW1lLCB0eXBlc1tuYW1lXSkgKyBzdC5tYXAoKHQpID0+IGVuY29kZVR5cGUodCwgdHlwZXNbdF0pKS5qb2luKFwiXCIpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJudGhlIGVuY29kZXIgZm9yIHRoZSBzcGVjaWZpYyAlJXR5cGUlJS5cbiAgICAgKi9cbiAgICBnZXRFbmNvZGVyKHR5cGUpIHtcbiAgICAgICAgbGV0IGVuY29kZXIgPSB0aGlzLiNlbmNvZGVyQ2FjaGUuZ2V0KHR5cGUpO1xuICAgICAgICBpZiAoIWVuY29kZXIpIHtcbiAgICAgICAgICAgIGVuY29kZXIgPSB0aGlzLiNnZXRFbmNvZGVyKHR5cGUpO1xuICAgICAgICAgICAgdGhpcy4jZW5jb2RlckNhY2hlLnNldCh0eXBlLCBlbmNvZGVyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZW5jb2RlcjtcbiAgICB9XG4gICAgI2dldEVuY29kZXIodHlwZSkge1xuICAgICAgICAvLyBCYXNpYyBlbmNvZGVyIHR5cGUgKGFkZHJlc3MsIGJvb2wsIHVpbnQyNTYsIGV0YylcbiAgICAgICAge1xuICAgICAgICAgICAgY29uc3QgZW5jb2RlciA9IGdldEJhc2VFbmNvZGVyKHR5cGUpO1xuICAgICAgICAgICAgaWYgKGVuY29kZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZW5jb2RlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBBcnJheVxuICAgICAgICBjb25zdCBhcnJheSA9IHNwbGl0QXJyYXkodHlwZSkuYXJyYXk7XG4gICAgICAgIGlmIChhcnJheSkge1xuICAgICAgICAgICAgY29uc3Qgc3VidHlwZSA9IGFycmF5LnByZWZpeDtcbiAgICAgICAgICAgIGNvbnN0IHN1YkVuY29kZXIgPSB0aGlzLmdldEVuY29kZXIoc3VidHlwZSk7XG4gICAgICAgICAgICByZXR1cm4gKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoYXJyYXkuY291bnQgPT09IC0xIHx8IGFycmF5LmNvdW50ID09PSB2YWx1ZS5sZW5ndGgsIGBhcnJheSBsZW5ndGggbWlzbWF0Y2g7IGV4cGVjdGVkIGxlbmd0aCAke2FycmF5LmNvdW50fWAsIFwidmFsdWVcIiwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIGxldCByZXN1bHQgPSB2YWx1ZS5tYXAoc3ViRW5jb2Rlcik7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuI2Z1bGxUeXBlcy5oYXMoc3VidHlwZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0Lm1hcChrZWNjYWsyNTYpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4ga2VjY2FrMjU2KGNvbmNhdChyZXN1bHQpKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgLy8gU3RydWN0XG4gICAgICAgIGNvbnN0IGZpZWxkcyA9IHRoaXMudHlwZXNbdHlwZV07XG4gICAgICAgIGlmIChmaWVsZHMpIHtcbiAgICAgICAgICAgIGNvbnN0IGVuY29kZWRUeXBlID0gaWQodGhpcy4jZnVsbFR5cGVzLmdldCh0eXBlKSk7XG4gICAgICAgICAgICByZXR1cm4gKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWVzID0gZmllbGRzLm1hcCgoeyBuYW1lLCB0eXBlIH0pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5nZXRFbmNvZGVyKHR5cGUpKHZhbHVlW25hbWVdKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuI2Z1bGxUeXBlcy5oYXModHlwZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBrZWNjYWsyNTYocmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHZhbHVlcy51bnNoaWZ0KGVuY29kZWRUeXBlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29uY2F0KHZhbHVlcyk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KGZhbHNlLCBgdW5rbm93biB0eXBlOiAke3R5cGV9YCwgXCJ0eXBlXCIsIHR5cGUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIHRoZSBmdWxsIHR5cGUgZm9yICUlbmFtZSUlLlxuICAgICAqL1xuICAgIGVuY29kZVR5cGUobmFtZSkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLiNmdWxsVHlwZXMuZ2V0KG5hbWUpO1xuICAgICAgICBhc3NlcnRBcmd1bWVudChyZXN1bHQsIGB1bmtub3duIHR5cGU6ICR7SlNPTi5zdHJpbmdpZnkobmFtZSl9YCwgXCJuYW1lXCIsIG5hbWUpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIHRoZSBlbmNvZGVkICUldmFsdWUlJSBmb3IgdGhlICUldHlwZSUlLlxuICAgICAqL1xuICAgIGVuY29kZURhdGEodHlwZSwgdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0RW5jb2Rlcih0eXBlKSh2YWx1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRoZSBoYXNoIG9mICUldmFsdWUlJSBmb3IgdGhlIHR5cGUgb2YgJSVuYW1lJSUuXG4gICAgICovXG4gICAgaGFzaFN0cnVjdChuYW1lLCB2YWx1ZSkge1xuICAgICAgICByZXR1cm4ga2VjY2FrMjU2KHRoaXMuZW5jb2RlRGF0YShuYW1lLCB2YWx1ZSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIHRoZSBmdWxsZWQgZW5jb2RlZCAlJXZhbHVlJSUgZm9yIHRoZSBbW3R5cGVzXV0uXG4gICAgICovXG4gICAgZW5jb2RlKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVuY29kZURhdGEodGhpcy5wcmltYXJ5VHlwZSwgdmFsdWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIHRoZSBoYXNoIG9mIHRoZSBmdWxseSBlbmNvZGVkICUldmFsdWUlJSBmb3IgdGhlIFtbdHlwZXNdXS5cbiAgICAgKi9cbiAgICBoYXNoKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmhhc2hTdHJ1Y3QodGhpcy5wcmltYXJ5VHlwZSwgdmFsdWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQF9pZ25vcmU6XG4gICAgICovXG4gICAgX3Zpc2l0KHR5cGUsIHZhbHVlLCBjYWxsYmFjaykge1xuICAgICAgICAvLyBCYXNpYyBlbmNvZGVyIHR5cGUgKGFkZHJlc3MsIGJvb2wsIHVpbnQyNTYsIGV0YylcbiAgICAgICAge1xuICAgICAgICAgICAgY29uc3QgZW5jb2RlciA9IGdldEJhc2VFbmNvZGVyKHR5cGUpO1xuICAgICAgICAgICAgaWYgKGVuY29kZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2sodHlwZSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIEFycmF5XG4gICAgICAgIGNvbnN0IGFycmF5ID0gc3BsaXRBcnJheSh0eXBlKS5hcnJheTtcbiAgICAgICAgaWYgKGFycmF5KSB7XG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudChhcnJheS5jb3VudCA9PT0gLTEgfHwgYXJyYXkuY291bnQgPT09IHZhbHVlLmxlbmd0aCwgYGFycmF5IGxlbmd0aCBtaXNtYXRjaDsgZXhwZWN0ZWQgbGVuZ3RoICR7YXJyYXkuY291bnR9YCwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUubWFwKCh2KSA9PiB0aGlzLl92aXNpdChhcnJheS5wcmVmaXgsIHYsIGNhbGxiYWNrKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU3RydWN0XG4gICAgICAgIGNvbnN0IGZpZWxkcyA9IHRoaXMudHlwZXNbdHlwZV07XG4gICAgICAgIGlmIChmaWVsZHMpIHtcbiAgICAgICAgICAgIHJldHVybiBmaWVsZHMucmVkdWNlKChhY2N1bSwgeyBuYW1lLCB0eXBlIH0pID0+IHtcbiAgICAgICAgICAgICAgICBhY2N1bVtuYW1lXSA9IHRoaXMuX3Zpc2l0KHR5cGUsIHZhbHVlW25hbWVdLCBjYWxsYmFjayk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFjY3VtO1xuICAgICAgICAgICAgfSwge30pO1xuICAgICAgICB9XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KGZhbHNlLCBgdW5rbm93biB0eXBlOiAke3R5cGV9YCwgXCJ0eXBlXCIsIHR5cGUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQ2FsbCAlJWNhbGJhY2slJSBmb3IgZWFjaCB2YWx1ZSBpbiAlJXZhbHVlJSUsIHBhc3NpbmcgdGhlIHR5cGUgYW5kXG4gICAgICogIGNvbXBvbmVudCB3aXRoaW4gJSV2YWx1ZSUlLlxuICAgICAqXG4gICAgICogIFRoaXMgaXMgdXNlZnVsIGZvciByZXBsYWNpbmcgYWRkcmVzc2VzIG9yIG90aGVyIHRyYW5zZm9ybWF0aW9uIHRoYXRcbiAgICAgKiAgbWF5IGJlIGRlc2lyZWQgb24gZWFjaCBjb21wb25lbnQsIGJhc2VkIG9uIGl0cyB0eXBlLlxuICAgICAqL1xuICAgIHZpc2l0KHZhbHVlLCBjYWxsYmFjaykge1xuICAgICAgICByZXR1cm4gdGhpcy5fdmlzaXQodGhpcy5wcmltYXJ5VHlwZSwgdmFsdWUsIGNhbGxiYWNrKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIENyZWF0ZSBhIG5ldyAqKlR5cGVkRGF0YUVuY29kZXIqKiBmb3IgJSV0eXBlcyUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tKHR5cGVzKSB7XG4gICAgICAgIHJldHVybiBuZXcgVHlwZWREYXRhRW5jb2Rlcih0eXBlcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gdGhlIHByaW1hcnkgdHlwZSBmb3IgJSV0eXBlcyUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBnZXRQcmltYXJ5VHlwZSh0eXBlcykge1xuICAgICAgICByZXR1cm4gVHlwZWREYXRhRW5jb2Rlci5mcm9tKHR5cGVzKS5wcmltYXJ5VHlwZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiB0aGUgaGFzaGVkIHN0cnVjdCBmb3IgJSV2YWx1ZSUlIHVzaW5nICUldHlwZXMlJSBhbmQgJSVuYW1lJSUuXG4gICAgICovXG4gICAgc3RhdGljIGhhc2hTdHJ1Y3QobmFtZSwgdHlwZXMsIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBUeXBlZERhdGFFbmNvZGVyLmZyb20odHlwZXMpLmhhc2hTdHJ1Y3QobmFtZSwgdmFsdWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIHRoZSBkb21haW4gaGFzaCBmb3IgJSVkb21haW4lJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgaGFzaERvbWFpbihkb21haW4pIHtcbiAgICAgICAgY29uc3QgZG9tYWluRmllbGRzID0gW107XG4gICAgICAgIGZvciAoY29uc3QgbmFtZSBpbiBkb21haW4pIHtcbiAgICAgICAgICAgIGlmIChkb21haW5bbmFtZV0gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgdHlwZSA9IGRvbWFpbkZpZWxkVHlwZXNbbmFtZV07XG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudCh0eXBlLCBgaW52YWxpZCB0eXBlZC1kYXRhIGRvbWFpbiBrZXk6ICR7SlNPTi5zdHJpbmdpZnkobmFtZSl9YCwgXCJkb21haW5cIiwgZG9tYWluKTtcbiAgICAgICAgICAgIGRvbWFpbkZpZWxkcy5wdXNoKHsgbmFtZSwgdHlwZSB9KTtcbiAgICAgICAgfVxuICAgICAgICBkb21haW5GaWVsZHMuc29ydCgoYSwgYikgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGRvbWFpbkZpZWxkTmFtZXMuaW5kZXhPZihhLm5hbWUpIC0gZG9tYWluRmllbGROYW1lcy5pbmRleE9mKGIubmFtZSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gVHlwZWREYXRhRW5jb2Rlci5oYXNoU3RydWN0KFwiRUlQNzEyRG9tYWluXCIsIHsgRUlQNzEyRG9tYWluOiBkb21haW5GaWVsZHMgfSwgZG9tYWluKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiB0aGUgZnVsbHkgZW5jb2RlZCBbW2xpbmstZWlwLTcxMl1dICUldmFsdWUlJSBmb3IgJSV0eXBlcyUlIHdpdGggJSVkb21haW4lJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgZW5jb2RlKGRvbWFpbiwgdHlwZXMsIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBjb25jYXQoW1xuICAgICAgICAgICAgXCIweDE5MDFcIixcbiAgICAgICAgICAgIFR5cGVkRGF0YUVuY29kZXIuaGFzaERvbWFpbihkb21haW4pLFxuICAgICAgICAgICAgVHlwZWREYXRhRW5jb2Rlci5mcm9tKHR5cGVzKS5oYXNoKHZhbHVlKVxuICAgICAgICBdKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiB0aGUgaGFzaCBvZiB0aGUgZnVsbHkgZW5jb2RlZCBbW2xpbmstZWlwLTcxMl1dICUldmFsdWUlJSBmb3IgJSV0eXBlcyUlIHdpdGggJSVkb21haW4lJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgaGFzaChkb21haW4sIHR5cGVzLCB2YWx1ZSkge1xuICAgICAgICByZXR1cm4ga2VjY2FrMjU2KFR5cGVkRGF0YUVuY29kZXIuZW5jb2RlKGRvbWFpbiwgdHlwZXMsIHZhbHVlKSk7XG4gICAgfVxuICAgIC8vIFJlcGxhY2VzIGFsbCBhZGRyZXNzIHR5cGVzIHdpdGggRU5TIG5hbWVzIHdpdGggdGhlaXIgbG9va2VkIHVwIGFkZHJlc3NcbiAgICAvKipcbiAgICAgKiBSZXNvbHZlcyB0byB0aGUgdmFsdWUgZnJvbSByZXNvbHZpbmcgYWxsIGFkZHJlc3NlcyBpbiAlJXZhbHVlJSUgZm9yXG4gICAgICogJSV0eXBlcyUlIGFuZCB0aGUgJSVkb21haW4lJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgYXN5bmMgcmVzb2x2ZU5hbWVzKGRvbWFpbiwgdHlwZXMsIHZhbHVlLCByZXNvbHZlTmFtZSkge1xuICAgICAgICAvLyBNYWtlIGEgY29weSB0byBpc29sYXRlIGl0IGZyb20gdGhlIG9iamVjdCBwYXNzZWQgaW5cbiAgICAgICAgZG9tYWluID0gT2JqZWN0LmFzc2lnbih7fSwgZG9tYWluKTtcbiAgICAgICAgLy8gQWxsb3cgcGFzc2luZyBudWxsIHRvIGlnbm9yZSB2YWx1ZVxuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBkb21haW4pIHtcbiAgICAgICAgICAgIGlmIChkb21haW5ba2V5XSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIGRvbWFpbltrZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIExvb2sgdXAgYWxsIEVOUyBuYW1lc1xuICAgICAgICBjb25zdCBlbnNDYWNoZSA9IHt9O1xuICAgICAgICAvLyBEbyB3ZSBuZWVkIHRvIGxvb2sgdXAgdGhlIGRvbWFpbidzIHZlcmlmeWluZ0NvbnRyYWN0P1xuICAgICAgICBpZiAoZG9tYWluLnZlcmlmeWluZ0NvbnRyYWN0ICYmICFpc0hleFN0cmluZyhkb21haW4udmVyaWZ5aW5nQ29udHJhY3QsIDIwKSkge1xuICAgICAgICAgICAgZW5zQ2FjaGVbZG9tYWluLnZlcmlmeWluZ0NvbnRyYWN0XSA9IFwiMHhcIjtcbiAgICAgICAgfVxuICAgICAgICAvLyBXZSBhcmUgZ29pbmcgdG8gdXNlIHRoZSBlbmNvZGVyIHRvIHZpc2l0IGFsbCB0aGUgYmFzZSB2YWx1ZXNcbiAgICAgICAgY29uc3QgZW5jb2RlciA9IFR5cGVkRGF0YUVuY29kZXIuZnJvbSh0eXBlcyk7XG4gICAgICAgIC8vIEdldCBhIGxpc3Qgb2YgYWxsIHRoZSBhZGRyZXNzZXNcbiAgICAgICAgZW5jb2Rlci52aXNpdCh2YWx1ZSwgKHR5cGUsIHZhbHVlKSA9PiB7XG4gICAgICAgICAgICBpZiAodHlwZSA9PT0gXCJhZGRyZXNzXCIgJiYgIWlzSGV4U3RyaW5nKHZhbHVlLCAyMCkpIHtcbiAgICAgICAgICAgICAgICBlbnNDYWNoZVt2YWx1ZV0gPSBcIjB4XCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBMb29rdXAgZWFjaCBuYW1lXG4gICAgICAgIGZvciAoY29uc3QgbmFtZSBpbiBlbnNDYWNoZSkge1xuICAgICAgICAgICAgZW5zQ2FjaGVbbmFtZV0gPSBhd2FpdCByZXNvbHZlTmFtZShuYW1lKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZXBsYWNlIHRoZSBkb21haW4gdmVyaWZ5aW5nQ29udHJhY3QgaWYgbmVlZGVkXG4gICAgICAgIGlmIChkb21haW4udmVyaWZ5aW5nQ29udHJhY3QgJiYgZW5zQ2FjaGVbZG9tYWluLnZlcmlmeWluZ0NvbnRyYWN0XSkge1xuICAgICAgICAgICAgZG9tYWluLnZlcmlmeWluZ0NvbnRyYWN0ID0gZW5zQ2FjaGVbZG9tYWluLnZlcmlmeWluZ0NvbnRyYWN0XTtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZXBsYWNlIGFsbCBFTlMgbmFtZXMgd2l0aCB0aGVpciBhZGRyZXNzXG4gICAgICAgIHZhbHVlID0gZW5jb2Rlci52aXNpdCh2YWx1ZSwgKHR5cGUsIHZhbHVlKSA9PiB7XG4gICAgICAgICAgICBpZiAodHlwZSA9PT0gXCJhZGRyZXNzXCIgJiYgZW5zQ2FjaGVbdmFsdWVdKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVuc0NhY2hlW3ZhbHVlXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB7IGRvbWFpbiwgdmFsdWUgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdGhlIEpTT04tZW5jb2RlZCBwYXlsb2FkIGV4cGVjdGVkIGJ5IG5vZGVzIHdoaWNoIGltcGxlbWVudFxuICAgICAqICB0aGUgSlNPTi1SUEMgW1tsaW5rLWVpcC03MTJdXSBtZXRob2QuXG4gICAgICovXG4gICAgc3RhdGljIGdldFBheWxvYWQoZG9tYWluLCB0eXBlcywgdmFsdWUpIHtcbiAgICAgICAgLy8gVmFsaWRhdGUgdGhlIGRvbWFpbiBmaWVsZHNcbiAgICAgICAgVHlwZWREYXRhRW5jb2Rlci5oYXNoRG9tYWluKGRvbWFpbik7XG4gICAgICAgIC8vIERlcml2ZSB0aGUgRUlQNzEyRG9tYWluIFN0cnVjdCByZWZlcmVuY2UgdHlwZVxuICAgICAgICBjb25zdCBkb21haW5WYWx1ZXMgPSB7fTtcbiAgICAgICAgY29uc3QgZG9tYWluVHlwZXMgPSBbXTtcbiAgICAgICAgZG9tYWluRmllbGROYW1lcy5mb3JFYWNoKChuYW1lKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGRvbWFpbltuYW1lXTtcbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZG9tYWluVmFsdWVzW25hbWVdID0gZG9tYWluQ2hlY2tzW25hbWVdKHZhbHVlKTtcbiAgICAgICAgICAgIGRvbWFpblR5cGVzLnB1c2goeyBuYW1lLCB0eXBlOiBkb21haW5GaWVsZFR5cGVzW25hbWVdIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgZW5jb2RlciA9IFR5cGVkRGF0YUVuY29kZXIuZnJvbSh0eXBlcyk7XG4gICAgICAgIC8vIEdldCB0aGUgbm9ybWFsaXplZCB0eXBlc1xuICAgICAgICB0eXBlcyA9IGVuY29kZXIudHlwZXM7XG4gICAgICAgIGNvbnN0IHR5cGVzV2l0aERvbWFpbiA9IE9iamVjdC5hc3NpZ24oe30sIHR5cGVzKTtcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQodHlwZXNXaXRoRG9tYWluLkVJUDcxMkRvbWFpbiA9PSBudWxsLCBcInR5cGVzIG11c3Qgbm90IGNvbnRhaW4gRUlQNzEyRG9tYWluIHR5cGVcIiwgXCJ0eXBlcy5FSVA3MTJEb21haW5cIiwgdHlwZXMpO1xuICAgICAgICB0eXBlc1dpdGhEb21haW4uRUlQNzEyRG9tYWluID0gZG9tYWluVHlwZXM7XG4gICAgICAgIC8vIFZhbGlkYXRlIHRoZSBkYXRhIHN0cnVjdHVyZXMgYW5kIHR5cGVzXG4gICAgICAgIGVuY29kZXIuZW5jb2RlKHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGVzOiB0eXBlc1dpdGhEb21haW4sXG4gICAgICAgICAgICBkb21haW46IGRvbWFpblZhbHVlcyxcbiAgICAgICAgICAgIHByaW1hcnlUeXBlOiBlbmNvZGVyLnByaW1hcnlUeXBlLFxuICAgICAgICAgICAgbWVzc2FnZTogZW5jb2Rlci52aXNpdCh2YWx1ZSwgKHR5cGUsIHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gYnl0ZXNcbiAgICAgICAgICAgICAgICBpZiAodHlwZS5tYXRjaCgvXmJ5dGVzKFxcZCopLykpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGhleGxpZnkoZ2V0Qnl0ZXModmFsdWUpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gdWludCBvciBpbnRcbiAgICAgICAgICAgICAgICBpZiAodHlwZS5tYXRjaCgvXnU/aW50LykpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGdldEJpZ0ludCh2YWx1ZSkudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJhZGRyZXNzXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcImJvb2xcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAhIXZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnRBcmd1bWVudCh0eXBlb2YgKHZhbHVlKSA9PT0gXCJzdHJpbmdcIiwgXCJpbnZhbGlkIHN0cmluZ1wiLCBcInZhbHVlXCIsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoZmFsc2UsIFwidW5zdXBwb3J0ZWQgdHlwZVwiLCBcInR5cGVcIiwgdHlwZSk7XG4gICAgICAgICAgICB9KVxuICAgICAgICB9O1xuICAgIH1cbn1cbi8qKlxuICogIENvbXB1dGUgdGhlIGFkZHJlc3MgdXNlZCB0byBzaWduIHRoZSB0eXBlZCBkYXRhIGZvciB0aGUgJSVzaWduYXR1cmUlJS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHZlcmlmeVR5cGVkRGF0YShkb21haW4sIHR5cGVzLCB2YWx1ZSwgc2lnbmF0dXJlKSB7XG4gICAgcmV0dXJuIHJlY292ZXJBZGRyZXNzKFR5cGVkRGF0YUVuY29kZXIuaGFzaChkb21haW4sIHR5cGVzLCB2YWx1ZSksIHNpZ25hdHVyZSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD10eXBlZC1kYXRhLmpzLm1hcCJdLCJuYW1lcyI6WyJnZXRBZGRyZXNzIiwia2VjY2FrMjU2IiwicmVjb3ZlckFkZHJlc3MiLCJjb25jYXQiLCJkZWZpbmVQcm9wZXJ0aWVzIiwiZ2V0QmlnSW50IiwiZ2V0Qnl0ZXMiLCJoZXhsaWZ5IiwiaXNIZXhTdHJpbmciLCJtYXNrIiwidG9CZUhleCIsInRvUXVhbnRpdHkiLCJ0b1R3b3MiLCJ6ZXJvUGFkVmFsdWUiLCJhc3NlcnRBcmd1bWVudCIsImlkIiwicGFkZGluZyIsIlVpbnQ4QXJyYXkiLCJmaWxsIiwiQk5fXzEiLCJCaWdJbnQiLCJCTl8wIiwiQk5fMSIsIkJOX01BWF9VSU5UMjU2IiwiaGV4UGFkUmlnaHQiLCJ2YWx1ZSIsImJ5dGVzIiwicGFkT2Zmc2V0IiwibGVuZ3RoIiwic2xpY2UiLCJoZXhUcnVlIiwiaGV4RmFsc2UiLCJkb21haW5GaWVsZFR5cGVzIiwibmFtZSIsInZlcnNpb24iLCJjaGFpbklkIiwidmVyaWZ5aW5nQ29udHJhY3QiLCJzYWx0IiwiZG9tYWluRmllbGROYW1lcyIsImNoZWNrU3RyaW5nIiwia2V5IiwiSlNPTiIsInN0cmluZ2lmeSIsImRvbWFpbkNoZWNrcyIsIl92YWx1ZSIsIk51bWJlciIsImlzU2FmZUludGVnZXIiLCJ0b0xvd2VyQ2FzZSIsImVycm9yIiwiZ2V0QmFzZUVuY29kZXIiLCJ0eXBlIiwibWF0Y2giLCJzaWduZWQiLCJ3aWR0aCIsInBhcnNlSW50IiwiU3RyaW5nIiwiYm91bmRzVXBwZXIiLCJib3VuZHNMb3dlciIsImVuY29kZVR5cGUiLCJmaWVsZHMiLCJtYXAiLCJqb2luIiwic3BsaXRBcnJheSIsImJhc2UiLCJpbmRleCIsImFycmF5IiwicHJlZml4IiwiY291bnQiLCJUeXBlZERhdGFFbmNvZGVyIiwidHlwZXMiLCJwYXJzZSIsImZ1bGxUeXBlcyIsImVuY29kZXJDYWNoZSIsImNvbnN0cnVjdG9yIiwiX3R5cGVzIiwiTWFwIiwibGlua3MiLCJwYXJlbnRzIiwic3VidHlwZXMiLCJPYmplY3QiLCJrZXlzIiwiZm9yRWFjaCIsInNldCIsIlNldCIsInVuaXF1ZU5hbWVzIiwiZmllbGQiLCJoYXMiLCJhZGQiLCJiYXNlVHlwZSIsImVuY29kZXIiLCJnZXQiLCJwdXNoIiwicHJpbWFyeVR5cGVzIiwiQXJyYXkiLCJmcm9tIiwiZmlsdGVyIiwibiIsInQiLCJwcmltYXJ5VHlwZSIsImNoZWNrQ2lyY3VsYXIiLCJmb3VuZCIsImNoaWxkIiwic3VidHlwZSIsImRlbGV0ZSIsInN0Iiwic29ydCIsImdldEVuY29kZXIiLCJzdWJFbmNvZGVyIiwicmVzdWx0IiwiZW5jb2RlZFR5cGUiLCJ2YWx1ZXMiLCJ1bnNoaWZ0IiwiZW5jb2RlRGF0YSIsImhhc2hTdHJ1Y3QiLCJlbmNvZGUiLCJoYXNoIiwiX3Zpc2l0IiwiY2FsbGJhY2siLCJ2IiwicmVkdWNlIiwiYWNjdW0iLCJ2aXNpdCIsImdldFByaW1hcnlUeXBlIiwiaGFzaERvbWFpbiIsImRvbWFpbiIsImRvbWFpbkZpZWxkcyIsImEiLCJiIiwiaW5kZXhPZiIsIkVJUDcxMkRvbWFpbiIsInJlc29sdmVOYW1lcyIsInJlc29sdmVOYW1lIiwiYXNzaWduIiwiZW5zQ2FjaGUiLCJnZXRQYXlsb2FkIiwiZG9tYWluVmFsdWVzIiwiZG9tYWluVHlwZXMiLCJ0eXBlc1dpdGhEb21haW4iLCJtZXNzYWdlIiwidG9TdHJpbmciLCJ2ZXJpZnlUeXBlZERhdGEiLCJzaWduYXR1cmUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.esm/hash/typed-data.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.esm/providers/abstract-provider.js":
/*!********************************************************************!*\
  !*** ./node_modules/ethers/lib.esm/providers/abstract-provider.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AbstractProvider: () => (/* binding */ AbstractProvider),\n/* harmony export */   UnmanagedSubscriber: () => (/* binding */ UnmanagedSubscriber)\n/* harmony export */ });\n/* harmony import */ var _address_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../address/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/address/checks.js\");\n/* harmony import */ var _address_index_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../address/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/address/address.js\");\n/* harmony import */ var _constants_index_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../constants/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/constants/addresses.js\");\n/* harmony import */ var _contract_index_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../contract/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/contract/contract.js\");\n/* harmony import */ var _hash_index_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../hash/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/hash/namehash.js\");\n/* harmony import */ var _transaction_index_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../transaction/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/transaction/transaction.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/properties.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/data.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/errors.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/fetch.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/maths.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/events.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/utf8.js\");\n/* harmony import */ var _ens_resolver_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./ens-resolver.js */ \"(ssr)/./node_modules/ethers/lib.esm/providers/ens-resolver.js\");\n/* harmony import */ var _format_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./format.js */ \"(ssr)/./node_modules/ethers/lib.esm/providers/format.js\");\n/* harmony import */ var _network_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./network.js */ \"(ssr)/./node_modules/ethers/lib.esm/providers/network.js\");\n/* harmony import */ var _provider_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./provider.js */ \"(ssr)/./node_modules/ethers/lib.esm/providers/provider.js\");\n/* harmony import */ var _subscriber_polling_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./subscriber-polling.js */ \"(ssr)/./node_modules/ethers/lib.esm/providers/subscriber-polling.js\");\n/**\n *  The available providers should suffice for most developers purposes,\n *  but the [[AbstractProvider]] class has many features which enable\n *  sub-classing it for specific purposes.\n *\n *  @_section: api/providers/abstract-provider: Subclassing Provider  [abstract-provider]\n */ // @TODO\n// Event coalescence\n//   When we register an event with an async value (e.g. address is a Signer\n//   or ENS name), we need to add it immeidately for the Event API, but also\n//   need time to resolve the address. Upon resolving the address, we need to\n//   migrate the listener to the static event. We also need to maintain a map\n//   of Signer/ENS name to address so we can sync respond to listenerCount.\n\n\n\n\n\n\n\n\n\n\n\n// Constants\nconst BN_2 = BigInt(2);\nconst MAX_CCIP_REDIRECTS = 10;\nfunction isPromise(value) {\n    return value && typeof value.then === \"function\";\n}\nfunction getTag(prefix, value) {\n    return prefix + \":\" + JSON.stringify(value, (k, v)=>{\n        if (v == null) {\n            return \"null\";\n        }\n        if (typeof v === \"bigint\") {\n            return `bigint:${v.toString()}`;\n        }\n        if (typeof v === \"string\") {\n            return v.toLowerCase();\n        }\n        // Sort object keys\n        if (typeof v === \"object\" && !Array.isArray(v)) {\n            const keys = Object.keys(v);\n            keys.sort();\n            return keys.reduce((accum, key)=>{\n                accum[key] = v[key];\n                return accum;\n            }, {});\n        }\n        return v;\n    });\n}\n/**\n *  An **UnmanagedSubscriber** is useful for events which do not require\n *  any additional management, such as ``\"debug\"`` which only requires\n *  emit in synchronous event loop triggered calls.\n */ class UnmanagedSubscriber {\n    /**\n     *  Create a new UnmanagedSubscriber with %%name%%.\n     */ constructor(name){\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.defineProperties)(this, {\n            name\n        });\n    }\n    start() {}\n    stop() {}\n    pause(dropWhilePaused) {}\n    resume() {}\n}\nfunction copy(value) {\n    return JSON.parse(JSON.stringify(value));\n}\nfunction concisify(items) {\n    items = Array.from(new Set(items).values());\n    items.sort();\n    return items;\n}\nasync function getSubscription(_event, provider) {\n    if (_event == null) {\n        throw new Error(\"invalid event\");\n    }\n    // Normalize topic array info an EventFilter\n    if (Array.isArray(_event)) {\n        _event = {\n            topics: _event\n        };\n    }\n    if (typeof _event === \"string\") {\n        switch(_event){\n            case \"block\":\n            case \"debug\":\n            case \"error\":\n            case \"finalized\":\n            case \"network\":\n            case \"pending\":\n            case \"safe\":\n                {\n                    return {\n                        type: _event,\n                        tag: _event\n                    };\n                }\n        }\n    }\n    if ((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.isHexString)(_event, 32)) {\n        const hash = _event.toLowerCase();\n        return {\n            type: \"transaction\",\n            tag: getTag(\"tx\", {\n                hash\n            }),\n            hash\n        };\n    }\n    if (_event.orphan) {\n        const event = _event;\n        // @TODO: Should lowercase and whatnot things here instead of copy...\n        return {\n            type: \"orphan\",\n            tag: getTag(\"orphan\", event),\n            filter: copy(event)\n        };\n    }\n    if (_event.address || _event.topics) {\n        const event = _event;\n        const filter = {\n            topics: (event.topics || []).map((t)=>{\n                if (t == null) {\n                    return null;\n                }\n                if (Array.isArray(t)) {\n                    return concisify(t.map((t)=>t.toLowerCase()));\n                }\n                return t.toLowerCase();\n            })\n        };\n        if (event.address) {\n            const addresses = [];\n            const promises = [];\n            const addAddress = (addr)=>{\n                if ((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.isHexString)(addr)) {\n                    addresses.push(addr);\n                } else {\n                    promises.push((async ()=>{\n                        addresses.push(await (0,_address_index_js__WEBPACK_IMPORTED_MODULE_2__.resolveAddress)(addr, provider));\n                    })());\n                }\n            };\n            if (Array.isArray(event.address)) {\n                event.address.forEach(addAddress);\n            } else {\n                addAddress(event.address);\n            }\n            if (promises.length) {\n                await Promise.all(promises);\n            }\n            filter.address = concisify(addresses.map((a)=>a.toLowerCase()));\n        }\n        return {\n            filter,\n            tag: getTag(\"event\", filter),\n            type: \"event\"\n        };\n    }\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(false, \"unknown ProviderEvent\", \"event\", _event);\n}\nfunction getTime() {\n    return new Date().getTime();\n}\nconst defaultOptions = {\n    cacheTimeout: 250,\n    pollingInterval: 4000\n};\n/**\n *  An **AbstractProvider** provides a base class for other sub-classes to\n *  implement the [[Provider]] API by normalizing input arguments and\n *  formatting output results as well as tracking events for consistent\n *  behaviour on an eventually-consistent network.\n */ class AbstractProvider {\n    #subs;\n    #plugins;\n    // null=unpaused, true=paused+dropWhilePaused, false=paused\n    #pausedState;\n    #destroyed;\n    #networkPromise;\n    #anyNetwork;\n    #performCache;\n    // The most recent block number if running an event or -1 if no \"block\" event\n    #lastBlockNumber;\n    #nextTimer;\n    #timers;\n    #disableCcipRead;\n    #options;\n    /**\n     *  Create a new **AbstractProvider** connected to %%network%%, or\n     *  use the various network detection capabilities to discover the\n     *  [[Network]] if necessary.\n     */ constructor(_network, options){\n        this.#options = Object.assign({}, defaultOptions, options || {});\n        if (_network === \"any\") {\n            this.#anyNetwork = true;\n            this.#networkPromise = null;\n        } else if (_network) {\n            const network = _network_js__WEBPACK_IMPORTED_MODULE_4__.Network.from(_network);\n            this.#anyNetwork = false;\n            this.#networkPromise = Promise.resolve(network);\n            setTimeout(()=>{\n                this.emit(\"network\", network, null);\n            }, 0);\n        } else {\n            this.#anyNetwork = false;\n            this.#networkPromise = null;\n        }\n        this.#lastBlockNumber = -1;\n        this.#performCache = new Map();\n        this.#subs = new Map();\n        this.#plugins = new Map();\n        this.#pausedState = null;\n        this.#destroyed = false;\n        this.#nextTimer = 1;\n        this.#timers = new Map();\n        this.#disableCcipRead = false;\n    }\n    get pollingInterval() {\n        return this.#options.pollingInterval;\n    }\n    /**\n     *  Returns ``this``, to allow an **AbstractProvider** to implement\n     *  the [[ContractRunner]] interface.\n     */ get provider() {\n        return this;\n    }\n    /**\n     *  Returns all the registered plug-ins.\n     */ get plugins() {\n        return Array.from(this.#plugins.values());\n    }\n    /**\n     *  Attach a new plug-in.\n     */ attachPlugin(plugin) {\n        if (this.#plugins.get(plugin.name)) {\n            throw new Error(`cannot replace existing plugin: ${plugin.name} `);\n        }\n        this.#plugins.set(plugin.name, plugin.connect(this));\n        return this;\n    }\n    /**\n     *  Get a plugin by name.\n     */ getPlugin(name) {\n        return this.#plugins.get(name) || null;\n    }\n    /**\n     *  Prevent any CCIP-read operation, regardless of whether requested\n     *  in a [[call]] using ``enableCcipRead``.\n     */ get disableCcipRead() {\n        return this.#disableCcipRead;\n    }\n    set disableCcipRead(value) {\n        this.#disableCcipRead = !!value;\n    }\n    // Shares multiple identical requests made during the same 250ms\n    async #perform(req) {\n        const timeout = this.#options.cacheTimeout;\n        // Caching disabled\n        if (timeout < 0) {\n            return await this._perform(req);\n        }\n        // Create a tag\n        const tag = getTag(req.method, req);\n        let perform = this.#performCache.get(tag);\n        if (!perform) {\n            perform = this._perform(req);\n            this.#performCache.set(tag, perform);\n            setTimeout(()=>{\n                if (this.#performCache.get(tag) === perform) {\n                    this.#performCache.delete(tag);\n                }\n            }, timeout);\n        }\n        return await perform;\n    }\n    /**\n     *  Resolves to the data for executing the CCIP-read operations.\n     */ async ccipReadFetch(tx, calldata, urls) {\n        if (this.disableCcipRead || urls.length === 0 || tx.to == null) {\n            return null;\n        }\n        const sender = tx.to.toLowerCase();\n        const data = calldata.toLowerCase();\n        const errorMessages = [];\n        for(let i = 0; i < urls.length; i++){\n            const url = urls[i];\n            // URL expansion\n            const href = url.replace(\"{sender}\", sender).replace(\"{data}\", data);\n            // If no {data} is present, use POST; otherwise GET\n            //const json: string | null = (url.indexOf(\"{data}\") >= 0) ? null: JSON.stringify({ data, sender });\n            //const result = await fetchJson({ url: href, errorPassThrough: true }, json, (value, response) => {\n            //    value.status = response.statusCode;\n            //    return value;\n            //});\n            const request = new _utils_index_js__WEBPACK_IMPORTED_MODULE_5__.FetchRequest(href);\n            if (url.indexOf(\"{data}\") === -1) {\n                request.body = {\n                    data,\n                    sender\n                };\n            }\n            this.emit(\"debug\", {\n                action: \"sendCcipReadFetchRequest\",\n                request,\n                index: i,\n                urls\n            });\n            let errorMessage = \"unknown error\";\n            // Fetch the resource...\n            let resp;\n            try {\n                resp = await request.send();\n            } catch (error) {\n                // ...low-level fetch error (missing host, bad SSL, etc.),\n                // so try next URL\n                errorMessages.push(error.message);\n                this.emit(\"debug\", {\n                    action: \"receiveCcipReadFetchError\",\n                    request,\n                    result: {\n                        error\n                    }\n                });\n                continue;\n            }\n            try {\n                const result = resp.bodyJson;\n                if (result.data) {\n                    this.emit(\"debug\", {\n                        action: \"receiveCcipReadFetchResult\",\n                        request,\n                        result\n                    });\n                    return result.data;\n                }\n                if (result.message) {\n                    errorMessage = result.message;\n                }\n                this.emit(\"debug\", {\n                    action: \"receiveCcipReadFetchError\",\n                    request,\n                    result\n                });\n            } catch (error) {}\n            // 4xx indicates the result is not present; stop\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assert)(resp.statusCode < 400 || resp.statusCode >= 500, `response not found during CCIP fetch: ${errorMessage}`, \"OFFCHAIN_FAULT\", {\n                reason: \"404_MISSING_RESOURCE\",\n                transaction: tx,\n                info: {\n                    url,\n                    errorMessage\n                }\n            });\n            // 5xx indicates server issue; try the next url\n            errorMessages.push(errorMessage);\n        }\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assert)(false, `error encountered during CCIP fetch: ${errorMessages.map((m)=>JSON.stringify(m)).join(\", \")}`, \"OFFCHAIN_FAULT\", {\n            reason: \"500_SERVER_ERROR\",\n            transaction: tx,\n            info: {\n                urls,\n                errorMessages\n            }\n        });\n    }\n    /**\n     *  Provides the opportunity for a sub-class to wrap a block before\n     *  returning it, to add additional properties or an alternate\n     *  sub-class of [[Block]].\n     */ _wrapBlock(value, network) {\n        return new _provider_js__WEBPACK_IMPORTED_MODULE_6__.Block((0,_format_js__WEBPACK_IMPORTED_MODULE_7__.formatBlock)(value), this);\n    }\n    /**\n     *  Provides the opportunity for a sub-class to wrap a log before\n     *  returning it, to add additional properties or an alternate\n     *  sub-class of [[Log]].\n     */ _wrapLog(value, network) {\n        return new _provider_js__WEBPACK_IMPORTED_MODULE_6__.Log((0,_format_js__WEBPACK_IMPORTED_MODULE_7__.formatLog)(value), this);\n    }\n    /**\n     *  Provides the opportunity for a sub-class to wrap a transaction\n     *  receipt before returning it, to add additional properties or an\n     *  alternate sub-class of [[TransactionReceipt]].\n     */ _wrapTransactionReceipt(value, network) {\n        return new _provider_js__WEBPACK_IMPORTED_MODULE_6__.TransactionReceipt((0,_format_js__WEBPACK_IMPORTED_MODULE_7__.formatTransactionReceipt)(value), this);\n    }\n    /**\n     *  Provides the opportunity for a sub-class to wrap a transaction\n     *  response before returning it, to add additional properties or an\n     *  alternate sub-class of [[TransactionResponse]].\n     */ _wrapTransactionResponse(tx, network) {\n        return new _provider_js__WEBPACK_IMPORTED_MODULE_6__.TransactionResponse((0,_format_js__WEBPACK_IMPORTED_MODULE_7__.formatTransactionResponse)(tx), this);\n    }\n    /**\n     *  Resolves to the Network, forcing a network detection using whatever\n     *  technique the sub-class requires.\n     *\n     *  Sub-classes **must** override this.\n     */ _detectNetwork() {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assert)(false, \"sub-classes must implement this\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"_detectNetwork\"\n        });\n    }\n    /**\n     *  Sub-classes should use this to perform all built-in operations. All\n     *  methods sanitizes and normalizes the values passed into this.\n     *\n     *  Sub-classes **must** override this.\n     */ async _perform(req) {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assert)(false, `unsupported method: ${req.method}`, \"UNSUPPORTED_OPERATION\", {\n            operation: req.method,\n            info: req\n        });\n    }\n    // State\n    async getBlockNumber() {\n        const blockNumber = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_8__.getNumber)(await this.#perform({\n            method: \"getBlockNumber\"\n        }), \"%response\");\n        if (this.#lastBlockNumber >= 0) {\n            this.#lastBlockNumber = blockNumber;\n        }\n        return blockNumber;\n    }\n    /**\n     *  Returns or resolves to the address for %%address%%, resolving ENS\n     *  names and [[Addressable]] objects and returning if already an\n     *  address.\n     */ _getAddress(address) {\n        return (0,_address_index_js__WEBPACK_IMPORTED_MODULE_2__.resolveAddress)(address, this);\n    }\n    /**\n     *  Returns or resolves to a valid block tag for %%blockTag%%, resolving\n     *  negative values and returning if already a valid block tag.\n     */ _getBlockTag(blockTag) {\n        if (blockTag == null) {\n            return \"latest\";\n        }\n        switch(blockTag){\n            case \"earliest\":\n                return \"0x0\";\n            case \"finalized\":\n            case \"latest\":\n            case \"pending\":\n            case \"safe\":\n                return blockTag;\n        }\n        if ((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.isHexString)(blockTag)) {\n            if ((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.isHexString)(blockTag, 32)) {\n                return blockTag;\n            }\n            return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_8__.toQuantity)(blockTag);\n        }\n        if (typeof blockTag === \"bigint\") {\n            blockTag = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_8__.getNumber)(blockTag, \"blockTag\");\n        }\n        if (typeof blockTag === \"number\") {\n            if (blockTag >= 0) {\n                return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_8__.toQuantity)(blockTag);\n            }\n            if (this.#lastBlockNumber >= 0) {\n                return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_8__.toQuantity)(this.#lastBlockNumber + blockTag);\n            }\n            return this.getBlockNumber().then((b)=>(0,_utils_index_js__WEBPACK_IMPORTED_MODULE_8__.toQuantity)(b + blockTag));\n        }\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(false, \"invalid blockTag\", \"blockTag\", blockTag);\n    }\n    /**\n     *  Returns or resolves to a filter for %%filter%%, resolving any ENS\n     *  names or [[Addressable]] object and returning if already a valid\n     *  filter.\n     */ _getFilter(filter) {\n        // Create a canonical representation of the topics\n        const topics = (filter.topics || []).map((t)=>{\n            if (t == null) {\n                return null;\n            }\n            if (Array.isArray(t)) {\n                return concisify(t.map((t)=>t.toLowerCase()));\n            }\n            return t.toLowerCase();\n        });\n        const blockHash = \"blockHash\" in filter ? filter.blockHash : undefined;\n        const resolve = (_address, fromBlock, toBlock)=>{\n            let address = undefined;\n            switch(_address.length){\n                case 0:\n                    break;\n                case 1:\n                    address = _address[0];\n                    break;\n                default:\n                    _address.sort();\n                    address = _address;\n            }\n            if (blockHash) {\n                if (fromBlock != null || toBlock != null) {\n                    throw new Error(\"invalid filter\");\n                }\n            }\n            const filter = {};\n            if (address) {\n                filter.address = address;\n            }\n            if (topics.length) {\n                filter.topics = topics;\n            }\n            if (fromBlock) {\n                filter.fromBlock = fromBlock;\n            }\n            if (toBlock) {\n                filter.toBlock = toBlock;\n            }\n            if (blockHash) {\n                filter.blockHash = blockHash;\n            }\n            return filter;\n        };\n        // Addresses could be async (ENS names or Addressables)\n        let address = [];\n        if (filter.address) {\n            if (Array.isArray(filter.address)) {\n                for (const addr of filter.address){\n                    address.push(this._getAddress(addr));\n                }\n            } else {\n                address.push(this._getAddress(filter.address));\n            }\n        }\n        let fromBlock = undefined;\n        if (\"fromBlock\" in filter) {\n            fromBlock = this._getBlockTag(filter.fromBlock);\n        }\n        let toBlock = undefined;\n        if (\"toBlock\" in filter) {\n            toBlock = this._getBlockTag(filter.toBlock);\n        }\n        if (address.filter((a)=>typeof a !== \"string\").length || fromBlock != null && typeof fromBlock !== \"string\" || toBlock != null && typeof toBlock !== \"string\") {\n            return Promise.all([\n                Promise.all(address),\n                fromBlock,\n                toBlock\n            ]).then((result)=>{\n                return resolve(result[0], result[1], result[2]);\n            });\n        }\n        return resolve(address, fromBlock, toBlock);\n    }\n    /**\n     *  Returns or resolves to a transaction for %%request%%, resolving\n     *  any ENS names or [[Addressable]] and returning if already a valid\n     *  transaction.\n     */ _getTransactionRequest(_request) {\n        const request = (0,_provider_js__WEBPACK_IMPORTED_MODULE_6__.copyRequest)(_request);\n        const promises = [];\n        [\n            \"to\",\n            \"from\"\n        ].forEach((key)=>{\n            if (request[key] == null) {\n                return;\n            }\n            const addr = (0,_address_index_js__WEBPACK_IMPORTED_MODULE_2__.resolveAddress)(request[key], this);\n            if (isPromise(addr)) {\n                promises.push(async function() {\n                    request[key] = await addr;\n                }());\n            } else {\n                request[key] = addr;\n            }\n        });\n        if (request.blockTag != null) {\n            const blockTag = this._getBlockTag(request.blockTag);\n            if (isPromise(blockTag)) {\n                promises.push(async function() {\n                    request.blockTag = await blockTag;\n                }());\n            } else {\n                request.blockTag = blockTag;\n            }\n        }\n        if (promises.length) {\n            return async function() {\n                await Promise.all(promises);\n                return request;\n            }();\n        }\n        return request;\n    }\n    async getNetwork() {\n        // No explicit network was set and this is our first time\n        if (this.#networkPromise == null) {\n            // Detect the current network (shared with all calls)\n            const detectNetwork = (async ()=>{\n                try {\n                    const network = await this._detectNetwork();\n                    this.emit(\"network\", network, null);\n                    return network;\n                } catch (error) {\n                    if (this.#networkPromise === detectNetwork) {\n                        this.#networkPromise = null;\n                    }\n                    throw error;\n                }\n            })();\n            this.#networkPromise = detectNetwork;\n            return (await detectNetwork).clone();\n        }\n        const networkPromise = this.#networkPromise;\n        const [expected, actual] = await Promise.all([\n            networkPromise,\n            this._detectNetwork() // The actual connected network\n        ]);\n        if (expected.chainId !== actual.chainId) {\n            if (this.#anyNetwork) {\n                // The \"any\" network can change, so notify listeners\n                this.emit(\"network\", actual, expected);\n                // Update the network if something else hasn't already changed it\n                if (this.#networkPromise === networkPromise) {\n                    this.#networkPromise = Promise.resolve(actual);\n                }\n            } else {\n                // Otherwise, we do not allow changes to the underlying network\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assert)(false, `network changed: ${expected.chainId} => ${actual.chainId} `, \"NETWORK_ERROR\", {\n                    event: \"changed\"\n                });\n            }\n        }\n        return expected.clone();\n    }\n    async getFeeData() {\n        const network = await this.getNetwork();\n        const getFeeDataFunc = async ()=>{\n            const { _block, gasPrice, priorityFee } = await (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.resolveProperties)({\n                _block: this.#getBlock(\"latest\", false),\n                gasPrice: (async ()=>{\n                    try {\n                        const value = await this.#perform({\n                            method: \"getGasPrice\"\n                        });\n                        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_8__.getBigInt)(value, \"%response\");\n                    } catch (error) {}\n                    return null;\n                })(),\n                priorityFee: (async ()=>{\n                    try {\n                        const value = await this.#perform({\n                            method: \"getPriorityFee\"\n                        });\n                        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_8__.getBigInt)(value, \"%response\");\n                    } catch (error) {}\n                    return null;\n                })()\n            });\n            let maxFeePerGas = null;\n            let maxPriorityFeePerGas = null;\n            // These are the recommended EIP-1559 heuristics for fee data\n            const block = this._wrapBlock(_block, network);\n            if (block && block.baseFeePerGas) {\n                maxPriorityFeePerGas = priorityFee != null ? priorityFee : BigInt(\"1000000000\");\n                maxFeePerGas = block.baseFeePerGas * BN_2 + maxPriorityFeePerGas;\n            }\n            return new _provider_js__WEBPACK_IMPORTED_MODULE_6__.FeeData(gasPrice, maxFeePerGas, maxPriorityFeePerGas);\n        };\n        // Check for a FeeDataNetWorkPlugin\n        const plugin = network.getPlugin(\"org.ethers.plugins.network.FetchUrlFeeDataPlugin\");\n        if (plugin) {\n            const req = new _utils_index_js__WEBPACK_IMPORTED_MODULE_5__.FetchRequest(plugin.url);\n            const feeData = await plugin.processFunc(getFeeDataFunc, this, req);\n            return new _provider_js__WEBPACK_IMPORTED_MODULE_6__.FeeData(feeData.gasPrice, feeData.maxFeePerGas, feeData.maxPriorityFeePerGas);\n        }\n        return await getFeeDataFunc();\n    }\n    async estimateGas(_tx) {\n        let tx = this._getTransactionRequest(_tx);\n        if (isPromise(tx)) {\n            tx = await tx;\n        }\n        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_8__.getBigInt)(await this.#perform({\n            method: \"estimateGas\",\n            transaction: tx\n        }), \"%response\");\n    }\n    async #call(tx, blockTag, attempt) {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assert)(attempt < MAX_CCIP_REDIRECTS, \"CCIP read exceeded maximum redirections\", \"OFFCHAIN_FAULT\", {\n            reason: \"TOO_MANY_REDIRECTS\",\n            transaction: Object.assign({}, tx, {\n                blockTag,\n                enableCcipRead: true\n            })\n        });\n        // This came in as a PerformActionTransaction, so to/from are safe; we can cast\n        const transaction = (0,_provider_js__WEBPACK_IMPORTED_MODULE_6__.copyRequest)(tx);\n        try {\n            return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.hexlify)(await this._perform({\n                method: \"call\",\n                transaction,\n                blockTag\n            }));\n        } catch (error) {\n            // CCIP Read OffchainLookup\n            if (!this.disableCcipRead && (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.isCallException)(error) && error.data && attempt >= 0 && blockTag === \"latest\" && transaction.to != null && (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.dataSlice)(error.data, 0, 4) === \"0x556f1830\") {\n                const data = error.data;\n                const txSender = await (0,_address_index_js__WEBPACK_IMPORTED_MODULE_2__.resolveAddress)(transaction.to, this);\n                // Parse the CCIP Read Arguments\n                let ccipArgs;\n                try {\n                    ccipArgs = parseOffchainLookup((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.dataSlice)(error.data, 4));\n                } catch (error) {\n                    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assert)(false, error.message, \"OFFCHAIN_FAULT\", {\n                        reason: \"BAD_DATA\",\n                        transaction,\n                        info: {\n                            data\n                        }\n                    });\n                }\n                // Check the sender of the OffchainLookup matches the transaction\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assert)(ccipArgs.sender.toLowerCase() === txSender.toLowerCase(), \"CCIP Read sender mismatch\", \"CALL_EXCEPTION\", {\n                    action: \"call\",\n                    data,\n                    reason: \"OffchainLookup\",\n                    transaction: transaction,\n                    invocation: null,\n                    revert: {\n                        signature: \"OffchainLookup(address,string[],bytes,bytes4,bytes)\",\n                        name: \"OffchainLookup\",\n                        args: ccipArgs.errorArgs\n                    }\n                });\n                const ccipResult = await this.ccipReadFetch(transaction, ccipArgs.calldata, ccipArgs.urls);\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assert)(ccipResult != null, \"CCIP Read failed to fetch data\", \"OFFCHAIN_FAULT\", {\n                    reason: \"FETCH_FAILED\",\n                    transaction,\n                    info: {\n                        data: error.data,\n                        errorArgs: ccipArgs.errorArgs\n                    }\n                });\n                const tx = {\n                    to: txSender,\n                    data: (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.concat)([\n                        ccipArgs.selector,\n                        encodeBytes([\n                            ccipResult,\n                            ccipArgs.extraData\n                        ])\n                    ])\n                };\n                this.emit(\"debug\", {\n                    action: \"sendCcipReadCall\",\n                    transaction: tx\n                });\n                try {\n                    const result = await this.#call(tx, blockTag, attempt + 1);\n                    this.emit(\"debug\", {\n                        action: \"receiveCcipReadCallResult\",\n                        transaction: Object.assign({}, tx),\n                        result\n                    });\n                    return result;\n                } catch (error) {\n                    this.emit(\"debug\", {\n                        action: \"receiveCcipReadCallError\",\n                        transaction: Object.assign({}, tx),\n                        error\n                    });\n                    throw error;\n                }\n            }\n            throw error;\n        }\n    }\n    async #checkNetwork(promise) {\n        const { value } = await (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.resolveProperties)({\n            network: this.getNetwork(),\n            value: promise\n        });\n        return value;\n    }\n    async call(_tx) {\n        const { tx, blockTag } = await (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.resolveProperties)({\n            tx: this._getTransactionRequest(_tx),\n            blockTag: this._getBlockTag(_tx.blockTag)\n        });\n        return await this.#checkNetwork(this.#call(tx, blockTag, _tx.enableCcipRead ? 0 : -1));\n    }\n    // Account\n    async #getAccountValue(request, _address, _blockTag) {\n        let address = this._getAddress(_address);\n        let blockTag = this._getBlockTag(_blockTag);\n        if (typeof address !== \"string\" || typeof blockTag !== \"string\") {\n            [address, blockTag] = await Promise.all([\n                address,\n                blockTag\n            ]);\n        }\n        return await this.#checkNetwork(this.#perform(Object.assign(request, {\n            address,\n            blockTag\n        })));\n    }\n    async getBalance(address, blockTag) {\n        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_8__.getBigInt)(await this.#getAccountValue({\n            method: \"getBalance\"\n        }, address, blockTag), \"%response\");\n    }\n    async getTransactionCount(address, blockTag) {\n        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_8__.getNumber)(await this.#getAccountValue({\n            method: \"getTransactionCount\"\n        }, address, blockTag), \"%response\");\n    }\n    async getCode(address, blockTag) {\n        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.hexlify)(await this.#getAccountValue({\n            method: \"getCode\"\n        }, address, blockTag));\n    }\n    async getStorage(address, _position, blockTag) {\n        const position = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_8__.getBigInt)(_position, \"position\");\n        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.hexlify)(await this.#getAccountValue({\n            method: \"getStorage\",\n            position\n        }, address, blockTag));\n    }\n    // Write\n    async broadcastTransaction(signedTx) {\n        const { blockNumber, hash, network } = await (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.resolveProperties)({\n            blockNumber: this.getBlockNumber(),\n            hash: this._perform({\n                method: \"broadcastTransaction\",\n                signedTransaction: signedTx\n            }),\n            network: this.getNetwork()\n        });\n        const tx = _transaction_index_js__WEBPACK_IMPORTED_MODULE_9__.Transaction.from(signedTx);\n        if (tx.hash !== hash) {\n            throw new Error(\"@TODO: the returned hash did not match\");\n        }\n        return this._wrapTransactionResponse(tx, network).replaceableTransaction(blockNumber);\n    }\n    async #getBlock(block, includeTransactions) {\n        // @TODO: Add CustomBlockPlugin check\n        if ((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.isHexString)(block, 32)) {\n            return await this.#perform({\n                method: \"getBlock\",\n                blockHash: block,\n                includeTransactions\n            });\n        }\n        let blockTag = this._getBlockTag(block);\n        if (typeof blockTag !== \"string\") {\n            blockTag = await blockTag;\n        }\n        return await this.#perform({\n            method: \"getBlock\",\n            blockTag,\n            includeTransactions\n        });\n    }\n    // Queries\n    async getBlock(block, prefetchTxs) {\n        const { network, params } = await (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.resolveProperties)({\n            network: this.getNetwork(),\n            params: this.#getBlock(block, !!prefetchTxs)\n        });\n        if (params == null) {\n            return null;\n        }\n        return this._wrapBlock(params, network);\n    }\n    async getTransaction(hash) {\n        const { network, params } = await (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.resolveProperties)({\n            network: this.getNetwork(),\n            params: this.#perform({\n                method: \"getTransaction\",\n                hash\n            })\n        });\n        if (params == null) {\n            return null;\n        }\n        return this._wrapTransactionResponse(params, network);\n    }\n    async getTransactionReceipt(hash) {\n        const { network, params } = await (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.resolveProperties)({\n            network: this.getNetwork(),\n            params: this.#perform({\n                method: \"getTransactionReceipt\",\n                hash\n            })\n        });\n        if (params == null) {\n            return null;\n        }\n        // Some backends did not backfill the effectiveGasPrice into old transactions\n        // in the receipt, so we look it up manually and inject it.\n        if (params.gasPrice == null && params.effectiveGasPrice == null) {\n            const tx = await this.#perform({\n                method: \"getTransaction\",\n                hash\n            });\n            if (tx == null) {\n                throw new Error(\"report this; could not find tx or effectiveGasPrice\");\n            }\n            params.effectiveGasPrice = tx.gasPrice;\n        }\n        return this._wrapTransactionReceipt(params, network);\n    }\n    async getTransactionResult(hash) {\n        const { result } = await (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.resolveProperties)({\n            network: this.getNetwork(),\n            result: this.#perform({\n                method: \"getTransactionResult\",\n                hash\n            })\n        });\n        if (result == null) {\n            return null;\n        }\n        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.hexlify)(result);\n    }\n    // Bloom-filter Queries\n    async getLogs(_filter) {\n        let filter = this._getFilter(_filter);\n        if (isPromise(filter)) {\n            filter = await filter;\n        }\n        const { network, params } = await (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.resolveProperties)({\n            network: this.getNetwork(),\n            params: this.#perform({\n                method: \"getLogs\",\n                filter\n            })\n        });\n        return params.map((p)=>this._wrapLog(p, network));\n    }\n    // ENS\n    _getProvider(chainId) {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assert)(false, \"provider cannot connect to target network\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"_getProvider()\"\n        });\n    }\n    async getResolver(name) {\n        return await _ens_resolver_js__WEBPACK_IMPORTED_MODULE_10__.EnsResolver.fromName(this, name);\n    }\n    async getAvatar(name) {\n        const resolver = await this.getResolver(name);\n        if (resolver) {\n            return await resolver.getAvatar();\n        }\n        return null;\n    }\n    async resolveName(name) {\n        const resolver = await this.getResolver(name);\n        if (resolver) {\n            return await resolver.getAddress();\n        }\n        return null;\n    }\n    async lookupAddress(address) {\n        address = (0,_address_index_js__WEBPACK_IMPORTED_MODULE_11__.getAddress)(address);\n        const node = (0,_hash_index_js__WEBPACK_IMPORTED_MODULE_12__.namehash)(address.substring(2).toLowerCase() + \".addr.reverse\");\n        try {\n            const ensAddr = await _ens_resolver_js__WEBPACK_IMPORTED_MODULE_10__.EnsResolver.getEnsAddress(this);\n            const ensContract = new _contract_index_js__WEBPACK_IMPORTED_MODULE_13__.Contract(ensAddr, [\n                \"function resolver(bytes32) view returns (address)\"\n            ], this);\n            const resolver = await ensContract.resolver(node);\n            if (resolver == null || resolver === _constants_index_js__WEBPACK_IMPORTED_MODULE_14__.ZeroAddress) {\n                return null;\n            }\n            const resolverContract = new _contract_index_js__WEBPACK_IMPORTED_MODULE_13__.Contract(resolver, [\n                \"function name(bytes32) view returns (string)\"\n            ], this);\n            const name = await resolverContract.name(node);\n            // Failed forward resolution\n            const check = await this.resolveName(name);\n            if (check !== address) {\n                return null;\n            }\n            return name;\n        } catch (error) {\n            // No data was returned from the resolver\n            if ((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.isError)(error, \"BAD_DATA\") && error.value === \"0x\") {\n                return null;\n            }\n            // Something reerted\n            if ((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.isError)(error, \"CALL_EXCEPTION\")) {\n                return null;\n            }\n            throw error;\n        }\n        return null;\n    }\n    async waitForTransaction(hash, _confirms, timeout) {\n        const confirms = _confirms != null ? _confirms : 1;\n        if (confirms === 0) {\n            return this.getTransactionReceipt(hash);\n        }\n        return new Promise(async (resolve, reject)=>{\n            let timer = null;\n            const listener = async (blockNumber)=>{\n                try {\n                    const receipt = await this.getTransactionReceipt(hash);\n                    if (receipt != null) {\n                        if (blockNumber - receipt.blockNumber + 1 >= confirms) {\n                            resolve(receipt);\n                            //this.off(\"block\", listener);\n                            if (timer) {\n                                clearTimeout(timer);\n                                timer = null;\n                            }\n                            return;\n                        }\n                    }\n                } catch (error) {\n                    console.log(\"EEE\", error);\n                }\n                this.once(\"block\", listener);\n            };\n            if (timeout != null) {\n                timer = setTimeout(()=>{\n                    if (timer == null) {\n                        return;\n                    }\n                    timer = null;\n                    this.off(\"block\", listener);\n                    reject((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.makeError)(\"timeout\", \"TIMEOUT\", {\n                        reason: \"timeout\"\n                    }));\n                }, timeout);\n            }\n            listener(await this.getBlockNumber());\n        });\n    }\n    async waitForBlock(blockTag) {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assert)(false, \"not implemented yet\", \"NOT_IMPLEMENTED\", {\n            operation: \"waitForBlock\"\n        });\n    }\n    /**\n     *  Clear a timer created using the [[_setTimeout]] method.\n     */ _clearTimeout(timerId) {\n        const timer = this.#timers.get(timerId);\n        if (!timer) {\n            return;\n        }\n        if (timer.timer) {\n            clearTimeout(timer.timer);\n        }\n        this.#timers.delete(timerId);\n    }\n    /**\n     *  Create a timer that will execute %%func%% after at least %%timeout%%\n     *  (in ms). If %%timeout%% is unspecified, then %%func%% will execute\n     *  in the next event loop.\n     *\n     *  [Pausing](AbstractProvider-paused) the provider will pause any\n     *  associated timers.\n     */ _setTimeout(_func, timeout) {\n        if (timeout == null) {\n            timeout = 0;\n        }\n        const timerId = this.#nextTimer++;\n        const func = ()=>{\n            this.#timers.delete(timerId);\n            _func();\n        };\n        if (this.paused) {\n            this.#timers.set(timerId, {\n                timer: null,\n                func,\n                time: timeout\n            });\n        } else {\n            const timer = setTimeout(func, timeout);\n            this.#timers.set(timerId, {\n                timer,\n                func,\n                time: getTime()\n            });\n        }\n        return timerId;\n    }\n    /**\n     *  Perform %%func%% on each subscriber.\n     */ _forEachSubscriber(func) {\n        for (const sub of this.#subs.values()){\n            func(sub.subscriber);\n        }\n    }\n    /**\n     *  Sub-classes may override this to customize subscription\n     *  implementations.\n     */ _getSubscriber(sub) {\n        switch(sub.type){\n            case \"debug\":\n            case \"error\":\n            case \"network\":\n                return new UnmanagedSubscriber(sub.type);\n            case \"block\":\n                {\n                    const subscriber = new _subscriber_polling_js__WEBPACK_IMPORTED_MODULE_15__.PollingBlockSubscriber(this);\n                    subscriber.pollingInterval = this.pollingInterval;\n                    return subscriber;\n                }\n            case \"safe\":\n            case \"finalized\":\n                return new _subscriber_polling_js__WEBPACK_IMPORTED_MODULE_15__.PollingBlockTagSubscriber(this, sub.type);\n            case \"event\":\n                return new _subscriber_polling_js__WEBPACK_IMPORTED_MODULE_15__.PollingEventSubscriber(this, sub.filter);\n            case \"transaction\":\n                return new _subscriber_polling_js__WEBPACK_IMPORTED_MODULE_15__.PollingTransactionSubscriber(this, sub.hash);\n            case \"orphan\":\n                return new _subscriber_polling_js__WEBPACK_IMPORTED_MODULE_15__.PollingOrphanSubscriber(this, sub.filter);\n        }\n        throw new Error(`unsupported event: ${sub.type}`);\n    }\n    /**\n     *  If a [[Subscriber]] fails and needs to replace itself, this\n     *  method may be used.\n     *\n     *  For example, this is used for providers when using the\n     *  ``eth_getFilterChanges`` method, which can return null if state\n     *  filters are not supported by the backend, allowing the Subscriber\n     *  to swap in a [[PollingEventSubscriber]].\n     */ _recoverSubscriber(oldSub, newSub) {\n        for (const sub of this.#subs.values()){\n            if (sub.subscriber === oldSub) {\n                if (sub.started) {\n                    sub.subscriber.stop();\n                }\n                sub.subscriber = newSub;\n                if (sub.started) {\n                    newSub.start();\n                }\n                if (this.#pausedState != null) {\n                    newSub.pause(this.#pausedState);\n                }\n                break;\n            }\n        }\n    }\n    async #hasSub(event, emitArgs) {\n        let sub = await getSubscription(event, this);\n        // This is a log that is removing an existing log; we actually want\n        // to emit an orphan event for the removed log\n        if (sub.type === \"event\" && emitArgs && emitArgs.length > 0 && emitArgs[0].removed === true) {\n            sub = await getSubscription({\n                orphan: \"drop-log\",\n                log: emitArgs[0]\n            }, this);\n        }\n        return this.#subs.get(sub.tag) || null;\n    }\n    async #getSub(event) {\n        const subscription = await getSubscription(event, this);\n        // Prevent tampering with our tag in any subclass' _getSubscriber\n        const tag = subscription.tag;\n        let sub = this.#subs.get(tag);\n        if (!sub) {\n            const subscriber = this._getSubscriber(subscription);\n            const addressableMap = new WeakMap();\n            const nameMap = new Map();\n            sub = {\n                subscriber,\n                tag,\n                addressableMap,\n                nameMap,\n                started: false,\n                listeners: []\n            };\n            this.#subs.set(tag, sub);\n        }\n        return sub;\n    }\n    async on(event, listener) {\n        const sub = await this.#getSub(event);\n        sub.listeners.push({\n            listener,\n            once: false\n        });\n        if (!sub.started) {\n            sub.subscriber.start();\n            sub.started = true;\n            if (this.#pausedState != null) {\n                sub.subscriber.pause(this.#pausedState);\n            }\n        }\n        return this;\n    }\n    async once(event, listener) {\n        const sub = await this.#getSub(event);\n        sub.listeners.push({\n            listener,\n            once: true\n        });\n        if (!sub.started) {\n            sub.subscriber.start();\n            sub.started = true;\n            if (this.#pausedState != null) {\n                sub.subscriber.pause(this.#pausedState);\n            }\n        }\n        return this;\n    }\n    async emit(event, ...args) {\n        const sub = await this.#hasSub(event, args);\n        // If there is not subscription or if a recent emit removed\n        // the last of them (which also deleted the sub) do nothing\n        if (!sub || sub.listeners.length === 0) {\n            return false;\n        }\n        ;\n        const count = sub.listeners.length;\n        sub.listeners = sub.listeners.filter(({ listener, once })=>{\n            const payload = new _utils_index_js__WEBPACK_IMPORTED_MODULE_16__.EventPayload(this, once ? null : listener, event);\n            try {\n                listener.call(this, ...args, payload);\n            } catch (error) {}\n            return !once;\n        });\n        if (sub.listeners.length === 0) {\n            if (sub.started) {\n                sub.subscriber.stop();\n            }\n            this.#subs.delete(sub.tag);\n        }\n        return count > 0;\n    }\n    async listenerCount(event) {\n        if (event) {\n            const sub = await this.#hasSub(event);\n            if (!sub) {\n                return 0;\n            }\n            return sub.listeners.length;\n        }\n        let total = 0;\n        for (const { listeners } of this.#subs.values()){\n            total += listeners.length;\n        }\n        return total;\n    }\n    async listeners(event) {\n        if (event) {\n            const sub = await this.#hasSub(event);\n            if (!sub) {\n                return [];\n            }\n            return sub.listeners.map(({ listener })=>listener);\n        }\n        let result = [];\n        for (const { listeners } of this.#subs.values()){\n            result = result.concat(listeners.map(({ listener })=>listener));\n        }\n        return result;\n    }\n    async off(event, listener) {\n        const sub = await this.#hasSub(event);\n        if (!sub) {\n            return this;\n        }\n        if (listener) {\n            const index = sub.listeners.map(({ listener })=>listener).indexOf(listener);\n            if (index >= 0) {\n                sub.listeners.splice(index, 1);\n            }\n        }\n        if (!listener || sub.listeners.length === 0) {\n            if (sub.started) {\n                sub.subscriber.stop();\n            }\n            this.#subs.delete(sub.tag);\n        }\n        return this;\n    }\n    async removeAllListeners(event) {\n        if (event) {\n            const { tag, started, subscriber } = await this.#getSub(event);\n            if (started) {\n                subscriber.stop();\n            }\n            this.#subs.delete(tag);\n        } else {\n            for (const [tag, { started, subscriber }] of this.#subs){\n                if (started) {\n                    subscriber.stop();\n                }\n                this.#subs.delete(tag);\n            }\n        }\n        return this;\n    }\n    // Alias for \"on\"\n    async addListener(event, listener) {\n        return await this.on(event, listener);\n    }\n    // Alias for \"off\"\n    async removeListener(event, listener) {\n        return this.off(event, listener);\n    }\n    /**\n     *  If this provider has been destroyed using the [[destroy]] method.\n     *\n     *  Once destroyed, all resources are reclaimed, internal event loops\n     *  and timers are cleaned up and no further requests may be sent to\n     *  the provider.\n     */ get destroyed() {\n        return this.#destroyed;\n    }\n    /**\n     *  Sub-classes may use this to shutdown any sockets or release their\n     *  resources and reject any pending requests.\n     *\n     *  Sub-classes **must** call ``super.destroy()``.\n     */ destroy() {\n        // Stop all listeners\n        this.removeAllListeners();\n        // Shut down all tiemrs\n        for (const timerId of this.#timers.keys()){\n            this._clearTimeout(timerId);\n        }\n        this.#destroyed = true;\n    }\n    /**\n     *  Whether the provider is currently paused.\n     *\n     *  A paused provider will not emit any events, and generally should\n     *  not make any requests to the network, but that is up to sub-classes\n     *  to manage.\n     *\n     *  Setting ``paused = true`` is identical to calling ``.pause(false)``,\n     *  which will buffer any events that occur while paused until the\n     *  provider is unpaused.\n     */ get paused() {\n        return this.#pausedState != null;\n    }\n    set paused(pause) {\n        if (!!pause === this.paused) {\n            return;\n        }\n        if (this.paused) {\n            this.resume();\n        } else {\n            this.pause(false);\n        }\n    }\n    /**\n     *  Pause the provider. If %%dropWhilePaused%%, any events that occur\n     *  while paused are dropped, otherwise all events will be emitted once\n     *  the provider is unpaused.\n     */ pause(dropWhilePaused) {\n        this.#lastBlockNumber = -1;\n        if (this.#pausedState != null) {\n            if (this.#pausedState == !!dropWhilePaused) {\n                return;\n            }\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assert)(false, \"cannot change pause type; resume first\", \"UNSUPPORTED_OPERATION\", {\n                operation: \"pause\"\n            });\n        }\n        this._forEachSubscriber((s)=>s.pause(dropWhilePaused));\n        this.#pausedState = !!dropWhilePaused;\n        for (const timer of this.#timers.values()){\n            // Clear the timer\n            if (timer.timer) {\n                clearTimeout(timer.timer);\n            }\n            // Remaining time needed for when we become unpaused\n            timer.time = getTime() - timer.time;\n        }\n    }\n    /**\n     *  Resume the provider.\n     */ resume() {\n        if (this.#pausedState == null) {\n            return;\n        }\n        this._forEachSubscriber((s)=>s.resume());\n        this.#pausedState = null;\n        for (const timer of this.#timers.values()){\n            // Remaining time when we were paused\n            let timeout = timer.time;\n            if (timeout < 0) {\n                timeout = 0;\n            }\n            // Start time (in cause paused, so we con compute remaininf time)\n            timer.time = getTime();\n            // Start the timer\n            setTimeout(timer.func, timeout);\n        }\n    }\n}\nfunction _parseString(result, start) {\n    try {\n        const bytes = _parseBytes(result, start);\n        if (bytes) {\n            return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_17__.toUtf8String)(bytes);\n        }\n    } catch (error) {}\n    return null;\n}\nfunction _parseBytes(result, start) {\n    if (result === \"0x\") {\n        return null;\n    }\n    try {\n        const offset = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_8__.getNumber)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.dataSlice)(result, start, start + 32));\n        const length = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_8__.getNumber)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.dataSlice)(result, offset, offset + 32));\n        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.dataSlice)(result, offset + 32, offset + 32 + length);\n    } catch (error) {}\n    return null;\n}\nfunction numPad(value) {\n    const result = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_8__.toBeArray)(value);\n    if (result.length > 32) {\n        throw new Error(\"internal; should not happen\");\n    }\n    const padded = new Uint8Array(32);\n    padded.set(result, 32 - result.length);\n    return padded;\n}\nfunction bytesPad(value) {\n    if (value.length % 32 === 0) {\n        return value;\n    }\n    const result = new Uint8Array(Math.ceil(value.length / 32) * 32);\n    result.set(value);\n    return result;\n}\nconst empty = new Uint8Array([]);\n// ABI Encodes a series of (bytes, bytes, ...)\nfunction encodeBytes(datas) {\n    const result = [];\n    let byteCount = 0;\n    // Add place-holders for pointers as we add items\n    for(let i = 0; i < datas.length; i++){\n        result.push(empty);\n        byteCount += 32;\n    }\n    for(let i = 0; i < datas.length; i++){\n        const data = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.getBytes)(datas[i]);\n        // Update the bytes offset\n        result[i] = numPad(byteCount);\n        // The length and padded value of data\n        result.push(numPad(data.length));\n        result.push(bytesPad(data));\n        byteCount += 32 + Math.ceil(data.length / 32) * 32;\n    }\n    return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.concat)(result);\n}\nconst zeros = \"0x0000000000000000000000000000000000000000000000000000000000000000\";\nfunction parseOffchainLookup(data) {\n    const result = {\n        sender: \"\",\n        urls: [],\n        calldata: \"\",\n        selector: \"\",\n        extraData: \"\",\n        errorArgs: []\n    };\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assert)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.dataLength)(data) >= 5 * 32, \"insufficient OffchainLookup data\", \"OFFCHAIN_FAULT\", {\n        reason: \"insufficient OffchainLookup data\"\n    });\n    const sender = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.dataSlice)(data, 0, 32);\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assert)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.dataSlice)(sender, 0, 12) === (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.dataSlice)(zeros, 0, 12), \"corrupt OffchainLookup sender\", \"OFFCHAIN_FAULT\", {\n        reason: \"corrupt OffchainLookup sender\"\n    });\n    result.sender = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.dataSlice)(sender, 12);\n    // Read the URLs from the response\n    try {\n        const urls = [];\n        const urlsOffset = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_8__.getNumber)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.dataSlice)(data, 32, 64));\n        const urlsLength = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_8__.getNumber)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.dataSlice)(data, urlsOffset, urlsOffset + 32));\n        const urlsData = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.dataSlice)(data, urlsOffset + 32);\n        for(let u = 0; u < urlsLength; u++){\n            const url = _parseString(urlsData, u * 32);\n            if (url == null) {\n                throw new Error(\"abort\");\n            }\n            urls.push(url);\n        }\n        result.urls = urls;\n    } catch (error) {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assert)(false, \"corrupt OffchainLookup urls\", \"OFFCHAIN_FAULT\", {\n            reason: \"corrupt OffchainLookup urls\"\n        });\n    }\n    // Get the CCIP calldata to forward\n    try {\n        const calldata = _parseBytes(data, 64);\n        if (calldata == null) {\n            throw new Error(\"abort\");\n        }\n        result.calldata = calldata;\n    } catch (error) {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assert)(false, \"corrupt OffchainLookup calldata\", \"OFFCHAIN_FAULT\", {\n            reason: \"corrupt OffchainLookup calldata\"\n        });\n    }\n    // Get the callbackSelector (bytes4)\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assert)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.dataSlice)(data, 100, 128) === (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.dataSlice)(zeros, 0, 28), \"corrupt OffchainLookup callbaackSelector\", \"OFFCHAIN_FAULT\", {\n        reason: \"corrupt OffchainLookup callbaackSelector\"\n    });\n    result.selector = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.dataSlice)(data, 96, 100);\n    // Get the extra data to send back to the contract as context\n    try {\n        const extraData = _parseBytes(data, 128);\n        if (extraData == null) {\n            throw new Error(\"abort\");\n        }\n        result.extraData = extraData;\n    } catch (error) {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assert)(false, \"corrupt OffchainLookup extraData\", \"OFFCHAIN_FAULT\", {\n            reason: \"corrupt OffchainLookup extraData\"\n        });\n    }\n    result.errorArgs = \"sender,urls,calldata,selector,extraData\".split(/,/).map((k)=>result[k]);\n    return result;\n} //# sourceMappingURL=abstract-provider.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vcHJvdmlkZXJzL2Fic3RyYWN0LXByb3ZpZGVyLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7Ozs7OztDQU1DLEdBQ0QsUUFBUTtBQUNSLG9CQUFvQjtBQUNwQiw0RUFBNEU7QUFDNUUsNEVBQTRFO0FBQzVFLDZFQUE2RTtBQUM3RSw2RUFBNkU7QUFDN0UsMkVBQTJFO0FBQ1Y7QUFDYjtBQUNKO0FBQ0o7QUFDVTtBQUNxTztBQUMzTztBQUMwRDtBQUNuRTtBQUNtRTtBQUNpRTtBQUMzSyxZQUFZO0FBQ1osTUFBTTJDLE9BQU9DLE9BQU87QUFDcEIsTUFBTUMscUJBQXFCO0FBQzNCLFNBQVNDLFVBQVVDLEtBQUs7SUFDcEIsT0FBUUEsU0FBUyxPQUFRQSxNQUFNQyxJQUFJLEtBQU07QUFDN0M7QUFDQSxTQUFTQyxPQUFPQyxNQUFNLEVBQUVILEtBQUs7SUFDekIsT0FBT0csU0FBUyxNQUFNQyxLQUFLQyxTQUFTLENBQUNMLE9BQU8sQ0FBQ00sR0FBR0M7UUFDNUMsSUFBSUEsS0FBSyxNQUFNO1lBQ1gsT0FBTztRQUNYO1FBQ0EsSUFBSSxPQUFRQSxNQUFPLFVBQVU7WUFDekIsT0FBTyxDQUFDLE9BQU8sRUFBRUEsRUFBRUMsUUFBUSxHQUFHLENBQUM7UUFDbkM7UUFDQSxJQUFJLE9BQVFELE1BQU8sVUFBVTtZQUN6QixPQUFPQSxFQUFFRSxXQUFXO1FBQ3hCO1FBQ0EsbUJBQW1CO1FBQ25CLElBQUksT0FBUUYsTUFBTyxZQUFZLENBQUNHLE1BQU1DLE9BQU8sQ0FBQ0osSUFBSTtZQUM5QyxNQUFNSyxPQUFPQyxPQUFPRCxJQUFJLENBQUNMO1lBQ3pCSyxLQUFLRSxJQUFJO1lBQ1QsT0FBT0YsS0FBS0csTUFBTSxDQUFDLENBQUNDLE9BQU9DO2dCQUN2QkQsS0FBSyxDQUFDQyxJQUFJLEdBQUdWLENBQUMsQ0FBQ1UsSUFBSTtnQkFDbkIsT0FBT0Q7WUFDWCxHQUFHLENB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QSxtQ0FBbUM7SUFDbkMsSUFBSTtRQUNBLE1BQU12QixXQUFXMkssWUFBWXZLLE1BQU07UUFDbkMsSUFBSUosWUFBWSxNQUFNO1lBQ2xCLE1BQU0sSUFBSTVELE1BQU07UUFDcEI7UUFDQWdGLE9BQU9wQixRQUFRLEdBQUdBO0lBQ3RCLEVBQ0EsT0FBT2tCLE9BQU87UUFDVmhKLHVEQUFNQSxDQUFDLE9BQU8sbUNBQW1DLGtCQUFrQjtZQUMvRHFKLFFBQVE7UUFDWjtJQUNKO0lBQ0Esb0NBQW9DO0lBQ3BDckosdURBQU1BLENBQUNULDBEQUFTQSxDQUFDMkksTUFBTSxLQUFLLFNBQVMzSSwwREFBU0EsQ0FBQzZULE9BQU8sR0FBRyxLQUFLLDRDQUE0QyxrQkFBa0I7UUFDeEgvSixRQUFRO0lBQ1o7SUFDQUgsT0FBTzRELFFBQVEsR0FBR3ZOLDBEQUFTQSxDQUFDMkksTUFBTSxJQUFJO0lBQ3RDLDZEQUE2RDtJQUM3RCxJQUFJO1FBQ0EsTUFBTThFLFlBQVl5RixZQUFZdkssTUFBTTtRQUNwQyxJQUFJOEUsYUFBYSxNQUFNO1lBQ25CLE1BQU0sSUFBSTlJLE1BQU07UUFDcEI7UUFDQWdGLE9BQU84RCxTQUFTLEdBQUdBO0lBQ3ZCLEVBQ0EsT0FBT2hFLE9BQU87UUFDVmhKLHVEQUFNQSxDQUFDLE9BQU8sb0NBQW9DLGtCQUFrQjtZQUNoRXFKLFFBQVE7UUFDWjtJQUNKO0lBQ0FILE9BQU8wRCxTQUFTLEdBQUcsMENBQTBDNkcsS0FBSyxDQUFDLEtBQUs5TyxHQUFHLENBQUMsQ0FBQ3ZDLElBQU04RyxNQUFNLENBQUM5RyxFQUFFO0lBQzVGLE9BQU84RztBQUNYLEVBQ0EsNkNBQTZDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbWVnYXZpYmUtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vcHJvdmlkZXJzL2Fic3RyYWN0LXByb3ZpZGVyLmpzPzFlYTkiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiAgVGhlIGF2YWlsYWJsZSBwcm92aWRlcnMgc2hvdWxkIHN1ZmZpY2UgZm9yIG1vc3QgZGV2ZWxvcGVycyBwdXJwb3NlcyxcbiAqICBidXQgdGhlIFtbQWJzdHJhY3RQcm92aWRlcl1dIGNsYXNzIGhhcyBtYW55IGZlYXR1cmVzIHdoaWNoIGVuYWJsZVxuICogIHN1Yi1jbGFzc2luZyBpdCBmb3Igc3BlY2lmaWMgcHVycG9zZXMuXG4gKlxuICogIEBfc2VjdGlvbjogYXBpL3Byb3ZpZGVycy9hYnN0cmFjdC1wcm92aWRlcjogU3ViY2xhc3NpbmcgUHJvdmlkZXIgIFthYnN0cmFjdC1wcm92aWRlcl1cbiAqL1xuLy8gQFRPRE9cbi8vIEV2ZW50IGNvYWxlc2NlbmNlXG4vLyAgIFdoZW4gd2UgcmVnaXN0ZXIgYW4gZXZlbnQgd2l0aCBhbiBhc3luYyB2YWx1ZSAoZS5nLiBhZGRyZXNzIGlzIGEgU2lnbmVyXG4vLyAgIG9yIEVOUyBuYW1lKSwgd2UgbmVlZCB0byBhZGQgaXQgaW1tZWlkYXRlbHkgZm9yIHRoZSBFdmVudCBBUEksIGJ1dCBhbHNvXG4vLyAgIG5lZWQgdGltZSB0byByZXNvbHZlIHRoZSBhZGRyZXNzLiBVcG9uIHJlc29sdmluZyB0aGUgYWRkcmVzcywgd2UgbmVlZCB0b1xuLy8gICBtaWdyYXRlIHRoZSBsaXN0ZW5lciB0byB0aGUgc3RhdGljIGV2ZW50LiBXZSBhbHNvIG5lZWQgdG8gbWFpbnRhaW4gYSBtYXBcbi8vICAgb2YgU2lnbmVyL0VOUyBuYW1lIHRvIGFkZHJlc3Mgc28gd2UgY2FuIHN5bmMgcmVzcG9uZCB0byBsaXN0ZW5lckNvdW50LlxuaW1wb3J0IHsgZ2V0QWRkcmVzcywgcmVzb2x2ZUFkZHJlc3MgfSBmcm9tIFwiLi4vYWRkcmVzcy9pbmRleC5qc1wiO1xuaW1wb3J0IHsgWmVyb0FkZHJlc3MgfSBmcm9tIFwiLi4vY29uc3RhbnRzL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBDb250cmFjdCB9IGZyb20gXCIuLi9jb250cmFjdC9pbmRleC5qc1wiO1xuaW1wb3J0IHsgbmFtZWhhc2ggfSBmcm9tIFwiLi4vaGFzaC9pbmRleC5qc1wiO1xuaW1wb3J0IHsgVHJhbnNhY3Rpb24gfSBmcm9tIFwiLi4vdHJhbnNhY3Rpb24vaW5kZXguanNcIjtcbmltcG9ydCB7IGNvbmNhdCwgZGF0YUxlbmd0aCwgZGF0YVNsaWNlLCBoZXhsaWZ5LCBpc0hleFN0cmluZywgZ2V0QmlnSW50LCBnZXRCeXRlcywgZ2V0TnVtYmVyLCBpc0NhbGxFeGNlcHRpb24sIGlzRXJyb3IsIG1ha2VFcnJvciwgYXNzZXJ0LCBhc3NlcnRBcmd1bWVudCwgRmV0Y2hSZXF1ZXN0LCB0b0JlQXJyYXksIHRvUXVhbnRpdHksIGRlZmluZVByb3BlcnRpZXMsIEV2ZW50UGF5bG9hZCwgcmVzb2x2ZVByb3BlcnRpZXMsIHRvVXRmOFN0cmluZyB9IGZyb20gXCIuLi91dGlscy9pbmRleC5qc1wiO1xuaW1wb3J0IHsgRW5zUmVzb2x2ZXIgfSBmcm9tIFwiLi9lbnMtcmVzb2x2ZXIuanNcIjtcbmltcG9ydCB7IGZvcm1hdEJsb2NrLCBmb3JtYXRMb2csIGZvcm1hdFRyYW5zYWN0aW9uUmVjZWlwdCwgZm9ybWF0VHJhbnNhY3Rpb25SZXNwb25zZSB9IGZyb20gXCIuL2Zvcm1hdC5qc1wiO1xuaW1wb3J0IHsgTmV0d29yayB9IGZyb20gXCIuL25ldHdvcmsuanNcIjtcbmltcG9ydCB7IGNvcHlSZXF1ZXN0LCBCbG9jaywgRmVlRGF0YSwgTG9nLCBUcmFuc2FjdGlvblJlY2VpcHQsIFRyYW5zYWN0aW9uUmVzcG9uc2UgfSBmcm9tIFwiLi9wcm92aWRlci5qc1wiO1xuaW1wb3J0IHsgUG9sbGluZ0Jsb2NrU3Vic2NyaWJlciwgUG9sbGluZ0Jsb2NrVGFnU3Vic2NyaWJlciwgUG9sbGluZ0V2ZW50U3Vic2NyaWJlciwgUG9sbGluZ09ycGhhblN1YnNjcmliZXIsIFBvbGxpbmdUcmFuc2FjdGlvblN1YnNjcmliZXIgfSBmcm9tIFwiLi9zdWJzY3JpYmVyLXBvbGxpbmcuanNcIjtcbi8vIENvbnN0YW50c1xuY29uc3QgQk5fMiA9IEJpZ0ludCgyKTtcbmNvbnN0IE1BWF9DQ0lQX1JFRElSRUNUUyA9IDEwO1xuZnVuY3Rpb24gaXNQcm9taXNlKHZhbHVlKSB7XG4gICAgcmV0dXJuICh2YWx1ZSAmJiB0eXBlb2YgKHZhbHVlLnRoZW4pID09PSBcImZ1bmN0aW9uXCIpO1xufVxuZnVuY3Rpb24gZ2V0VGFnKHByZWZpeCwgdmFsdWUpIHtcbiAgICByZXR1cm4gcHJlZml4ICsgXCI6XCIgKyBKU09OLnN0cmluZ2lmeSh2YWx1ZSwgKGssIHYpID0+IHtcbiAgICAgICAgaWYgKHYgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIFwibnVsbFwiO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgKHYpID09PSBcImJpZ2ludFwiKSB7XG4gICAgICAgICAgICByZXR1cm4gYGJpZ2ludDoke3YudG9TdHJpbmcoKX1gO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgKHYpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICByZXR1cm4gdi50b0xvd2VyQ2FzZSgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNvcnQgb2JqZWN0IGtleXNcbiAgICAgICAgaWYgKHR5cGVvZiAodikgPT09IFwib2JqZWN0XCIgJiYgIUFycmF5LmlzQXJyYXkodikpIHtcbiAgICAgICAgICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyh2KTtcbiAgICAgICAgICAgIGtleXMuc29ydCgpO1xuICAgICAgICAgICAgcmV0dXJuIGtleXMucmVkdWNlKChhY2N1bSwga2V5KSA9PiB7XG4gICAgICAgICAgICAgICAgYWNjdW1ba2V5XSA9IHZba2V5XTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYWNjdW07XG4gICAgICAgICAgICB9LCB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHY7XG4gICAgfSk7XG59XG4vKipcbiAqICBBbiAqKlVubWFuYWdlZFN1YnNjcmliZXIqKiBpcyB1c2VmdWwgZm9yIGV2ZW50cyB3aGljaCBkbyBub3QgcmVxdWlyZVxuICogIGFueSBhZGRpdGlvbmFsIG1hbmFnZW1lbnQsIHN1Y2ggYXMgYGBcImRlYnVnXCJgYCB3aGljaCBvbmx5IHJlcXVpcmVzXG4gKiAgZW1pdCBpbiBzeW5jaHJvbm91cyBldmVudCBsb29wIHRyaWdnZXJlZCBjYWxscy5cbiAqL1xuZXhwb3J0IGNsYXNzIFVubWFuYWdlZFN1YnNjcmliZXIge1xuICAgIC8qKlxuICAgICAqICBUaGUgbmFtZSBmb2YgdGhlIGV2ZW50LlxuICAgICAqL1xuICAgIG5hbWU7XG4gICAgLyoqXG4gICAgICogIENyZWF0ZSBhIG5ldyBVbm1hbmFnZWRTdWJzY3JpYmVyIHdpdGggJSVuYW1lJSUuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IobmFtZSkgeyBkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHsgbmFtZSB9KTsgfVxuICAgIHN0YXJ0KCkgeyB9XG4gICAgc3RvcCgpIHsgfVxuICAgIHBhdXNlKGRyb3BXaGlsZVBhdXNlZCkgeyB9XG4gICAgcmVzdW1lKCkgeyB9XG59XG5mdW5jdGlvbiBjb3B5KHZhbHVlKSB7XG4gICAgcmV0dXJuIEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkodmFsdWUpKTtcbn1cbmZ1bmN0aW9uIGNvbmNpc2lmeShpdGVtcykge1xuICAgIGl0ZW1zID0gQXJyYXkuZnJvbSgobmV3IFNldChpdGVtcykpLnZhbHVlcygpKTtcbiAgICBpdGVtcy5zb3J0KCk7XG4gICAgcmV0dXJuIGl0ZW1zO1xufVxuYXN5bmMgZnVuY3Rpb24gZ2V0U3Vic2NyaXB0aW9uKF9ldmVudCwgcHJvdmlkZXIpIHtcbiAgICBpZiAoX2V2ZW50ID09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBldmVudFwiKTtcbiAgICB9XG4gICAgLy8gTm9ybWFsaXplIHRvcGljIGFycmF5IGluZm8gYW4gRXZlbnRGaWx0ZXJcbiAgICBpZiAoQXJyYXkuaXNBcnJheShfZXZlbnQpKSB7XG4gICAgICAgIF9ldmVudCA9IHsgdG9waWNzOiBfZXZlbnQgfTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiAoX2V2ZW50KSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBzd2l0Y2ggKF9ldmVudCkge1xuICAgICAgICAgICAgY2FzZSBcImJsb2NrXCI6XG4gICAgICAgICAgICBjYXNlIFwiZGVidWdcIjpcbiAgICAgICAgICAgIGNhc2UgXCJlcnJvclwiOlxuICAgICAgICAgICAgY2FzZSBcImZpbmFsaXplZFwiOlxuICAgICAgICAgICAgY2FzZSBcIm5ldHdvcmtcIjpcbiAgICAgICAgICAgIGNhc2UgXCJwZW5kaW5nXCI6XG4gICAgICAgICAgICBjYXNlIFwic2FmZVwiOiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgdHlwZTogX2V2ZW50LCB0YWc6IF9ldmVudCB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChpc0hleFN0cmluZyhfZXZlbnQsIDMyKSkge1xuICAgICAgICBjb25zdCBoYXNoID0gX2V2ZW50LnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIHJldHVybiB7IHR5cGU6IFwidHJhbnNhY3Rpb25cIiwgdGFnOiBnZXRUYWcoXCJ0eFwiLCB7IGhhc2ggfSksIGhhc2ggfTtcbiAgICB9XG4gICAgaWYgKF9ldmVudC5vcnBoYW4pIHtcbiAgICAgICAgY29uc3QgZXZlbnQgPSBfZXZlbnQ7XG4gICAgICAgIC8vIEBUT0RPOiBTaG91bGQgbG93ZXJjYXNlIGFuZCB3aGF0bm90IHRoaW5ncyBoZXJlIGluc3RlYWQgb2YgY29weS4uLlxuICAgICAgICByZXR1cm4geyB0eXBlOiBcIm9ycGhhblwiLCB0YWc6IGdldFRhZyhcIm9ycGhhblwiLCBldmVudCksIGZpbHRlcjogY29weShldmVudCkgfTtcbiAgICB9XG4gICAgaWYgKChfZXZlbnQuYWRkcmVzcyB8fCBfZXZlbnQudG9waWNzKSkge1xuICAgICAgICBjb25zdCBldmVudCA9IF9ldmVudDtcbiAgICAgICAgY29uc3QgZmlsdGVyID0ge1xuICAgICAgICAgICAgdG9waWNzOiAoKGV2ZW50LnRvcGljcyB8fCBbXSkubWFwKCh0KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbmNpc2lmeSh0Lm1hcCgodCkgPT4gdC50b0xvd2VyQ2FzZSgpKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0LnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICB9KSlcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGV2ZW50LmFkZHJlc3MpIHtcbiAgICAgICAgICAgIGNvbnN0IGFkZHJlc3NlcyA9IFtdO1xuICAgICAgICAgICAgY29uc3QgcHJvbWlzZXMgPSBbXTtcbiAgICAgICAgICAgIGNvbnN0IGFkZEFkZHJlc3MgPSAoYWRkcikgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChpc0hleFN0cmluZyhhZGRyKSkge1xuICAgICAgICAgICAgICAgICAgICBhZGRyZXNzZXMucHVzaChhZGRyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHByb21pc2VzLnB1c2goKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZHJlc3Nlcy5wdXNoKGF3YWl0IHJlc29sdmVBZGRyZXNzKGFkZHIsIHByb3ZpZGVyKSk7XG4gICAgICAgICAgICAgICAgICAgIH0pKCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShldmVudC5hZGRyZXNzKSkge1xuICAgICAgICAgICAgICAgIGV2ZW50LmFkZHJlc3MuZm9yRWFjaChhZGRBZGRyZXNzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGFkZEFkZHJlc3MoZXZlbnQuYWRkcmVzcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocHJvbWlzZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwocHJvbWlzZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmlsdGVyLmFkZHJlc3MgPSBjb25jaXNpZnkoYWRkcmVzc2VzLm1hcCgoYSkgPT4gYS50b0xvd2VyQ2FzZSgpKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgZmlsdGVyLCB0YWc6IGdldFRhZyhcImV2ZW50XCIsIGZpbHRlciksIHR5cGU6IFwiZXZlbnRcIiB9O1xuICAgIH1cbiAgICBhc3NlcnRBcmd1bWVudChmYWxzZSwgXCJ1bmtub3duIFByb3ZpZGVyRXZlbnRcIiwgXCJldmVudFwiLCBfZXZlbnQpO1xufVxuZnVuY3Rpb24gZ2V0VGltZSgpIHsgcmV0dXJuIChuZXcgRGF0ZSgpKS5nZXRUaW1lKCk7IH1cbmNvbnN0IGRlZmF1bHRPcHRpb25zID0ge1xuICAgIGNhY2hlVGltZW91dDogMjUwLFxuICAgIHBvbGxpbmdJbnRlcnZhbDogNDAwMFxufTtcbi8qKlxuICogIEFuICoqQWJzdHJhY3RQcm92aWRlcioqIHByb3ZpZGVzIGEgYmFzZSBjbGFzcyBmb3Igb3RoZXIgc3ViLWNsYXNzZXMgdG9cbiAqICBpbXBsZW1lbnQgdGhlIFtbUHJvdmlkZXJdXSBBUEkgYnkgbm9ybWFsaXppbmcgaW5wdXQgYXJndW1lbnRzIGFuZFxuICogIGZvcm1hdHRpbmcgb3V0cHV0IHJlc3VsdHMgYXMgd2VsbCBhcyB0cmFja2luZyBldmVudHMgZm9yIGNvbnNpc3RlbnRcbiAqICBiZWhhdmlvdXIgb24gYW4gZXZlbnR1YWxseS1jb25zaXN0ZW50IG5ldHdvcmsuXG4gKi9cbmV4cG9ydCBjbGFzcyBBYnN0cmFjdFByb3ZpZGVyIHtcbiAgICAjc3VicztcbiAgICAjcGx1Z2lucztcbiAgICAvLyBudWxsPXVucGF1c2VkLCB0cnVlPXBhdXNlZCtkcm9wV2hpbGVQYXVzZWQsIGZhbHNlPXBhdXNlZFxuICAgICNwYXVzZWRTdGF0ZTtcbiAgICAjZGVzdHJveWVkO1xuICAgICNuZXR3b3JrUHJvbWlzZTtcbiAgICAjYW55TmV0d29yaztcbiAgICAjcGVyZm9ybUNhY2hlO1xuICAgIC8vIFRoZSBtb3N0IHJlY2VudCBibG9jayBudW1iZXIgaWYgcnVubmluZyBhbiBldmVudCBvciAtMSBpZiBubyBcImJsb2NrXCIgZXZlbnRcbiAgICAjbGFzdEJsb2NrTnVtYmVyO1xuICAgICNuZXh0VGltZXI7XG4gICAgI3RpbWVycztcbiAgICAjZGlzYWJsZUNjaXBSZWFkO1xuICAgICNvcHRpb25zO1xuICAgIC8qKlxuICAgICAqICBDcmVhdGUgYSBuZXcgKipBYnN0cmFjdFByb3ZpZGVyKiogY29ubmVjdGVkIHRvICUlbmV0d29yayUlLCBvclxuICAgICAqICB1c2UgdGhlIHZhcmlvdXMgbmV0d29yayBkZXRlY3Rpb24gY2FwYWJpbGl0aWVzIHRvIGRpc2NvdmVyIHRoZVxuICAgICAqICBbW05ldHdvcmtdXSBpZiBuZWNlc3NhcnkuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoX25ldHdvcmssIG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy4jb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRPcHRpb25zLCBvcHRpb25zIHx8IHt9KTtcbiAgICAgICAgaWYgKF9uZXR3b3JrID09PSBcImFueVwiKSB7XG4gICAgICAgICAgICB0aGlzLiNhbnlOZXR3b3JrID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuI25ldHdvcmtQcm9taXNlID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChfbmV0d29yaykge1xuICAgICAgICAgICAgY29uc3QgbmV0d29yayA9IE5ldHdvcmsuZnJvbShfbmV0d29yayk7XG4gICAgICAgICAgICB0aGlzLiNhbnlOZXR3b3JrID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLiNuZXR3b3JrUHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZShuZXR3b3JrKTtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4geyB0aGlzLmVtaXQoXCJuZXR3b3JrXCIsIG5ldHdvcmssIG51bGwpOyB9LCAwKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuI2FueU5ldHdvcmsgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuI25ldHdvcmtQcm9taXNlID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLiNsYXN0QmxvY2tOdW1iZXIgPSAtMTtcbiAgICAgICAgdGhpcy4jcGVyZm9ybUNhY2hlID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLiNzdWJzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLiNwbHVnaW5zID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLiNwYXVzZWRTdGF0ZSA9IG51bGw7XG4gICAgICAgIHRoaXMuI2Rlc3Ryb3llZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLiNuZXh0VGltZXIgPSAxO1xuICAgICAgICB0aGlzLiN0aW1lcnMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuI2Rpc2FibGVDY2lwUmVhZCA9IGZhbHNlO1xuICAgIH1cbiAgICBnZXQgcG9sbGluZ0ludGVydmFsKCkgeyByZXR1cm4gdGhpcy4jb3B0aW9ucy5wb2xsaW5nSW50ZXJ2YWw7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBgYHRoaXNgYCwgdG8gYWxsb3cgYW4gKipBYnN0cmFjdFByb3ZpZGVyKiogdG8gaW1wbGVtZW50XG4gICAgICogIHRoZSBbW0NvbnRyYWN0UnVubmVyXV0gaW50ZXJmYWNlLlxuICAgICAqL1xuICAgIGdldCBwcm92aWRlcigpIHsgcmV0dXJuIHRoaXM7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBhbGwgdGhlIHJlZ2lzdGVyZWQgcGx1Zy1pbnMuXG4gICAgICovXG4gICAgZ2V0IHBsdWdpbnMoKSB7XG4gICAgICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMuI3BsdWdpbnMudmFsdWVzKCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQXR0YWNoIGEgbmV3IHBsdWctaW4uXG4gICAgICovXG4gICAgYXR0YWNoUGx1Z2luKHBsdWdpbikge1xuICAgICAgICBpZiAodGhpcy4jcGx1Z2lucy5nZXQocGx1Z2luLm5hbWUpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGNhbm5vdCByZXBsYWNlIGV4aXN0aW5nIHBsdWdpbjogJHtwbHVnaW4ubmFtZX0gYCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4jcGx1Z2lucy5zZXQocGx1Z2luLm5hbWUsIHBsdWdpbi5jb25uZWN0KHRoaXMpKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBHZXQgYSBwbHVnaW4gYnkgbmFtZS5cbiAgICAgKi9cbiAgICBnZXRQbHVnaW4obmFtZSkge1xuICAgICAgICByZXR1cm4gKHRoaXMuI3BsdWdpbnMuZ2V0KG5hbWUpKSB8fCBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUHJldmVudCBhbnkgQ0NJUC1yZWFkIG9wZXJhdGlvbiwgcmVnYXJkbGVzcyBvZiB3aGV0aGVyIHJlcXVlc3RlZFxuICAgICAqICBpbiBhIFtbY2FsbF1dIHVzaW5nIGBgZW5hYmxlQ2NpcFJlYWRgYC5cbiAgICAgKi9cbiAgICBnZXQgZGlzYWJsZUNjaXBSZWFkKCkgeyByZXR1cm4gdGhpcy4jZGlzYWJsZUNjaXBSZWFkOyB9XG4gICAgc2V0IGRpc2FibGVDY2lwUmVhZCh2YWx1ZSkgeyB0aGlzLiNkaXNhYmxlQ2NpcFJlYWQgPSAhIXZhbHVlOyB9XG4gICAgLy8gU2hhcmVzIG11bHRpcGxlIGlkZW50aWNhbCByZXF1ZXN0cyBtYWRlIGR1cmluZyB0aGUgc2FtZSAyNTBtc1xuICAgIGFzeW5jICNwZXJmb3JtKHJlcSkge1xuICAgICAgICBjb25zdCB0aW1lb3V0ID0gdGhpcy4jb3B0aW9ucy5jYWNoZVRpbWVvdXQ7XG4gICAgICAgIC8vIENhY2hpbmcgZGlzYWJsZWRcbiAgICAgICAgaWYgKHRpbWVvdXQgPCAwKSB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5fcGVyZm9ybShyZXEpO1xuICAgICAgICB9XG4gICAgICAgIC8vIENyZWF0ZSBhIHRhZ1xuICAgICAgICBjb25zdCB0YWcgPSBnZXRUYWcocmVxLm1ldGhvZCwgcmVxKTtcbiAgICAgICAgbGV0IHBlcmZvcm0gPSB0aGlzLiNwZXJmb3JtQ2FjaGUuZ2V0KHRhZyk7XG4gICAgICAgIGlmICghcGVyZm9ybSkge1xuICAgICAgICAgICAgcGVyZm9ybSA9IHRoaXMuX3BlcmZvcm0ocmVxKTtcbiAgICAgICAgICAgIHRoaXMuI3BlcmZvcm1DYWNoZS5zZXQodGFnLCBwZXJmb3JtKTtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLiNwZXJmb3JtQ2FjaGUuZ2V0KHRhZykgPT09IHBlcmZvcm0pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4jcGVyZm9ybUNhY2hlLmRlbGV0ZSh0YWcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHRpbWVvdXQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhd2FpdCBwZXJmb3JtO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmVzb2x2ZXMgdG8gdGhlIGRhdGEgZm9yIGV4ZWN1dGluZyB0aGUgQ0NJUC1yZWFkIG9wZXJhdGlvbnMuXG4gICAgICovXG4gICAgYXN5bmMgY2NpcFJlYWRGZXRjaCh0eCwgY2FsbGRhdGEsIHVybHMpIHtcbiAgICAgICAgaWYgKHRoaXMuZGlzYWJsZUNjaXBSZWFkIHx8IHVybHMubGVuZ3RoID09PSAwIHx8IHR4LnRvID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNlbmRlciA9IHR4LnRvLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBjYWxsZGF0YS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBjb25zdCBlcnJvck1lc3NhZ2VzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdXJscy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgdXJsID0gdXJsc1tpXTtcbiAgICAgICAgICAgIC8vIFVSTCBleHBhbnNpb25cbiAgICAgICAgICAgIGNvbnN0IGhyZWYgPSB1cmwucmVwbGFjZShcIntzZW5kZXJ9XCIsIHNlbmRlcikucmVwbGFjZShcIntkYXRhfVwiLCBkYXRhKTtcbiAgICAgICAgICAgIC8vIElmIG5vIHtkYXRhfSBpcyBwcmVzZW50LCB1c2UgUE9TVDsgb3RoZXJ3aXNlIEdFVFxuICAgICAgICAgICAgLy9jb25zdCBqc29uOiBzdHJpbmcgfCBudWxsID0gKHVybC5pbmRleE9mKFwie2RhdGF9XCIpID49IDApID8gbnVsbDogSlNPTi5zdHJpbmdpZnkoeyBkYXRhLCBzZW5kZXIgfSk7XG4gICAgICAgICAgICAvL2NvbnN0IHJlc3VsdCA9IGF3YWl0IGZldGNoSnNvbih7IHVybDogaHJlZiwgZXJyb3JQYXNzVGhyb3VnaDogdHJ1ZSB9LCBqc29uLCAodmFsdWUsIHJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAvLyAgICB2YWx1ZS5zdGF0dXMgPSByZXNwb25zZS5zdGF0dXNDb2RlO1xuICAgICAgICAgICAgLy8gICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgLy99KTtcbiAgICAgICAgICAgIGNvbnN0IHJlcXVlc3QgPSBuZXcgRmV0Y2hSZXF1ZXN0KGhyZWYpO1xuICAgICAgICAgICAgaWYgKHVybC5pbmRleE9mKFwie2RhdGF9XCIpID09PSAtMSkge1xuICAgICAgICAgICAgICAgIHJlcXVlc3QuYm9keSA9IHsgZGF0YSwgc2VuZGVyIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmVtaXQoXCJkZWJ1Z1wiLCB7IGFjdGlvbjogXCJzZW5kQ2NpcFJlYWRGZXRjaFJlcXVlc3RcIiwgcmVxdWVzdCwgaW5kZXg6IGksIHVybHMgfSk7XG4gICAgICAgICAgICBsZXQgZXJyb3JNZXNzYWdlID0gXCJ1bmtub3duIGVycm9yXCI7XG4gICAgICAgICAgICAvLyBGZXRjaCB0aGUgcmVzb3VyY2UuLi5cbiAgICAgICAgICAgIGxldCByZXNwO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXNwID0gYXdhaXQgcmVxdWVzdC5zZW5kKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAvLyAuLi5sb3ctbGV2ZWwgZmV0Y2ggZXJyb3IgKG1pc3NpbmcgaG9zdCwgYmFkIFNTTCwgZXRjLiksXG4gICAgICAgICAgICAgICAgLy8gc28gdHJ5IG5leHQgVVJMXG4gICAgICAgICAgICAgICAgZXJyb3JNZXNzYWdlcy5wdXNoKGVycm9yLm1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcImRlYnVnXCIsIHsgYWN0aW9uOiBcInJlY2VpdmVDY2lwUmVhZEZldGNoRXJyb3JcIiwgcmVxdWVzdCwgcmVzdWx0OiB7IGVycm9yIH0gfSk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHJlc3AuYm9keUpzb247XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5kYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcImRlYnVnXCIsIHsgYWN0aW9uOiBcInJlY2VpdmVDY2lwUmVhZEZldGNoUmVzdWx0XCIsIHJlcXVlc3QsIHJlc3VsdCB9KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC5kYXRhO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0Lm1lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JNZXNzYWdlID0gcmVzdWx0Lm1lc3NhZ2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcImRlYnVnXCIsIHsgYWN0aW9uOiBcInJlY2VpdmVDY2lwUmVhZEZldGNoRXJyb3JcIiwgcmVxdWVzdCwgcmVzdWx0IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7IH1cbiAgICAgICAgICAgIC8vIDR4eCBpbmRpY2F0ZXMgdGhlIHJlc3VsdCBpcyBub3QgcHJlc2VudDsgc3RvcFxuICAgICAgICAgICAgYXNzZXJ0KHJlc3Auc3RhdHVzQ29kZSA8IDQwMCB8fCByZXNwLnN0YXR1c0NvZGUgPj0gNTAwLCBgcmVzcG9uc2Ugbm90IGZvdW5kIGR1cmluZyBDQ0lQIGZldGNoOiAke2Vycm9yTWVzc2FnZX1gLCBcIk9GRkNIQUlOX0ZBVUxUXCIsIHsgcmVhc29uOiBcIjQwNF9NSVNTSU5HX1JFU09VUkNFXCIsIHRyYW5zYWN0aW9uOiB0eCwgaW5mbzogeyB1cmwsIGVycm9yTWVzc2FnZSB9IH0pO1xuICAgICAgICAgICAgLy8gNXh4IGluZGljYXRlcyBzZXJ2ZXIgaXNzdWU7IHRyeSB0aGUgbmV4dCB1cmxcbiAgICAgICAgICAgIGVycm9yTWVzc2FnZXMucHVzaChlcnJvck1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgICAgIGFzc2VydChmYWxzZSwgYGVycm9yIGVuY291bnRlcmVkIGR1cmluZyBDQ0lQIGZldGNoOiAke2Vycm9yTWVzc2FnZXMubWFwKChtKSA9PiBKU09OLnN0cmluZ2lmeShtKSkuam9pbihcIiwgXCIpfWAsIFwiT0ZGQ0hBSU5fRkFVTFRcIiwge1xuICAgICAgICAgICAgcmVhc29uOiBcIjUwMF9TRVJWRVJfRVJST1JcIixcbiAgICAgICAgICAgIHRyYW5zYWN0aW9uOiB0eCwgaW5mbzogeyB1cmxzLCBlcnJvck1lc3NhZ2VzIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBQcm92aWRlcyB0aGUgb3Bwb3J0dW5pdHkgZm9yIGEgc3ViLWNsYXNzIHRvIHdyYXAgYSBibG9jayBiZWZvcmVcbiAgICAgKiAgcmV0dXJuaW5nIGl0LCB0byBhZGQgYWRkaXRpb25hbCBwcm9wZXJ0aWVzIG9yIGFuIGFsdGVybmF0ZVxuICAgICAqICBzdWItY2xhc3Mgb2YgW1tCbG9ja11dLlxuICAgICAqL1xuICAgIF93cmFwQmxvY2sodmFsdWUsIG5ldHdvcmspIHtcbiAgICAgICAgcmV0dXJuIG5ldyBCbG9jayhmb3JtYXRCbG9jayh2YWx1ZSksIHRoaXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUHJvdmlkZXMgdGhlIG9wcG9ydHVuaXR5IGZvciBhIHN1Yi1jbGFzcyB0byB3cmFwIGEgbG9nIGJlZm9yZVxuICAgICAqICByZXR1cm5pbmcgaXQsIHRvIGFkZCBhZGRpdGlvbmFsIHByb3BlcnRpZXMgb3IgYW4gYWx0ZXJuYXRlXG4gICAgICogIHN1Yi1jbGFzcyBvZiBbW0xvZ11dLlxuICAgICAqL1xuICAgIF93cmFwTG9nKHZhbHVlLCBuZXR3b3JrKSB7XG4gICAgICAgIHJldHVybiBuZXcgTG9nKGZvcm1hdExvZyh2YWx1ZSksIHRoaXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUHJvdmlkZXMgdGhlIG9wcG9ydHVuaXR5IGZvciBhIHN1Yi1jbGFzcyB0byB3cmFwIGEgdHJhbnNhY3Rpb25cbiAgICAgKiAgcmVjZWlwdCBiZWZvcmUgcmV0dXJuaW5nIGl0LCB0byBhZGQgYWRkaXRpb25hbCBwcm9wZXJ0aWVzIG9yIGFuXG4gICAgICogIGFsdGVybmF0ZSBzdWItY2xhc3Mgb2YgW1tUcmFuc2FjdGlvblJlY2VpcHRdXS5cbiAgICAgKi9cbiAgICBfd3JhcFRyYW5zYWN0aW9uUmVjZWlwdCh2YWx1ZSwgbmV0d29yaykge1xuICAgICAgICByZXR1cm4gbmV3IFRyYW5zYWN0aW9uUmVjZWlwdChmb3JtYXRUcmFuc2FjdGlvblJlY2VpcHQodmFsdWUpLCB0aGlzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFByb3ZpZGVzIHRoZSBvcHBvcnR1bml0eSBmb3IgYSBzdWItY2xhc3MgdG8gd3JhcCBhIHRyYW5zYWN0aW9uXG4gICAgICogIHJlc3BvbnNlIGJlZm9yZSByZXR1cm5pbmcgaXQsIHRvIGFkZCBhZGRpdGlvbmFsIHByb3BlcnRpZXMgb3IgYW5cbiAgICAgKiAgYWx0ZXJuYXRlIHN1Yi1jbGFzcyBvZiBbW1RyYW5zYWN0aW9uUmVzcG9uc2VdXS5cbiAgICAgKi9cbiAgICBfd3JhcFRyYW5zYWN0aW9uUmVzcG9uc2UodHgsIG5ldHdvcmspIHtcbiAgICAgICAgcmV0dXJuIG5ldyBUcmFuc2FjdGlvblJlc3BvbnNlKGZvcm1hdFRyYW5zYWN0aW9uUmVzcG9uc2UodHgpLCB0aGlzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJlc29sdmVzIHRvIHRoZSBOZXR3b3JrLCBmb3JjaW5nIGEgbmV0d29yayBkZXRlY3Rpb24gdXNpbmcgd2hhdGV2ZXJcbiAgICAgKiAgdGVjaG5pcXVlIHRoZSBzdWItY2xhc3MgcmVxdWlyZXMuXG4gICAgICpcbiAgICAgKiAgU3ViLWNsYXNzZXMgKiptdXN0Kiogb3ZlcnJpZGUgdGhpcy5cbiAgICAgKi9cbiAgICBfZGV0ZWN0TmV0d29yaygpIHtcbiAgICAgICAgYXNzZXJ0KGZhbHNlLCBcInN1Yi1jbGFzc2VzIG11c3QgaW1wbGVtZW50IHRoaXNcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwge1xuICAgICAgICAgICAgb3BlcmF0aW9uOiBcIl9kZXRlY3ROZXR3b3JrXCJcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBTdWItY2xhc3NlcyBzaG91bGQgdXNlIHRoaXMgdG8gcGVyZm9ybSBhbGwgYnVpbHQtaW4gb3BlcmF0aW9ucy4gQWxsXG4gICAgICogIG1ldGhvZHMgc2FuaXRpemVzIGFuZCBub3JtYWxpemVzIHRoZSB2YWx1ZXMgcGFzc2VkIGludG8gdGhpcy5cbiAgICAgKlxuICAgICAqICBTdWItY2xhc3NlcyAqKm11c3QqKiBvdmVycmlkZSB0aGlzLlxuICAgICAqL1xuICAgIGFzeW5jIF9wZXJmb3JtKHJlcSkge1xuICAgICAgICBhc3NlcnQoZmFsc2UsIGB1bnN1cHBvcnRlZCBtZXRob2Q6ICR7cmVxLm1ldGhvZH1gLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7XG4gICAgICAgICAgICBvcGVyYXRpb246IHJlcS5tZXRob2QsXG4gICAgICAgICAgICBpbmZvOiByZXFcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8vIFN0YXRlXG4gICAgYXN5bmMgZ2V0QmxvY2tOdW1iZXIoKSB7XG4gICAgICAgIGNvbnN0IGJsb2NrTnVtYmVyID0gZ2V0TnVtYmVyKGF3YWl0IHRoaXMuI3BlcmZvcm0oeyBtZXRob2Q6IFwiZ2V0QmxvY2tOdW1iZXJcIiB9KSwgXCIlcmVzcG9uc2VcIik7XG4gICAgICAgIGlmICh0aGlzLiNsYXN0QmxvY2tOdW1iZXIgPj0gMCkge1xuICAgICAgICAgICAgdGhpcy4jbGFzdEJsb2NrTnVtYmVyID0gYmxvY2tOdW1iZXI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJsb2NrTnVtYmVyO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBvciByZXNvbHZlcyB0byB0aGUgYWRkcmVzcyBmb3IgJSVhZGRyZXNzJSUsIHJlc29sdmluZyBFTlNcbiAgICAgKiAgbmFtZXMgYW5kIFtbQWRkcmVzc2FibGVdXSBvYmplY3RzIGFuZCByZXR1cm5pbmcgaWYgYWxyZWFkeSBhblxuICAgICAqICBhZGRyZXNzLlxuICAgICAqL1xuICAgIF9nZXRBZGRyZXNzKGFkZHJlc3MpIHtcbiAgICAgICAgcmV0dXJuIHJlc29sdmVBZGRyZXNzKGFkZHJlc3MsIHRoaXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBvciByZXNvbHZlcyB0byBhIHZhbGlkIGJsb2NrIHRhZyBmb3IgJSVibG9ja1RhZyUlLCByZXNvbHZpbmdcbiAgICAgKiAgbmVnYXRpdmUgdmFsdWVzIGFuZCByZXR1cm5pbmcgaWYgYWxyZWFkeSBhIHZhbGlkIGJsb2NrIHRhZy5cbiAgICAgKi9cbiAgICBfZ2V0QmxvY2tUYWcoYmxvY2tUYWcpIHtcbiAgICAgICAgaWYgKGJsb2NrVGFnID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBcImxhdGVzdFwiO1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAoYmxvY2tUYWcpIHtcbiAgICAgICAgICAgIGNhc2UgXCJlYXJsaWVzdFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBcIjB4MFwiO1xuICAgICAgICAgICAgY2FzZSBcImZpbmFsaXplZFwiOlxuICAgICAgICAgICAgY2FzZSBcImxhdGVzdFwiOlxuICAgICAgICAgICAgY2FzZSBcInBlbmRpbmdcIjpcbiAgICAgICAgICAgIGNhc2UgXCJzYWZlXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGJsb2NrVGFnO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0hleFN0cmluZyhibG9ja1RhZykpIHtcbiAgICAgICAgICAgIGlmIChpc0hleFN0cmluZyhibG9ja1RhZywgMzIpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGJsb2NrVGFnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRvUXVhbnRpdHkoYmxvY2tUYWcpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgKGJsb2NrVGFnKSA9PT0gXCJiaWdpbnRcIikge1xuICAgICAgICAgICAgYmxvY2tUYWcgPSBnZXROdW1iZXIoYmxvY2tUYWcsIFwiYmxvY2tUYWdcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiAoYmxvY2tUYWcpID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICBpZiAoYmxvY2tUYWcgPj0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0b1F1YW50aXR5KGJsb2NrVGFnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLiNsYXN0QmxvY2tOdW1iZXIgPj0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0b1F1YW50aXR5KHRoaXMuI2xhc3RCbG9ja051bWJlciArIGJsb2NrVGFnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldEJsb2NrTnVtYmVyKCkudGhlbigoYikgPT4gdG9RdWFudGl0eShiICsgYmxvY2tUYWcpKTtcbiAgICAgICAgfVxuICAgICAgICBhc3NlcnRBcmd1bWVudChmYWxzZSwgXCJpbnZhbGlkIGJsb2NrVGFnXCIsIFwiYmxvY2tUYWdcIiwgYmxvY2tUYWcpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBvciByZXNvbHZlcyB0byBhIGZpbHRlciBmb3IgJSVmaWx0ZXIlJSwgcmVzb2x2aW5nIGFueSBFTlNcbiAgICAgKiAgbmFtZXMgb3IgW1tBZGRyZXNzYWJsZV1dIG9iamVjdCBhbmQgcmV0dXJuaW5nIGlmIGFscmVhZHkgYSB2YWxpZFxuICAgICAqICBmaWx0ZXIuXG4gICAgICovXG4gICAgX2dldEZpbHRlcihmaWx0ZXIpIHtcbiAgICAgICAgLy8gQ3JlYXRlIGEgY2Fub25pY2FsIHJlcHJlc2VudGF0aW9uIG9mIHRoZSB0b3BpY3NcbiAgICAgICAgY29uc3QgdG9waWNzID0gKGZpbHRlci50b3BpY3MgfHwgW10pLm1hcCgodCkgPT4ge1xuICAgICAgICAgICAgaWYgKHQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29uY2lzaWZ5KHQubWFwKCh0KSA9PiB0LnRvTG93ZXJDYXNlKCkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0LnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBibG9ja0hhc2ggPSAoXCJibG9ja0hhc2hcIiBpbiBmaWx0ZXIpID8gZmlsdGVyLmJsb2NrSGFzaCA6IHVuZGVmaW5lZDtcbiAgICAgICAgY29uc3QgcmVzb2x2ZSA9IChfYWRkcmVzcywgZnJvbUJsb2NrLCB0b0Jsb2NrKSA9PiB7XG4gICAgICAgICAgICBsZXQgYWRkcmVzcyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHN3aXRjaCAoX2FkZHJlc3MubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOiBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIGFkZHJlc3MgPSBfYWRkcmVzc1swXTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgX2FkZHJlc3Muc29ydCgpO1xuICAgICAgICAgICAgICAgICAgICBhZGRyZXNzID0gX2FkZHJlc3M7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYmxvY2tIYXNoKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZyb21CbG9jayAhPSBudWxsIHx8IHRvQmxvY2sgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGZpbHRlclwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBmaWx0ZXIgPSB7fTtcbiAgICAgICAgICAgIGlmIChhZGRyZXNzKSB7XG4gICAgICAgICAgICAgICAgZmlsdGVyLmFkZHJlc3MgPSBhZGRyZXNzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRvcGljcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBmaWx0ZXIudG9waWNzID0gdG9waWNzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZyb21CbG9jaykge1xuICAgICAgICAgICAgICAgIGZpbHRlci5mcm9tQmxvY2sgPSBmcm9tQmxvY2s7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodG9CbG9jaykge1xuICAgICAgICAgICAgICAgIGZpbHRlci50b0Jsb2NrID0gdG9CbG9jaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChibG9ja0hhc2gpIHtcbiAgICAgICAgICAgICAgICBmaWx0ZXIuYmxvY2tIYXNoID0gYmxvY2tIYXNoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZpbHRlcjtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gQWRkcmVzc2VzIGNvdWxkIGJlIGFzeW5jIChFTlMgbmFtZXMgb3IgQWRkcmVzc2FibGVzKVxuICAgICAgICBsZXQgYWRkcmVzcyA9IFtdO1xuICAgICAgICBpZiAoZmlsdGVyLmFkZHJlc3MpIHtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGZpbHRlci5hZGRyZXNzKSkge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgYWRkciBvZiBmaWx0ZXIuYWRkcmVzcykge1xuICAgICAgICAgICAgICAgICAgICBhZGRyZXNzLnB1c2godGhpcy5fZ2V0QWRkcmVzcyhhZGRyKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYWRkcmVzcy5wdXNoKHRoaXMuX2dldEFkZHJlc3MoZmlsdGVyLmFkZHJlc3MpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgZnJvbUJsb2NrID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAoXCJmcm9tQmxvY2tcIiBpbiBmaWx0ZXIpIHtcbiAgICAgICAgICAgIGZyb21CbG9jayA9IHRoaXMuX2dldEJsb2NrVGFnKGZpbHRlci5mcm9tQmxvY2spO1xuICAgICAgICB9XG4gICAgICAgIGxldCB0b0Jsb2NrID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAoXCJ0b0Jsb2NrXCIgaW4gZmlsdGVyKSB7XG4gICAgICAgICAgICB0b0Jsb2NrID0gdGhpcy5fZ2V0QmxvY2tUYWcoZmlsdGVyLnRvQmxvY2spO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhZGRyZXNzLmZpbHRlcigoYSkgPT4gKHR5cGVvZiAoYSkgIT09IFwic3RyaW5nXCIpKS5sZW5ndGggfHxcbiAgICAgICAgICAgIChmcm9tQmxvY2sgIT0gbnVsbCAmJiB0eXBlb2YgKGZyb21CbG9jaykgIT09IFwic3RyaW5nXCIpIHx8XG4gICAgICAgICAgICAodG9CbG9jayAhPSBudWxsICYmIHR5cGVvZiAodG9CbG9jaykgIT09IFwic3RyaW5nXCIpKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwoW1Byb21pc2UuYWxsKGFkZHJlc3MpLCBmcm9tQmxvY2ssIHRvQmxvY2tdKS50aGVuKChyZXN1bHQpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZShyZXN1bHRbMF0sIHJlc3VsdFsxXSwgcmVzdWx0WzJdKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXNvbHZlKGFkZHJlc3MsIGZyb21CbG9jaywgdG9CbG9jayk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIG9yIHJlc29sdmVzIHRvIGEgdHJhbnNhY3Rpb24gZm9yICUlcmVxdWVzdCUlLCByZXNvbHZpbmdcbiAgICAgKiAgYW55IEVOUyBuYW1lcyBvciBbW0FkZHJlc3NhYmxlXV0gYW5kIHJldHVybmluZyBpZiBhbHJlYWR5IGEgdmFsaWRcbiAgICAgKiAgdHJhbnNhY3Rpb24uXG4gICAgICovXG4gICAgX2dldFRyYW5zYWN0aW9uUmVxdWVzdChfcmVxdWVzdCkge1xuICAgICAgICBjb25zdCByZXF1ZXN0ID0gY29weVJlcXVlc3QoX3JlcXVlc3QpO1xuICAgICAgICBjb25zdCBwcm9taXNlcyA9IFtdO1xuICAgICAgICBbXCJ0b1wiLCBcImZyb21cIl0uZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgICAgICBpZiAocmVxdWVzdFtrZXldID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBhZGRyID0gcmVzb2x2ZUFkZHJlc3MocmVxdWVzdFtrZXldLCB0aGlzKTtcbiAgICAgICAgICAgIGlmIChpc1Byb21pc2UoYWRkcikpIHtcbiAgICAgICAgICAgICAgICBwcm9taXNlcy5wdXNoKChhc3luYyBmdW5jdGlvbiAoKSB7IHJlcXVlc3Rba2V5XSA9IGF3YWl0IGFkZHI7IH0pKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVxdWVzdFtrZXldID0gYWRkcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChyZXF1ZXN0LmJsb2NrVGFnICE9IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnN0IGJsb2NrVGFnID0gdGhpcy5fZ2V0QmxvY2tUYWcocmVxdWVzdC5ibG9ja1RhZyk7XG4gICAgICAgICAgICBpZiAoaXNQcm9taXNlKGJsb2NrVGFnKSkge1xuICAgICAgICAgICAgICAgIHByb21pc2VzLnB1c2goKGFzeW5jIGZ1bmN0aW9uICgpIHsgcmVxdWVzdC5ibG9ja1RhZyA9IGF3YWl0IGJsb2NrVGFnOyB9KSgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlcXVlc3QuYmxvY2tUYWcgPSBibG9ja1RhZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocHJvbWlzZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gKGFzeW5jIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChwcm9taXNlcyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlcXVlc3Q7XG4gICAgICAgICAgICB9KSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXF1ZXN0O1xuICAgIH1cbiAgICBhc3luYyBnZXROZXR3b3JrKCkge1xuICAgICAgICAvLyBObyBleHBsaWNpdCBuZXR3b3JrIHdhcyBzZXQgYW5kIHRoaXMgaXMgb3VyIGZpcnN0IHRpbWVcbiAgICAgICAgaWYgKHRoaXMuI25ldHdvcmtQcm9taXNlID09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIERldGVjdCB0aGUgY3VycmVudCBuZXR3b3JrIChzaGFyZWQgd2l0aCBhbGwgY2FsbHMpXG4gICAgICAgICAgICBjb25zdCBkZXRlY3ROZXR3b3JrID0gKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXR3b3JrID0gYXdhaXQgdGhpcy5fZGV0ZWN0TmV0d29yaygpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJuZXR3b3JrXCIsIG5ldHdvcmssIG51bGwpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV0d29yaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLiNuZXR3b3JrUHJvbWlzZSA9PT0gZGV0ZWN0TmV0d29yaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy4jbmV0d29ya1Byb21pc2UgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pKCk7XG4gICAgICAgICAgICB0aGlzLiNuZXR3b3JrUHJvbWlzZSA9IGRldGVjdE5ldHdvcms7XG4gICAgICAgICAgICByZXR1cm4gKGF3YWl0IGRldGVjdE5ldHdvcmspLmNsb25lKCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbmV0d29ya1Byb21pc2UgPSB0aGlzLiNuZXR3b3JrUHJvbWlzZTtcbiAgICAgICAgY29uc3QgW2V4cGVjdGVkLCBhY3R1YWxdID0gYXdhaXQgUHJvbWlzZS5hbGwoW1xuICAgICAgICAgICAgbmV0d29ya1Byb21pc2UsXG4gICAgICAgICAgICB0aGlzLl9kZXRlY3ROZXR3b3JrKCkgLy8gVGhlIGFjdHVhbCBjb25uZWN0ZWQgbmV0d29ya1xuICAgICAgICBdKTtcbiAgICAgICAgaWYgKGV4cGVjdGVkLmNoYWluSWQgIT09IGFjdHVhbC5jaGFpbklkKSB7XG4gICAgICAgICAgICBpZiAodGhpcy4jYW55TmV0d29yaykge1xuICAgICAgICAgICAgICAgIC8vIFRoZSBcImFueVwiIG5ldHdvcmsgY2FuIGNoYW5nZSwgc28gbm90aWZ5IGxpc3RlbmVyc1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcIm5ldHdvcmtcIiwgYWN0dWFsLCBleHBlY3RlZCk7XG4gICAgICAgICAgICAgICAgLy8gVXBkYXRlIHRoZSBuZXR3b3JrIGlmIHNvbWV0aGluZyBlbHNlIGhhc24ndCBhbHJlYWR5IGNoYW5nZWQgaXRcbiAgICAgICAgICAgICAgICBpZiAodGhpcy4jbmV0d29ya1Byb21pc2UgPT09IG5ldHdvcmtQcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuI25ldHdvcmtQcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKGFjdHVhbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gT3RoZXJ3aXNlLCB3ZSBkbyBub3QgYWxsb3cgY2hhbmdlcyB0byB0aGUgdW5kZXJseWluZyBuZXR3b3JrXG4gICAgICAgICAgICAgICAgYXNzZXJ0KGZhbHNlLCBgbmV0d29yayBjaGFuZ2VkOiAke2V4cGVjdGVkLmNoYWluSWR9ID0+ICR7YWN0dWFsLmNoYWluSWR9IGAsIFwiTkVUV09SS19FUlJPUlwiLCB7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50OiBcImNoYW5nZWRcIlxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBleHBlY3RlZC5jbG9uZSgpO1xuICAgIH1cbiAgICBhc3luYyBnZXRGZWVEYXRhKCkge1xuICAgICAgICBjb25zdCBuZXR3b3JrID0gYXdhaXQgdGhpcy5nZXROZXR3b3JrKCk7XG4gICAgICAgIGNvbnN0IGdldEZlZURhdGFGdW5jID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyBfYmxvY2ssIGdhc1ByaWNlLCBwcmlvcml0eUZlZSB9ID0gYXdhaXQgcmVzb2x2ZVByb3BlcnRpZXMoe1xuICAgICAgICAgICAgICAgIF9ibG9jazogdGhpcy4jZ2V0QmxvY2soXCJsYXRlc3RcIiwgZmFsc2UpLFxuICAgICAgICAgICAgICAgIGdhc1ByaWNlOiAoKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gYXdhaXQgdGhpcy4jcGVyZm9ybSh7IG1ldGhvZDogXCJnZXRHYXNQcmljZVwiIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGdldEJpZ0ludCh2YWx1ZSwgXCIlcmVzcG9uc2VcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7IH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfSkoKSksXG4gICAgICAgICAgICAgICAgcHJpb3JpdHlGZWU6ICgoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBhd2FpdCB0aGlzLiNwZXJmb3JtKHsgbWV0aG9kOiBcImdldFByaW9yaXR5RmVlXCIgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZ2V0QmlnSW50KHZhbHVlLCBcIiVyZXNwb25zZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHsgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9KSgpKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBsZXQgbWF4RmVlUGVyR2FzID0gbnVsbDtcbiAgICAgICAgICAgIGxldCBtYXhQcmlvcml0eUZlZVBlckdhcyA9IG51bGw7XG4gICAgICAgICAgICAvLyBUaGVzZSBhcmUgdGhlIHJlY29tbWVuZGVkIEVJUC0xNTU5IGhldXJpc3RpY3MgZm9yIGZlZSBkYXRhXG4gICAgICAgICAgICBjb25zdCBibG9jayA9IHRoaXMuX3dyYXBCbG9jayhfYmxvY2ssIG5ldHdvcmspO1xuICAgICAgICAgICAgaWYgKGJsb2NrICYmIGJsb2NrLmJhc2VGZWVQZXJHYXMpIHtcbiAgICAgICAgICAgICAgICBtYXhQcmlvcml0eUZlZVBlckdhcyA9IChwcmlvcml0eUZlZSAhPSBudWxsKSA/IHByaW9yaXR5RmVlIDogQmlnSW50KFwiMTAwMDAwMDAwMFwiKTtcbiAgICAgICAgICAgICAgICBtYXhGZWVQZXJHYXMgPSAoYmxvY2suYmFzZUZlZVBlckdhcyAqIEJOXzIpICsgbWF4UHJpb3JpdHlGZWVQZXJHYXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IEZlZURhdGEoZ2FzUHJpY2UsIG1heEZlZVBlckdhcywgbWF4UHJpb3JpdHlGZWVQZXJHYXMpO1xuICAgICAgICB9O1xuICAgICAgICAvLyBDaGVjayBmb3IgYSBGZWVEYXRhTmV0V29ya1BsdWdpblxuICAgICAgICBjb25zdCBwbHVnaW4gPSBuZXR3b3JrLmdldFBsdWdpbihcIm9yZy5ldGhlcnMucGx1Z2lucy5uZXR3b3JrLkZldGNoVXJsRmVlRGF0YVBsdWdpblwiKTtcbiAgICAgICAgaWYgKHBsdWdpbikge1xuICAgICAgICAgICAgY29uc3QgcmVxID0gbmV3IEZldGNoUmVxdWVzdChwbHVnaW4udXJsKTtcbiAgICAgICAgICAgIGNvbnN0IGZlZURhdGEgPSBhd2FpdCBwbHVnaW4ucHJvY2Vzc0Z1bmMoZ2V0RmVlRGF0YUZ1bmMsIHRoaXMsIHJlcSk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEZlZURhdGEoZmVlRGF0YS5nYXNQcmljZSwgZmVlRGF0YS5tYXhGZWVQZXJHYXMsIGZlZURhdGEubWF4UHJpb3JpdHlGZWVQZXJHYXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhd2FpdCBnZXRGZWVEYXRhRnVuYygpO1xuICAgIH1cbiAgICBhc3luYyBlc3RpbWF0ZUdhcyhfdHgpIHtcbiAgICAgICAgbGV0IHR4ID0gdGhpcy5fZ2V0VHJhbnNhY3Rpb25SZXF1ZXN0KF90eCk7XG4gICAgICAgIGlmIChpc1Byb21pc2UodHgpKSB7XG4gICAgICAgICAgICB0eCA9IGF3YWl0IHR4O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBnZXRCaWdJbnQoYXdhaXQgdGhpcy4jcGVyZm9ybSh7XG4gICAgICAgICAgICBtZXRob2Q6IFwiZXN0aW1hdGVHYXNcIiwgdHJhbnNhY3Rpb246IHR4XG4gICAgICAgIH0pLCBcIiVyZXNwb25zZVwiKTtcbiAgICB9XG4gICAgYXN5bmMgI2NhbGwodHgsIGJsb2NrVGFnLCBhdHRlbXB0KSB7XG4gICAgICAgIGFzc2VydChhdHRlbXB0IDwgTUFYX0NDSVBfUkVESVJFQ1RTLCBcIkNDSVAgcmVhZCBleGNlZWRlZCBtYXhpbXVtIHJlZGlyZWN0aW9uc1wiLCBcIk9GRkNIQUlOX0ZBVUxUXCIsIHtcbiAgICAgICAgICAgIHJlYXNvbjogXCJUT09fTUFOWV9SRURJUkVDVFNcIixcbiAgICAgICAgICAgIHRyYW5zYWN0aW9uOiBPYmplY3QuYXNzaWduKHt9LCB0eCwgeyBibG9ja1RhZywgZW5hYmxlQ2NpcFJlYWQ6IHRydWUgfSlcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIFRoaXMgY2FtZSBpbiBhcyBhIFBlcmZvcm1BY3Rpb25UcmFuc2FjdGlvbiwgc28gdG8vZnJvbSBhcmUgc2FmZTsgd2UgY2FuIGNhc3RcbiAgICAgICAgY29uc3QgdHJhbnNhY3Rpb24gPSBjb3B5UmVxdWVzdCh0eCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gaGV4bGlmeShhd2FpdCB0aGlzLl9wZXJmb3JtKHsgbWV0aG9kOiBcImNhbGxcIiwgdHJhbnNhY3Rpb24sIGJsb2NrVGFnIH0pKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIC8vIENDSVAgUmVhZCBPZmZjaGFpbkxvb2t1cFxuICAgICAgICAgICAgaWYgKCF0aGlzLmRpc2FibGVDY2lwUmVhZCAmJiBpc0NhbGxFeGNlcHRpb24oZXJyb3IpICYmIGVycm9yLmRhdGEgJiYgYXR0ZW1wdCA+PSAwICYmIGJsb2NrVGFnID09PSBcImxhdGVzdFwiICYmIHRyYW5zYWN0aW9uLnRvICE9IG51bGwgJiYgZGF0YVNsaWNlKGVycm9yLmRhdGEsIDAsIDQpID09PSBcIjB4NTU2ZjE4MzBcIikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBlcnJvci5kYXRhO1xuICAgICAgICAgICAgICAgIGNvbnN0IHR4U2VuZGVyID0gYXdhaXQgcmVzb2x2ZUFkZHJlc3ModHJhbnNhY3Rpb24udG8sIHRoaXMpO1xuICAgICAgICAgICAgICAgIC8vIFBhcnNlIHRoZSBDQ0lQIFJlYWQgQXJndW1lbnRzXG4gICAgICAgICAgICAgICAgbGV0IGNjaXBBcmdzO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGNjaXBBcmdzID0gcGFyc2VPZmZjaGFpbkxvb2t1cChkYXRhU2xpY2UoZXJyb3IuZGF0YSwgNCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgYXNzZXJ0KGZhbHNlLCBlcnJvci5tZXNzYWdlLCBcIk9GRkNIQUlOX0ZBVUxUXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlYXNvbjogXCJCQURfREFUQVwiLCB0cmFuc2FjdGlvbiwgaW5mbzogeyBkYXRhIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIENoZWNrIHRoZSBzZW5kZXIgb2YgdGhlIE9mZmNoYWluTG9va3VwIG1hdGNoZXMgdGhlIHRyYW5zYWN0aW9uXG4gICAgICAgICAgICAgICAgYXNzZXJ0KGNjaXBBcmdzLnNlbmRlci50b0xvd2VyQ2FzZSgpID09PSB0eFNlbmRlci50b0xvd2VyQ2FzZSgpLCBcIkNDSVAgUmVhZCBzZW5kZXIgbWlzbWF0Y2hcIiwgXCJDQUxMX0VYQ0VQVElPTlwiLCB7XG4gICAgICAgICAgICAgICAgICAgIGFjdGlvbjogXCJjYWxsXCIsXG4gICAgICAgICAgICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgICAgICAgICAgIHJlYXNvbjogXCJPZmZjaGFpbkxvb2t1cFwiLFxuICAgICAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbjogdHJhbnNhY3Rpb24sXG4gICAgICAgICAgICAgICAgICAgIGludm9jYXRpb246IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIHJldmVydDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2lnbmF0dXJlOiBcIk9mZmNoYWluTG9va3VwKGFkZHJlc3Msc3RyaW5nW10sYnl0ZXMsYnl0ZXM0LGJ5dGVzKVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogXCJPZmZjaGFpbkxvb2t1cFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgYXJnczogY2NpcEFyZ3MuZXJyb3JBcmdzXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBjb25zdCBjY2lwUmVzdWx0ID0gYXdhaXQgdGhpcy5jY2lwUmVhZEZldGNoKHRyYW5zYWN0aW9uLCBjY2lwQXJncy5jYWxsZGF0YSwgY2NpcEFyZ3MudXJscyk7XG4gICAgICAgICAgICAgICAgYXNzZXJ0KGNjaXBSZXN1bHQgIT0gbnVsbCwgXCJDQ0lQIFJlYWQgZmFpbGVkIHRvIGZldGNoIGRhdGFcIiwgXCJPRkZDSEFJTl9GQVVMVFwiLCB7XG4gICAgICAgICAgICAgICAgICAgIHJlYXNvbjogXCJGRVRDSF9GQUlMRURcIiwgdHJhbnNhY3Rpb24sIGluZm86IHsgZGF0YTogZXJyb3IuZGF0YSwgZXJyb3JBcmdzOiBjY2lwQXJncy5lcnJvckFyZ3MgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGNvbnN0IHR4ID0ge1xuICAgICAgICAgICAgICAgICAgICB0bzogdHhTZW5kZXIsXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IGNvbmNhdChbY2NpcEFyZ3Muc2VsZWN0b3IsIGVuY29kZUJ5dGVzKFtjY2lwUmVzdWx0LCBjY2lwQXJncy5leHRyYURhdGFdKV0pXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJkZWJ1Z1wiLCB7IGFjdGlvbjogXCJzZW5kQ2NpcFJlYWRDYWxsXCIsIHRyYW5zYWN0aW9uOiB0eCB9KTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLiNjYWxsKHR4LCBibG9ja1RhZywgYXR0ZW1wdCArIDEpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJkZWJ1Z1wiLCB7IGFjdGlvbjogXCJyZWNlaXZlQ2NpcFJlYWRDYWxsUmVzdWx0XCIsIHRyYW5zYWN0aW9uOiBPYmplY3QuYXNzaWduKHt9LCB0eCksIHJlc3VsdCB9KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcImRlYnVnXCIsIHsgYWN0aW9uOiBcInJlY2VpdmVDY2lwUmVhZENhbGxFcnJvclwiLCB0cmFuc2FjdGlvbjogT2JqZWN0LmFzc2lnbih7fSwgdHgpLCBlcnJvciB9KTtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgI2NoZWNrTmV0d29yayhwcm9taXNlKSB7XG4gICAgICAgIGNvbnN0IHsgdmFsdWUgfSA9IGF3YWl0IHJlc29sdmVQcm9wZXJ0aWVzKHtcbiAgICAgICAgICAgIG5ldHdvcms6IHRoaXMuZ2V0TmV0d29yaygpLFxuICAgICAgICAgICAgdmFsdWU6IHByb21pc2VcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgYXN5bmMgY2FsbChfdHgpIHtcbiAgICAgICAgY29uc3QgeyB0eCwgYmxvY2tUYWcgfSA9IGF3YWl0IHJlc29sdmVQcm9wZXJ0aWVzKHtcbiAgICAgICAgICAgIHR4OiB0aGlzLl9nZXRUcmFuc2FjdGlvblJlcXVlc3QoX3R4KSxcbiAgICAgICAgICAgIGJsb2NrVGFnOiB0aGlzLl9nZXRCbG9ja1RhZyhfdHguYmxvY2tUYWcpXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy4jY2hlY2tOZXR3b3JrKHRoaXMuI2NhbGwodHgsIGJsb2NrVGFnLCBfdHguZW5hYmxlQ2NpcFJlYWQgPyAwIDogLTEpKTtcbiAgICB9XG4gICAgLy8gQWNjb3VudFxuICAgIGFzeW5jICNnZXRBY2NvdW50VmFsdWUocmVxdWVzdCwgX2FkZHJlc3MsIF9ibG9ja1RhZykge1xuICAgICAgICBsZXQgYWRkcmVzcyA9IHRoaXMuX2dldEFkZHJlc3MoX2FkZHJlc3MpO1xuICAgICAgICBsZXQgYmxvY2tUYWcgPSB0aGlzLl9nZXRCbG9ja1RhZyhfYmxvY2tUYWcpO1xuICAgICAgICBpZiAodHlwZW9mIChhZGRyZXNzKSAhPT0gXCJzdHJpbmdcIiB8fCB0eXBlb2YgKGJsb2NrVGFnKSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgW2FkZHJlc3MsIGJsb2NrVGFnXSA9IGF3YWl0IFByb21pc2UuYWxsKFthZGRyZXNzLCBibG9ja1RhZ10pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLiNjaGVja05ldHdvcmsodGhpcy4jcGVyZm9ybShPYmplY3QuYXNzaWduKHJlcXVlc3QsIHsgYWRkcmVzcywgYmxvY2tUYWcgfSkpKTtcbiAgICB9XG4gICAgYXN5bmMgZ2V0QmFsYW5jZShhZGRyZXNzLCBibG9ja1RhZykge1xuICAgICAgICByZXR1cm4gZ2V0QmlnSW50KGF3YWl0IHRoaXMuI2dldEFjY291bnRWYWx1ZSh7IG1ldGhvZDogXCJnZXRCYWxhbmNlXCIgfSwgYWRkcmVzcywgYmxvY2tUYWcpLCBcIiVyZXNwb25zZVwiKTtcbiAgICB9XG4gICAgYXN5bmMgZ2V0VHJhbnNhY3Rpb25Db3VudChhZGRyZXNzLCBibG9ja1RhZykge1xuICAgICAgICByZXR1cm4gZ2V0TnVtYmVyKGF3YWl0IHRoaXMuI2dldEFjY291bnRWYWx1ZSh7IG1ldGhvZDogXCJnZXRUcmFuc2FjdGlvbkNvdW50XCIgfSwgYWRkcmVzcywgYmxvY2tUYWcpLCBcIiVyZXNwb25zZVwiKTtcbiAgICB9XG4gICAgYXN5bmMgZ2V0Q29kZShhZGRyZXNzLCBibG9ja1RhZykge1xuICAgICAgICByZXR1cm4gaGV4bGlmeShhd2FpdCB0aGlzLiNnZXRBY2NvdW50VmFsdWUoeyBtZXRob2Q6IFwiZ2V0Q29kZVwiIH0sIGFkZHJlc3MsIGJsb2NrVGFnKSk7XG4gICAgfVxuICAgIGFzeW5jIGdldFN0b3JhZ2UoYWRkcmVzcywgX3Bvc2l0aW9uLCBibG9ja1RhZykge1xuICAgICAgICBjb25zdCBwb3NpdGlvbiA9IGdldEJpZ0ludChfcG9zaXRpb24sIFwicG9zaXRpb25cIik7XG4gICAgICAgIHJldHVybiBoZXhsaWZ5KGF3YWl0IHRoaXMuI2dldEFjY291bnRWYWx1ZSh7IG1ldGhvZDogXCJnZXRTdG9yYWdlXCIsIHBvc2l0aW9uIH0sIGFkZHJlc3MsIGJsb2NrVGFnKSk7XG4gICAgfVxuICAgIC8vIFdyaXRlXG4gICAgYXN5bmMgYnJvYWRjYXN0VHJhbnNhY3Rpb24oc2lnbmVkVHgpIHtcbiAgICAgICAgY29uc3QgeyBibG9ja051bWJlciwgaGFzaCwgbmV0d29yayB9ID0gYXdhaXQgcmVzb2x2ZVByb3BlcnRpZXMoe1xuICAgICAgICAgICAgYmxvY2tOdW1iZXI6IHRoaXMuZ2V0QmxvY2tOdW1iZXIoKSxcbiAgICAgICAgICAgIGhhc2g6IHRoaXMuX3BlcmZvcm0oe1xuICAgICAgICAgICAgICAgIG1ldGhvZDogXCJicm9hZGNhc3RUcmFuc2FjdGlvblwiLFxuICAgICAgICAgICAgICAgIHNpZ25lZFRyYW5zYWN0aW9uOiBzaWduZWRUeFxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBuZXR3b3JrOiB0aGlzLmdldE5ldHdvcmsoKVxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgdHggPSBUcmFuc2FjdGlvbi5mcm9tKHNpZ25lZFR4KTtcbiAgICAgICAgaWYgKHR4Lmhhc2ggIT09IGhhc2gpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkBUT0RPOiB0aGUgcmV0dXJuZWQgaGFzaCBkaWQgbm90IG1hdGNoXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl93cmFwVHJhbnNhY3Rpb25SZXNwb25zZSh0eCwgbmV0d29yaykucmVwbGFjZWFibGVUcmFuc2FjdGlvbihibG9ja051bWJlcik7XG4gICAgfVxuICAgIGFzeW5jICNnZXRCbG9jayhibG9jaywgaW5jbHVkZVRyYW5zYWN0aW9ucykge1xuICAgICAgICAvLyBAVE9ETzogQWRkIEN1c3RvbUJsb2NrUGx1Z2luIGNoZWNrXG4gICAgICAgIGlmIChpc0hleFN0cmluZyhibG9jaywgMzIpKSB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy4jcGVyZm9ybSh7XG4gICAgICAgICAgICAgICAgbWV0aG9kOiBcImdldEJsb2NrXCIsIGJsb2NrSGFzaDogYmxvY2ssIGluY2x1ZGVUcmFuc2FjdGlvbnNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGxldCBibG9ja1RhZyA9IHRoaXMuX2dldEJsb2NrVGFnKGJsb2NrKTtcbiAgICAgICAgaWYgKHR5cGVvZiAoYmxvY2tUYWcpICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBibG9ja1RhZyA9IGF3YWl0IGJsb2NrVGFnO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLiNwZXJmb3JtKHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJnZXRCbG9ja1wiLCBibG9ja1RhZywgaW5jbHVkZVRyYW5zYWN0aW9uc1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLy8gUXVlcmllc1xuICAgIGFzeW5jIGdldEJsb2NrKGJsb2NrLCBwcmVmZXRjaFR4cykge1xuICAgICAgICBjb25zdCB7IG5ldHdvcmssIHBhcmFtcyB9ID0gYXdhaXQgcmVzb2x2ZVByb3BlcnRpZXMoe1xuICAgICAgICAgICAgbmV0d29yazogdGhpcy5nZXROZXR3b3JrKCksXG4gICAgICAgICAgICBwYXJhbXM6IHRoaXMuI2dldEJsb2NrKGJsb2NrLCAhIXByZWZldGNoVHhzKVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHBhcmFtcyA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fd3JhcEJsb2NrKHBhcmFtcywgbmV0d29yayk7XG4gICAgfVxuICAgIGFzeW5jIGdldFRyYW5zYWN0aW9uKGhhc2gpIHtcbiAgICAgICAgY29uc3QgeyBuZXR3b3JrLCBwYXJhbXMgfSA9IGF3YWl0IHJlc29sdmVQcm9wZXJ0aWVzKHtcbiAgICAgICAgICAgIG5ldHdvcms6IHRoaXMuZ2V0TmV0d29yaygpLFxuICAgICAgICAgICAgcGFyYW1zOiB0aGlzLiNwZXJmb3JtKHsgbWV0aG9kOiBcImdldFRyYW5zYWN0aW9uXCIsIGhhc2ggfSlcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChwYXJhbXMgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3dyYXBUcmFuc2FjdGlvblJlc3BvbnNlKHBhcmFtcywgbmV0d29yayk7XG4gICAgfVxuICAgIGFzeW5jIGdldFRyYW5zYWN0aW9uUmVjZWlwdChoYXNoKSB7XG4gICAgICAgIGNvbnN0IHsgbmV0d29yaywgcGFyYW1zIH0gPSBhd2FpdCByZXNvbHZlUHJvcGVydGllcyh7XG4gICAgICAgICAgICBuZXR3b3JrOiB0aGlzLmdldE5ldHdvcmsoKSxcbiAgICAgICAgICAgIHBhcmFtczogdGhpcy4jcGVyZm9ybSh7IG1ldGhvZDogXCJnZXRUcmFuc2FjdGlvblJlY2VpcHRcIiwgaGFzaCB9KVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHBhcmFtcyA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICAvLyBTb21lIGJhY2tlbmRzIGRpZCBub3QgYmFja2ZpbGwgdGhlIGVmZmVjdGl2ZUdhc1ByaWNlIGludG8gb2xkIHRyYW5zYWN0aW9uc1xuICAgICAgICAvLyBpbiB0aGUgcmVjZWlwdCwgc28gd2UgbG9vayBpdCB1cCBtYW51YWxseSBhbmQgaW5qZWN0IGl0LlxuICAgICAgICBpZiAocGFyYW1zLmdhc1ByaWNlID09IG51bGwgJiYgcGFyYW1zLmVmZmVjdGl2ZUdhc1ByaWNlID09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnN0IHR4ID0gYXdhaXQgdGhpcy4jcGVyZm9ybSh7IG1ldGhvZDogXCJnZXRUcmFuc2FjdGlvblwiLCBoYXNoIH0pO1xuICAgICAgICAgICAgaWYgKHR4ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJyZXBvcnQgdGhpczsgY291bGQgbm90IGZpbmQgdHggb3IgZWZmZWN0aXZlR2FzUHJpY2VcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwYXJhbXMuZWZmZWN0aXZlR2FzUHJpY2UgPSB0eC5nYXNQcmljZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fd3JhcFRyYW5zYWN0aW9uUmVjZWlwdChwYXJhbXMsIG5ldHdvcmspO1xuICAgIH1cbiAgICBhc3luYyBnZXRUcmFuc2FjdGlvblJlc3VsdChoYXNoKSB7XG4gICAgICAgIGNvbnN0IHsgcmVzdWx0IH0gPSBhd2FpdCByZXNvbHZlUHJvcGVydGllcyh7XG4gICAgICAgICAgICBuZXR3b3JrOiB0aGlzLmdldE5ldHdvcmsoKSxcbiAgICAgICAgICAgIHJlc3VsdDogdGhpcy4jcGVyZm9ybSh7IG1ldGhvZDogXCJnZXRUcmFuc2FjdGlvblJlc3VsdFwiLCBoYXNoIH0pXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAocmVzdWx0ID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBoZXhsaWZ5KHJlc3VsdCk7XG4gICAgfVxuICAgIC8vIEJsb29tLWZpbHRlciBRdWVyaWVzXG4gICAgYXN5bmMgZ2V0TG9ncyhfZmlsdGVyKSB7XG4gICAgICAgIGxldCBmaWx0ZXIgPSB0aGlzLl9nZXRGaWx0ZXIoX2ZpbHRlcik7XG4gICAgICAgIGlmIChpc1Byb21pc2UoZmlsdGVyKSkge1xuICAgICAgICAgICAgZmlsdGVyID0gYXdhaXQgZmlsdGVyO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgbmV0d29yaywgcGFyYW1zIH0gPSBhd2FpdCByZXNvbHZlUHJvcGVydGllcyh7XG4gICAgICAgICAgICBuZXR3b3JrOiB0aGlzLmdldE5ldHdvcmsoKSxcbiAgICAgICAgICAgIHBhcmFtczogdGhpcy4jcGVyZm9ybSh7IG1ldGhvZDogXCJnZXRMb2dzXCIsIGZpbHRlciB9KVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHBhcmFtcy5tYXAoKHApID0+IHRoaXMuX3dyYXBMb2cocCwgbmV0d29yaykpO1xuICAgIH1cbiAgICAvLyBFTlNcbiAgICBfZ2V0UHJvdmlkZXIoY2hhaW5JZCkge1xuICAgICAgICBhc3NlcnQoZmFsc2UsIFwicHJvdmlkZXIgY2Fubm90IGNvbm5lY3QgdG8gdGFyZ2V0IG5ldHdvcmtcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwge1xuICAgICAgICAgICAgb3BlcmF0aW9uOiBcIl9nZXRQcm92aWRlcigpXCJcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFzeW5jIGdldFJlc29sdmVyKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IEVuc1Jlc29sdmVyLmZyb21OYW1lKHRoaXMsIG5hbWUpO1xuICAgIH1cbiAgICBhc3luYyBnZXRBdmF0YXIobmFtZSkge1xuICAgICAgICBjb25zdCByZXNvbHZlciA9IGF3YWl0IHRoaXMuZ2V0UmVzb2x2ZXIobmFtZSk7XG4gICAgICAgIGlmIChyZXNvbHZlcikge1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHJlc29sdmVyLmdldEF2YXRhcigpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBhc3luYyByZXNvbHZlTmFtZShuYW1lKSB7XG4gICAgICAgIGNvbnN0IHJlc29sdmVyID0gYXdhaXQgdGhpcy5nZXRSZXNvbHZlcihuYW1lKTtcbiAgICAgICAgaWYgKHJlc29sdmVyKSB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgcmVzb2x2ZXIuZ2V0QWRkcmVzcygpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBhc3luYyBsb29rdXBBZGRyZXNzKGFkZHJlc3MpIHtcbiAgICAgICAgYWRkcmVzcyA9IGdldEFkZHJlc3MoYWRkcmVzcyk7XG4gICAgICAgIGNvbnN0IG5vZGUgPSBuYW1laGFzaChhZGRyZXNzLnN1YnN0cmluZygyKS50b0xvd2VyQ2FzZSgpICsgXCIuYWRkci5yZXZlcnNlXCIpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgZW5zQWRkciA9IGF3YWl0IEVuc1Jlc29sdmVyLmdldEVuc0FkZHJlc3ModGhpcyk7XG4gICAgICAgICAgICBjb25zdCBlbnNDb250cmFjdCA9IG5ldyBDb250cmFjdChlbnNBZGRyLCBbXG4gICAgICAgICAgICAgICAgXCJmdW5jdGlvbiByZXNvbHZlcihieXRlczMyKSB2aWV3IHJldHVybnMgKGFkZHJlc3MpXCJcbiAgICAgICAgICAgIF0sIHRoaXMpO1xuICAgICAgICAgICAgY29uc3QgcmVzb2x2ZXIgPSBhd2FpdCBlbnNDb250cmFjdC5yZXNvbHZlcihub2RlKTtcbiAgICAgICAgICAgIGlmIChyZXNvbHZlciA9PSBudWxsIHx8IHJlc29sdmVyID09PSBaZXJvQWRkcmVzcykge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzb2x2ZXJDb250cmFjdCA9IG5ldyBDb250cmFjdChyZXNvbHZlciwgW1xuICAgICAgICAgICAgICAgIFwiZnVuY3Rpb24gbmFtZShieXRlczMyKSB2aWV3IHJldHVybnMgKHN0cmluZylcIlxuICAgICAgICAgICAgXSwgdGhpcyk7XG4gICAgICAgICAgICBjb25zdCBuYW1lID0gYXdhaXQgcmVzb2x2ZXJDb250cmFjdC5uYW1lKG5vZGUpO1xuICAgICAgICAgICAgLy8gRmFpbGVkIGZvcndhcmQgcmVzb2x1dGlvblxuICAgICAgICAgICAgY29uc3QgY2hlY2sgPSBhd2FpdCB0aGlzLnJlc29sdmVOYW1lKG5hbWUpO1xuICAgICAgICAgICAgaWYgKGNoZWNrICE9PSBhZGRyZXNzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmFtZTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIC8vIE5vIGRhdGEgd2FzIHJldHVybmVkIGZyb20gdGhlIHJlc29sdmVyXG4gICAgICAgICAgICBpZiAoaXNFcnJvcihlcnJvciwgXCJCQURfREFUQVwiKSAmJiBlcnJvci52YWx1ZSA9PT0gXCIweFwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBTb21ldGhpbmcgcmVlcnRlZFxuICAgICAgICAgICAgaWYgKGlzRXJyb3IoZXJyb3IsIFwiQ0FMTF9FWENFUFRJT05cIikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBhc3luYyB3YWl0Rm9yVHJhbnNhY3Rpb24oaGFzaCwgX2NvbmZpcm1zLCB0aW1lb3V0KSB7XG4gICAgICAgIGNvbnN0IGNvbmZpcm1zID0gKF9jb25maXJtcyAhPSBudWxsKSA/IF9jb25maXJtcyA6IDE7XG4gICAgICAgIGlmIChjb25maXJtcyA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VHJhbnNhY3Rpb25SZWNlaXB0KGhhc2gpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShhc3luYyAocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBsZXQgdGltZXIgPSBudWxsO1xuICAgICAgICAgICAgY29uc3QgbGlzdGVuZXIgPSAoYXN5bmMgKGJsb2NrTnVtYmVyKSA9PiB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVjZWlwdCA9IGF3YWl0IHRoaXMuZ2V0VHJhbnNhY3Rpb25SZWNlaXB0KGhhc2gpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVjZWlwdCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYmxvY2tOdW1iZXIgLSByZWNlaXB0LmJsb2NrTnVtYmVyICsgMSA+PSBjb25maXJtcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUocmVjZWlwdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy90aGlzLm9mZihcImJsb2NrXCIsIGxpc3RlbmVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGltZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGltZXIgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiRUVFXCIsIGVycm9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5vbmNlKFwiYmxvY2tcIiwgbGlzdGVuZXIpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAodGltZW91dCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRpbWVyID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aW1lciA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub2ZmKFwiYmxvY2tcIiwgbGlzdGVuZXIpO1xuICAgICAgICAgICAgICAgICAgICByZWplY3QobWFrZUVycm9yKFwidGltZW91dFwiLCBcIlRJTUVPVVRcIiwgeyByZWFzb246IFwidGltZW91dFwiIH0pKTtcbiAgICAgICAgICAgICAgICB9LCB0aW1lb3V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxpc3RlbmVyKGF3YWl0IHRoaXMuZ2V0QmxvY2tOdW1iZXIoKSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhc3luYyB3YWl0Rm9yQmxvY2soYmxvY2tUYWcpIHtcbiAgICAgICAgYXNzZXJ0KGZhbHNlLCBcIm5vdCBpbXBsZW1lbnRlZCB5ZXRcIiwgXCJOT1RfSU1QTEVNRU5URURcIiwge1xuICAgICAgICAgICAgb3BlcmF0aW9uOiBcIndhaXRGb3JCbG9ja1wiXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQ2xlYXIgYSB0aW1lciBjcmVhdGVkIHVzaW5nIHRoZSBbW19zZXRUaW1lb3V0XV0gbWV0aG9kLlxuICAgICAqL1xuICAgIF9jbGVhclRpbWVvdXQodGltZXJJZCkge1xuICAgICAgICBjb25zdCB0aW1lciA9IHRoaXMuI3RpbWVycy5nZXQodGltZXJJZCk7XG4gICAgICAgIGlmICghdGltZXIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGltZXIudGltZXIpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lci50aW1lcik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4jdGltZXJzLmRlbGV0ZSh0aW1lcklkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIENyZWF0ZSBhIHRpbWVyIHRoYXQgd2lsbCBleGVjdXRlICUlZnVuYyUlIGFmdGVyIGF0IGxlYXN0ICUldGltZW91dCUlXG4gICAgICogIChpbiBtcykuIElmICUldGltZW91dCUlIGlzIHVuc3BlY2lmaWVkLCB0aGVuICUlZnVuYyUlIHdpbGwgZXhlY3V0ZVxuICAgICAqICBpbiB0aGUgbmV4dCBldmVudCBsb29wLlxuICAgICAqXG4gICAgICogIFtQYXVzaW5nXShBYnN0cmFjdFByb3ZpZGVyLXBhdXNlZCkgdGhlIHByb3ZpZGVyIHdpbGwgcGF1c2UgYW55XG4gICAgICogIGFzc29jaWF0ZWQgdGltZXJzLlxuICAgICAqL1xuICAgIF9zZXRUaW1lb3V0KF9mdW5jLCB0aW1lb3V0KSB7XG4gICAgICAgIGlmICh0aW1lb3V0ID09IG51bGwpIHtcbiAgICAgICAgICAgIHRpbWVvdXQgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRpbWVySWQgPSB0aGlzLiNuZXh0VGltZXIrKztcbiAgICAgICAgY29uc3QgZnVuYyA9ICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuI3RpbWVycy5kZWxldGUodGltZXJJZCk7XG4gICAgICAgICAgICBfZnVuYygpO1xuICAgICAgICB9O1xuICAgICAgICBpZiAodGhpcy5wYXVzZWQpIHtcbiAgICAgICAgICAgIHRoaXMuI3RpbWVycy5zZXQodGltZXJJZCwgeyB0aW1lcjogbnVsbCwgZnVuYywgdGltZTogdGltZW91dCB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHRpbWVyID0gc2V0VGltZW91dChmdW5jLCB0aW1lb3V0KTtcbiAgICAgICAgICAgIHRoaXMuI3RpbWVycy5zZXQodGltZXJJZCwgeyB0aW1lciwgZnVuYywgdGltZTogZ2V0VGltZSgpIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aW1lcklkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUGVyZm9ybSAlJWZ1bmMlJSBvbiBlYWNoIHN1YnNjcmliZXIuXG4gICAgICovXG4gICAgX2ZvckVhY2hTdWJzY3JpYmVyKGZ1bmMpIHtcbiAgICAgICAgZm9yIChjb25zdCBzdWIgb2YgdGhpcy4jc3Vicy52YWx1ZXMoKSkge1xuICAgICAgICAgICAgZnVuYyhzdWIuc3Vic2NyaWJlcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogIFN1Yi1jbGFzc2VzIG1heSBvdmVycmlkZSB0aGlzIHRvIGN1c3RvbWl6ZSBzdWJzY3JpcHRpb25cbiAgICAgKiAgaW1wbGVtZW50YXRpb25zLlxuICAgICAqL1xuICAgIF9nZXRTdWJzY3JpYmVyKHN1Yikge1xuICAgICAgICBzd2l0Y2ggKHN1Yi50eXBlKSB7XG4gICAgICAgICAgICBjYXNlIFwiZGVidWdcIjpcbiAgICAgICAgICAgIGNhc2UgXCJlcnJvclwiOlxuICAgICAgICAgICAgY2FzZSBcIm5ldHdvcmtcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFVubWFuYWdlZFN1YnNjcmliZXIoc3ViLnR5cGUpO1xuICAgICAgICAgICAgY2FzZSBcImJsb2NrXCI6IHtcbiAgICAgICAgICAgICAgICBjb25zdCBzdWJzY3JpYmVyID0gbmV3IFBvbGxpbmdCbG9ja1N1YnNjcmliZXIodGhpcyk7XG4gICAgICAgICAgICAgICAgc3Vic2NyaWJlci5wb2xsaW5nSW50ZXJ2YWwgPSB0aGlzLnBvbGxpbmdJbnRlcnZhbDtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3Vic2NyaWJlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJzYWZlXCI6XG4gICAgICAgICAgICBjYXNlIFwiZmluYWxpemVkXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQb2xsaW5nQmxvY2tUYWdTdWJzY3JpYmVyKHRoaXMsIHN1Yi50eXBlKTtcbiAgICAgICAgICAgIGNhc2UgXCJldmVudFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUG9sbGluZ0V2ZW50U3Vic2NyaWJlcih0aGlzLCBzdWIuZmlsdGVyKTtcbiAgICAgICAgICAgIGNhc2UgXCJ0cmFuc2FjdGlvblwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUG9sbGluZ1RyYW5zYWN0aW9uU3Vic2NyaWJlcih0aGlzLCBzdWIuaGFzaCk7XG4gICAgICAgICAgICBjYXNlIFwib3JwaGFuXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQb2xsaW5nT3JwaGFuU3Vic2NyaWJlcih0aGlzLCBzdWIuZmlsdGVyKTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHVuc3VwcG9ydGVkIGV2ZW50OiAke3N1Yi50eXBlfWApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgSWYgYSBbW1N1YnNjcmliZXJdXSBmYWlscyBhbmQgbmVlZHMgdG8gcmVwbGFjZSBpdHNlbGYsIHRoaXNcbiAgICAgKiAgbWV0aG9kIG1heSBiZSB1c2VkLlxuICAgICAqXG4gICAgICogIEZvciBleGFtcGxlLCB0aGlzIGlzIHVzZWQgZm9yIHByb3ZpZGVycyB3aGVuIHVzaW5nIHRoZVxuICAgICAqICBgYGV0aF9nZXRGaWx0ZXJDaGFuZ2VzYGAgbWV0aG9kLCB3aGljaCBjYW4gcmV0dXJuIG51bGwgaWYgc3RhdGVcbiAgICAgKiAgZmlsdGVycyBhcmUgbm90IHN1cHBvcnRlZCBieSB0aGUgYmFja2VuZCwgYWxsb3dpbmcgdGhlIFN1YnNjcmliZXJcbiAgICAgKiAgdG8gc3dhcCBpbiBhIFtbUG9sbGluZ0V2ZW50U3Vic2NyaWJlcl1dLlxuICAgICAqL1xuICAgIF9yZWNvdmVyU3Vic2NyaWJlcihvbGRTdWIsIG5ld1N1Yikge1xuICAgICAgICBmb3IgKGNvbnN0IHN1YiBvZiB0aGlzLiNzdWJzLnZhbHVlcygpKSB7XG4gICAgICAgICAgICBpZiAoc3ViLnN1YnNjcmliZXIgPT09IG9sZFN1Yikge1xuICAgICAgICAgICAgICAgIGlmIChzdWIuc3RhcnRlZCkge1xuICAgICAgICAgICAgICAgICAgICBzdWIuc3Vic2NyaWJlci5zdG9wKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHN1Yi5zdWJzY3JpYmVyID0gbmV3U3ViO1xuICAgICAgICAgICAgICAgIGlmIChzdWIuc3RhcnRlZCkge1xuICAgICAgICAgICAgICAgICAgICBuZXdTdWIuc3RhcnQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuI3BhdXNlZFN0YXRlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3U3ViLnBhdXNlKHRoaXMuI3BhdXNlZFN0YXRlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgI2hhc1N1YihldmVudCwgZW1pdEFyZ3MpIHtcbiAgICAgICAgbGV0IHN1YiA9IGF3YWl0IGdldFN1YnNjcmlwdGlvbihldmVudCwgdGhpcyk7XG4gICAgICAgIC8vIFRoaXMgaXMgYSBsb2cgdGhhdCBpcyByZW1vdmluZyBhbiBleGlzdGluZyBsb2c7IHdlIGFjdHVhbGx5IHdhbnRcbiAgICAgICAgLy8gdG8gZW1pdCBhbiBvcnBoYW4gZXZlbnQgZm9yIHRoZSByZW1vdmVkIGxvZ1xuICAgICAgICBpZiAoc3ViLnR5cGUgPT09IFwiZXZlbnRcIiAmJiBlbWl0QXJncyAmJiBlbWl0QXJncy5sZW5ndGggPiAwICYmIGVtaXRBcmdzWzBdLnJlbW92ZWQgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHN1YiA9IGF3YWl0IGdldFN1YnNjcmlwdGlvbih7IG9ycGhhbjogXCJkcm9wLWxvZ1wiLCBsb2c6IGVtaXRBcmdzWzBdIH0sIHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLiNzdWJzLmdldChzdWIudGFnKSB8fCBudWxsO1xuICAgIH1cbiAgICBhc3luYyAjZ2V0U3ViKGV2ZW50KSB7XG4gICAgICAgIGNvbnN0IHN1YnNjcmlwdGlvbiA9IGF3YWl0IGdldFN1YnNjcmlwdGlvbihldmVudCwgdGhpcyk7XG4gICAgICAgIC8vIFByZXZlbnQgdGFtcGVyaW5nIHdpdGggb3VyIHRhZyBpbiBhbnkgc3ViY2xhc3MnIF9nZXRTdWJzY3JpYmVyXG4gICAgICAgIGNvbnN0IHRhZyA9IHN1YnNjcmlwdGlvbi50YWc7XG4gICAgICAgIGxldCBzdWIgPSB0aGlzLiNzdWJzLmdldCh0YWcpO1xuICAgICAgICBpZiAoIXN1Yikge1xuICAgICAgICAgICAgY29uc3Qgc3Vic2NyaWJlciA9IHRoaXMuX2dldFN1YnNjcmliZXIoc3Vic2NyaXB0aW9uKTtcbiAgICAgICAgICAgIGNvbnN0IGFkZHJlc3NhYmxlTWFwID0gbmV3IFdlYWtNYXAoKTtcbiAgICAgICAgICAgIGNvbnN0IG5hbWVNYXAgPSBuZXcgTWFwKCk7XG4gICAgICAgICAgICBzdWIgPSB7IHN1YnNjcmliZXIsIHRhZywgYWRkcmVzc2FibGVNYXAsIG5hbWVNYXAsIHN0YXJ0ZWQ6IGZhbHNlLCBsaXN0ZW5lcnM6IFtdIH07XG4gICAgICAgICAgICB0aGlzLiNzdWJzLnNldCh0YWcsIHN1Yik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN1YjtcbiAgICB9XG4gICAgYXN5bmMgb24oZXZlbnQsIGxpc3RlbmVyKSB7XG4gICAgICAgIGNvbnN0IHN1YiA9IGF3YWl0IHRoaXMuI2dldFN1YihldmVudCk7XG4gICAgICAgIHN1Yi5saXN0ZW5lcnMucHVzaCh7IGxpc3RlbmVyLCBvbmNlOiBmYWxzZSB9KTtcbiAgICAgICAgaWYgKCFzdWIuc3RhcnRlZCkge1xuICAgICAgICAgICAgc3ViLnN1YnNjcmliZXIuc3RhcnQoKTtcbiAgICAgICAgICAgIHN1Yi5zdGFydGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmICh0aGlzLiNwYXVzZWRTdGF0ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgc3ViLnN1YnNjcmliZXIucGF1c2UodGhpcy4jcGF1c2VkU3RhdGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBhc3luYyBvbmNlKGV2ZW50LCBsaXN0ZW5lcikge1xuICAgICAgICBjb25zdCBzdWIgPSBhd2FpdCB0aGlzLiNnZXRTdWIoZXZlbnQpO1xuICAgICAgICBzdWIubGlzdGVuZXJzLnB1c2goeyBsaXN0ZW5lciwgb25jZTogdHJ1ZSB9KTtcbiAgICAgICAgaWYgKCFzdWIuc3RhcnRlZCkge1xuICAgICAgICAgICAgc3ViLnN1YnNjcmliZXIuc3RhcnQoKTtcbiAgICAgICAgICAgIHN1Yi5zdGFydGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmICh0aGlzLiNwYXVzZWRTdGF0ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgc3ViLnN1YnNjcmliZXIucGF1c2UodGhpcy4jcGF1c2VkU3RhdGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBhc3luYyBlbWl0KGV2ZW50LCAuLi5hcmdzKSB7XG4gICAgICAgIGNvbnN0IHN1YiA9IGF3YWl0IHRoaXMuI2hhc1N1YihldmVudCwgYXJncyk7XG4gICAgICAgIC8vIElmIHRoZXJlIGlzIG5vdCBzdWJzY3JpcHRpb24gb3IgaWYgYSByZWNlbnQgZW1pdCByZW1vdmVkXG4gICAgICAgIC8vIHRoZSBsYXN0IG9mIHRoZW0gKHdoaWNoIGFsc28gZGVsZXRlZCB0aGUgc3ViKSBkbyBub3RoaW5nXG4gICAgICAgIGlmICghc3ViIHx8IHN1Yi5saXN0ZW5lcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgO1xuICAgICAgICBjb25zdCBjb3VudCA9IHN1Yi5saXN0ZW5lcnMubGVuZ3RoO1xuICAgICAgICBzdWIubGlzdGVuZXJzID0gc3ViLmxpc3RlbmVycy5maWx0ZXIoKHsgbGlzdGVuZXIsIG9uY2UgfSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcGF5bG9hZCA9IG5ldyBFdmVudFBheWxvYWQodGhpcywgKG9uY2UgPyBudWxsIDogbGlzdGVuZXIpLCBldmVudCk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGxpc3RlbmVyLmNhbGwodGhpcywgLi4uYXJncywgcGF5bG9hZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHsgfVxuICAgICAgICAgICAgcmV0dXJuICFvbmNlO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHN1Yi5saXN0ZW5lcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBpZiAoc3ViLnN0YXJ0ZWQpIHtcbiAgICAgICAgICAgICAgICBzdWIuc3Vic2NyaWJlci5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLiNzdWJzLmRlbGV0ZShzdWIudGFnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKGNvdW50ID4gMCk7XG4gICAgfVxuICAgIGFzeW5jIGxpc3RlbmVyQ291bnQoZXZlbnQpIHtcbiAgICAgICAgaWYgKGV2ZW50KSB7XG4gICAgICAgICAgICBjb25zdCBzdWIgPSBhd2FpdCB0aGlzLiNoYXNTdWIoZXZlbnQpO1xuICAgICAgICAgICAgaWYgKCFzdWIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzdWIubGlzdGVuZXJzLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgdG90YWwgPSAwO1xuICAgICAgICBmb3IgKGNvbnN0IHsgbGlzdGVuZXJzIH0gb2YgdGhpcy4jc3Vicy52YWx1ZXMoKSkge1xuICAgICAgICAgICAgdG90YWwgKz0gbGlzdGVuZXJzLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdG90YWw7XG4gICAgfVxuICAgIGFzeW5jIGxpc3RlbmVycyhldmVudCkge1xuICAgICAgICBpZiAoZXZlbnQpIHtcbiAgICAgICAgICAgIGNvbnN0IHN1YiA9IGF3YWl0IHRoaXMuI2hhc1N1YihldmVudCk7XG4gICAgICAgICAgICBpZiAoIXN1Yikge1xuICAgICAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzdWIubGlzdGVuZXJzLm1hcCgoeyBsaXN0ZW5lciB9KSA9PiBsaXN0ZW5lcik7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IHsgbGlzdGVuZXJzIH0gb2YgdGhpcy4jc3Vicy52YWx1ZXMoKSkge1xuICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0LmNvbmNhdChsaXN0ZW5lcnMubWFwKCh7IGxpc3RlbmVyIH0pID0+IGxpc3RlbmVyKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgYXN5bmMgb2ZmKGV2ZW50LCBsaXN0ZW5lcikge1xuICAgICAgICBjb25zdCBzdWIgPSBhd2FpdCB0aGlzLiNoYXNTdWIoZXZlbnQpO1xuICAgICAgICBpZiAoIXN1Yikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxpc3RlbmVyKSB7XG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IHN1Yi5saXN0ZW5lcnMubWFwKCh7IGxpc3RlbmVyIH0pID0+IGxpc3RlbmVyKS5pbmRleE9mKGxpc3RlbmVyKTtcbiAgICAgICAgICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgc3ViLmxpc3RlbmVycy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghbGlzdGVuZXIgfHwgc3ViLmxpc3RlbmVycy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGlmIChzdWIuc3RhcnRlZCkge1xuICAgICAgICAgICAgICAgIHN1Yi5zdWJzY3JpYmVyLnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuI3N1YnMuZGVsZXRlKHN1Yi50YWcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBhc3luYyByZW1vdmVBbGxMaXN0ZW5lcnMoZXZlbnQpIHtcbiAgICAgICAgaWYgKGV2ZW50KSB7XG4gICAgICAgICAgICBjb25zdCB7IHRhZywgc3RhcnRlZCwgc3Vic2NyaWJlciB9ID0gYXdhaXQgdGhpcy4jZ2V0U3ViKGV2ZW50KTtcbiAgICAgICAgICAgIGlmIChzdGFydGVkKSB7XG4gICAgICAgICAgICAgICAgc3Vic2NyaWJlci5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLiNzdWJzLmRlbGV0ZSh0YWcpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZm9yIChjb25zdCBbdGFnLCB7IHN0YXJ0ZWQsIHN1YnNjcmliZXIgfV0gb2YgdGhpcy4jc3Vicykge1xuICAgICAgICAgICAgICAgIGlmIChzdGFydGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHN1YnNjcmliZXIuc3RvcCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLiNzdWJzLmRlbGV0ZSh0YWcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvLyBBbGlhcyBmb3IgXCJvblwiXG4gICAgYXN5bmMgYWRkTGlzdGVuZXIoZXZlbnQsIGxpc3RlbmVyKSB7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLm9uKGV2ZW50LCBsaXN0ZW5lcik7XG4gICAgfVxuICAgIC8vIEFsaWFzIGZvciBcIm9mZlwiXG4gICAgYXN5bmMgcmVtb3ZlTGlzdGVuZXIoZXZlbnQsIGxpc3RlbmVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9mZihldmVudCwgbGlzdGVuZXIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgSWYgdGhpcyBwcm92aWRlciBoYXMgYmVlbiBkZXN0cm95ZWQgdXNpbmcgdGhlIFtbZGVzdHJveV1dIG1ldGhvZC5cbiAgICAgKlxuICAgICAqICBPbmNlIGRlc3Ryb3llZCwgYWxsIHJlc291cmNlcyBhcmUgcmVjbGFpbWVkLCBpbnRlcm5hbCBldmVudCBsb29wc1xuICAgICAqICBhbmQgdGltZXJzIGFyZSBjbGVhbmVkIHVwIGFuZCBubyBmdXJ0aGVyIHJlcXVlc3RzIG1heSBiZSBzZW50IHRvXG4gICAgICogIHRoZSBwcm92aWRlci5cbiAgICAgKi9cbiAgICBnZXQgZGVzdHJveWVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4jZGVzdHJveWVkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgU3ViLWNsYXNzZXMgbWF5IHVzZSB0aGlzIHRvIHNodXRkb3duIGFueSBzb2NrZXRzIG9yIHJlbGVhc2UgdGhlaXJcbiAgICAgKiAgcmVzb3VyY2VzIGFuZCByZWplY3QgYW55IHBlbmRpbmcgcmVxdWVzdHMuXG4gICAgICpcbiAgICAgKiAgU3ViLWNsYXNzZXMgKiptdXN0KiogY2FsbCBgYHN1cGVyLmRlc3Ryb3koKWBgLlxuICAgICAqL1xuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIC8vIFN0b3AgYWxsIGxpc3RlbmVyc1xuICAgICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICAgICAgICAvLyBTaHV0IGRvd24gYWxsIHRpZW1yc1xuICAgICAgICBmb3IgKGNvbnN0IHRpbWVySWQgb2YgdGhpcy4jdGltZXJzLmtleXMoKSkge1xuICAgICAgICAgICAgdGhpcy5fY2xlYXJUaW1lb3V0KHRpbWVySWQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuI2Rlc3Ryb3llZCA9IHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBXaGV0aGVyIHRoZSBwcm92aWRlciBpcyBjdXJyZW50bHkgcGF1c2VkLlxuICAgICAqXG4gICAgICogIEEgcGF1c2VkIHByb3ZpZGVyIHdpbGwgbm90IGVtaXQgYW55IGV2ZW50cywgYW5kIGdlbmVyYWxseSBzaG91bGRcbiAgICAgKiAgbm90IG1ha2UgYW55IHJlcXVlc3RzIHRvIHRoZSBuZXR3b3JrLCBidXQgdGhhdCBpcyB1cCB0byBzdWItY2xhc3Nlc1xuICAgICAqICB0byBtYW5hZ2UuXG4gICAgICpcbiAgICAgKiAgU2V0dGluZyBgYHBhdXNlZCA9IHRydWVgYCBpcyBpZGVudGljYWwgdG8gY2FsbGluZyBgYC5wYXVzZShmYWxzZSlgYCxcbiAgICAgKiAgd2hpY2ggd2lsbCBidWZmZXIgYW55IGV2ZW50cyB0aGF0IG9jY3VyIHdoaWxlIHBhdXNlZCB1bnRpbCB0aGVcbiAgICAgKiAgcHJvdmlkZXIgaXMgdW5wYXVzZWQuXG4gICAgICovXG4gICAgZ2V0IHBhdXNlZCgpIHsgcmV0dXJuICh0aGlzLiNwYXVzZWRTdGF0ZSAhPSBudWxsKTsgfVxuICAgIHNldCBwYXVzZWQocGF1c2UpIHtcbiAgICAgICAgaWYgKCEhcGF1c2UgPT09IHRoaXMucGF1c2VkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucGF1c2VkKSB7XG4gICAgICAgICAgICB0aGlzLnJlc3VtZSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5wYXVzZShmYWxzZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogIFBhdXNlIHRoZSBwcm92aWRlci4gSWYgJSVkcm9wV2hpbGVQYXVzZWQlJSwgYW55IGV2ZW50cyB0aGF0IG9jY3VyXG4gICAgICogIHdoaWxlIHBhdXNlZCBhcmUgZHJvcHBlZCwgb3RoZXJ3aXNlIGFsbCBldmVudHMgd2lsbCBiZSBlbWl0dGVkIG9uY2VcbiAgICAgKiAgdGhlIHByb3ZpZGVyIGlzIHVucGF1c2VkLlxuICAgICAqL1xuICAgIHBhdXNlKGRyb3BXaGlsZVBhdXNlZCkge1xuICAgICAgICB0aGlzLiNsYXN0QmxvY2tOdW1iZXIgPSAtMTtcbiAgICAgICAgaWYgKHRoaXMuI3BhdXNlZFN0YXRlICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLiNwYXVzZWRTdGF0ZSA9PSAhIWRyb3BXaGlsZVBhdXNlZCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFzc2VydChmYWxzZSwgXCJjYW5ub3QgY2hhbmdlIHBhdXNlIHR5cGU7IHJlc3VtZSBmaXJzdFwiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7XG4gICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBcInBhdXNlXCJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2ZvckVhY2hTdWJzY3JpYmVyKChzKSA9PiBzLnBhdXNlKGRyb3BXaGlsZVBhdXNlZCkpO1xuICAgICAgICB0aGlzLiNwYXVzZWRTdGF0ZSA9ICEhZHJvcFdoaWxlUGF1c2VkO1xuICAgICAgICBmb3IgKGNvbnN0IHRpbWVyIG9mIHRoaXMuI3RpbWVycy52YWx1ZXMoKSkge1xuICAgICAgICAgICAgLy8gQ2xlYXIgdGhlIHRpbWVyXG4gICAgICAgICAgICBpZiAodGltZXIudGltZXIpIHtcbiAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZXIudGltZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gUmVtYWluaW5nIHRpbWUgbmVlZGVkIGZvciB3aGVuIHdlIGJlY29tZSB1bnBhdXNlZFxuICAgICAgICAgICAgdGltZXIudGltZSA9IGdldFRpbWUoKSAtIHRpbWVyLnRpbWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJlc3VtZSB0aGUgcHJvdmlkZXIuXG4gICAgICovXG4gICAgcmVzdW1lKCkge1xuICAgICAgICBpZiAodGhpcy4jcGF1c2VkU3RhdGUgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2ZvckVhY2hTdWJzY3JpYmVyKChzKSA9PiBzLnJlc3VtZSgpKTtcbiAgICAgICAgdGhpcy4jcGF1c2VkU3RhdGUgPSBudWxsO1xuICAgICAgICBmb3IgKGNvbnN0IHRpbWVyIG9mIHRoaXMuI3RpbWVycy52YWx1ZXMoKSkge1xuICAgICAgICAgICAgLy8gUmVtYWluaW5nIHRpbWUgd2hlbiB3ZSB3ZXJlIHBhdXNlZFxuICAgICAgICAgICAgbGV0IHRpbWVvdXQgPSB0aW1lci50aW1lO1xuICAgICAgICAgICAgaWYgKHRpbWVvdXQgPCAwKSB7XG4gICAgICAgICAgICAgICAgdGltZW91dCA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBTdGFydCB0aW1lIChpbiBjYXVzZSBwYXVzZWQsIHNvIHdlIGNvbiBjb21wdXRlIHJlbWFpbmluZiB0aW1lKVxuICAgICAgICAgICAgdGltZXIudGltZSA9IGdldFRpbWUoKTtcbiAgICAgICAgICAgIC8vIFN0YXJ0IHRoZSB0aW1lclxuICAgICAgICAgICAgc2V0VGltZW91dCh0aW1lci5mdW5jLCB0aW1lb3V0KTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIF9wYXJzZVN0cmluZyhyZXN1bHQsIHN0YXJ0KSB7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgYnl0ZXMgPSBfcGFyc2VCeXRlcyhyZXN1bHQsIHN0YXJ0KTtcbiAgICAgICAgaWYgKGJ5dGVzKSB7XG4gICAgICAgICAgICByZXR1cm4gdG9VdGY4U3RyaW5nKGJ5dGVzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHsgfVxuICAgIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gX3BhcnNlQnl0ZXMocmVzdWx0LCBzdGFydCkge1xuICAgIGlmIChyZXN1bHQgPT09IFwiMHhcIikge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gZ2V0TnVtYmVyKGRhdGFTbGljZShyZXN1bHQsIHN0YXJ0LCBzdGFydCArIDMyKSk7XG4gICAgICAgIGNvbnN0IGxlbmd0aCA9IGdldE51bWJlcihkYXRhU2xpY2UocmVzdWx0LCBvZmZzZXQsIG9mZnNldCArIDMyKSk7XG4gICAgICAgIHJldHVybiBkYXRhU2xpY2UocmVzdWx0LCBvZmZzZXQgKyAzMiwgb2Zmc2V0ICsgMzIgKyBsZW5ndGgpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHsgfVxuICAgIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gbnVtUGFkKHZhbHVlKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gdG9CZUFycmF5KHZhbHVlKTtcbiAgICBpZiAocmVzdWx0Lmxlbmd0aCA+IDMyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImludGVybmFsOyBzaG91bGQgbm90IGhhcHBlblwiKTtcbiAgICB9XG4gICAgY29uc3QgcGFkZGVkID0gbmV3IFVpbnQ4QXJyYXkoMzIpO1xuICAgIHBhZGRlZC5zZXQocmVzdWx0LCAzMiAtIHJlc3VsdC5sZW5ndGgpO1xuICAgIHJldHVybiBwYWRkZWQ7XG59XG5mdW5jdGlvbiBieXRlc1BhZCh2YWx1ZSkge1xuICAgIGlmICgodmFsdWUubGVuZ3RoICUgMzIpID09PSAwKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgY29uc3QgcmVzdWx0ID0gbmV3IFVpbnQ4QXJyYXkoTWF0aC5jZWlsKHZhbHVlLmxlbmd0aCAvIDMyKSAqIDMyKTtcbiAgICByZXN1bHQuc2V0KHZhbHVlKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuY29uc3QgZW1wdHkgPSBuZXcgVWludDhBcnJheShbXSk7XG4vLyBBQkkgRW5jb2RlcyBhIHNlcmllcyBvZiAoYnl0ZXMsIGJ5dGVzLCAuLi4pXG5mdW5jdGlvbiBlbmNvZGVCeXRlcyhkYXRhcykge1xuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgIGxldCBieXRlQ291bnQgPSAwO1xuICAgIC8vIEFkZCBwbGFjZS1ob2xkZXJzIGZvciBwb2ludGVycyBhcyB3ZSBhZGQgaXRlbXNcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGFzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKGVtcHR5KTtcbiAgICAgICAgYnl0ZUNvdW50ICs9IDMyO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGFzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBnZXRCeXRlcyhkYXRhc1tpXSk7XG4gICAgICAgIC8vIFVwZGF0ZSB0aGUgYnl0ZXMgb2Zmc2V0XG4gICAgICAgIHJlc3VsdFtpXSA9IG51bVBhZChieXRlQ291bnQpO1xuICAgICAgICAvLyBUaGUgbGVuZ3RoIGFuZCBwYWRkZWQgdmFsdWUgb2YgZGF0YVxuICAgICAgICByZXN1bHQucHVzaChudW1QYWQoZGF0YS5sZW5ndGgpKTtcbiAgICAgICAgcmVzdWx0LnB1c2goYnl0ZXNQYWQoZGF0YSkpO1xuICAgICAgICBieXRlQ291bnQgKz0gMzIgKyBNYXRoLmNlaWwoZGF0YS5sZW5ndGggLyAzMikgKiAzMjtcbiAgICB9XG4gICAgcmV0dXJuIGNvbmNhdChyZXN1bHQpO1xufVxuY29uc3QgemVyb3MgPSBcIjB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMFwiO1xuZnVuY3Rpb24gcGFyc2VPZmZjaGFpbkxvb2t1cChkYXRhKSB7XG4gICAgY29uc3QgcmVzdWx0ID0ge1xuICAgICAgICBzZW5kZXI6IFwiXCIsIHVybHM6IFtdLCBjYWxsZGF0YTogXCJcIiwgc2VsZWN0b3I6IFwiXCIsIGV4dHJhRGF0YTogXCJcIiwgZXJyb3JBcmdzOiBbXVxuICAgIH07XG4gICAgYXNzZXJ0KGRhdGFMZW5ndGgoZGF0YSkgPj0gNSAqIDMyLCBcImluc3VmZmljaWVudCBPZmZjaGFpbkxvb2t1cCBkYXRhXCIsIFwiT0ZGQ0hBSU5fRkFVTFRcIiwge1xuICAgICAgICByZWFzb246IFwiaW5zdWZmaWNpZW50IE9mZmNoYWluTG9va3VwIGRhdGFcIlxuICAgIH0pO1xuICAgIGNvbnN0IHNlbmRlciA9IGRhdGFTbGljZShkYXRhLCAwLCAzMik7XG4gICAgYXNzZXJ0KGRhdGFTbGljZShzZW5kZXIsIDAsIDEyKSA9PT0gZGF0YVNsaWNlKHplcm9zLCAwLCAxMiksIFwiY29ycnVwdCBPZmZjaGFpbkxvb2t1cCBzZW5kZXJcIiwgXCJPRkZDSEFJTl9GQVVMVFwiLCB7XG4gICAgICAgIHJlYXNvbjogXCJjb3JydXB0IE9mZmNoYWluTG9va3VwIHNlbmRlclwiXG4gICAgfSk7XG4gICAgcmVzdWx0LnNlbmRlciA9IGRhdGFTbGljZShzZW5kZXIsIDEyKTtcbiAgICAvLyBSZWFkIHRoZSBVUkxzIGZyb20gdGhlIHJlc3BvbnNlXG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgdXJscyA9IFtdO1xuICAgICAgICBjb25zdCB1cmxzT2Zmc2V0ID0gZ2V0TnVtYmVyKGRhdGFTbGljZShkYXRhLCAzMiwgNjQpKTtcbiAgICAgICAgY29uc3QgdXJsc0xlbmd0aCA9IGdldE51bWJlcihkYXRhU2xpY2UoZGF0YSwgdXJsc09mZnNldCwgdXJsc09mZnNldCArIDMyKSk7XG4gICAgICAgIGNvbnN0IHVybHNEYXRhID0gZGF0YVNsaWNlKGRhdGEsIHVybHNPZmZzZXQgKyAzMik7XG4gICAgICAgIGZvciAobGV0IHUgPSAwOyB1IDwgdXJsc0xlbmd0aDsgdSsrKSB7XG4gICAgICAgICAgICBjb25zdCB1cmwgPSBfcGFyc2VTdHJpbmcodXJsc0RhdGEsIHUgKiAzMik7XG4gICAgICAgICAgICBpZiAodXJsID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJhYm9ydFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHVybHMucHVzaCh1cmwpO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdC51cmxzID0gdXJscztcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGFzc2VydChmYWxzZSwgXCJjb3JydXB0IE9mZmNoYWluTG9va3VwIHVybHNcIiwgXCJPRkZDSEFJTl9GQVVMVFwiLCB7XG4gICAgICAgICAgICByZWFzb246IFwiY29ycnVwdCBPZmZjaGFpbkxvb2t1cCB1cmxzXCJcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8vIEdldCB0aGUgQ0NJUCBjYWxsZGF0YSB0byBmb3J3YXJkXG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgY2FsbGRhdGEgPSBfcGFyc2VCeXRlcyhkYXRhLCA2NCk7XG4gICAgICAgIGlmIChjYWxsZGF0YSA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJhYm9ydFwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQuY2FsbGRhdGEgPSBjYWxsZGF0YTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGFzc2VydChmYWxzZSwgXCJjb3JydXB0IE9mZmNoYWluTG9va3VwIGNhbGxkYXRhXCIsIFwiT0ZGQ0hBSU5fRkFVTFRcIiwge1xuICAgICAgICAgICAgcmVhc29uOiBcImNvcnJ1cHQgT2ZmY2hhaW5Mb29rdXAgY2FsbGRhdGFcIlxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLy8gR2V0IHRoZSBjYWxsYmFja1NlbGVjdG9yIChieXRlczQpXG4gICAgYXNzZXJ0KGRhdGFTbGljZShkYXRhLCAxMDAsIDEyOCkgPT09IGRhdGFTbGljZSh6ZXJvcywgMCwgMjgpLCBcImNvcnJ1cHQgT2ZmY2hhaW5Mb29rdXAgY2FsbGJhYWNrU2VsZWN0b3JcIiwgXCJPRkZDSEFJTl9GQVVMVFwiLCB7XG4gICAgICAgIHJlYXNvbjogXCJjb3JydXB0IE9mZmNoYWluTG9va3VwIGNhbGxiYWFja1NlbGVjdG9yXCJcbiAgICB9KTtcbiAgICByZXN1bHQuc2VsZWN0b3IgPSBkYXRhU2xpY2UoZGF0YSwgOTYsIDEwMCk7XG4gICAgLy8gR2V0IHRoZSBleHRyYSBkYXRhIHRvIHNlbmQgYmFjayB0byB0aGUgY29udHJhY3QgYXMgY29udGV4dFxuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGV4dHJhRGF0YSA9IF9wYXJzZUJ5dGVzKGRhdGEsIDEyOCk7XG4gICAgICAgIGlmIChleHRyYURhdGEgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYWJvcnRcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0LmV4dHJhRGF0YSA9IGV4dHJhRGF0YTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGFzc2VydChmYWxzZSwgXCJjb3JydXB0IE9mZmNoYWluTG9va3VwIGV4dHJhRGF0YVwiLCBcIk9GRkNIQUlOX0ZBVUxUXCIsIHtcbiAgICAgICAgICAgIHJlYXNvbjogXCJjb3JydXB0IE9mZmNoYWluTG9va3VwIGV4dHJhRGF0YVwiXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXN1bHQuZXJyb3JBcmdzID0gXCJzZW5kZXIsdXJscyxjYWxsZGF0YSxzZWxlY3RvcixleHRyYURhdGFcIi5zcGxpdCgvLC8pLm1hcCgoaykgPT4gcmVzdWx0W2tdKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWJzdHJhY3QtcHJvdmlkZXIuanMubWFwIl0sIm5hbWVzIjpbImdldEFkZHJlc3MiLCJyZXNvbHZlQWRkcmVzcyIsIlplcm9BZGRyZXNzIiwiQ29udHJhY3QiLCJuYW1laGFzaCIsIlRyYW5zYWN0aW9uIiwiY29uY2F0IiwiZGF0YUxlbmd0aCIsImRhdGFTbGljZSIsImhleGxpZnkiLCJpc0hleFN0cmluZyIsImdldEJpZ0ludCIsImdldEJ5dGVzIiwiZ2V0TnVtYmVyIiwiaXNDYWxsRXhjZXB0aW9uIiwiaXNFcnJvciIsIm1ha2VFcnJvciIsImFzc2VydCIsImFzc2VydEFyZ3VtZW50IiwiRmV0Y2hSZXF1ZXN0IiwidG9CZUFycmF5IiwidG9RdWFudGl0eSIsImRlZmluZVByb3BlcnRpZXMiLCJFdmVudFBheWxvYWQiLCJyZXNvbHZlUHJvcGVydGllcyIsInRvVXRmOFN0cmluZyIsIkVuc1Jlc29sdmVyIiwiZm9ybWF0QmxvY2siLCJmb3JtYXRMb2ciLCJmb3JtYXRUcmFuc2FjdGlvblJlY2VpcHQiLCJmb3JtYXRUcmFuc2FjdGlvblJlc3BvbnNlIiwiTmV0d29yayIsImNvcHlSZXF1ZXN0IiwiQmxvY2siLCJGZWVEYXRhIiwiTG9nIiwiVHJhbnNhY3Rpb25SZWNlaXB0IiwiVHJhbnNhY3Rpb25SZXNwb25zZSIsIlBvbGxpbmdCbG9ja1N1YnNjcmliZXIiLCJQb2xsaW5nQmxvY2tUYWdTdWJzY3JpYmVyIiwiUG9sbGluZ0V2ZW50U3Vic2NyaWJlciIsIlBvbGxpbmdPcnBoYW5TdWJzY3JpYmVyIiwiUG9sbGluZ1RyYW5zYWN0aW9uU3Vic2NyaWJlciIsIkJOXzIiLCJCaWdJbnQiLCJNQVhfQ0NJUF9SRURJUkVDVFMiLCJpc1Byb21pc2UiLCJ2YWx1ZSIsInRoZW4iLCJnZXRUYWciLCJwcmVmaXgiLCJKU09OIiwic3RyaW5naWZ5IiwiayIsInYiLCJ0b1N0cmluZyIsInRvTG93ZXJDYXNlIiwiQXJyYXkiLCJpc0FycmF5Iiwia2V5cyIsIk9iamVjdCIsInNvcnQiLCJyZWR1Y2UiLCJhY2N1bSIsImtleSIsIlVubWFuYWdlZFN1YnNjcmliZXIiLCJjb25zdHJ1Y3RvciIsIm5hbWUiLCJzdGFydCIsInN0b3AiLCJwYXVzZSIsImRyb3BXaGlsZVBhdXNlZCIsInJlc3VtZSIsImNvcHkiLCJwYXJzZSIsImNvbmNpc2lmeSIsIml0ZW1zIiwiZnJvbSIsIlNldCIsInZhbHVlcyIsImdldFN1YnNjcmlwdGlvbiIsIl9ldmVudCIsInByb3ZpZGVyIiwiRXJyb3IiLCJ0b3BpY3MiLCJ0eXBlIiwidGFnIiwiaGFzaCIsIm9ycGhhbiIsImV2ZW50IiwiZmlsdGVyIiwiYWRkcmVzcyIsIm1hcCIsInQiLCJhZGRyZXNzZXMiLCJwcm9taXNlcyIsImFkZEFkZHJlc3MiLCJhZGRyIiwicHVzaCIsImZvckVhY2giLCJsZW5ndGgiLCJQcm9taXNlIiwiYWxsIiwiYSIsImdldFRpbWUiLCJEYXRlIiwiZGVmYXVsdE9wdGlvbnMiLCJjYWNoZVRpbWVvdXQiLCJwb2xsaW5nSW50ZXJ2YWwiLCJBYnN0cmFjdFByb3ZpZGVyIiwic3VicyIsInBsdWdpbnMiLCJwYXVzZWRTdGF0ZSIsImRlc3Ryb3llZCIsIm5ldHdvcmtQcm9taXNlIiwiYW55TmV0d29yayIsInBlcmZvcm1DYWNoZSIsImxhc3RCbG9ja051bWJlciIsIm5leHRUaW1lciIsInRpbWVycyIsImRpc2FibGVDY2lwUmVhZCIsIm9wdGlvbnMiLCJfbmV0d29yayIsImFzc2lnbiIsIm5ldHdvcmsiLCJyZXNvbHZlIiwic2V0VGltZW91dCIsImVtaXQiLCJNYXAiLCJhdHRhY2hQbHVnaW4iLCJwbHVnaW4iLCJnZXQiLCJzZXQiLCJjb25uZWN0IiwiZ2V0UGx1Z2luIiwicGVyZm9ybSIsInJlcSIsInRpbWVvdXQiLCJfcGVyZm9ybSIsIm1ldGhvZCIsImRlbGV0ZSIsImNjaXBSZWFkRmV0Y2giLCJ0eCIsImNhbGxkYXRhIiwidXJscyIsInRvIiwic2VuZGVyIiwiZGF0YSIsImVycm9yTWVzc2FnZXMiLCJpIiwidXJsIiwiaHJlZiIsInJlcGxhY2UiLCJyZXF1ZXN0IiwiaW5kZXhPZiIsImJvZHkiLCJhY3Rpb24iLCJpbmRleCIsImVycm9yTWVzc2FnZSIsInJlc3AiLCJzZW5kIiwiZXJyb3IiLCJtZXNzYWdlIiwicmVzdWx0IiwiYm9keUpzb24iLCJzdGF0dXNDb2RlIiwicmVhc29uIiwidHJhbnNhY3Rpb24iLCJpbmZvIiwibSIsImpvaW4iLCJfd3JhcEJsb2NrIiwiX3dyYXBMb2ciLCJfd3JhcFRyYW5zYWN0aW9uUmVjZWlwdCIsIl93cmFwVHJhbnNhY3Rpb25SZXNwb25zZSIsIl9kZXRlY3ROZXR3b3JrIiwib3BlcmF0aW9uIiwiZ2V0QmxvY2tOdW1iZXIiLCJibG9ja051bWJlciIsIl9nZXRBZGRyZXNzIiwiX2dldEJsb2NrVGFnIiwiYmxvY2tUYWciLCJiIiwiX2dldEZpbHRlciIsImJsb2NrSGFzaCIsInVuZGVmaW5lZCIsIl9hZGRyZXNzIiwiZnJvbUJsb2NrIiwidG9CbG9jayIsIl9nZXRUcmFuc2FjdGlvblJlcXVlc3QiLCJfcmVxdWVzdCIsImdldE5ldHdvcmsiLCJkZXRlY3ROZXR3b3JrIiwiY2xvbmUiLCJleHBlY3RlZCIsImFjdHVhbCIsImNoYWluSWQiLCJnZXRGZWVEYXRhIiwiZ2V0RmVlRGF0YUZ1bmMiLCJfYmxvY2siLCJnYXNQcmljZSIsInByaW9yaXR5RmVlIiwiZ2V0QmxvY2siLCJtYXhGZWVQZXJHYXMiLCJtYXhQcmlvcml0eUZlZVBlckdhcyIsImJsb2NrIiwiYmFzZUZlZVBlckdhcyIsImZlZURhdGEiLCJwcm9jZXNzRnVuYyIsImVzdGltYXRlR2FzIiwiX3R4IiwiY2FsbCIsImF0dGVtcHQiLCJlbmFibGVDY2lwUmVhZCIsInR4U2VuZGVyIiwiY2NpcEFyZ3MiLCJwYXJzZU9mZmNoYWluTG9va3VwIiwiaW52b2NhdGlvbiIsInJldmVydCIsInNpZ25hdHVyZSIsImFyZ3MiLCJlcnJvckFyZ3MiLCJjY2lwUmVzdWx0Iiwic2VsZWN0b3IiLCJlbmNvZGVCeXRlcyIsImV4dHJhRGF0YSIsImNoZWNrTmV0d29yayIsInByb21pc2UiLCJnZXRBY2NvdW50VmFsdWUiLCJfYmxvY2tUYWciLCJnZXRCYWxhbmNlIiwiZ2V0VHJhbnNhY3Rpb25Db3VudCIsImdldENvZGUiLCJnZXRTdG9yYWdlIiwiX3Bvc2l0aW9uIiwicG9zaXRpb24iLCJicm9hZGNhc3RUcmFuc2FjdGlvbiIsInNpZ25lZFR4Iiwic2lnbmVkVHJhbnNhY3Rpb24iLCJyZXBsYWNlYWJsZVRyYW5zYWN0aW9uIiwiaW5jbHVkZVRyYW5zYWN0aW9ucyIsInByZWZldGNoVHhzIiwicGFyYW1zIiwiZ2V0VHJhbnNhY3Rpb24iLCJnZXRUcmFuc2FjdGlvblJlY2VpcHQiLCJlZmZlY3RpdmVHYXNQcmljZSIsImdldFRyYW5zYWN0aW9uUmVzdWx0IiwiZ2V0TG9ncyIsIl9maWx0ZXIiLCJwIiwiX2dldFByb3ZpZGVyIiwiZ2V0UmVzb2x2ZXIiLCJmcm9tTmFtZSIsImdldEF2YXRhciIsInJlc29sdmVyIiwicmVzb2x2ZU5hbWUiLCJsb29rdXBBZGRyZXNzIiwibm9kZSIsInN1YnN0cmluZyIsImVuc0FkZHIiLCJnZXRFbnNBZGRyZXNzIiwiZW5zQ29udHJhY3QiLCJyZXNvbHZlckNvbnRyYWN0IiwiY2hlY2siLCJ3YWl0Rm9yVHJhbnNhY3Rpb24iLCJfY29uZmlybXMiLCJjb25maXJtcyIsInJlamVjdCIsInRpbWVyIiwibGlzdGVuZXIiLCJyZWNlaXB0IiwiY2xlYXJUaW1lb3V0IiwiY29uc29sZSIsImxvZyIsIm9uY2UiLCJvZmYiLCJ3YWl0Rm9yQmxvY2siLCJfY2xlYXJUaW1lb3V0IiwidGltZXJJZCIsIl9zZXRUaW1lb3V0IiwiX2Z1bmMiLCJmdW5jIiwicGF1c2VkIiwidGltZSIsIl9mb3JFYWNoU3Vic2NyaWJlciIsInN1YiIsInN1YnNjcmliZXIiLCJfZ2V0U3Vic2NyaWJlciIsIl9yZWNvdmVyU3Vic2NyaWJlciIsIm9sZFN1YiIsIm5ld1N1YiIsInN0YXJ0ZWQiLCJoYXNTdWIiLCJlbWl0QXJncyIsInJlbW92ZWQiLCJnZXRTdWIiLCJzdWJzY3JpcHRpb24iLCJhZGRyZXNzYWJsZU1hcCIsIldlYWtNYXAiLCJuYW1lTWFwIiwibGlzdGVuZXJzIiwib24iLCJjb3VudCIsInBheWxvYWQiLCJsaXN0ZW5lckNvdW50IiwidG90YWwiLCJzcGxpY2UiLCJyZW1vdmVBbGxMaXN0ZW5lcnMiLCJhZGRMaXN0ZW5lciIsInJlbW92ZUxpc3RlbmVyIiwiZGVzdHJveSIsInMiLCJfcGFyc2VTdHJpbmciLCJieXRlcyIsIl9wYXJzZUJ5dGVzIiwib2Zmc2V0IiwibnVtUGFkIiwicGFkZGVkIiwiVWludDhBcnJheSIsImJ5dGVzUGFkIiwiTWF0aCIsImNlaWwiLCJlbXB0eSIsImRhdGFzIiwiYnl0ZUNvdW50IiwiemVyb3MiLCJ1cmxzT2Zmc2V0IiwidXJsc0xlbmd0aCIsInVybHNEYXRhIiwidSIsInNwbGl0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.esm/providers/abstract-provider.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.esm/providers/abstract-signer.js":
/*!******************************************************************!*\
  !*** ./node_modules/ethers/lib.esm/providers/abstract-signer.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AbstractSigner: () => (/* binding */ AbstractSigner),\n/* harmony export */   VoidSigner: () => (/* binding */ VoidSigner)\n/* harmony export */ });\n/* harmony import */ var _address_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../address/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/address/checks.js\");\n/* harmony import */ var _transaction_index_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../transaction/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/transaction/transaction.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/errors.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/properties.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/maths.js\");\n/* harmony import */ var _provider_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./provider.js */ \"(ssr)/./node_modules/ethers/lib.esm/providers/provider.js\");\n/**\n *  Generally the [[Wallet]] and [[JsonRpcSigner]] and their sub-classes\n *  are sufficent for most developers, but this is provided to\n *  fascilitate more complex Signers.\n *\n *  @_section: api/providers/abstract-signer: Subclassing Signer [abstract-signer]\n */ \n\n\n\nfunction checkProvider(signer, operation) {\n    if (signer.provider) {\n        return signer.provider;\n    }\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assert)(false, \"missing provider\", \"UNSUPPORTED_OPERATION\", {\n        operation\n    });\n}\nasync function populate(signer, tx) {\n    let pop = (0,_provider_js__WEBPACK_IMPORTED_MODULE_1__.copyRequest)(tx);\n    if (pop.to != null) {\n        pop.to = (0,_address_index_js__WEBPACK_IMPORTED_MODULE_2__.resolveAddress)(pop.to, signer);\n    }\n    if (pop.from != null) {\n        const from = pop.from;\n        pop.from = Promise.all([\n            signer.getAddress(),\n            (0,_address_index_js__WEBPACK_IMPORTED_MODULE_2__.resolveAddress)(from, signer)\n        ]).then(([address, from])=>{\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(address.toLowerCase() === from.toLowerCase(), \"transaction from mismatch\", \"tx.from\", from);\n            return address;\n        });\n    } else {\n        pop.from = signer.getAddress();\n    }\n    return await (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.resolveProperties)(pop);\n}\n/**\n *  An **AbstractSigner** includes most of teh functionality required\n *  to get a [[Signer]] working as expected, but requires a few\n *  Signer-specific methods be overridden.\n *\n */ class AbstractSigner {\n    /**\n     *  Creates a new Signer connected to %%provider%%.\n     */ constructor(provider){\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.defineProperties)(this, {\n            provider: provider || null\n        });\n    }\n    async getNonce(blockTag) {\n        return checkProvider(this, \"getTransactionCount\").getTransactionCount(await this.getAddress(), blockTag);\n    }\n    async populateCall(tx) {\n        const pop = await populate(this, tx);\n        return pop;\n    }\n    async populateTransaction(tx) {\n        const provider = checkProvider(this, \"populateTransaction\");\n        const pop = await populate(this, tx);\n        if (pop.nonce == null) {\n            pop.nonce = await this.getNonce(\"pending\");\n        }\n        if (pop.gasLimit == null) {\n            pop.gasLimit = await this.estimateGas(pop);\n        }\n        // Populate the chain ID\n        const network = await this.provider.getNetwork();\n        if (pop.chainId != null) {\n            const chainId = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_4__.getBigInt)(pop.chainId);\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(chainId === network.chainId, \"transaction chainId mismatch\", \"tx.chainId\", tx.chainId);\n        } else {\n            pop.chainId = network.chainId;\n        }\n        // Do not allow mixing pre-eip-1559 and eip-1559 properties\n        const hasEip1559 = pop.maxFeePerGas != null || pop.maxPriorityFeePerGas != null;\n        if (pop.gasPrice != null && (pop.type === 2 || hasEip1559)) {\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(false, \"eip-1559 transaction do not support gasPrice\", \"tx\", tx);\n        } else if ((pop.type === 0 || pop.type === 1) && hasEip1559) {\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(false, \"pre-eip-1559 transaction do not support maxFeePerGas/maxPriorityFeePerGas\", \"tx\", tx);\n        }\n        if ((pop.type === 2 || pop.type == null) && pop.maxFeePerGas != null && pop.maxPriorityFeePerGas != null) {\n            // Fully-formed EIP-1559 transaction (skip getFeeData)\n            pop.type = 2;\n        } else if (pop.type === 0 || pop.type === 1) {\n            // Explicit Legacy or EIP-2930 transaction\n            // We need to get fee data to determine things\n            const feeData = await provider.getFeeData();\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assert)(feeData.gasPrice != null, \"network does not support gasPrice\", \"UNSUPPORTED_OPERATION\", {\n                operation: \"getGasPrice\"\n            });\n            // Populate missing gasPrice\n            if (pop.gasPrice == null) {\n                pop.gasPrice = feeData.gasPrice;\n            }\n        } else {\n            // We need to get fee data to determine things\n            const feeData = await provider.getFeeData();\n            if (pop.type == null) {\n                // We need to auto-detect the intended type of this transaction...\n                if (feeData.maxFeePerGas != null && feeData.maxPriorityFeePerGas != null) {\n                    // The network supports EIP-1559!\n                    // Upgrade transaction from null to eip-1559\n                    if (pop.authorizationList && pop.authorizationList.length) {\n                        pop.type = 4;\n                    } else {\n                        pop.type = 2;\n                    }\n                    if (pop.gasPrice != null) {\n                        // Using legacy gasPrice property on an eip-1559 network,\n                        // so use gasPrice as both fee properties\n                        const gasPrice = pop.gasPrice;\n                        delete pop.gasPrice;\n                        pop.maxFeePerGas = gasPrice;\n                        pop.maxPriorityFeePerGas = gasPrice;\n                    } else {\n                        // Populate missing fee data\n                        if (pop.maxFeePerGas == null) {\n                            pop.maxFeePerGas = feeData.maxFeePerGas;\n                        }\n                        if (pop.maxPriorityFeePerGas == null) {\n                            pop.maxPriorityFeePerGas = feeData.maxPriorityFeePerGas;\n                        }\n                    }\n                } else if (feeData.gasPrice != null) {\n                    // Network doesn't support EIP-1559...\n                    // ...but they are trying to use EIP-1559 properties\n                    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assert)(!hasEip1559, \"network does not support EIP-1559\", \"UNSUPPORTED_OPERATION\", {\n                        operation: \"populateTransaction\"\n                    });\n                    // Populate missing fee data\n                    if (pop.gasPrice == null) {\n                        pop.gasPrice = feeData.gasPrice;\n                    }\n                    // Explicitly set untyped transaction to legacy\n                    // @TODO: Maybe this shold allow type 1?\n                    pop.type = 0;\n                } else {\n                    // getFeeData has failed us.\n                    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assert)(false, \"failed to get consistent fee data\", \"UNSUPPORTED_OPERATION\", {\n                        operation: \"signer.getFeeData\"\n                    });\n                }\n            } else if (pop.type === 2 || pop.type === 3 || pop.type === 4) {\n                // Explicitly using EIP-1559 or EIP-4844\n                // Populate missing fee data\n                if (pop.maxFeePerGas == null) {\n                    pop.maxFeePerGas = feeData.maxFeePerGas;\n                }\n                if (pop.maxPriorityFeePerGas == null) {\n                    pop.maxPriorityFeePerGas = feeData.maxPriorityFeePerGas;\n                }\n            }\n        }\n        //@TOOD: Don't await all over the place; save them up for\n        // the end for better batching\n        return await (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.resolveProperties)(pop);\n    }\n    async populateAuthorization(_auth) {\n        const auth = Object.assign({}, _auth);\n        // Add a chain ID if not explicitly set to 0\n        if (auth.chainId == null) {\n            auth.chainId = (await checkProvider(this, \"getNetwork\").getNetwork()).chainId;\n        }\n        // @TODO: Take chain ID into account when populating noce?\n        if (auth.nonce == null) {\n            auth.nonce = await this.getNonce();\n        }\n        return auth;\n    }\n    async estimateGas(tx) {\n        return checkProvider(this, \"estimateGas\").estimateGas(await this.populateCall(tx));\n    }\n    async call(tx) {\n        return checkProvider(this, \"call\").call(await this.populateCall(tx));\n    }\n    async resolveName(name) {\n        const provider = checkProvider(this, \"resolveName\");\n        return await provider.resolveName(name);\n    }\n    async sendTransaction(tx) {\n        const provider = checkProvider(this, \"sendTransaction\");\n        const pop = await this.populateTransaction(tx);\n        delete pop.from;\n        const txObj = _transaction_index_js__WEBPACK_IMPORTED_MODULE_5__.Transaction.from(pop);\n        return await provider.broadcastTransaction(await this.signTransaction(txObj));\n    }\n    // @TODO: in v7 move this to be abstract\n    authorize(authorization) {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assert)(false, \"authorization not implemented for this signer\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"authorize\"\n        });\n    }\n}\n/**\n *  A **VoidSigner** is a class deisgned to allow an address to be used\n *  in any API which accepts a Signer, but for which there are no\n *  credentials available to perform any actual signing.\n *\n *  This for example allow impersonating an account for the purpose of\n *  static calls or estimating gas, but does not allow sending transactions.\n */ class VoidSigner extends AbstractSigner {\n    /**\n     *  Creates a new **VoidSigner** with %%address%% attached to\n     *  %%provider%%.\n     */ constructor(address, provider){\n        super(provider);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.defineProperties)(this, {\n            address\n        });\n    }\n    async getAddress() {\n        return this.address;\n    }\n    connect(provider) {\n        return new VoidSigner(this.address, provider);\n    }\n    #throwUnsupported(suffix, operation) {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assert)(false, `VoidSigner cannot sign ${suffix}`, \"UNSUPPORTED_OPERATION\", {\n            operation\n        });\n    }\n    async signTransaction(tx) {\n        this.#throwUnsupported(\"transactions\", \"signTransaction\");\n    }\n    async signMessage(message) {\n        this.#throwUnsupported(\"messages\", \"signMessage\");\n    }\n    async signTypedData(domain, types, value) {\n        this.#throwUnsupported(\"typed-data\", \"signTypedData\");\n    }\n} //# sourceMappingURL=abstract-signer.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vcHJvdmlkZXJzL2Fic3RyYWN0LXNpZ25lci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUFBOzs7Ozs7Q0FNQyxHQUNvRDtBQUNDO0FBQ3FEO0FBQy9EO0FBQzVDLFNBQVNRLGNBQWNDLE1BQU0sRUFBRUMsU0FBUztJQUNwQyxJQUFJRCxPQUFPRSxRQUFRLEVBQUU7UUFDakIsT0FBT0YsT0FBT0UsUUFBUTtJQUMxQjtJQUNBTix1REFBTUEsQ0FBQyxPQUFPLG9CQUFvQix5QkFBeUI7UUFBRUs7SUFBVTtBQUMzRTtBQUNBLGVBQWVFLFNBQVNILE1BQU0sRUFBRUksRUFBRTtJQUM5QixJQUFJQyxNQUFNUCx5REFBV0EsQ0FBQ007SUFDdEIsSUFBSUMsSUFBSUMsRUFBRSxJQUFJLE1BQU07UUFDaEJELElBQUlDLEVBQUUsR0FBR2YsaUVBQWNBLENBQUNjLElBQUlDLEVBQUUsRUFBRU47SUFDcEM7SUFDQSxJQUFJSyxJQUFJRSxJQUFJLElBQUksTUFBTTtRQUNsQixNQUFNQSxPQUFPRixJQUFJRSxJQUFJO1FBQ3JCRixJQUFJRSxJQUFJLEdBQUdDLFFBQVFDLEdBQUcsQ0FBQztZQUNuQlQsT0FBT1UsVUFBVTtZQUNqQm5CLGlFQUFjQSxDQUFDZ0IsTUFBTVA7U0FDeEIsRUFBRVcsSUFBSSxDQUFDLENBQUMsQ0FBQ0MsU0FBU0wsS0FBSztZQUNwQlYsK0RBQWNBLENBQUNlLFFBQVFDLFdBQVcsT0FBT04sS0FBS00sV0FBVyxJQUFJLDZCQUE2QixXQUFXTjtZQUNyRyxPQUFPSztRQUNYO0lBQ0osT0FDSztRQUNEUCxJQUFJRSxJQUFJLEdBQUdQLE9BQU9VLFVBQVU7SUFDaEM7SUFDQSxPQUFPLE1BQU1mLGtFQUFpQkEsQ0FBQ1U7QUFDbkM7QUFDQTs7Ozs7Q0FLQyxHQUNNLE1BQU1TO0lBS1Q7O0tBRUMsR0FDREMsWUFBWWIsUUFBUSxDQUFFO1FBQ2xCVCxpRUFBZ0JBLENBQUMsSUFBSSxFQUFFO1lB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QUssRUFBRUMsS0FBSyxFQUFFO1FBQ3RDLElBQUksQ0FBQyxDQUFDUCxnQkFBZ0IsQ0FBQyxjQUFjO0lBQ3pDO0FBQ0osRUFDQSwyQ0FBMkMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tZWdhdmliZS1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9wcm92aWRlcnMvYWJzdHJhY3Qtc2lnbmVyLmpzPzk0NGEiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiAgR2VuZXJhbGx5IHRoZSBbW1dhbGxldF1dIGFuZCBbW0pzb25ScGNTaWduZXJdXSBhbmQgdGhlaXIgc3ViLWNsYXNzZXNcbiAqICBhcmUgc3VmZmljZW50IGZvciBtb3N0IGRldmVsb3BlcnMsIGJ1dCB0aGlzIGlzIHByb3ZpZGVkIHRvXG4gKiAgZmFzY2lsaXRhdGUgbW9yZSBjb21wbGV4IFNpZ25lcnMuXG4gKlxuICogIEBfc2VjdGlvbjogYXBpL3Byb3ZpZGVycy9hYnN0cmFjdC1zaWduZXI6IFN1YmNsYXNzaW5nIFNpZ25lciBbYWJzdHJhY3Qtc2lnbmVyXVxuICovXG5pbXBvcnQgeyByZXNvbHZlQWRkcmVzcyB9IGZyb20gXCIuLi9hZGRyZXNzL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBUcmFuc2FjdGlvbiB9IGZyb20gXCIuLi90cmFuc2FjdGlvbi9pbmRleC5qc1wiO1xuaW1wb3J0IHsgZGVmaW5lUHJvcGVydGllcywgZ2V0QmlnSW50LCByZXNvbHZlUHJvcGVydGllcywgYXNzZXJ0LCBhc3NlcnRBcmd1bWVudCB9IGZyb20gXCIuLi91dGlscy9pbmRleC5qc1wiO1xuaW1wb3J0IHsgY29weVJlcXVlc3QgfSBmcm9tIFwiLi9wcm92aWRlci5qc1wiO1xuZnVuY3Rpb24gY2hlY2tQcm92aWRlcihzaWduZXIsIG9wZXJhdGlvbikge1xuICAgIGlmIChzaWduZXIucHJvdmlkZXIpIHtcbiAgICAgICAgcmV0dXJuIHNpZ25lci5wcm92aWRlcjtcbiAgICB9XG4gICAgYXNzZXJ0KGZhbHNlLCBcIm1pc3NpbmcgcHJvdmlkZXJcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwgeyBvcGVyYXRpb24gfSk7XG59XG5hc3luYyBmdW5jdGlvbiBwb3B1bGF0ZShzaWduZXIsIHR4KSB7XG4gICAgbGV0IHBvcCA9IGNvcHlSZXF1ZXN0KHR4KTtcbiAgICBpZiAocG9wLnRvICE9IG51bGwpIHtcbiAgICAgICAgcG9wLnRvID0gcmVzb2x2ZUFkZHJlc3MocG9wLnRvLCBzaWduZXIpO1xuICAgIH1cbiAgICBpZiAocG9wLmZyb20gIT0gbnVsbCkge1xuICAgICAgICBjb25zdCBmcm9tID0gcG9wLmZyb207XG4gICAgICAgIHBvcC5mcm9tID0gUHJvbWlzZS5hbGwoW1xuICAgICAgICAgICAgc2lnbmVyLmdldEFkZHJlc3MoKSxcbiAgICAgICAgICAgIHJlc29sdmVBZGRyZXNzKGZyb20sIHNpZ25lcilcbiAgICAgICAgXSkudGhlbigoW2FkZHJlc3MsIGZyb21dKSA9PiB7XG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudChhZGRyZXNzLnRvTG93ZXJDYXNlKCkgPT09IGZyb20udG9Mb3dlckNhc2UoKSwgXCJ0cmFuc2FjdGlvbiBmcm9tIG1pc21hdGNoXCIsIFwidHguZnJvbVwiLCBmcm9tKTtcbiAgICAgICAgICAgIHJldHVybiBhZGRyZXNzO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHBvcC5mcm9tID0gc2lnbmVyLmdldEFkZHJlc3MoKTtcbiAgICB9XG4gICAgcmV0dXJuIGF3YWl0IHJlc29sdmVQcm9wZXJ0aWVzKHBvcCk7XG59XG4vKipcbiAqICBBbiAqKkFic3RyYWN0U2lnbmVyKiogaW5jbHVkZXMgbW9zdCBvZiB0ZWggZnVuY3Rpb25hbGl0eSByZXF1aXJlZFxuICogIHRvIGdldCBhIFtbU2lnbmVyXV0gd29ya2luZyBhcyBleHBlY3RlZCwgYnV0IHJlcXVpcmVzIGEgZmV3XG4gKiAgU2lnbmVyLXNwZWNpZmljIG1ldGhvZHMgYmUgb3ZlcnJpZGRlbi5cbiAqXG4gKi9cbmV4cG9ydCBjbGFzcyBBYnN0cmFjdFNpZ25lciB7XG4gICAgLyoqXG4gICAgICogIFRoZSBwcm92aWRlciB0aGlzIHNpZ25lciBpcyBjb25uZWN0ZWQgdG8uXG4gICAgICovXG4gICAgcHJvdmlkZXI7XG4gICAgLyoqXG4gICAgICogIENyZWF0ZXMgYSBuZXcgU2lnbmVyIGNvbm5lY3RlZCB0byAlJXByb3ZpZGVyJSUuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IocHJvdmlkZXIpIHtcbiAgICAgICAgZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7IHByb3ZpZGVyOiAocHJvdmlkZXIgfHwgbnVsbCkgfSk7XG4gICAgfVxuICAgIGFzeW5jIGdldE5vbmNlKGJsb2NrVGFnKSB7XG4gICAgICAgIHJldHVybiBjaGVja1Byb3ZpZGVyKHRoaXMsIFwiZ2V0VHJhbnNhY3Rpb25Db3VudFwiKS5nZXRUcmFuc2FjdGlvbkNvdW50KGF3YWl0IHRoaXMuZ2V0QWRkcmVzcygpLCBibG9ja1RhZyk7XG4gICAgfVxuICAgIGFzeW5jIHBvcHVsYXRlQ2FsbCh0eCkge1xuICAgICAgICBjb25zdCBwb3AgPSBhd2FpdCBwb3B1bGF0ZSh0aGlzLCB0eCk7XG4gICAgICAgIHJldHVybiBwb3A7XG4gICAgfVxuICAgIGFzeW5jIHBvcHVsYXRlVHJhbnNhY3Rpb24odHgpIHtcbiAgICAgICAgY29uc3QgcHJvdmlkZXIgPSBjaGVja1Byb3ZpZGVyKHRoaXMsIFwicG9wdWxhdGVUcmFuc2FjdGlvblwiKTtcbiAgICAgICAgY29uc3QgcG9wID0gYXdhaXQgcG9wdWxhdGUodGhpcywgdHgpO1xuICAgICAgICBpZiAocG9wLm5vbmNlID09IG51bGwpIHtcbiAgICAgICAgICAgIHBvcC5ub25jZSA9IGF3YWl0IHRoaXMuZ2V0Tm9uY2UoXCJwZW5kaW5nXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwb3AuZ2FzTGltaXQgPT0gbnVsbCkge1xuICAgICAgICAgICAgcG9wLmdhc0xpbWl0ID0gYXdhaXQgdGhpcy5lc3RpbWF0ZUdhcyhwb3ApO1xuICAgICAgICB9XG4gICAgICAgIC8vIFBvcHVsYXRlIHRoZSBjaGFpbiBJRFxuICAgICAgICBjb25zdCBuZXR3b3JrID0gYXdhaXQgKHRoaXMucHJvdmlkZXIpLmdldE5ldHdvcmsoKTtcbiAgICAgICAgaWYgKHBvcC5jaGFpbklkICE9IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnN0IGNoYWluSWQgPSBnZXRCaWdJbnQocG9wLmNoYWluSWQpO1xuICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoY2hhaW5JZCA9PT0gbmV0d29yay5jaGFpbklkLCBcInRyYW5zYWN0aW9uIGNoYWluSWQgbWlzbWF0Y2hcIiwgXCJ0eC5jaGFpbklkXCIsIHR4LmNoYWluSWQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcG9wLmNoYWluSWQgPSBuZXR3b3JrLmNoYWluSWQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRG8gbm90IGFsbG93IG1peGluZyBwcmUtZWlwLTE1NTkgYW5kIGVpcC0xNTU5IHByb3BlcnRpZXNcbiAgICAgICAgY29uc3QgaGFzRWlwMTU1OSA9IChwb3AubWF4RmVlUGVyR2FzICE9IG51bGwgfHwgcG9wLm1heFByaW9yaXR5RmVlUGVyR2FzICE9IG51bGwpO1xuICAgICAgICBpZiAocG9wLmdhc1ByaWNlICE9IG51bGwgJiYgKHBvcC50eXBlID09PSAyIHx8IGhhc0VpcDE1NTkpKSB7XG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudChmYWxzZSwgXCJlaXAtMTU1OSB0cmFuc2FjdGlvbiBkbyBub3Qgc3VwcG9ydCBnYXNQcmljZVwiLCBcInR4XCIsIHR4KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgocG9wLnR5cGUgPT09IDAgfHwgcG9wLnR5cGUgPT09IDEpICYmIGhhc0VpcDE1NTkpIHtcbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KGZhbHNlLCBcInByZS1laXAtMTU1OSB0cmFuc2FjdGlvbiBkbyBub3Qgc3VwcG9ydCBtYXhGZWVQZXJHYXMvbWF4UHJpb3JpdHlGZWVQZXJHYXNcIiwgXCJ0eFwiLCB0eCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKChwb3AudHlwZSA9PT0gMiB8fCBwb3AudHlwZSA9PSBudWxsKSAmJiAocG9wLm1heEZlZVBlckdhcyAhPSBudWxsICYmIHBvcC5tYXhQcmlvcml0eUZlZVBlckdhcyAhPSBudWxsKSkge1xuICAgICAgICAgICAgLy8gRnVsbHktZm9ybWVkIEVJUC0xNTU5IHRyYW5zYWN0aW9uIChza2lwIGdldEZlZURhdGEpXG4gICAgICAgICAgICBwb3AudHlwZSA9IDI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocG9wLnR5cGUgPT09IDAgfHwgcG9wLnR5cGUgPT09IDEpIHtcbiAgICAgICAgICAgIC8vIEV4cGxpY2l0IExlZ2FjeSBvciBFSVAtMjkzMCB0cmFuc2FjdGlvblxuICAgICAgICAgICAgLy8gV2UgbmVlZCB0byBnZXQgZmVlIGRhdGEgdG8gZGV0ZXJtaW5lIHRoaW5nc1xuICAgICAgICAgICAgY29uc3QgZmVlRGF0YSA9IGF3YWl0IHByb3ZpZGVyLmdldEZlZURhdGEoKTtcbiAgICAgICAgICAgIGFzc2VydChmZWVEYXRhLmdhc1ByaWNlICE9IG51bGwsIFwibmV0d29yayBkb2VzIG5vdCBzdXBwb3J0IGdhc1ByaWNlXCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHtcbiAgICAgICAgICAgICAgICBvcGVyYXRpb246IFwiZ2V0R2FzUHJpY2VcIlxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBQb3B1bGF0ZSBtaXNzaW5nIGdhc1ByaWNlXG4gICAgICAgICAgICBpZiAocG9wLmdhc1ByaWNlID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBwb3AuZ2FzUHJpY2UgPSBmZWVEYXRhLmdhc1ByaWNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gV2UgbmVlZCB0byBnZXQgZmVlIGRhdGEgdG8gZGV0ZXJtaW5lIHRoaW5nc1xuICAgICAgICAgICAgY29uc3QgZmVlRGF0YSA9IGF3YWl0IHByb3ZpZGVyLmdldEZlZURhdGEoKTtcbiAgICAgICAgICAgIGlmIChwb3AudHlwZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgLy8gV2UgbmVlZCB0byBhdXRvLWRldGVjdCB0aGUgaW50ZW5kZWQgdHlwZSBvZiB0aGlzIHRyYW5zYWN0aW9uLi4uXG4gICAgICAgICAgICAgICAgaWYgKGZlZURhdGEubWF4RmVlUGVyR2FzICE9IG51bGwgJiYgZmVlRGF0YS5tYXhQcmlvcml0eUZlZVBlckdhcyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZSBuZXR3b3JrIHN1cHBvcnRzIEVJUC0xNTU5IVxuICAgICAgICAgICAgICAgICAgICAvLyBVcGdyYWRlIHRyYW5zYWN0aW9uIGZyb20gbnVsbCB0byBlaXAtMTU1OVxuICAgICAgICAgICAgICAgICAgICBpZiAocG9wLmF1dGhvcml6YXRpb25MaXN0ICYmIHBvcC5hdXRob3JpemF0aW9uTGlzdC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvcC50eXBlID0gNDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvcC50eXBlID0gMjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAocG9wLmdhc1ByaWNlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFVzaW5nIGxlZ2FjeSBnYXNQcmljZSBwcm9wZXJ0eSBvbiBhbiBlaXAtMTU1OSBuZXR3b3JrLFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc28gdXNlIGdhc1ByaWNlIGFzIGJvdGggZmVlIHByb3BlcnRpZXNcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGdhc1ByaWNlID0gcG9wLmdhc1ByaWNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHBvcC5nYXNQcmljZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvcC5tYXhGZWVQZXJHYXMgPSBnYXNQcmljZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvcC5tYXhQcmlvcml0eUZlZVBlckdhcyA9IGdhc1ByaWNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUG9wdWxhdGUgbWlzc2luZyBmZWUgZGF0YVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBvcC5tYXhGZWVQZXJHYXMgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvcC5tYXhGZWVQZXJHYXMgPSBmZWVEYXRhLm1heEZlZVBlckdhcztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwb3AubWF4UHJpb3JpdHlGZWVQZXJHYXMgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvcC5tYXhQcmlvcml0eUZlZVBlckdhcyA9IGZlZURhdGEubWF4UHJpb3JpdHlGZWVQZXJHYXM7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoZmVlRGF0YS5nYXNQcmljZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE5ldHdvcmsgZG9lc24ndCBzdXBwb3J0IEVJUC0xNTU5Li4uXG4gICAgICAgICAgICAgICAgICAgIC8vIC4uLmJ1dCB0aGV5IGFyZSB0cnlpbmcgdG8gdXNlIEVJUC0xNTU5IHByb3BlcnRpZXNcbiAgICAgICAgICAgICAgICAgICAgYXNzZXJ0KCFoYXNFaXAxNTU5LCBcIm5ldHdvcmsgZG9lcyBub3Qgc3VwcG9ydCBFSVAtMTU1OVwiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcGVyYXRpb246IFwicG9wdWxhdGVUcmFuc2FjdGlvblwiXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAvLyBQb3B1bGF0ZSBtaXNzaW5nIGZlZSBkYXRhXG4gICAgICAgICAgICAgICAgICAgIGlmIChwb3AuZ2FzUHJpY2UgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9wLmdhc1ByaWNlID0gZmVlRGF0YS5nYXNQcmljZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBFeHBsaWNpdGx5IHNldCB1bnR5cGVkIHRyYW5zYWN0aW9uIHRvIGxlZ2FjeVxuICAgICAgICAgICAgICAgICAgICAvLyBAVE9ETzogTWF5YmUgdGhpcyBzaG9sZCBhbGxvdyB0eXBlIDE/XG4gICAgICAgICAgICAgICAgICAgIHBvcC50eXBlID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGdldEZlZURhdGEgaGFzIGZhaWxlZCB1cy5cbiAgICAgICAgICAgICAgICAgICAgYXNzZXJ0KGZhbHNlLCBcImZhaWxlZCB0byBnZXQgY29uc2lzdGVudCBmZWUgZGF0YVwiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcGVyYXRpb246IFwic2lnbmVyLmdldEZlZURhdGFcIlxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChwb3AudHlwZSA9PT0gMiB8fCBwb3AudHlwZSA9PT0gMyB8fCBwb3AudHlwZSA9PT0gNCkge1xuICAgICAgICAgICAgICAgIC8vIEV4cGxpY2l0bHkgdXNpbmcgRUlQLTE1NTkgb3IgRUlQLTQ4NDRcbiAgICAgICAgICAgICAgICAvLyBQb3B1bGF0ZSBtaXNzaW5nIGZlZSBkYXRhXG4gICAgICAgICAgICAgICAgaWYgKHBvcC5tYXhGZWVQZXJHYXMgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBwb3AubWF4RmVlUGVyR2FzID0gZmVlRGF0YS5tYXhGZWVQZXJHYXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChwb3AubWF4UHJpb3JpdHlGZWVQZXJHYXMgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBwb3AubWF4UHJpb3JpdHlGZWVQZXJHYXMgPSBmZWVEYXRhLm1heFByaW9yaXR5RmVlUGVyR2FzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvL0BUT09EOiBEb24ndCBhd2FpdCBhbGwgb3ZlciB0aGUgcGxhY2U7IHNhdmUgdGhlbSB1cCBmb3JcbiAgICAgICAgLy8gdGhlIGVuZCBmb3IgYmV0dGVyIGJhdGNoaW5nXG4gICAgICAgIHJldHVybiBhd2FpdCByZXNvbHZlUHJvcGVydGllcyhwb3ApO1xuICAgIH1cbiAgICBhc3luYyBwb3B1bGF0ZUF1dGhvcml6YXRpb24oX2F1dGgpIHtcbiAgICAgICAgY29uc3QgYXV0aCA9IE9iamVjdC5hc3NpZ24oe30sIF9hdXRoKTtcbiAgICAgICAgLy8gQWRkIGEgY2hhaW4gSUQgaWYgbm90IGV4cGxpY2l0bHkgc2V0IHRvIDBcbiAgICAgICAgaWYgKGF1dGguY2hhaW5JZCA9PSBudWxsKSB7XG4gICAgICAgICAgICBhdXRoLmNoYWluSWQgPSAoYXdhaXQgY2hlY2tQcm92aWRlcih0aGlzLCBcImdldE5ldHdvcmtcIikuZ2V0TmV0d29yaygpKS5jaGFpbklkO1xuICAgICAgICB9XG4gICAgICAgIC8vIEBUT0RPOiBUYWtlIGNoYWluIElEIGludG8gYWNjb3VudCB3aGVuIHBvcHVsYXRpbmcgbm9jZT9cbiAgICAgICAgaWYgKGF1dGgubm9uY2UgPT0gbnVsbCkge1xuICAgICAgICAgICAgYXV0aC5ub25jZSA9IGF3YWl0IHRoaXMuZ2V0Tm9uY2UoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXV0aDtcbiAgICB9XG4gICAgYXN5bmMgZXN0aW1hdGVHYXModHgpIHtcbiAgICAgICAgcmV0dXJuIGNoZWNrUHJvdmlkZXIodGhpcywgXCJlc3RpbWF0ZUdhc1wiKS5lc3RpbWF0ZUdhcyhhd2FpdCB0aGlzLnBvcHVsYXRlQ2FsbCh0eCkpO1xuICAgIH1cbiAgICBhc3luYyBjYWxsKHR4KSB7XG4gICAgICAgIHJldHVybiBjaGVja1Byb3ZpZGVyKHRoaXMsIFwiY2FsbFwiKS5jYWxsKGF3YWl0IHRoaXMucG9wdWxhdGVDYWxsKHR4KSk7XG4gICAgfVxuICAgIGFzeW5jIHJlc29sdmVOYW1lKG5hbWUpIHtcbiAgICAgICAgY29uc3QgcHJvdmlkZXIgPSBjaGVja1Byb3ZpZGVyKHRoaXMsIFwicmVzb2x2ZU5hbWVcIik7XG4gICAgICAgIHJldHVybiBhd2FpdCBwcm92aWRlci5yZXNvbHZlTmFtZShuYW1lKTtcbiAgICB9XG4gICAgYXN5bmMgc2VuZFRyYW5zYWN0aW9uKHR4KSB7XG4gICAgICAgIGNvbnN0IHByb3ZpZGVyID0gY2hlY2tQcm92aWRlcih0aGlzLCBcInNlbmRUcmFuc2FjdGlvblwiKTtcbiAgICAgICAgY29uc3QgcG9wID0gYXdhaXQgdGhpcy5wb3B1bGF0ZVRyYW5zYWN0aW9uKHR4KTtcbiAgICAgICAgZGVsZXRlIHBvcC5mcm9tO1xuICAgICAgICBjb25zdCB0eE9iaiA9IFRyYW5zYWN0aW9uLmZyb20ocG9wKTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHByb3ZpZGVyLmJyb2FkY2FzdFRyYW5zYWN0aW9uKGF3YWl0IHRoaXMuc2lnblRyYW5zYWN0aW9uKHR4T2JqKSk7XG4gICAgfVxuICAgIC8vIEBUT0RPOiBpbiB2NyBtb3ZlIHRoaXMgdG8gYmUgYWJzdHJhY3RcbiAgICBhdXRob3JpemUoYXV0aG9yaXphdGlvbikge1xuICAgICAgICBhc3NlcnQoZmFsc2UsIFwiYXV0aG9yaXphdGlvbiBub3QgaW1wbGVtZW50ZWQgZm9yIHRoaXMgc2lnbmVyXCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHsgb3BlcmF0aW9uOiBcImF1dGhvcml6ZVwiIH0pO1xuICAgIH1cbn1cbi8qKlxuICogIEEgKipWb2lkU2lnbmVyKiogaXMgYSBjbGFzcyBkZWlzZ25lZCB0byBhbGxvdyBhbiBhZGRyZXNzIHRvIGJlIHVzZWRcbiAqICBpbiBhbnkgQVBJIHdoaWNoIGFjY2VwdHMgYSBTaWduZXIsIGJ1dCBmb3Igd2hpY2ggdGhlcmUgYXJlIG5vXG4gKiAgY3JlZGVudGlhbHMgYXZhaWxhYmxlIHRvIHBlcmZvcm0gYW55IGFjdHVhbCBzaWduaW5nLlxuICpcbiAqICBUaGlzIGZvciBleGFtcGxlIGFsbG93IGltcGVyc29uYXRpbmcgYW4gYWNjb3VudCBmb3IgdGhlIHB1cnBvc2Ugb2ZcbiAqICBzdGF0aWMgY2FsbHMgb3IgZXN0aW1hdGluZyBnYXMsIGJ1dCBkb2VzIG5vdCBhbGxvdyBzZW5kaW5nIHRyYW5zYWN0aW9ucy5cbiAqL1xuZXhwb3J0IGNsYXNzIFZvaWRTaWduZXIgZXh0ZW5kcyBBYnN0cmFjdFNpZ25lciB7XG4gICAgLyoqXG4gICAgICogIFRoZSBzaWduZXIgYWRkcmVzcy5cbiAgICAgKi9cbiAgICBhZGRyZXNzO1xuICAgIC8qKlxuICAgICAqICBDcmVhdGVzIGEgbmV3ICoqVm9pZFNpZ25lcioqIHdpdGggJSVhZGRyZXNzJSUgYXR0YWNoZWQgdG9cbiAgICAgKiAgJSVwcm92aWRlciUlLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGFkZHJlc3MsIHByb3ZpZGVyKSB7XG4gICAgICAgIHN1cGVyKHByb3ZpZGVyKTtcbiAgICAgICAgZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7IGFkZHJlc3MgfSk7XG4gICAgfVxuICAgIGFzeW5jIGdldEFkZHJlc3MoKSB7IHJldHVybiB0aGlzLmFkZHJlc3M7IH1cbiAgICBjb25uZWN0KHByb3ZpZGVyKSB7XG4gICAgICAgIHJldHVybiBuZXcgVm9pZFNpZ25lcih0aGlzLmFkZHJlc3MsIHByb3ZpZGVyKTtcbiAgICB9XG4gICAgI3Rocm93VW5zdXBwb3J0ZWQoc3VmZml4LCBvcGVyYXRpb24pIHtcbiAgICAgICAgYXNzZXJ0KGZhbHNlLCBgVm9pZFNpZ25lciBjYW5ub3Qgc2lnbiAke3N1ZmZpeH1gLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7IG9wZXJhdGlvbiB9KTtcbiAgICB9XG4gICAgYXN5bmMgc2lnblRyYW5zYWN0aW9uKHR4KSB7XG4gICAgICAgIHRoaXMuI3Rocm93VW5zdXBwb3J0ZWQoXCJ0cmFuc2FjdGlvbnNcIiwgXCJzaWduVHJhbnNhY3Rpb25cIik7XG4gICAgfVxuICAgIGFzeW5jIHNpZ25NZXNzYWdlKG1lc3NhZ2UpIHtcbiAgICAgICAgdGhpcy4jdGhyb3dVbnN1cHBvcnRlZChcIm1lc3NhZ2VzXCIsIFwic2lnbk1lc3NhZ2VcIik7XG4gICAgfVxuICAgIGFzeW5jIHNpZ25UeXBlZERhdGEoZG9tYWluLCB0eXBlcywgdmFsdWUpIHtcbiAgICAgICAgdGhpcy4jdGhyb3dVbnN1cHBvcnRlZChcInR5cGVkLWRhdGFcIiwgXCJzaWduVHlwZWREYXRhXCIpO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFic3RyYWN0LXNpZ25lci5qcy5tYXAiXSwibmFtZXMiOlsicmVzb2x2ZUFkZHJlc3MiLCJUcmFuc2FjdGlvbiIsImRlZmluZVByb3BlcnRpZXMiLCJnZXRCaWdJbnQiLCJyZXNvbHZlUHJvcGVydGllcyIsImFzc2VydCIsImFzc2VydEFyZ3VtZW50IiwiY29weVJlcXVlc3QiLCJjaGVja1Byb3ZpZGVyIiwic2lnbmVyIiwib3BlcmF0aW9uIiwicHJvdmlkZXIiLCJwb3B1bGF0ZSIsInR4IiwicG9wIiwidG8iLCJmcm9tIiwiUHJvbWlzZSIsImFsbCIsImdldEFkZHJlc3MiLCJ0aGVuIiwiYWRkcmVzcyIsInRvTG93ZXJDYXNlIiwiQWJzdHJhY3RTaWduZXIiLCJjb25zdHJ1Y3RvciIsImdldE5vbmNlIiwiYmxvY2tUYWciLCJnZXRUcmFuc2FjdGlvbkNvdW50IiwicG9wdWxhdGVDYWxsIiwicG9wdWxhdGVUcmFuc2FjdGlvbiIsIm5vbmNlIiwiZ2FzTGltaXQiLCJlc3RpbWF0ZUdhcyIsIm5ldHdvcmsiLCJnZXROZXR3b3JrIiwiY2hhaW5JZCIsImhhc0VpcDE1NTkiLCJtYXhGZWVQZXJHYXMiLCJtYXhQcmlvcml0eUZlZVBlckdhcyIsImdhc1ByaWNlIiwidHlwZSIsImZlZURhdGEiLCJnZXRGZWVEYXRhIiwiYXV0aG9yaXphdGlvbkxpc3QiLCJsZW5ndGgiLCJwb3B1bGF0ZUF1dGhvcml6YXRpb24iLCJfYXV0aCIsImF1dGgiLCJPYmplY3QiLCJhc3NpZ24iLCJjYWxsIiwicmVzb2x2ZU5hbWUiLCJuYW1lIiwic2VuZFRyYW5zYWN0aW9uIiwidHhPYmoiLCJicm9hZGNhc3RUcmFuc2FjdGlvbiIsInNpZ25UcmFuc2FjdGlvbiIsImF1dGhvcml6ZSIsImF1dGhvcml6YXRpb24iLCJWb2lkU2lnbmVyIiwiY29ubmVjdCIsInRocm93VW5zdXBwb3J0ZWQiLCJzdWZmaXgiLCJzaWduTWVzc2FnZSIsIm1lc3NhZ2UiLCJzaWduVHlwZWREYXRhIiwiZG9tYWluIiwidHlwZXMiLCJ2YWx1ZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.esm/providers/abstract-signer.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.esm/providers/ens-resolver.js":
/*!***************************************************************!*\
  !*** ./node_modules/ethers/lib.esm/providers/ens-resolver.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BasicMulticoinProviderPlugin: () => (/* binding */ BasicMulticoinProviderPlugin),\n/* harmony export */   EnsResolver: () => (/* binding */ EnsResolver),\n/* harmony export */   MulticoinProviderPlugin: () => (/* binding */ MulticoinProviderPlugin)\n/* harmony export */ });\n/* harmony import */ var _address_index_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../address/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/address/address.js\");\n/* harmony import */ var _constants_index_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../constants/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/constants/addresses.js\");\n/* harmony import */ var _contract_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../contract/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/contract/contract.js\");\n/* harmony import */ var _hash_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../hash/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/hash/namehash.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/errors.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/properties.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/data.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/base58.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/maths.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/fetch.js\");\n/**\n *  ENS is a service which allows easy-to-remember names to map to\n *  network addresses.\n *\n *  @_section: api/providers/ens-resolver:ENS Resolver  [about-ens-rsolver]\n */ \n\n\n\n\n// @TODO: This should use the fetch-data:ipfs gateway\n// Trim off the ipfs:// prefix and return the default gateway URL\nfunction getIpfsLink(link) {\n    if (link.match(/^ipfs:\\/\\/ipfs\\//i)) {\n        link = link.substring(12);\n    } else if (link.match(/^ipfs:\\/\\//i)) {\n        link = link.substring(7);\n    } else {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(false, \"unsupported IPFS format\", \"link\", link);\n    }\n    return `https:/\\/gateway.ipfs.io/ipfs/${link}`;\n}\n;\n;\n/**\n *  A provider plugin super-class for processing multicoin address types.\n */ class MulticoinProviderPlugin {\n    /**\n     *  Creates a new **MulticoinProviderPluing** for %%name%%.\n     */ constructor(name){\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.defineProperties)(this, {\n            name\n        });\n    }\n    connect(proivder) {\n        return this;\n    }\n    /**\n     *  Returns ``true`` if %%coinType%% is supported by this plugin.\n     */ supportsCoinType(coinType) {\n        return false;\n    }\n    /**\n     *  Resolves to the encoded %%address%% for %%coinType%%.\n     */ async encodeAddress(coinType, address) {\n        throw new Error(\"unsupported coin\");\n    }\n    /**\n     *  Resolves to the decoded %%data%% for %%coinType%%.\n     */ async decodeAddress(coinType, data) {\n        throw new Error(\"unsupported coin\");\n    }\n}\nconst BasicMulticoinPluginId = \"org.ethers.plugins.provider.BasicMulticoin\";\n/**\n *  A **BasicMulticoinProviderPlugin** provides service for common\n *  coin types, which do not require additional libraries to encode or\n *  decode.\n */ class BasicMulticoinProviderPlugin extends MulticoinProviderPlugin {\n    /**\n     *  Creates a new **BasicMulticoinProviderPlugin**.\n     */ constructor(){\n        super(BasicMulticoinPluginId);\n    }\n}\nconst matcherIpfs = new RegExp(\"^(ipfs)://(.*)$\", \"i\");\nconst matchers = [\n    new RegExp(\"^(https)://(.*)$\", \"i\"),\n    new RegExp(\"^(data):(.*)$\", \"i\"),\n    matcherIpfs,\n    new RegExp(\"^eip155:[0-9]+/(erc[0-9]+):(.*)$\", \"i\")\n];\n/**\n *  A connected object to a resolved ENS name resolver, which can be\n *  used to query additional details.\n */ class EnsResolver {\n    // For EIP-2544 names, the ancestor that provided the resolver\n    #supports2544;\n    #resolver;\n    constructor(provider, address, name){\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.defineProperties)(this, {\n            provider,\n            address,\n            name\n        });\n        this.#supports2544 = null;\n        this.#resolver = new _contract_index_js__WEBPACK_IMPORTED_MODULE_2__.Contract(address, [\n            \"function supportsInterface(bytes4) view returns (bool)\",\n            \"function resolve(bytes, bytes) view returns (bytes)\",\n            \"function addr(bytes32) view returns (address)\",\n            \"function addr(bytes32, uint) view returns (bytes)\",\n            \"function text(bytes32, string) view returns (string)\",\n            \"function contenthash(bytes32) view returns (bytes)\"\n        ], provider);\n    }\n    /**\n     *  Resolves to true if the resolver supports wildcard resolution.\n     */ async supportsWildcard() {\n        if (this.#supports2544 == null) {\n            this.#supports2544 = (async ()=>{\n                try {\n                    return await this.#resolver.supportsInterface(\"0x9061b923\");\n                } catch (error) {\n                    // Wildcard resolvers must understand supportsInterface\n                    // and return true.\n                    if ((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.isError)(error, \"CALL_EXCEPTION\")) {\n                        return false;\n                    }\n                    // Let future attempts try again...\n                    this.#supports2544 = null;\n                    throw error;\n                }\n            })();\n        }\n        return await this.#supports2544;\n    }\n    async #fetch(funcName, params) {\n        params = (params || []).slice();\n        const iface = this.#resolver.interface;\n        // The first parameters is always the nodehash\n        params.unshift((0,_hash_index_js__WEBPACK_IMPORTED_MODULE_3__.namehash)(this.name));\n        let fragment = null;\n        if (await this.supportsWildcard()) {\n            fragment = iface.getFunction(funcName);\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assert)(fragment, \"missing fragment\", \"UNKNOWN_ERROR\", {\n                info: {\n                    funcName\n                }\n            });\n            params = [\n                (0,_hash_index_js__WEBPACK_IMPORTED_MODULE_3__.dnsEncode)(this.name, 255),\n                iface.encodeFunctionData(fragment, params)\n            ];\n            funcName = \"resolve(bytes,bytes)\";\n        }\n        params.push({\n            enableCcipRead: true\n        });\n        try {\n            const result = await this.#resolver[funcName](...params);\n            if (fragment) {\n                return iface.decodeFunctionResult(fragment, result)[0];\n            }\n            return result;\n        } catch (error) {\n            if (!(0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.isError)(error, \"CALL_EXCEPTION\")) {\n                throw error;\n            }\n        }\n        return null;\n    }\n    /**\n     *  Resolves to the address for %%coinType%% or null if the\n     *  provided %%coinType%% has not been configured.\n     */ async getAddress(coinType) {\n        if (coinType == null) {\n            coinType = 60;\n        }\n        if (coinType === 60) {\n            try {\n                const result = await this.#fetch(\"addr(bytes32)\");\n                // No address\n                if (result == null || result === _constants_index_js__WEBPACK_IMPORTED_MODULE_4__.ZeroAddress) {\n                    return null;\n                }\n                return result;\n            } catch (error) {\n                if ((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.isError)(error, \"CALL_EXCEPTION\")) {\n                    return null;\n                }\n                throw error;\n            }\n        }\n        // Try decoding its EVM canonical chain as an EVM chain address first\n        if (coinType >= 0 && coinType < 0x80000000) {\n            let ethCoinType = coinType + 0x80000000;\n            const data = await this.#fetch(\"addr(bytes32,uint)\", [\n                ethCoinType\n            ]);\n            if ((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.isHexString)(data, 20)) {\n                return (0,_address_index_js__WEBPACK_IMPORTED_MODULE_6__.getAddress)(data);\n            }\n        }\n        let coinPlugin = null;\n        for (const plugin of this.provider.plugins){\n            if (!(plugin instanceof MulticoinProviderPlugin)) {\n                continue;\n            }\n            if (plugin.supportsCoinType(coinType)) {\n                coinPlugin = plugin;\n                break;\n            }\n        }\n        if (coinPlugin == null) {\n            return null;\n        }\n        // keccak256(\"addr(bytes32,uint256\")\n        const data = await this.#fetch(\"addr(bytes32,uint)\", [\n            coinType\n        ]);\n        // No address\n        if (data == null || data === \"0x\") {\n            return null;\n        }\n        // Compute the address\n        const address = await coinPlugin.decodeAddress(coinType, data);\n        if (address != null) {\n            return address;\n        }\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assert)(false, `invalid coin data`, \"UNSUPPORTED_OPERATION\", {\n            operation: `getAddress(${coinType})`,\n            info: {\n                coinType,\n                data\n            }\n        });\n    }\n    /**\n     *  Resolves to the EIP-634 text record for %%key%%, or ``null``\n     *  if unconfigured.\n     */ async getText(key) {\n        const data = await this.#fetch(\"text(bytes32,string)\", [\n            key\n        ]);\n        if (data == null || data === \"0x\") {\n            return null;\n        }\n        return data;\n    }\n    /**\n     *  Rsolves to the content-hash or ``null`` if unconfigured.\n     */ async getContentHash() {\n        // keccak256(\"contenthash()\")\n        const data = await this.#fetch(\"contenthash(bytes32)\");\n        // No contenthash\n        if (data == null || data === \"0x\") {\n            return null;\n        }\n        // IPFS (CID: 1, Type: 70=DAG-PB, 72=libp2p-key)\n        const ipfs = data.match(/^0x(e3010170|e5010172)(([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])([0-9a-f]*))$/);\n        if (ipfs) {\n            const scheme = ipfs[1] === \"e3010170\" ? \"ipfs\" : \"ipns\";\n            const length = parseInt(ipfs[4], 16);\n            if (ipfs[5].length === length * 2) {\n                return `${scheme}:/\\/${(0,_utils_index_js__WEBPACK_IMPORTED_MODULE_7__.encodeBase58)(\"0x\" + ipfs[2])}`;\n            }\n        }\n        // Swarm (CID: 1, Type: swarm-manifest; hash/length hard-coded to keccak256/32)\n        const swarm = data.match(/^0xe40101fa011b20([0-9a-f]*)$/);\n        if (swarm && swarm[1].length === 64) {\n            return `bzz:/\\/${swarm[1]}`;\n        }\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assert)(false, `invalid or unsupported content hash data`, \"UNSUPPORTED_OPERATION\", {\n            operation: \"getContentHash()\",\n            info: {\n                data\n            }\n        });\n    }\n    /**\n     *  Resolves to the avatar url or ``null`` if the avatar is either\n     *  unconfigured or incorrectly configured (e.g. references an NFT\n     *  not owned by the address).\n     *\n     *  If diagnosing issues with configurations, the [[_getAvatar]]\n     *  method may be useful.\n     */ async getAvatar() {\n        const avatar = await this._getAvatar();\n        return avatar.url;\n    }\n    /**\n     *  When resolving an avatar, there are many steps involved, such\n     *  fetching metadata and possibly validating ownership of an\n     *  NFT.\n     *\n     *  This method can be used to examine each step and the value it\n     *  was working from.\n     */ async _getAvatar() {\n        const linkage = [\n            {\n                type: \"name\",\n                value: this.name\n            }\n        ];\n        try {\n            // test data for ricmoo.eth\n            //const avatar = \"eip155:1/erc721:0x265385c7f4132228A0d54EB1A9e7460b91c0cC68/29233\";\n            const avatar = await this.getText(\"avatar\");\n            if (avatar == null) {\n                linkage.push({\n                    type: \"!avatar\",\n                    value: \"\"\n                });\n                return {\n                    url: null,\n                    linkage\n                };\n            }\n            linkage.push({\n                type: \"avatar\",\n                value: avatar\n            });\n            for(let i = 0; i < matchers.length; i++){\n                const match = avatar.match(matchers[i]);\n                if (match == null) {\n                    continue;\n                }\n                const scheme = match[1].toLowerCase();\n                switch(scheme){\n                    case \"https\":\n                    case \"data\":\n                        linkage.push({\n                            type: \"url\",\n                            value: avatar\n                        });\n                        return {\n                            linkage,\n                            url: avatar\n                        };\n                    case \"ipfs\":\n                        {\n                            const url = getIpfsLink(avatar);\n                            linkage.push({\n                                type: \"ipfs\",\n                                value: avatar\n                            });\n                            linkage.push({\n                                type: \"url\",\n                                value: url\n                            });\n                            return {\n                                linkage,\n                                url\n                            };\n                        }\n                    case \"erc721\":\n                    case \"erc1155\":\n                        {\n                            // Depending on the ERC type, use tokenURI(uint256) or url(uint256)\n                            const selector = scheme === \"erc721\" ? \"tokenURI(uint256)\" : \"uri(uint256)\";\n                            linkage.push({\n                                type: scheme,\n                                value: avatar\n                            });\n                            // The owner of this name\n                            const owner = await this.getAddress();\n                            if (owner == null) {\n                                linkage.push({\n                                    type: \"!owner\",\n                                    value: \"\"\n                                });\n                                return {\n                                    url: null,\n                                    linkage\n                                };\n                            }\n                            const comps = (match[2] || \"\").split(\"/\");\n                            if (comps.length !== 2) {\n                                linkage.push({\n                                    type: `!${scheme}caip`,\n                                    value: match[2] || \"\"\n                                });\n                                return {\n                                    url: null,\n                                    linkage\n                                };\n                            }\n                            const tokenId = comps[1];\n                            const contract = new _contract_index_js__WEBPACK_IMPORTED_MODULE_2__.Contract(comps[0], [\n                                // ERC-721\n                                \"function tokenURI(uint) view returns (string)\",\n                                \"function ownerOf(uint) view returns (address)\",\n                                // ERC-1155\n                                \"function uri(uint) view returns (string)\",\n                                \"function balanceOf(address, uint256) view returns (uint)\"\n                            ], this.provider);\n                            // Check that this account owns the token\n                            if (scheme === \"erc721\") {\n                                const tokenOwner = await contract.ownerOf(tokenId);\n                                if (owner !== tokenOwner) {\n                                    linkage.push({\n                                        type: \"!owner\",\n                                        value: tokenOwner\n                                    });\n                                    return {\n                                        url: null,\n                                        linkage\n                                    };\n                                }\n                                linkage.push({\n                                    type: \"owner\",\n                                    value: tokenOwner\n                                });\n                            } else if (scheme === \"erc1155\") {\n                                const balance = await contract.balanceOf(owner, tokenId);\n                                if (!balance) {\n                                    linkage.push({\n                                        type: \"!balance\",\n                                        value: \"0\"\n                                    });\n                                    return {\n                                        url: null,\n                                        linkage\n                                    };\n                                }\n                                linkage.push({\n                                    type: \"balance\",\n                                    value: balance.toString()\n                                });\n                            }\n                            // Call the token contract for the metadata URL\n                            let metadataUrl = await contract[selector](tokenId);\n                            if (metadataUrl == null || metadataUrl === \"0x\") {\n                                linkage.push({\n                                    type: \"!metadata-url\",\n                                    value: \"\"\n                                });\n                                return {\n                                    url: null,\n                                    linkage\n                                };\n                            }\n                            linkage.push({\n                                type: \"metadata-url-base\",\n                                value: metadataUrl\n                            });\n                            // ERC-1155 allows a generic {id} in the URL\n                            if (scheme === \"erc1155\") {\n                                metadataUrl = metadataUrl.replace(\"{id}\", (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_8__.toBeHex)(tokenId, 32).substring(2));\n                                linkage.push({\n                                    type: \"metadata-url-expanded\",\n                                    value: metadataUrl\n                                });\n                            }\n                            // Transform IPFS metadata links\n                            if (metadataUrl.match(/^ipfs:/i)) {\n                                metadataUrl = getIpfsLink(metadataUrl);\n                            }\n                            linkage.push({\n                                type: \"metadata-url\",\n                                value: metadataUrl\n                            });\n                            // Get the token metadata\n                            let metadata = {};\n                            const response = await new _utils_index_js__WEBPACK_IMPORTED_MODULE_9__.FetchRequest(metadataUrl).send();\n                            response.assertOk();\n                            try {\n                                metadata = response.bodyJson;\n                            } catch (error) {\n                                try {\n                                    linkage.push({\n                                        type: \"!metadata\",\n                                        value: response.bodyText\n                                    });\n                                } catch (error) {\n                                    const bytes = response.body;\n                                    if (bytes) {\n                                        linkage.push({\n                                            type: \"!metadata\",\n                                            value: (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.hexlify)(bytes)\n                                        });\n                                    }\n                                    return {\n                                        url: null,\n                                        linkage\n                                    };\n                                }\n                                return {\n                                    url: null,\n                                    linkage\n                                };\n                            }\n                            if (!metadata) {\n                                linkage.push({\n                                    type: \"!metadata\",\n                                    value: \"\"\n                                });\n                                return {\n                                    url: null,\n                                    linkage\n                                };\n                            }\n                            linkage.push({\n                                type: \"metadata\",\n                                value: JSON.stringify(metadata)\n                            });\n                            // Pull the image URL out\n                            let imageUrl = metadata.image;\n                            if (typeof imageUrl !== \"string\") {\n                                linkage.push({\n                                    type: \"!imageUrl\",\n                                    value: \"\"\n                                });\n                                return {\n                                    url: null,\n                                    linkage\n                                };\n                            }\n                            if (imageUrl.match(/^(https:\\/\\/|data:)/i)) {\n                            // Allow\n                            } else {\n                                // Transform IPFS link to gateway\n                                const ipfs = imageUrl.match(matcherIpfs);\n                                if (ipfs == null) {\n                                    linkage.push({\n                                        type: \"!imageUrl-ipfs\",\n                                        value: imageUrl\n                                    });\n                                    return {\n                                        url: null,\n                                        linkage\n                                    };\n                                }\n                                linkage.push({\n                                    type: \"imageUrl-ipfs\",\n                                    value: imageUrl\n                                });\n                                imageUrl = getIpfsLink(imageUrl);\n                            }\n                            linkage.push({\n                                type: \"url\",\n                                value: imageUrl\n                            });\n                            return {\n                                linkage,\n                                url: imageUrl\n                            };\n                        }\n                }\n            }\n        } catch (error) {}\n        return {\n            linkage,\n            url: null\n        };\n    }\n    static async getEnsAddress(provider) {\n        const network = await provider.getNetwork();\n        const ensPlugin = network.getPlugin(\"org.ethers.plugins.network.Ens\");\n        // No ENS...\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assert)(ensPlugin, \"network does not support ENS\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"getEnsAddress\",\n            info: {\n                network\n            }\n        });\n        return ensPlugin.address;\n    }\n    static async #getResolver(provider, name) {\n        const ensAddr = await EnsResolver.getEnsAddress(provider);\n        try {\n            const contract = new _contract_index_js__WEBPACK_IMPORTED_MODULE_2__.Contract(ensAddr, [\n                \"function resolver(bytes32) view returns (address)\"\n            ], provider);\n            const addr = await contract.resolver((0,_hash_index_js__WEBPACK_IMPORTED_MODULE_3__.namehash)(name), {\n                enableCcipRead: true\n            });\n            if (addr === _constants_index_js__WEBPACK_IMPORTED_MODULE_4__.ZeroAddress) {\n                return null;\n            }\n            return addr;\n        } catch (error) {\n            // ENS registry cannot throw errors on resolver(bytes32),\n            // so probably a link error\n            throw error;\n        }\n        return null;\n    }\n    /**\n     *  Resolve to the ENS resolver for %%name%% using %%provider%% or\n     *  ``null`` if unconfigured.\n     */ static async fromName(provider, name) {\n        let currentName = name;\n        while(true){\n            if (currentName === \"\" || currentName === \".\") {\n                return null;\n            }\n            // Optimization since the eth node cannot change and does\n            // not have a wildcard resolver\n            if (name !== \"eth\" && currentName === \"eth\") {\n                return null;\n            }\n            // Check the current node for a resolver\n            const addr = await EnsResolver.#getResolver(provider, currentName);\n            // Found a resolver!\n            if (addr != null) {\n                const resolver = new EnsResolver(provider, addr, name);\n                // Legacy resolver found, using EIP-2544 so it isn't safe to use\n                if (currentName !== name && !await resolver.supportsWildcard()) {\n                    return null;\n                }\n                return resolver;\n            }\n            // Get the parent node\n            currentName = currentName.split(\".\").slice(1).join(\".\");\n        }\n    }\n} //# sourceMappingURL=ens-resolver.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vcHJvdmlkZXJzL2Vucy1yZXNvbHZlci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7Ozs7O0NBS0MsR0FDZ0Q7QUFDRztBQUNKO0FBQ087QUFDMEY7QUFDakoscURBQXFEO0FBQ3JELGlFQUFpRTtBQUNqRSxTQUFTYyxZQUFZQyxJQUFJO0lBQ3JCLElBQUlBLEtBQUtDLEtBQUssQ0FBQyxzQkFBc0I7UUFDakNELE9BQU9BLEtBQUtFLFNBQVMsQ0FBQztJQUMxQixPQUNLLElBQUlGLEtBQUtDLEtBQUssQ0FBQyxnQkFBZ0I7UUFDaENELE9BQU9BLEtBQUtFLFNBQVMsQ0FBQztJQUMxQixPQUNLO1FBQ0ROLCtEQUFjQSxDQUFDLE9BQU8sMkJBQTJCLFFBQVFJO0lBQzdEO0lBQ0EsT0FBTyxDQUFDLDhCQUE4QixFQUFFQSxLQUFLLENBQUM7QUFDbEQ7OztBQUdBOztDQUVDLEdBQ00sTUFBTUc7SUFLVDs7S0FFQyxHQUNEQyxZQUFZQyxJQUFJLENBQUU7UUFDZFosaUVBQWdCQSxDQUFDLElBQUksRUFBRTtZQUFFWTtRQUFLO0lBQ2xDO0lBQ0FDLFFBQVFDLFFBQVEsRUFBRTtRQUNkLE9BQU8sSUFBSTtJQUNmO0lBQ0E7O0tBRUMsR0FDREMsaUJBQWlCQyxRQUFRLEVBQUU7UUFDdkIsT0FBTztJQUNYO0lBQ0E7O0tBRUMsR0FDRCxNQUFNQyxjQUFjRCxRQUFRLEVBQUVFLE9BQU8sRUFBRTtRQUNuQyxNQUFNLElBQUlDLE1BQU07SUFDcEI7SUFDQTs7S0FFQyxHQUNELE1BQU1DLGNBQWNKLFFBQVEsRUFBRUssSUFBSSxFQUFFO1FBQ2hDLE1BQU0sSUFBSUYsTUFBTTtJQUNwQjtBQUNKO0FBQ0EsTUFBTUcseUJBQXlCO0FBQy9COzs7O0NBSUMsR0FDTSxNQUFNQyxxQ0FBcUNiO0lBQzlDOztLQUVDLEdBQ0RDLGFBQWM7UUFDVixLQUFLLENBQUNXO0lBQ1Y7QUFDSjtBQUNBLE1BQU1FLGNB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QUFHcUUsSUFBSSxDQUFDO1FBQ3ZEO0lBQ0o7QUFDSixFQUNBLHdDQUF3QyIsInNvdXJjZXMiOlsid2VicGFjazovL21lZ2F2aWJlLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL3Byb3ZpZGVycy9lbnMtcmVzb2x2ZXIuanM/NDIzMiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqICBFTlMgaXMgYSBzZXJ2aWNlIHdoaWNoIGFsbG93cyBlYXN5LXRvLXJlbWVtYmVyIG5hbWVzIHRvIG1hcCB0b1xuICogIG5ldHdvcmsgYWRkcmVzc2VzLlxuICpcbiAqICBAX3NlY3Rpb246IGFwaS9wcm92aWRlcnMvZW5zLXJlc29sdmVyOkVOUyBSZXNvbHZlciAgW2Fib3V0LWVucy1yc29sdmVyXVxuICovXG5pbXBvcnQgeyBnZXRBZGRyZXNzIH0gZnJvbSBcIi4uL2FkZHJlc3MvaW5kZXguanNcIjtcbmltcG9ydCB7IFplcm9BZGRyZXNzIH0gZnJvbSBcIi4uL2NvbnN0YW50cy9pbmRleC5qc1wiO1xuaW1wb3J0IHsgQ29udHJhY3QgfSBmcm9tIFwiLi4vY29udHJhY3QvaW5kZXguanNcIjtcbmltcG9ydCB7IGRuc0VuY29kZSwgbmFtZWhhc2ggfSBmcm9tIFwiLi4vaGFzaC9pbmRleC5qc1wiO1xuaW1wb3J0IHsgaGV4bGlmeSwgaXNIZXhTdHJpbmcsIHRvQmVIZXgsIGRlZmluZVByb3BlcnRpZXMsIGVuY29kZUJhc2U1OCwgYXNzZXJ0LCBhc3NlcnRBcmd1bWVudCwgaXNFcnJvciwgRmV0Y2hSZXF1ZXN0IH0gZnJvbSBcIi4uL3V0aWxzL2luZGV4LmpzXCI7XG4vLyBAVE9ETzogVGhpcyBzaG91bGQgdXNlIHRoZSBmZXRjaC1kYXRhOmlwZnMgZ2F0ZXdheVxuLy8gVHJpbSBvZmYgdGhlIGlwZnM6Ly8gcHJlZml4IGFuZCByZXR1cm4gdGhlIGRlZmF1bHQgZ2F0ZXdheSBVUkxcbmZ1bmN0aW9uIGdldElwZnNMaW5rKGxpbmspIHtcbiAgICBpZiAobGluay5tYXRjaCgvXmlwZnM6XFwvXFwvaXBmc1xcLy9pKSkge1xuICAgICAgICBsaW5rID0gbGluay5zdWJzdHJpbmcoMTIpO1xuICAgIH1cbiAgICBlbHNlIGlmIChsaW5rLm1hdGNoKC9eaXBmczpcXC9cXC8vaSkpIHtcbiAgICAgICAgbGluayA9IGxpbmsuc3Vic3RyaW5nKDcpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQoZmFsc2UsIFwidW5zdXBwb3J0ZWQgSVBGUyBmb3JtYXRcIiwgXCJsaW5rXCIsIGxpbmspO1xuICAgIH1cbiAgICByZXR1cm4gYGh0dHBzOi9cXC9nYXRld2F5LmlwZnMuaW8vaXBmcy8ke2xpbmt9YDtcbn1cbjtcbjtcbi8qKlxuICogIEEgcHJvdmlkZXIgcGx1Z2luIHN1cGVyLWNsYXNzIGZvciBwcm9jZXNzaW5nIG11bHRpY29pbiBhZGRyZXNzIHR5cGVzLlxuICovXG5leHBvcnQgY2xhc3MgTXVsdGljb2luUHJvdmlkZXJQbHVnaW4ge1xuICAgIC8qKlxuICAgICAqICBUaGUgbmFtZS5cbiAgICAgKi9cbiAgICBuYW1lO1xuICAgIC8qKlxuICAgICAqICBDcmVhdGVzIGEgbmV3ICoqTXVsdGljb2luUHJvdmlkZXJQbHVpbmcqKiBmb3IgJSVuYW1lJSUuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IobmFtZSkge1xuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHsgbmFtZSB9KTtcbiAgICB9XG4gICAgY29ubmVjdChwcm9pdmRlcikge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYGB0cnVlYGAgaWYgJSVjb2luVHlwZSUlIGlzIHN1cHBvcnRlZCBieSB0aGlzIHBsdWdpbi5cbiAgICAgKi9cbiAgICBzdXBwb3J0c0NvaW5UeXBlKGNvaW5UeXBlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJlc29sdmVzIHRvIHRoZSBlbmNvZGVkICUlYWRkcmVzcyUlIGZvciAlJWNvaW5UeXBlJSUuXG4gICAgICovXG4gICAgYXN5bmMgZW5jb2RlQWRkcmVzcyhjb2luVHlwZSwgYWRkcmVzcykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ1bnN1cHBvcnRlZCBjb2luXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmVzb2x2ZXMgdG8gdGhlIGRlY29kZWQgJSVkYXRhJSUgZm9yICUlY29pblR5cGUlJS5cbiAgICAgKi9cbiAgICBhc3luYyBkZWNvZGVBZGRyZXNzKGNvaW5UeXBlLCBkYXRhKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcInVuc3VwcG9ydGVkIGNvaW5cIik7XG4gICAgfVxufVxuY29uc3QgQmFzaWNNdWx0aWNvaW5QbHVnaW5JZCA9IFwib3JnLmV0aGVycy5wbHVnaW5zLnByb3ZpZGVyLkJhc2ljTXVsdGljb2luXCI7XG4vKipcbiAqICBBICoqQmFzaWNNdWx0aWNvaW5Qcm92aWRlclBsdWdpbioqIHByb3ZpZGVzIHNlcnZpY2UgZm9yIGNvbW1vblxuICogIGNvaW4gdHlwZXMsIHdoaWNoIGRvIG5vdCByZXF1aXJlIGFkZGl0aW9uYWwgbGlicmFyaWVzIHRvIGVuY29kZSBvclxuICogIGRlY29kZS5cbiAqL1xuZXhwb3J0IGNsYXNzIEJhc2ljTXVsdGljb2luUHJvdmlkZXJQbHVnaW4gZXh0ZW5kcyBNdWx0aWNvaW5Qcm92aWRlclBsdWdpbiB7XG4gICAgLyoqXG4gICAgICogIENyZWF0ZXMgYSBuZXcgKipCYXNpY011bHRpY29pblByb3ZpZGVyUGx1Z2luKiouXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKEJhc2ljTXVsdGljb2luUGx1Z2luSWQpO1xuICAgIH1cbn1cbmNvbnN0IG1hdGNoZXJJcGZzID0gbmV3IFJlZ0V4cChcIl4oaXBmcyk6L1xcLyguKikkXCIsIFwiaVwiKTtcbmNvbnN0IG1hdGNoZXJzID0gW1xuICAgIG5ldyBSZWdFeHAoXCJeKGh0dHBzKTovXFwvKC4qKSRcIiwgXCJpXCIpLFxuICAgIG5ldyBSZWdFeHAoXCJeKGRhdGEpOiguKikkXCIsIFwiaVwiKSxcbiAgICBtYXRjaGVySXBmcyxcbiAgICBuZXcgUmVnRXhwKFwiXmVpcDE1NTpbMC05XSsvKGVyY1swLTldKyk6KC4qKSRcIiwgXCJpXCIpLFxuXTtcbi8qKlxuICogIEEgY29ubmVjdGVkIG9iamVjdCB0byBhIHJlc29sdmVkIEVOUyBuYW1lIHJlc29sdmVyLCB3aGljaCBjYW4gYmVcbiAqICB1c2VkIHRvIHF1ZXJ5IGFkZGl0aW9uYWwgZGV0YWlscy5cbiAqL1xuZXhwb3J0IGNsYXNzIEVuc1Jlc29sdmVyIHtcbiAgICAvKipcbiAgICAgKiAgVGhlIGNvbm5lY3RlZCBwcm92aWRlci5cbiAgICAgKi9cbiAgICBwcm92aWRlcjtcbiAgICAvKipcbiAgICAgKiAgVGhlIGFkZHJlc3Mgb2YgdGhlIHJlc29sdmVyLlxuICAgICAqL1xuICAgIGFkZHJlc3M7XG4gICAgLyoqXG4gICAgICogIFRoZSBuYW1lIHRoaXMgcmVzb2x2ZXIgd2FzIHJlc29sdmVkIGFnYWluc3QuXG4gICAgICovXG4gICAgbmFtZTtcbiAgICAvLyBGb3IgRUlQLTI1NDQgbmFtZXMsIHRoZSBhbmNlc3RvciB0aGF0IHByb3ZpZGVkIHRoZSByZXNvbHZlclxuICAgICNzdXBwb3J0czI1NDQ7XG4gICAgI3Jlc29sdmVyO1xuICAgIGNvbnN0cnVjdG9yKHByb3ZpZGVyLCBhZGRyZXNzLCBuYW1lKSB7XG4gICAgICAgIGRlZmluZVByb3BlcnRpZXModGhpcywgeyBwcm92aWRlciwgYWRkcmVzcywgbmFtZSB9KTtcbiAgICAgICAgdGhpcy4jc3VwcG9ydHMyNTQ0ID0gbnVsbDtcbiAgICAgICAgdGhpcy4jcmVzb2x2ZXIgPSBuZXcgQ29udHJhY3QoYWRkcmVzcywgW1xuICAgICAgICAgICAgXCJmdW5jdGlvbiBzdXBwb3J0c0ludGVyZmFjZShieXRlczQpIHZpZXcgcmV0dXJucyAoYm9vbClcIixcbiAgICAgICAgICAgIFwiZnVuY3Rpb24gcmVzb2x2ZShieXRlcywgYnl0ZXMpIHZpZXcgcmV0dXJucyAoYnl0ZXMpXCIsXG4gICAgICAgICAgICBcImZ1bmN0aW9uIGFkZHIoYnl0ZXMzMikgdmlldyByZXR1cm5zIChhZGRyZXNzKVwiLFxuICAgICAgICAgICAgXCJmdW5jdGlvbiBhZGRyKGJ5dGVzMzIsIHVpbnQpIHZpZXcgcmV0dXJucyAoYnl0ZXMpXCIsXG4gICAgICAgICAgICBcImZ1bmN0aW9uIHRleHQoYnl0ZXMzMiwgc3RyaW5nKSB2aWV3IHJldHVybnMgKHN0cmluZylcIixcbiAgICAgICAgICAgIFwiZnVuY3Rpb24gY29udGVudGhhc2goYnl0ZXMzMikgdmlldyByZXR1cm5zIChieXRlcylcIixcbiAgICAgICAgXSwgcHJvdmlkZXIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmVzb2x2ZXMgdG8gdHJ1ZSBpZiB0aGUgcmVzb2x2ZXIgc3VwcG9ydHMgd2lsZGNhcmQgcmVzb2x1dGlvbi5cbiAgICAgKi9cbiAgICBhc3luYyBzdXBwb3J0c1dpbGRjYXJkKCkge1xuICAgICAgICBpZiAodGhpcy4jc3VwcG9ydHMyNTQ0ID09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuI3N1cHBvcnRzMjU0NCA9IChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuI3Jlc29sdmVyLnN1cHBvcnRzSW50ZXJmYWNlKFwiMHg5MDYxYjkyM1wiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFdpbGRjYXJkIHJlc29sdmVycyBtdXN0IHVuZGVyc3RhbmQgc3VwcG9ydHNJbnRlcmZhY2VcbiAgICAgICAgICAgICAgICAgICAgLy8gYW5kIHJldHVybiB0cnVlLlxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNFcnJvcihlcnJvciwgXCJDQUxMX0VYQ0VQVElPTlwiKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIExldCBmdXR1cmUgYXR0ZW1wdHMgdHJ5IGFnYWluLi4uXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuI3N1cHBvcnRzMjU0NCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuI3N1cHBvcnRzMjU0NDtcbiAgICB9XG4gICAgYXN5bmMgI2ZldGNoKGZ1bmNOYW1lLCBwYXJhbXMpIHtcbiAgICAgICAgcGFyYW1zID0gKHBhcmFtcyB8fCBbXSkuc2xpY2UoKTtcbiAgICAgICAgY29uc3QgaWZhY2UgPSB0aGlzLiNyZXNvbHZlci5pbnRlcmZhY2U7XG4gICAgICAgIC8vIFRoZSBmaXJzdCBwYXJhbWV0ZXJzIGlzIGFsd2F5cyB0aGUgbm9kZWhhc2hcbiAgICAgICAgcGFyYW1zLnVuc2hpZnQobmFtZWhhc2godGhpcy5uYW1lKSk7XG4gICAgICAgIGxldCBmcmFnbWVudCA9IG51bGw7XG4gICAgICAgIGlmIChhd2FpdCB0aGlzLnN1cHBvcnRzV2lsZGNhcmQoKSkge1xuICAgICAgICAgICAgZnJhZ21lbnQgPSBpZmFjZS5nZXRGdW5jdGlvbihmdW5jTmFtZSk7XG4gICAgICAgICAgICBhc3NlcnQoZnJhZ21lbnQsIFwibWlzc2luZyBmcmFnbWVudFwiLCBcIlVOS05PV05fRVJST1JcIiwge1xuICAgICAgICAgICAgICAgIGluZm86IHsgZnVuY05hbWUgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBwYXJhbXMgPSBbXG4gICAgICAgICAgICAgICAgZG5zRW5jb2RlKHRoaXMubmFtZSwgMjU1KSxcbiAgICAgICAgICAgICAgICBpZmFjZS5lbmNvZGVGdW5jdGlvbkRhdGEoZnJhZ21lbnQsIHBhcmFtcylcbiAgICAgICAgICAgIF07XG4gICAgICAgICAgICBmdW5jTmFtZSA9IFwicmVzb2x2ZShieXRlcyxieXRlcylcIjtcbiAgICAgICAgfVxuICAgICAgICBwYXJhbXMucHVzaCh7XG4gICAgICAgICAgICBlbmFibGVDY2lwUmVhZDogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuI3Jlc29sdmVyW2Z1bmNOYW1lXSguLi5wYXJhbXMpO1xuICAgICAgICAgICAgaWYgKGZyYWdtZW50KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlmYWNlLmRlY29kZUZ1bmN0aW9uUmVzdWx0KGZyYWdtZW50LCByZXN1bHQpWzBdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmICghaXNFcnJvcihlcnJvciwgXCJDQUxMX0VYQ0VQVElPTlwiKSkge1xuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmVzb2x2ZXMgdG8gdGhlIGFkZHJlc3MgZm9yICUlY29pblR5cGUlJSBvciBudWxsIGlmIHRoZVxuICAgICAqICBwcm92aWRlZCAlJWNvaW5UeXBlJSUgaGFzIG5vdCBiZWVuIGNvbmZpZ3VyZWQuXG4gICAgICovXG4gICAgYXN5bmMgZ2V0QWRkcmVzcyhjb2luVHlwZSkge1xuICAgICAgICBpZiAoY29pblR5cGUgPT0gbnVsbCkge1xuICAgICAgICAgICAgY29pblR5cGUgPSA2MDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29pblR5cGUgPT09IDYwKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuI2ZldGNoKFwiYWRkcihieXRlczMyKVwiKTtcbiAgICAgICAgICAgICAgICAvLyBObyBhZGRyZXNzXG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdCA9PSBudWxsIHx8IHJlc3VsdCA9PT0gWmVyb0FkZHJlc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNFcnJvcihlcnJvciwgXCJDQUxMX0VYQ0VQVElPTlwiKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gVHJ5IGRlY29kaW5nIGl0cyBFVk0gY2Fub25pY2FsIGNoYWluIGFzIGFuIEVWTSBjaGFpbiBhZGRyZXNzIGZpcnN0XG4gICAgICAgIGlmIChjb2luVHlwZSA+PSAwICYmIGNvaW5UeXBlIDwgMHg4MDAwMDAwMCkge1xuICAgICAgICAgICAgbGV0IGV0aENvaW5UeXBlID0gY29pblR5cGUgKyAweDgwMDAwMDAwO1xuICAgICAgICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHRoaXMuI2ZldGNoKFwiYWRkcihieXRlczMyLHVpbnQpXCIsIFtldGhDb2luVHlwZV0pO1xuICAgICAgICAgICAgaWYgKGlzSGV4U3RyaW5nKGRhdGEsIDIwKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBnZXRBZGRyZXNzKGRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBjb2luUGx1Z2luID0gbnVsbDtcbiAgICAgICAgZm9yIChjb25zdCBwbHVnaW4gb2YgdGhpcy5wcm92aWRlci5wbHVnaW5zKSB7XG4gICAgICAgICAgICBpZiAoIShwbHVnaW4gaW5zdGFuY2VvZiBNdWx0aWNvaW5Qcm92aWRlclBsdWdpbikpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwbHVnaW4uc3VwcG9ydHNDb2luVHlwZShjb2luVHlwZSkpIHtcbiAgICAgICAgICAgICAgICBjb2luUGx1Z2luID0gcGx1Z2luO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChjb2luUGx1Z2luID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIC8vIGtlY2NhazI1NihcImFkZHIoYnl0ZXMzMix1aW50MjU2XCIpXG4gICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCB0aGlzLiNmZXRjaChcImFkZHIoYnl0ZXMzMix1aW50KVwiLCBbY29pblR5cGVdKTtcbiAgICAgICAgLy8gTm8gYWRkcmVzc1xuICAgICAgICBpZiAoZGF0YSA9PSBudWxsIHx8IGRhdGEgPT09IFwiMHhcIikge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ29tcHV0ZSB0aGUgYWRkcmVzc1xuICAgICAgICBjb25zdCBhZGRyZXNzID0gYXdhaXQgY29pblBsdWdpbi5kZWNvZGVBZGRyZXNzKGNvaW5UeXBlLCBkYXRhKTtcbiAgICAgICAgaWYgKGFkZHJlc3MgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGFkZHJlc3M7XG4gICAgICAgIH1cbiAgICAgICAgYXNzZXJ0KGZhbHNlLCBgaW52YWxpZCBjb2luIGRhdGFgLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7XG4gICAgICAgICAgICBvcGVyYXRpb246IGBnZXRBZGRyZXNzKCR7Y29pblR5cGV9KWAsXG4gICAgICAgICAgICBpbmZvOiB7IGNvaW5UeXBlLCBkYXRhIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXNvbHZlcyB0byB0aGUgRUlQLTYzNCB0ZXh0IHJlY29yZCBmb3IgJSVrZXklJSwgb3IgYGBudWxsYGBcbiAgICAgKiAgaWYgdW5jb25maWd1cmVkLlxuICAgICAqL1xuICAgIGFzeW5jIGdldFRleHQoa2V5KSB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCB0aGlzLiNmZXRjaChcInRleHQoYnl0ZXMzMixzdHJpbmcpXCIsIFtrZXldKTtcbiAgICAgICAgaWYgKGRhdGEgPT0gbnVsbCB8fCBkYXRhID09PSBcIjB4XCIpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUnNvbHZlcyB0byB0aGUgY29udGVudC1oYXNoIG9yIGBgbnVsbGBgIGlmIHVuY29uZmlndXJlZC5cbiAgICAgKi9cbiAgICBhc3luYyBnZXRDb250ZW50SGFzaCgpIHtcbiAgICAgICAgLy8ga2VjY2FrMjU2KFwiY29udGVudGhhc2goKVwiKVxuICAgICAgICBjb25zdCBkYXRhID0gYXdhaXQgdGhpcy4jZmV0Y2goXCJjb250ZW50aGFzaChieXRlczMyKVwiKTtcbiAgICAgICAgLy8gTm8gY29udGVudGhhc2hcbiAgICAgICAgaWYgKGRhdGEgPT0gbnVsbCB8fCBkYXRhID09PSBcIjB4XCIpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIC8vIElQRlMgKENJRDogMSwgVHlwZTogNzA9REFHLVBCLCA3Mj1saWJwMnAta2V5KVxuICAgICAgICBjb25zdCBpcGZzID0gZGF0YS5tYXRjaCgvXjB4KGUzMDEwMTcwfGU1MDEwMTcyKSgoWzAtOWEtZl1bMC05YS1mXSkoWzAtOWEtZl1bMC05YS1mXSkoWzAtOWEtZl0qKSkkLyk7XG4gICAgICAgIGlmIChpcGZzKSB7XG4gICAgICAgICAgICBjb25zdCBzY2hlbWUgPSAoaXBmc1sxXSA9PT0gXCJlMzAxMDE3MFwiKSA/IFwiaXBmc1wiIDogXCJpcG5zXCI7XG4gICAgICAgICAgICBjb25zdCBsZW5ndGggPSBwYXJzZUludChpcGZzWzRdLCAxNik7XG4gICAgICAgICAgICBpZiAoaXBmc1s1XS5sZW5ndGggPT09IGxlbmd0aCAqIDIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYCR7c2NoZW1lfTovXFwvJHtlbmNvZGVCYXNlNTgoXCIweFwiICsgaXBmc1syXSl9YDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBTd2FybSAoQ0lEOiAxLCBUeXBlOiBzd2FybS1tYW5pZmVzdDsgaGFzaC9sZW5ndGggaGFyZC1jb2RlZCB0byBrZWNjYWsyNTYvMzIpXG4gICAgICAgIGNvbnN0IHN3YXJtID0gZGF0YS5tYXRjaCgvXjB4ZTQwMTAxZmEwMTFiMjAoWzAtOWEtZl0qKSQvKTtcbiAgICAgICAgaWYgKHN3YXJtICYmIHN3YXJtWzFdLmxlbmd0aCA9PT0gNjQpIHtcbiAgICAgICAgICAgIHJldHVybiBgYnp6Oi9cXC8ke3N3YXJtWzFdfWA7XG4gICAgICAgIH1cbiAgICAgICAgYXNzZXJ0KGZhbHNlLCBgaW52YWxpZCBvciB1bnN1cHBvcnRlZCBjb250ZW50IGhhc2ggZGF0YWAsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHtcbiAgICAgICAgICAgIG9wZXJhdGlvbjogXCJnZXRDb250ZW50SGFzaCgpXCIsXG4gICAgICAgICAgICBpbmZvOiB7IGRhdGEgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJlc29sdmVzIHRvIHRoZSBhdmF0YXIgdXJsIG9yIGBgbnVsbGBgIGlmIHRoZSBhdmF0YXIgaXMgZWl0aGVyXG4gICAgICogIHVuY29uZmlndXJlZCBvciBpbmNvcnJlY3RseSBjb25maWd1cmVkIChlLmcuIHJlZmVyZW5jZXMgYW4gTkZUXG4gICAgICogIG5vdCBvd25lZCBieSB0aGUgYWRkcmVzcykuXG4gICAgICpcbiAgICAgKiAgSWYgZGlhZ25vc2luZyBpc3N1ZXMgd2l0aCBjb25maWd1cmF0aW9ucywgdGhlIFtbX2dldEF2YXRhcl1dXG4gICAgICogIG1ldGhvZCBtYXkgYmUgdXNlZnVsLlxuICAgICAqL1xuICAgIGFzeW5jIGdldEF2YXRhcigpIHtcbiAgICAgICAgY29uc3QgYXZhdGFyID0gYXdhaXQgdGhpcy5fZ2V0QXZhdGFyKCk7XG4gICAgICAgIHJldHVybiBhdmF0YXIudXJsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgV2hlbiByZXNvbHZpbmcgYW4gYXZhdGFyLCB0aGVyZSBhcmUgbWFueSBzdGVwcyBpbnZvbHZlZCwgc3VjaFxuICAgICAqICBmZXRjaGluZyBtZXRhZGF0YSBhbmQgcG9zc2libHkgdmFsaWRhdGluZyBvd25lcnNoaXAgb2YgYW5cbiAgICAgKiAgTkZULlxuICAgICAqXG4gICAgICogIFRoaXMgbWV0aG9kIGNhbiBiZSB1c2VkIHRvIGV4YW1pbmUgZWFjaCBzdGVwIGFuZCB0aGUgdmFsdWUgaXRcbiAgICAgKiAgd2FzIHdvcmtpbmcgZnJvbS5cbiAgICAgKi9cbiAgICBhc3luYyBfZ2V0QXZhdGFyKCkge1xuICAgICAgICBjb25zdCBsaW5rYWdlID0gW3sgdHlwZTogXCJuYW1lXCIsIHZhbHVlOiB0aGlzLm5hbWUgfV07XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyB0ZXN0IGRhdGEgZm9yIHJpY21vby5ldGhcbiAgICAgICAgICAgIC8vY29uc3QgYXZhdGFyID0gXCJlaXAxNTU6MS9lcmM3MjE6MHgyNjUzODVjN2Y0MTMyMjI4QTBkNTRFQjFBOWU3NDYwYjkxYzBjQzY4LzI5MjMzXCI7XG4gICAgICAgICAgICBjb25zdCBhdmF0YXIgPSBhd2FpdCB0aGlzLmdldFRleHQoXCJhdmF0YXJcIik7XG4gICAgICAgICAgICBpZiAoYXZhdGFyID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBsaW5rYWdlLnB1c2goeyB0eXBlOiBcIiFhdmF0YXJcIiwgdmFsdWU6IFwiXCIgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgdXJsOiBudWxsLCBsaW5rYWdlIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsaW5rYWdlLnB1c2goeyB0eXBlOiBcImF2YXRhclwiLCB2YWx1ZTogYXZhdGFyIH0pO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtYXRjaGVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1hdGNoID0gYXZhdGFyLm1hdGNoKG1hdGNoZXJzW2ldKTtcbiAgICAgICAgICAgICAgICBpZiAobWF0Y2ggPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3Qgc2NoZW1lID0gbWF0Y2hbMV0udG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHNjaGVtZSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiaHR0cHNcIjpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcImRhdGFcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmthZ2UucHVzaCh7IHR5cGU6IFwidXJsXCIsIHZhbHVlOiBhdmF0YXIgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBsaW5rYWdlLCB1cmw6IGF2YXRhciB9O1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiaXBmc1wiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB1cmwgPSBnZXRJcGZzTGluayhhdmF0YXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGlua2FnZS5wdXNoKHsgdHlwZTogXCJpcGZzXCIsIHZhbHVlOiBhdmF0YXIgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5rYWdlLnB1c2goeyB0eXBlOiBcInVybFwiLCB2YWx1ZTogdXJsIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgbGlua2FnZSwgdXJsIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcImVyYzcyMVwiOlxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZXJjMTE1NVwiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBEZXBlbmRpbmcgb24gdGhlIEVSQyB0eXBlLCB1c2UgdG9rZW5VUkkodWludDI1Nikgb3IgdXJsKHVpbnQyNTYpXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzZWxlY3RvciA9IChzY2hlbWUgPT09IFwiZXJjNzIxXCIpID8gXCJ0b2tlblVSSSh1aW50MjU2KVwiIDogXCJ1cmkodWludDI1NilcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmthZ2UucHVzaCh7IHR5cGU6IHNjaGVtZSwgdmFsdWU6IGF2YXRhciB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSBvd25lciBvZiB0aGlzIG5hbWVcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG93bmVyID0gYXdhaXQgdGhpcy5nZXRBZGRyZXNzKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob3duZXIgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmthZ2UucHVzaCh7IHR5cGU6IFwiIW93bmVyXCIsIHZhbHVlOiBcIlwiIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHVybDogbnVsbCwgbGlua2FnZSB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY29tcHMgPSAobWF0Y2hbMl0gfHwgXCJcIikuc3BsaXQoXCIvXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbXBzLmxlbmd0aCAhPT0gMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmthZ2UucHVzaCh7IHR5cGU6IGAhJHtzY2hlbWV9Y2FpcGAsIHZhbHVlOiAobWF0Y2hbMl0gfHwgXCJcIikgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgdXJsOiBudWxsLCBsaW5rYWdlIH07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0b2tlbklkID0gY29tcHNbMV07XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjb250cmFjdCA9IG5ldyBDb250cmFjdChjb21wc1swXSwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEVSQy03MjFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImZ1bmN0aW9uIHRva2VuVVJJKHVpbnQpIHZpZXcgcmV0dXJucyAoc3RyaW5nKVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiZnVuY3Rpb24gb3duZXJPZih1aW50KSB2aWV3IHJldHVybnMgKGFkZHJlc3MpXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRVJDLTExNTVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImZ1bmN0aW9uIHVyaSh1aW50KSB2aWV3IHJldHVybnMgKHN0cmluZylcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImZ1bmN0aW9uIGJhbGFuY2VPZihhZGRyZXNzLCB1aW50MjU2KSB2aWV3IHJldHVybnMgKHVpbnQpXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIF0sIHRoaXMucHJvdmlkZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgdGhhdCB0aGlzIGFjY291bnQgb3ducyB0aGUgdG9rZW5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzY2hlbWUgPT09IFwiZXJjNzIxXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0b2tlbk93bmVyID0gYXdhaXQgY29udHJhY3Qub3duZXJPZih0b2tlbklkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAob3duZXIgIT09IHRva2VuT3duZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlua2FnZS5wdXNoKHsgdHlwZTogXCIhb3duZXJcIiwgdmFsdWU6IHRva2VuT3duZXIgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHVybDogbnVsbCwgbGlua2FnZSB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5rYWdlLnB1c2goeyB0eXBlOiBcIm93bmVyXCIsIHZhbHVlOiB0b2tlbk93bmVyIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoc2NoZW1lID09PSBcImVyYzExNTVcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGJhbGFuY2UgPSBhd2FpdCBjb250cmFjdC5iYWxhbmNlT2Yob3duZXIsIHRva2VuSWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghYmFsYW5jZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5rYWdlLnB1c2goeyB0eXBlOiBcIiFiYWxhbmNlXCIsIHZhbHVlOiBcIjBcIiB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgdXJsOiBudWxsLCBsaW5rYWdlIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmthZ2UucHVzaCh7IHR5cGU6IFwiYmFsYW5jZVwiLCB2YWx1ZTogYmFsYW5jZS50b1N0cmluZygpIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2FsbCB0aGUgdG9rZW4gY29udHJhY3QgZm9yIHRoZSBtZXRhZGF0YSBVUkxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBtZXRhZGF0YVVybCA9IGF3YWl0IGNvbnRyYWN0W3NlbGVjdG9yXSh0b2tlbklkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtZXRhZGF0YVVybCA9PSBudWxsIHx8IG1ldGFkYXRhVXJsID09PSBcIjB4XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5rYWdlLnB1c2goeyB0eXBlOiBcIiFtZXRhZGF0YS11cmxcIiwgdmFsdWU6IFwiXCIgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgdXJsOiBudWxsLCBsaW5rYWdlIH07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5rYWdlLnB1c2goeyB0eXBlOiBcIm1ldGFkYXRhLXVybC1iYXNlXCIsIHZhbHVlOiBtZXRhZGF0YVVybCB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEVSQy0xMTU1IGFsbG93cyBhIGdlbmVyaWMge2lkfSBpbiB0aGUgVVJMXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2NoZW1lID09PSBcImVyYzExNTVcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1ldGFkYXRhVXJsID0gbWV0YWRhdGFVcmwucmVwbGFjZShcIntpZH1cIiwgdG9CZUhleCh0b2tlbklkLCAzMikuc3Vic3RyaW5nKDIpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5rYWdlLnB1c2goeyB0eXBlOiBcIm1ldGFkYXRhLXVybC1leHBhbmRlZFwiLCB2YWx1ZTogbWV0YWRhdGFVcmwgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUcmFuc2Zvcm0gSVBGUyBtZXRhZGF0YSBsaW5rc1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1ldGFkYXRhVXJsLm1hdGNoKC9eaXBmczovaSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXRhZGF0YVVybCA9IGdldElwZnNMaW5rKG1ldGFkYXRhVXJsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmthZ2UucHVzaCh7IHR5cGU6IFwibWV0YWRhdGEtdXJsXCIsIHZhbHVlOiBtZXRhZGF0YVVybCB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEdldCB0aGUgdG9rZW4gbWV0YWRhdGFcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBtZXRhZGF0YSA9IHt9O1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCAobmV3IEZldGNoUmVxdWVzdChtZXRhZGF0YVVybCkpLnNlbmQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLmFzc2VydE9rKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1ldGFkYXRhID0gcmVzcG9uc2UuYm9keUpzb247XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5rYWdlLnB1c2goeyB0eXBlOiBcIiFtZXRhZGF0YVwiLCB2YWx1ZTogcmVzcG9uc2UuYm9keVRleHQgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBieXRlcyA9IHJlc3BvbnNlLmJvZHk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChieXRlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlua2FnZS5wdXNoKHsgdHlwZTogXCIhbWV0YWRhdGFcIiwgdmFsdWU6IGhleGxpZnkoYnl0ZXMpIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHVybDogbnVsbCwgbGlua2FnZSB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyB1cmw6IG51bGwsIGxpbmthZ2UgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghbWV0YWRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5rYWdlLnB1c2goeyB0eXBlOiBcIiFtZXRhZGF0YVwiLCB2YWx1ZTogXCJcIiB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyB1cmw6IG51bGwsIGxpbmthZ2UgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmthZ2UucHVzaCh7IHR5cGU6IFwibWV0YWRhdGFcIiwgdmFsdWU6IEpTT04uc3RyaW5naWZ5KG1ldGFkYXRhKSB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFB1bGwgdGhlIGltYWdlIFVSTCBvdXRcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBpbWFnZVVybCA9IG1ldGFkYXRhLmltYWdlO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiAoaW1hZ2VVcmwpICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlua2FnZS5wdXNoKHsgdHlwZTogXCIhaW1hZ2VVcmxcIiwgdmFsdWU6IFwiXCIgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgdXJsOiBudWxsLCBsaW5rYWdlIH07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW1hZ2VVcmwubWF0Y2goL14oaHR0cHM6XFwvXFwvfGRhdGE6KS9pKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFsbG93XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUcmFuc2Zvcm0gSVBGUyBsaW5rIHRvIGdhdGV3YXlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBpcGZzID0gaW1hZ2VVcmwubWF0Y2gobWF0Y2hlcklwZnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpcGZzID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlua2FnZS5wdXNoKHsgdHlwZTogXCIhaW1hZ2VVcmwtaXBmc1wiLCB2YWx1ZTogaW1hZ2VVcmwgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHVybDogbnVsbCwgbGlua2FnZSB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5rYWdlLnB1c2goeyB0eXBlOiBcImltYWdlVXJsLWlwZnNcIiwgdmFsdWU6IGltYWdlVXJsIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGltYWdlVXJsID0gZ2V0SXBmc0xpbmsoaW1hZ2VVcmwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgbGlua2FnZS5wdXNoKHsgdHlwZTogXCJ1cmxcIiwgdmFsdWU6IGltYWdlVXJsIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgbGlua2FnZSwgdXJsOiBpbWFnZVVybCB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikgeyB9XG4gICAgICAgIHJldHVybiB7IGxpbmthZ2UsIHVybDogbnVsbCB9O1xuICAgIH1cbiAgICBzdGF0aWMgYXN5bmMgZ2V0RW5zQWRkcmVzcyhwcm92aWRlcikge1xuICAgICAgICBjb25zdCBuZXR3b3JrID0gYXdhaXQgcHJvdmlkZXIuZ2V0TmV0d29yaygpO1xuICAgICAgICBjb25zdCBlbnNQbHVnaW4gPSBuZXR3b3JrLmdldFBsdWdpbihcIm9yZy5ldGhlcnMucGx1Z2lucy5uZXR3b3JrLkVuc1wiKTtcbiAgICAgICAgLy8gTm8gRU5TLi4uXG4gICAgICAgIGFzc2VydChlbnNQbHVnaW4sIFwibmV0d29yayBkb2VzIG5vdCBzdXBwb3J0IEVOU1wiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7XG4gICAgICAgICAgICBvcGVyYXRpb246IFwiZ2V0RW5zQWRkcmVzc1wiLCBpbmZvOiB7IG5ldHdvcmsgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGVuc1BsdWdpbi5hZGRyZXNzO1xuICAgIH1cbiAgICBzdGF0aWMgYXN5bmMgI2dldFJlc29sdmVyKHByb3ZpZGVyLCBuYW1lKSB7XG4gICAgICAgIGNvbnN0IGVuc0FkZHIgPSBhd2FpdCBFbnNSZXNvbHZlci5nZXRFbnNBZGRyZXNzKHByb3ZpZGVyKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGNvbnRyYWN0ID0gbmV3IENvbnRyYWN0KGVuc0FkZHIsIFtcbiAgICAgICAgICAgICAgICBcImZ1bmN0aW9uIHJlc29sdmVyKGJ5dGVzMzIpIHZpZXcgcmV0dXJucyAoYWRkcmVzcylcIlxuICAgICAgICAgICAgXSwgcHJvdmlkZXIpO1xuICAgICAgICAgICAgY29uc3QgYWRkciA9IGF3YWl0IGNvbnRyYWN0LnJlc29sdmVyKG5hbWVoYXNoKG5hbWUpLCB7XG4gICAgICAgICAgICAgICAgZW5hYmxlQ2NpcFJlYWQ6IHRydWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKGFkZHIgPT09IFplcm9BZGRyZXNzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYWRkcjtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIC8vIEVOUyByZWdpc3RyeSBjYW5ub3QgdGhyb3cgZXJyb3JzIG9uIHJlc29sdmVyKGJ5dGVzMzIpLFxuICAgICAgICAgICAgLy8gc28gcHJvYmFibHkgYSBsaW5rIGVycm9yXG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJlc29sdmUgdG8gdGhlIEVOUyByZXNvbHZlciBmb3IgJSVuYW1lJSUgdXNpbmcgJSVwcm92aWRlciUlIG9yXG4gICAgICogIGBgbnVsbGBgIGlmIHVuY29uZmlndXJlZC5cbiAgICAgKi9cbiAgICBzdGF0aWMgYXN5bmMgZnJvbU5hbWUocHJvdmlkZXIsIG5hbWUpIHtcbiAgICAgICAgbGV0IGN1cnJlbnROYW1lID0gbmFtZTtcbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50TmFtZSA9PT0gXCJcIiB8fCBjdXJyZW50TmFtZSA9PT0gXCIuXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE9wdGltaXphdGlvbiBzaW5jZSB0aGUgZXRoIG5vZGUgY2Fubm90IGNoYW5nZSBhbmQgZG9lc1xuICAgICAgICAgICAgLy8gbm90IGhhdmUgYSB3aWxkY2FyZCByZXNvbHZlclxuICAgICAgICAgICAgaWYgKG5hbWUgIT09IFwiZXRoXCIgJiYgY3VycmVudE5hbWUgPT09IFwiZXRoXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIENoZWNrIHRoZSBjdXJyZW50IG5vZGUgZm9yIGEgcmVzb2x2ZXJcbiAgICAgICAgICAgIGNvbnN0IGFkZHIgPSBhd2FpdCBFbnNSZXNvbHZlci4jZ2V0UmVzb2x2ZXIocHJvdmlkZXIsIGN1cnJlbnROYW1lKTtcbiAgICAgICAgICAgIC8vIEZvdW5kIGEgcmVzb2x2ZXIhXG4gICAgICAgICAgICBpZiAoYWRkciAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzb2x2ZXIgPSBuZXcgRW5zUmVzb2x2ZXIocHJvdmlkZXIsIGFkZHIsIG5hbWUpO1xuICAgICAgICAgICAgICAgIC8vIExlZ2FjeSByZXNvbHZlciBmb3VuZCwgdXNpbmcgRUlQLTI1NDQgc28gaXQgaXNuJ3Qgc2FmZSB0byB1c2VcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudE5hbWUgIT09IG5hbWUgJiYgIShhd2FpdCByZXNvbHZlci5zdXBwb3J0c1dpbGRjYXJkKCkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBHZXQgdGhlIHBhcmVudCBub2RlXG4gICAgICAgICAgICBjdXJyZW50TmFtZSA9IGN1cnJlbnROYW1lLnNwbGl0KFwiLlwiKS5zbGljZSgxKS5qb2luKFwiLlwiKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVucy1yZXNvbHZlci5qcy5tYXAiXSwibmFtZXMiOlsiZ2V0QWRkcmVzcyIsIlplcm9BZGRyZXNzIiwiQ29udHJhY3QiLCJkbnNFbmNvZGUiLCJuYW1laGFzaCIsImhleGxpZnkiLCJpc0hleFN0cmluZyIsInRvQmVIZXgiLCJkZWZpbmVQcm9wZXJ0aWVzIiwiZW5jb2RlQmFzZTU4IiwiYXNzZXJ0IiwiYXNzZXJ0QXJndW1lbnQiLCJpc0Vycm9yIiwiRmV0Y2hSZXF1ZXN0IiwiZ2V0SXBmc0xpbmsiLCJsaW5rIiwibWF0Y2giLCJzdWJzdHJpbmciLCJNdWx0aWNvaW5Qcm92aWRlclBsdWdpbiIsImNvbnN0cnVjdG9yIiwibmFtZSIsImNvbm5lY3QiLCJwcm9pdmRlciIsInN1cHBvcnRzQ29pblR5cGUiLCJjb2luVHlwZSIsImVuY29kZUFkZHJlc3MiLCJhZGRyZXNzIiwiRXJyb3IiLCJkZWNvZGVBZGRyZXNzIiwiZGF0YSIsIkJhc2ljTXVsdGljb2luUGx1Z2luSWQiLCJCYXNpY011bHRpY29pblByb3ZpZGVyUGx1Z2luIiwibWF0Y2hlcklwZnMiLCJSZWdFeHAiLCJtYXRjaGVycyIsIkVuc1Jlc29sdmVyIiwic3VwcG9ydHMyNTQ0IiwicmVzb2x2ZXIiLCJwcm92aWRlciIsInN1cHBvcnRzV2lsZGNhcmQiLCJzdXBwb3J0c0ludGVyZmFjZSIsImVycm9yIiwiZmV0Y2giLCJmdW5jTmFtZSIsInBhcmFtcyIsInNsaWNlIiwiaWZhY2UiLCJpbnRlcmZhY2UiLCJ1bnNoaWZ0IiwiZnJhZ21lbnQiLCJnZXRGdW5jdGlvbiIsImluZm8iLCJlbmNvZGVGdW5jdGlvbkRhdGEiLCJwdXNoIiwiZW5hYmxlQ2NpcFJlYWQiLCJyZXN1bHQiLCJkZWNvZGVGdW5jdGlvblJlc3VsdCIsImV0aENvaW5UeXBlIiwiY29pblBsdWdpbiIsInBsdWdpbiIsInBsdWdpbnMiLCJvcGVyYXRpb24iLCJnZXRUZXh0Iiwia2V5IiwiZ2V0Q29udGVudEhhc2giLCJpcGZzIiwic2NoZW1lIiwibGVuZ3RoIiwicGFyc2VJbnQiLCJzd2FybSIsImdldEF2YXRhciIsImF2YXRhciIsIl9nZXRBdmF0YXIiLCJ1cmwiLCJsaW5rYWdlIiwidHlwZSIsInZhbHVlIiwiaSIsInRvTG93ZXJDYXNlIiwic2VsZWN0b3IiLCJvd25lciIsImNvbXBzIiwic3BsaXQiLCJ0b2tlbklkIiwiY29udHJhY3QiLCJ0b2tlbk93bmVyIiwib3duZXJPZiIsImJhbGFuY2UiLCJiYWxhbmNlT2YiLCJ0b1N0cmluZyIsIm1ldGFkYXRhVXJsIiwicmVwbGFjZSIsIm1ldGFkYXRhIiwicmVzcG9uc2UiLCJzZW5kIiwiYXNzZXJ0T2siLCJib2R5SnNvbiIsImJvZHlUZXh0IiwiYnl0ZXMiLCJib2R5IiwiSlNPTiIsInN0cmluZ2lmeSIsImltYWdlVXJsIiwiaW1hZ2UiLCJnZXRFbnNBZGRyZXNzIiwibmV0d29yayIsImdldE5ldHdvcmsiLCJlbnNQbHVnaW4iLCJnZXRQbHVnaW4iLCJnZXRSZXNvbHZlciIsImVuc0FkZHIiLCJhZGRyIiwiZnJvbU5hbWUiLCJjdXJyZW50TmFtZSIsImpvaW4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.esm/providers/ens-resolver.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.esm/providers/format.js":
/*!*********************************************************!*\
  !*** ./node_modules/ethers/lib.esm/providers/format.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   allowNull: () => (/* binding */ allowNull),\n/* harmony export */   arrayOf: () => (/* binding */ arrayOf),\n/* harmony export */   formatBlock: () => (/* binding */ formatBlock),\n/* harmony export */   formatBoolean: () => (/* binding */ formatBoolean),\n/* harmony export */   formatData: () => (/* binding */ formatData),\n/* harmony export */   formatHash: () => (/* binding */ formatHash),\n/* harmony export */   formatLog: () => (/* binding */ formatLog),\n/* harmony export */   formatReceiptLog: () => (/* binding */ formatReceiptLog),\n/* harmony export */   formatTransactionReceipt: () => (/* binding */ formatTransactionReceipt),\n/* harmony export */   formatTransactionResponse: () => (/* binding */ formatTransactionResponse),\n/* harmony export */   formatUint256: () => (/* binding */ formatUint256),\n/* harmony export */   object: () => (/* binding */ object)\n/* harmony export */ });\n/* harmony import */ var _address_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../address/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/address/address.js\");\n/* harmony import */ var _address_index_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../address/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/address/contract-address.js\");\n/* harmony import */ var _crypto_index_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../crypto/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/crypto/signature.js\");\n/* harmony import */ var _transaction_index_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../transaction/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/transaction/accesslist.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/errors.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/data.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/maths.js\");\n/**\n *  @_ignore\n */ \n\n\n\nconst BN_0 = BigInt(0);\nfunction allowNull(format, nullValue) {\n    return function(value) {\n        if (value == null) {\n            return nullValue;\n        }\n        return format(value);\n    };\n}\nfunction arrayOf(format, allowNull) {\n    return (array)=>{\n        if (allowNull && array == null) {\n            return null;\n        }\n        if (!Array.isArray(array)) {\n            throw new Error(\"not an array\");\n        }\n        return array.map((i)=>format(i));\n    };\n}\n// Requires an object which matches a fleet of other formatters\n// Any FormatFunc may return `undefined` to have the value omitted\n// from the result object. Calls preserve `this`.\nfunction object(format, altNames) {\n    return (value)=>{\n        const result = {};\n        for(const key in format){\n            let srcKey = key;\n            if (altNames && key in altNames && !(srcKey in value)) {\n                for (const altKey of altNames[key]){\n                    if (altKey in value) {\n                        srcKey = altKey;\n                        break;\n                    }\n                }\n            }\n            try {\n                const nv = format[key](value[srcKey]);\n                if (nv !== undefined) {\n                    result[key] = nv;\n                }\n            } catch (error) {\n                const message = error instanceof Error ? error.message : \"not-an-error\";\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assert)(false, `invalid value for value.${key} (${message})`, \"BAD_DATA\", {\n                    value\n                });\n            }\n        }\n        return result;\n    };\n}\nfunction formatBoolean(value) {\n    switch(value){\n        case true:\n        case \"true\":\n            return true;\n        case false:\n        case \"false\":\n            return false;\n    }\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(false, `invalid boolean; ${JSON.stringify(value)}`, \"value\", value);\n}\nfunction formatData(value) {\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.isHexString)(value, true), \"invalid data\", \"value\", value);\n    return value;\n}\nfunction formatHash(value) {\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.isHexString)(value, 32), \"invalid hash\", \"value\", value);\n    return value;\n}\nfunction formatUint256(value) {\n    if (!(0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.isHexString)(value)) {\n        throw new Error(\"invalid uint256\");\n    }\n    return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.zeroPadValue)(value, 32);\n}\nconst _formatLog = object({\n    address: _address_index_js__WEBPACK_IMPORTED_MODULE_2__.getAddress,\n    blockHash: formatHash,\n    blockNumber: _utils_index_js__WEBPACK_IMPORTED_MODULE_3__.getNumber,\n    data: formatData,\n    index: _utils_index_js__WEBPACK_IMPORTED_MODULE_3__.getNumber,\n    removed: allowNull(formatBoolean, false),\n    topics: arrayOf(formatHash),\n    transactionHash: formatHash,\n    transactionIndex: _utils_index_js__WEBPACK_IMPORTED_MODULE_3__.getNumber\n}, {\n    index: [\n        \"logIndex\"\n    ]\n});\nfunction formatLog(value) {\n    return _formatLog(value);\n}\nconst _formatBlock = object({\n    hash: allowNull(formatHash),\n    parentHash: formatHash,\n    parentBeaconBlockRoot: allowNull(formatHash, null),\n    number: _utils_index_js__WEBPACK_IMPORTED_MODULE_3__.getNumber,\n    timestamp: _utils_index_js__WEBPACK_IMPORTED_MODULE_3__.getNumber,\n    nonce: allowNull(formatData),\n    difficulty: _utils_index_js__WEBPACK_IMPORTED_MODULE_3__.getBigInt,\n    gasLimit: _utils_index_js__WEBPACK_IMPORTED_MODULE_3__.getBigInt,\n    gasUsed: _utils_index_js__WEBPACK_IMPORTED_MODULE_3__.getBigInt,\n    stateRoot: allowNull(formatHash, null),\n    receiptsRoot: allowNull(formatHash, null),\n    blobGasUsed: allowNull(_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.getBigInt, null),\n    excessBlobGas: allowNull(_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.getBigInt, null),\n    miner: allowNull(_address_index_js__WEBPACK_IMPORTED_MODULE_2__.getAddress),\n    prevRandao: allowNull(formatHash, null),\n    extraData: formatData,\n    baseFeePerGas: allowNull(_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.getBigInt)\n}, {\n    prevRandao: [\n        \"mixHash\"\n    ]\n});\nfunction formatBlock(value) {\n    const result = _formatBlock(value);\n    result.transactions = value.transactions.map((tx)=>{\n        if (typeof tx === \"string\") {\n            return tx;\n        }\n        return formatTransactionResponse(tx);\n    });\n    return result;\n}\nconst _formatReceiptLog = object({\n    transactionIndex: _utils_index_js__WEBPACK_IMPORTED_MODULE_3__.getNumber,\n    blockNumber: _utils_index_js__WEBPACK_IMPORTED_MODULE_3__.getNumber,\n    transactionHash: formatHash,\n    address: _address_index_js__WEBPACK_IMPORTED_MODULE_2__.getAddress,\n    topics: arrayOf(formatHash),\n    data: formatData,\n    index: _utils_index_js__WEBPACK_IMPORTED_MODULE_3__.getNumber,\n    blockHash: formatHash\n}, {\n    index: [\n        \"logIndex\"\n    ]\n});\nfunction formatReceiptLog(value) {\n    return _formatReceiptLog(value);\n}\nconst _formatTransactionReceipt = object({\n    to: allowNull(_address_index_js__WEBPACK_IMPORTED_MODULE_2__.getAddress, null),\n    from: allowNull(_address_index_js__WEBPACK_IMPORTED_MODULE_2__.getAddress, null),\n    contractAddress: allowNull(_address_index_js__WEBPACK_IMPORTED_MODULE_2__.getAddress, null),\n    // should be allowNull(hash), but broken-EIP-658 support is handled in receipt\n    index: _utils_index_js__WEBPACK_IMPORTED_MODULE_3__.getNumber,\n    root: allowNull(_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.hexlify),\n    gasUsed: _utils_index_js__WEBPACK_IMPORTED_MODULE_3__.getBigInt,\n    blobGasUsed: allowNull(_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.getBigInt, null),\n    logsBloom: allowNull(formatData),\n    blockHash: formatHash,\n    hash: formatHash,\n    logs: arrayOf(formatReceiptLog),\n    blockNumber: _utils_index_js__WEBPACK_IMPORTED_MODULE_3__.getNumber,\n    //confirmations: allowNull(getNumber, null),\n    cumulativeGasUsed: _utils_index_js__WEBPACK_IMPORTED_MODULE_3__.getBigInt,\n    effectiveGasPrice: allowNull(_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.getBigInt),\n    blobGasPrice: allowNull(_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.getBigInt, null),\n    status: allowNull(_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.getNumber),\n    type: allowNull(_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.getNumber, 0)\n}, {\n    effectiveGasPrice: [\n        \"gasPrice\"\n    ],\n    hash: [\n        \"transactionHash\"\n    ],\n    index: [\n        \"transactionIndex\"\n    ]\n});\nfunction formatTransactionReceipt(value) {\n    return _formatTransactionReceipt(value);\n}\nfunction formatTransactionResponse(value) {\n    // Some clients (TestRPC) do strange things like return 0x0 for the\n    // 0 address; correct this to be a real address\n    if (value.to && (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.getBigInt)(value.to) === BN_0) {\n        value.to = \"0x0000000000000000000000000000000000000000\";\n    }\n    const result = object({\n        hash: formatHash,\n        // Some nodes do not return this, usually test nodes (like Ganache)\n        index: allowNull(_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.getNumber, undefined),\n        type: (value)=>{\n            if (value === \"0x\" || value == null) {\n                return 0;\n            }\n            return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.getNumber)(value);\n        },\n        accessList: allowNull(_transaction_index_js__WEBPACK_IMPORTED_MODULE_4__.accessListify, null),\n        blobVersionedHashes: allowNull(arrayOf(formatHash, true), null),\n        authorizationList: allowNull(arrayOf((v)=>{\n            let sig;\n            if (v.signature) {\n                sig = v.signature;\n            } else {\n                let yParity = v.yParity;\n                if (yParity === \"0x1b\") {\n                    yParity = 0;\n                } else if (yParity === \"0x1c\") {\n                    yParity = 1;\n                }\n                sig = Object.assign({}, v, {\n                    yParity\n                });\n            }\n            return {\n                address: (0,_address_index_js__WEBPACK_IMPORTED_MODULE_2__.getAddress)(v.address),\n                chainId: (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.getBigInt)(v.chainId),\n                nonce: (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.getBigInt)(v.nonce),\n                signature: _crypto_index_js__WEBPACK_IMPORTED_MODULE_5__.Signature.from(sig)\n            };\n        }, false), null),\n        blockHash: allowNull(formatHash, null),\n        blockNumber: allowNull(_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.getNumber, null),\n        transactionIndex: allowNull(_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.getNumber, null),\n        from: _address_index_js__WEBPACK_IMPORTED_MODULE_2__.getAddress,\n        // either (gasPrice) or (maxPriorityFeePerGas + maxFeePerGas) must be set\n        gasPrice: allowNull(_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.getBigInt),\n        maxPriorityFeePerGas: allowNull(_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.getBigInt),\n        maxFeePerGas: allowNull(_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.getBigInt),\n        maxFeePerBlobGas: allowNull(_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.getBigInt, null),\n        gasLimit: _utils_index_js__WEBPACK_IMPORTED_MODULE_3__.getBigInt,\n        to: allowNull(_address_index_js__WEBPACK_IMPORTED_MODULE_2__.getAddress, null),\n        value: _utils_index_js__WEBPACK_IMPORTED_MODULE_3__.getBigInt,\n        nonce: _utils_index_js__WEBPACK_IMPORTED_MODULE_3__.getNumber,\n        data: formatData,\n        creates: allowNull(_address_index_js__WEBPACK_IMPORTED_MODULE_2__.getAddress, null),\n        chainId: allowNull(_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.getBigInt, null)\n    }, {\n        data: [\n            \"input\"\n        ],\n        gasLimit: [\n            \"gas\"\n        ],\n        index: [\n            \"transactionIndex\"\n        ]\n    })(value);\n    // If to and creates are empty, populate the creates from the value\n    if (result.to == null && result.creates == null) {\n        result.creates = (0,_address_index_js__WEBPACK_IMPORTED_MODULE_6__.getCreateAddress)(result);\n    }\n    // @TODO: Check fee data\n    // Add an access list to supported transaction types\n    if ((value.type === 1 || value.type === 2) && value.accessList == null) {\n        result.accessList = [];\n    }\n    // Compute the signature\n    if (value.signature) {\n        result.signature = _crypto_index_js__WEBPACK_IMPORTED_MODULE_5__.Signature.from(value.signature);\n    } else {\n        result.signature = _crypto_index_js__WEBPACK_IMPORTED_MODULE_5__.Signature.from(value);\n    }\n    // Some backends omit ChainId on legacy transactions, but we can compute it\n    if (result.chainId == null) {\n        const chainId = result.signature.legacyChainId;\n        if (chainId != null) {\n            result.chainId = chainId;\n        }\n    }\n    // @TODO: check chainID\n    /*\n    if (value.chainId != null) {\n        let chainId = value.chainId;\n\n        if (isHexString(chainId)) {\n            chainId = BigNumber.from(chainId).toNumber();\n        }\n\n        result.chainId = chainId;\n\n    } else {\n        let chainId = value.networkId;\n\n        // geth-etc returns chainId\n        if (chainId == null && result.v == null) {\n            chainId = value.chainId;\n        }\n\n        if (isHexString(chainId)) {\n            chainId = BigNumber.from(chainId).toNumber();\n        }\n\n        if (typeof(chainId) !== \"number\" && result.v != null) {\n            chainId = (result.v - 35) / 2;\n            if (chainId < 0) { chainId = 0; }\n            chainId = parseInt(chainId);\n        }\n\n        if (typeof(chainId) !== \"number\") { chainId = 0; }\n\n        result.chainId = chainId;\n    }\n    */ // 0x0000... should actually be null\n    if (result.blockHash && (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.getBigInt)(result.blockHash) === BN_0) {\n        result.blockHash = null;\n    }\n    return result;\n} //# sourceMappingURL=format.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vcHJvdmlkZXJzL2Zvcm1hdC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7O0NBRUMsR0FDa0U7QUFDcEI7QUFDUztBQUM2RDtBQUNySCxNQUFNVyxPQUFPQyxPQUFPO0FBQ2IsU0FBU0MsVUFBVUMsTUFBTSxFQUFFQyxTQUFTO0lBQ3ZDLE9BQVEsU0FBVUMsS0FBSztRQUNuQixJQUFJQSxTQUFTLE1BQU07WUFDZixPQUFPRDtRQUNYO1FBQ0EsT0FBT0QsT0FBT0U7SUFDbEI7QUFDSjtBQUNPLFNBQVNDLFFBQVFILE1BQU0sRUFBRUQsU0FBUztJQUNyQyxPQUFRLENBQUNLO1FBQ0wsSUFBSUwsYUFBYUssU0FBUyxNQUFNO1lBQzVCLE9BQU87UUFDWDtRQUNBLElBQUksQ0FBQ0MsTUFBTUMsT0FBTyxDQUFDRixRQUFRO1lBQ3ZCLE1BQU0sSUFBSUcsTUFBTTtRQUNwQjtRQUNBLE9BQU9ILE1BQU1JLEdBQUcsQ0FBQyxDQUFDQyxJQUFNVCxPQUFPUztJQUNuQztBQUNKO0FBQ0EsK0RBQStEO0FBQy9ELGtFQUFrRTtBQUNsRSxpREFBaUQ7QUFDMUMsU0FBU0MsT0FBT1YsTUFBTSxFQUFFVyxRQUFRO0lBQ25DLE9BQVEsQ0FBQ1Q7UUFDTCxNQUFNVSxTQUFTLENBQUM7UUFDaEIsSUFBSyxNQUFNQyxPQUFPYixPQUFRO1lBQ3RCLElBQUljLFNBQVNEO1lBQ2IsSUFBSUYsWUFBWUUsT0FBT0YsWUFBWSxDQUFFRyxDQUFBQSxVQUFVWixLQUFJLEdBQUk7Z0JBQ25ELEtBQUssTUFBTWEsVUFBVUosUUFBUSxDQUFDRSxJQUFJLENBQUU7b0JBQ2hDLElBQUlFLFVBQVViLE9BQU87d0JBQ2pCWSxTQUFTQzt3QkFDVDtvQkFDSjtnQkFDSjtZQUNKO1lBQ0EsSUFBSTtnQkFDQSxNQUFNQyxLQUFLaEIsTUFBTSxDQUFDYSxJQUFJLENBQUNYLEtBQUssQ0FBQ1ksT0FBTztnQkFDcEMsSUFB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SSxNQUFNO1FBQ3hCLE1BQU1BLFVBQVV2RSxPQUFPbUUsU0FBUyxDQUFDVSxhQUFhO1FBQzlDLElBQUlOLFdBQVcsTUFBTTtZQUNqQnZFLE9BQU91RSxPQUFPLEdBQUdBO1FBQ3JCO0lBQ0o7SUFDQSx1QkFBdUI7SUFDdkI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0lBZ0NBLEdBQ0Esb0NBQW9DO0lBQ3BDLElBQUl2RSxPQUFPZ0IsU0FBUyxJQUFJdEMsMERBQVNBLENBQUNzQixPQUFPZ0IsU0FBUyxNQUFNL0IsTUFBTTtRQUMxRGUsT0FBT2dCLFNBQVMsR0FBRztJQUN2QjtJQUNBLE9BQU9oQjtBQUNYLEVBQ0Esa0NBQWtDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbWVnYXZpYmUtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vcHJvdmlkZXJzL2Zvcm1hdC5qcz83YzRhIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogIEBfaWdub3JlXG4gKi9cbmltcG9ydCB7IGdldEFkZHJlc3MsIGdldENyZWF0ZUFkZHJlc3MgfSBmcm9tIFwiLi4vYWRkcmVzcy9pbmRleC5qc1wiO1xuaW1wb3J0IHsgU2lnbmF0dXJlIH0gZnJvbSBcIi4uL2NyeXB0by9pbmRleC5qc1wiO1xuaW1wb3J0IHsgYWNjZXNzTGlzdGlmeSB9IGZyb20gXCIuLi90cmFuc2FjdGlvbi9pbmRleC5qc1wiO1xuaW1wb3J0IHsgZ2V0QmlnSW50LCBnZXROdW1iZXIsIGhleGxpZnksIGlzSGV4U3RyaW5nLCB6ZXJvUGFkVmFsdWUsIGFzc2VydCwgYXNzZXJ0QXJndW1lbnQgfSBmcm9tIFwiLi4vdXRpbHMvaW5kZXguanNcIjtcbmNvbnN0IEJOXzAgPSBCaWdJbnQoMCk7XG5leHBvcnQgZnVuY3Rpb24gYWxsb3dOdWxsKGZvcm1hdCwgbnVsbFZhbHVlKSB7XG4gICAgcmV0dXJuIChmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsVmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZvcm1hdCh2YWx1ZSk7XG4gICAgfSk7XG59XG5leHBvcnQgZnVuY3Rpb24gYXJyYXlPZihmb3JtYXQsIGFsbG93TnVsbCkge1xuICAgIHJldHVybiAoKGFycmF5KSA9PiB7XG4gICAgICAgIGlmIChhbGxvd051bGwgJiYgYXJyYXkgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGFycmF5KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibm90IGFuIGFycmF5XCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhcnJheS5tYXAoKGkpID0+IGZvcm1hdChpKSk7XG4gICAgfSk7XG59XG4vLyBSZXF1aXJlcyBhbiBvYmplY3Qgd2hpY2ggbWF0Y2hlcyBhIGZsZWV0IG9mIG90aGVyIGZvcm1hdHRlcnNcbi8vIEFueSBGb3JtYXRGdW5jIG1heSByZXR1cm4gYHVuZGVmaW5lZGAgdG8gaGF2ZSB0aGUgdmFsdWUgb21pdHRlZFxuLy8gZnJvbSB0aGUgcmVzdWx0IG9iamVjdC4gQ2FsbHMgcHJlc2VydmUgYHRoaXNgLlxuZXhwb3J0IGZ1bmN0aW9uIG9iamVjdChmb3JtYXQsIGFsdE5hbWVzKSB7XG4gICAgcmV0dXJuICgodmFsdWUpID0+IHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0ge307XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIGZvcm1hdCkge1xuICAgICAgICAgICAgbGV0IHNyY0tleSA9IGtleTtcbiAgICAgICAgICAgIGlmIChhbHROYW1lcyAmJiBrZXkgaW4gYWx0TmFtZXMgJiYgIShzcmNLZXkgaW4gdmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBhbHRLZXkgb2YgYWx0TmFtZXNba2V5XSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYWx0S2V5IGluIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzcmNLZXkgPSBhbHRLZXk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbnYgPSBmb3JtYXRba2V5XSh2YWx1ZVtzcmNLZXldKTtcbiAgICAgICAgICAgICAgICBpZiAobnYgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRba2V5XSA9IG52O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2UgPSAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikgPyBlcnJvci5tZXNzYWdlIDogXCJub3QtYW4tZXJyb3JcIjtcbiAgICAgICAgICAgICAgICBhc3NlcnQoZmFsc2UsIGBpbnZhbGlkIHZhbHVlIGZvciB2YWx1ZS4ke2tleX0gKCR7bWVzc2FnZX0pYCwgXCJCQURfREFUQVwiLCB7IHZhbHVlIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSk7XG59XG5leHBvcnQgZnVuY3Rpb24gZm9ybWF0Qm9vbGVhbih2YWx1ZSkge1xuICAgIHN3aXRjaCAodmFsdWUpIHtcbiAgICAgICAgY2FzZSB0cnVlOlxuICAgICAgICBjYXNlIFwidHJ1ZVwiOlxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGNhc2UgZmFsc2U6XG4gICAgICAgIGNhc2UgXCJmYWxzZVwiOlxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBhc3NlcnRBcmd1bWVudChmYWxzZSwgYGludmFsaWQgYm9vbGVhbjsgJHtKU09OLnN0cmluZ2lmeSh2YWx1ZSl9YCwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG59XG5leHBvcnQgZnVuY3Rpb24gZm9ybWF0RGF0YSh2YWx1ZSkge1xuICAgIGFzc2VydEFyZ3VtZW50KGlzSGV4U3RyaW5nKHZhbHVlLCB0cnVlKSwgXCJpbnZhbGlkIGRhdGFcIiwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG4gICAgcmV0dXJuIHZhbHVlO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGZvcm1hdEhhc2godmFsdWUpIHtcbiAgICBhc3NlcnRBcmd1bWVudChpc0hleFN0cmluZyh2YWx1ZSwgMzIpLCBcImludmFsaWQgaGFzaFwiLCBcInZhbHVlXCIsIHZhbHVlKTtcbiAgICByZXR1cm4gdmFsdWU7XG59XG5leHBvcnQgZnVuY3Rpb24gZm9ybWF0VWludDI1Nih2YWx1ZSkge1xuICAgIGlmICghaXNIZXhTdHJpbmcodmFsdWUpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgdWludDI1NlwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHplcm9QYWRWYWx1ZSh2YWx1ZSwgMzIpO1xufVxuY29uc3QgX2Zvcm1hdExvZyA9IG9iamVjdCh7XG4gICAgYWRkcmVzczogZ2V0QWRkcmVzcyxcbiAgICBibG9ja0hhc2g6IGZvcm1hdEhhc2gsXG4gICAgYmxvY2tOdW1iZXI6IGdldE51bWJlcixcbiAgICBkYXRhOiBmb3JtYXREYXRhLFxuICAgIGluZGV4OiBnZXROdW1iZXIsXG4gICAgcmVtb3ZlZDogYWxsb3dOdWxsKGZvcm1hdEJvb2xlYW4sIGZhbHNlKSxcbiAgICB0b3BpY3M6IGFycmF5T2YoZm9ybWF0SGFzaCksXG4gICAgdHJhbnNhY3Rpb25IYXNoOiBmb3JtYXRIYXNoLFxuICAgIHRyYW5zYWN0aW9uSW5kZXg6IGdldE51bWJlcixcbn0sIHtcbiAgICBpbmRleDogW1wibG9nSW5kZXhcIl1cbn0pO1xuZXhwb3J0IGZ1bmN0aW9uIGZvcm1hdExvZyh2YWx1ZSkge1xuICAgIHJldHVybiBfZm9ybWF0TG9nKHZhbHVlKTtcbn1cbmNvbnN0IF9mb3JtYXRCbG9jayA9IG9iamVjdCh7XG4gICAgaGFzaDogYWxsb3dOdWxsKGZvcm1hdEhhc2gpLFxuICAgIHBhcmVudEhhc2g6IGZvcm1hdEhhc2gsXG4gICAgcGFyZW50QmVhY29uQmxvY2tSb290OiBhbGxvd051bGwoZm9ybWF0SGFzaCwgbnVsbCksXG4gICAgbnVtYmVyOiBnZXROdW1iZXIsXG4gICAgdGltZXN0YW1wOiBnZXROdW1iZXIsXG4gICAgbm9uY2U6IGFsbG93TnVsbChmb3JtYXREYXRhKSxcbiAgICBkaWZmaWN1bHR5OiBnZXRCaWdJbnQsXG4gICAgZ2FzTGltaXQ6IGdldEJpZ0ludCxcbiAgICBnYXNVc2VkOiBnZXRCaWdJbnQsXG4gICAgc3RhdGVSb290OiBhbGxvd051bGwoZm9ybWF0SGFzaCwgbnVsbCksXG4gICAgcmVjZWlwdHNSb290OiBhbGxvd051bGwoZm9ybWF0SGFzaCwgbnVsbCksXG4gICAgYmxvYkdhc1VzZWQ6IGFsbG93TnVsbChnZXRCaWdJbnQsIG51bGwpLFxuICAgIGV4Y2Vzc0Jsb2JHYXM6IGFsbG93TnVsbChnZXRCaWdJbnQsIG51bGwpLFxuICAgIG1pbmVyOiBhbGxvd051bGwoZ2V0QWRkcmVzcyksXG4gICAgcHJldlJhbmRhbzogYWxsb3dOdWxsKGZvcm1hdEhhc2gsIG51bGwpLFxuICAgIGV4dHJhRGF0YTogZm9ybWF0RGF0YSxcbiAgICBiYXNlRmVlUGVyR2FzOiBhbGxvd051bGwoZ2V0QmlnSW50KVxufSwge1xuICAgIHByZXZSYW5kYW86IFtcIm1peEhhc2hcIl1cbn0pO1xuZXhwb3J0IGZ1bmN0aW9uIGZvcm1hdEJsb2NrKHZhbHVlKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gX2Zvcm1hdEJsb2NrKHZhbHVlKTtcbiAgICByZXN1bHQudHJhbnNhY3Rpb25zID0gdmFsdWUudHJhbnNhY3Rpb25zLm1hcCgodHgpID0+IHtcbiAgICAgICAgaWYgKHR5cGVvZiAodHgpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICByZXR1cm4gdHg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZvcm1hdFRyYW5zYWN0aW9uUmVzcG9uc2UodHgpO1xuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5jb25zdCBfZm9ybWF0UmVjZWlwdExvZyA9IG9iamVjdCh7XG4gICAgdHJhbnNhY3Rpb25JbmRleDogZ2V0TnVtYmVyLFxuICAgIGJsb2NrTnVtYmVyOiBnZXROdW1iZXIsXG4gICAgdHJhbnNhY3Rpb25IYXNoOiBmb3JtYXRIYXNoLFxuICAgIGFkZHJlc3M6IGdldEFkZHJlc3MsXG4gICAgdG9waWNzOiBhcnJheU9mKGZvcm1hdEhhc2gpLFxuICAgIGRhdGE6IGZvcm1hdERhdGEsXG4gICAgaW5kZXg6IGdldE51bWJlcixcbiAgICBibG9ja0hhc2g6IGZvcm1hdEhhc2gsXG59LCB7XG4gICAgaW5kZXg6IFtcImxvZ0luZGV4XCJdXG59KTtcbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXRSZWNlaXB0TG9nKHZhbHVlKSB7XG4gICAgcmV0dXJuIF9mb3JtYXRSZWNlaXB0TG9nKHZhbHVlKTtcbn1cbmNvbnN0IF9mb3JtYXRUcmFuc2FjdGlvblJlY2VpcHQgPSBvYmplY3Qoe1xuICAgIHRvOiBhbGxvd051bGwoZ2V0QWRkcmVzcywgbnVsbCksXG4gICAgZnJvbTogYWxsb3dOdWxsKGdldEFkZHJlc3MsIG51bGwpLFxuICAgIGNvbnRyYWN0QWRkcmVzczogYWxsb3dOdWxsKGdldEFkZHJlc3MsIG51bGwpLFxuICAgIC8vIHNob3VsZCBiZSBhbGxvd051bGwoaGFzaCksIGJ1dCBicm9rZW4tRUlQLTY1OCBzdXBwb3J0IGlzIGhhbmRsZWQgaW4gcmVjZWlwdFxuICAgIGluZGV4OiBnZXROdW1iZXIsXG4gICAgcm9vdDogYWxsb3dOdWxsKGhleGxpZnkpLFxuICAgIGdhc1VzZWQ6IGdldEJpZ0ludCxcbiAgICBibG9iR2FzVXNlZDogYWxsb3dOdWxsKGdldEJpZ0ludCwgbnVsbCksXG4gICAgbG9nc0Jsb29tOiBhbGxvd051bGwoZm9ybWF0RGF0YSksXG4gICAgYmxvY2tIYXNoOiBmb3JtYXRIYXNoLFxuICAgIGhhc2g6IGZvcm1hdEhhc2gsXG4gICAgbG9nczogYXJyYXlPZihmb3JtYXRSZWNlaXB0TG9nKSxcbiAgICBibG9ja051bWJlcjogZ2V0TnVtYmVyLFxuICAgIC8vY29uZmlybWF0aW9uczogYWxsb3dOdWxsKGdldE51bWJlciwgbnVsbCksXG4gICAgY3VtdWxhdGl2ZUdhc1VzZWQ6IGdldEJpZ0ludCxcbiAgICBlZmZlY3RpdmVHYXNQcmljZTogYWxsb3dOdWxsKGdldEJpZ0ludCksXG4gICAgYmxvYkdhc1ByaWNlOiBhbGxvd051bGwoZ2V0QmlnSW50LCBudWxsKSxcbiAgICBzdGF0dXM6IGFsbG93TnVsbChnZXROdW1iZXIpLFxuICAgIHR5cGU6IGFsbG93TnVsbChnZXROdW1iZXIsIDApXG59LCB7XG4gICAgZWZmZWN0aXZlR2FzUHJpY2U6IFtcImdhc1ByaWNlXCJdLFxuICAgIGhhc2g6IFtcInRyYW5zYWN0aW9uSGFzaFwiXSxcbiAgICBpbmRleDogW1widHJhbnNhY3Rpb25JbmRleFwiXSxcbn0pO1xuZXhwb3J0IGZ1bmN0aW9uIGZvcm1hdFRyYW5zYWN0aW9uUmVjZWlwdCh2YWx1ZSkge1xuICAgIHJldHVybiBfZm9ybWF0VHJhbnNhY3Rpb25SZWNlaXB0KHZhbHVlKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXRUcmFuc2FjdGlvblJlc3BvbnNlKHZhbHVlKSB7XG4gICAgLy8gU29tZSBjbGllbnRzIChUZXN0UlBDKSBkbyBzdHJhbmdlIHRoaW5ncyBsaWtlIHJldHVybiAweDAgZm9yIHRoZVxuICAgIC8vIDAgYWRkcmVzczsgY29ycmVjdCB0aGlzIHRvIGJlIGEgcmVhbCBhZGRyZXNzXG4gICAgaWYgKHZhbHVlLnRvICYmIGdldEJpZ0ludCh2YWx1ZS50bykgPT09IEJOXzApIHtcbiAgICAgICAgdmFsdWUudG8gPSBcIjB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMFwiO1xuICAgIH1cbiAgICBjb25zdCByZXN1bHQgPSBvYmplY3Qoe1xuICAgICAgICBoYXNoOiBmb3JtYXRIYXNoLFxuICAgICAgICAvLyBTb21lIG5vZGVzIGRvIG5vdCByZXR1cm4gdGhpcywgdXN1YWxseSB0ZXN0IG5vZGVzIChsaWtlIEdhbmFjaGUpXG4gICAgICAgIGluZGV4OiBhbGxvd051bGwoZ2V0TnVtYmVyLCB1bmRlZmluZWQpLFxuICAgICAgICB0eXBlOiAodmFsdWUpID0+IHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gXCIweFwiIHx8IHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBnZXROdW1iZXIodmFsdWUpO1xuICAgICAgICB9LFxuICAgICAgICBhY2Nlc3NMaXN0OiBhbGxvd051bGwoYWNjZXNzTGlzdGlmeSwgbnVsbCksXG4gICAgICAgIGJsb2JWZXJzaW9uZWRIYXNoZXM6IGFsbG93TnVsbChhcnJheU9mKGZvcm1hdEhhc2gsIHRydWUpLCBudWxsKSxcbiAgICAgICAgYXV0aG9yaXphdGlvbkxpc3Q6IGFsbG93TnVsbChhcnJheU9mKCh2KSA9PiB7XG4gICAgICAgICAgICBsZXQgc2lnO1xuICAgICAgICAgICAgaWYgKHYuc2lnbmF0dXJlKSB7XG4gICAgICAgICAgICAgICAgc2lnID0gdi5zaWduYXR1cmU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgeVBhcml0eSA9IHYueVBhcml0eTtcbiAgICAgICAgICAgICAgICBpZiAoeVBhcml0eSA9PT0gXCIweDFiXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgeVBhcml0eSA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHlQYXJpdHkgPT09IFwiMHgxY1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIHlQYXJpdHkgPSAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzaWcgPSBPYmplY3QuYXNzaWduKHt9LCB2LCB7IHlQYXJpdHkgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGFkZHJlc3M6IGdldEFkZHJlc3Modi5hZGRyZXNzKSxcbiAgICAgICAgICAgICAgICBjaGFpbklkOiBnZXRCaWdJbnQodi5jaGFpbklkKSxcbiAgICAgICAgICAgICAgICBub25jZTogZ2V0QmlnSW50KHYubm9uY2UpLFxuICAgICAgICAgICAgICAgIHNpZ25hdHVyZTogU2lnbmF0dXJlLmZyb20oc2lnKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSwgZmFsc2UpLCBudWxsKSxcbiAgICAgICAgYmxvY2tIYXNoOiBhbGxvd051bGwoZm9ybWF0SGFzaCwgbnVsbCksXG4gICAgICAgIGJsb2NrTnVtYmVyOiBhbGxvd051bGwoZ2V0TnVtYmVyLCBudWxsKSxcbiAgICAgICAgdHJhbnNhY3Rpb25JbmRleDogYWxsb3dOdWxsKGdldE51bWJlciwgbnVsbCksXG4gICAgICAgIGZyb206IGdldEFkZHJlc3MsXG4gICAgICAgIC8vIGVpdGhlciAoZ2FzUHJpY2UpIG9yIChtYXhQcmlvcml0eUZlZVBlckdhcyArIG1heEZlZVBlckdhcykgbXVzdCBiZSBzZXRcbiAgICAgICAgZ2FzUHJpY2U6IGFsbG93TnVsbChnZXRCaWdJbnQpLFxuICAgICAgICBtYXhQcmlvcml0eUZlZVBlckdhczogYWxsb3dOdWxsKGdldEJpZ0ludCksXG4gICAgICAgIG1heEZlZVBlckdhczogYWxsb3dOdWxsKGdldEJpZ0ludCksXG4gICAgICAgIG1heEZlZVBlckJsb2JHYXM6IGFsbG93TnVsbChnZXRCaWdJbnQsIG51bGwpLFxuICAgICAgICBnYXNMaW1pdDogZ2V0QmlnSW50LFxuICAgICAgICB0bzogYWxsb3dOdWxsKGdldEFkZHJlc3MsIG51bGwpLFxuICAgICAgICB2YWx1ZTogZ2V0QmlnSW50LFxuICAgICAgICBub25jZTogZ2V0TnVtYmVyLFxuICAgICAgICBkYXRhOiBmb3JtYXREYXRhLFxuICAgICAgICBjcmVhdGVzOiBhbGxvd051bGwoZ2V0QWRkcmVzcywgbnVsbCksXG4gICAgICAgIGNoYWluSWQ6IGFsbG93TnVsbChnZXRCaWdJbnQsIG51bGwpXG4gICAgfSwge1xuICAgICAgICBkYXRhOiBbXCJpbnB1dFwiXSxcbiAgICAgICAgZ2FzTGltaXQ6IFtcImdhc1wiXSxcbiAgICAgICAgaW5kZXg6IFtcInRyYW5zYWN0aW9uSW5kZXhcIl1cbiAgICB9KSh2YWx1ZSk7XG4gICAgLy8gSWYgdG8gYW5kIGNyZWF0ZXMgYXJlIGVtcHR5LCBwb3B1bGF0ZSB0aGUgY3JlYXRlcyBmcm9tIHRoZSB2YWx1ZVxuICAgIGlmIChyZXN1bHQudG8gPT0gbnVsbCAmJiByZXN1bHQuY3JlYXRlcyA9PSBudWxsKSB7XG4gICAgICAgIHJlc3VsdC5jcmVhdGVzID0gZ2V0Q3JlYXRlQWRkcmVzcyhyZXN1bHQpO1xuICAgIH1cbiAgICAvLyBAVE9ETzogQ2hlY2sgZmVlIGRhdGFcbiAgICAvLyBBZGQgYW4gYWNjZXNzIGxpc3QgdG8gc3VwcG9ydGVkIHRyYW5zYWN0aW9uIHR5cGVzXG4gICAgaWYgKCh2YWx1ZS50eXBlID09PSAxIHx8IHZhbHVlLnR5cGUgPT09IDIpICYmIHZhbHVlLmFjY2Vzc0xpc3QgPT0gbnVsbCkge1xuICAgICAgICByZXN1bHQuYWNjZXNzTGlzdCA9IFtdO1xuICAgIH1cbiAgICAvLyBDb21wdXRlIHRoZSBzaWduYXR1cmVcbiAgICBpZiAodmFsdWUuc2lnbmF0dXJlKSB7XG4gICAgICAgIHJlc3VsdC5zaWduYXR1cmUgPSBTaWduYXR1cmUuZnJvbSh2YWx1ZS5zaWduYXR1cmUpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmVzdWx0LnNpZ25hdHVyZSA9IFNpZ25hdHVyZS5mcm9tKHZhbHVlKTtcbiAgICB9XG4gICAgLy8gU29tZSBiYWNrZW5kcyBvbWl0IENoYWluSWQgb24gbGVnYWN5IHRyYW5zYWN0aW9ucywgYnV0IHdlIGNhbiBjb21wdXRlIGl0XG4gICAgaWYgKHJlc3VsdC5jaGFpbklkID09IG51bGwpIHtcbiAgICAgICAgY29uc3QgY2hhaW5JZCA9IHJlc3VsdC5zaWduYXR1cmUubGVnYWN5Q2hhaW5JZDtcbiAgICAgICAgaWYgKGNoYWluSWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmVzdWx0LmNoYWluSWQgPSBjaGFpbklkO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIEBUT0RPOiBjaGVjayBjaGFpbklEXG4gICAgLypcbiAgICBpZiAodmFsdWUuY2hhaW5JZCAhPSBudWxsKSB7XG4gICAgICAgIGxldCBjaGFpbklkID0gdmFsdWUuY2hhaW5JZDtcblxuICAgICAgICBpZiAoaXNIZXhTdHJpbmcoY2hhaW5JZCkpIHtcbiAgICAgICAgICAgIGNoYWluSWQgPSBCaWdOdW1iZXIuZnJvbShjaGFpbklkKS50b051bWJlcigpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVzdWx0LmNoYWluSWQgPSBjaGFpbklkO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgICAgbGV0IGNoYWluSWQgPSB2YWx1ZS5uZXR3b3JrSWQ7XG5cbiAgICAgICAgLy8gZ2V0aC1ldGMgcmV0dXJucyBjaGFpbklkXG4gICAgICAgIGlmIChjaGFpbklkID09IG51bGwgJiYgcmVzdWx0LnYgPT0gbnVsbCkge1xuICAgICAgICAgICAgY2hhaW5JZCA9IHZhbHVlLmNoYWluSWQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNIZXhTdHJpbmcoY2hhaW5JZCkpIHtcbiAgICAgICAgICAgIGNoYWluSWQgPSBCaWdOdW1iZXIuZnJvbShjaGFpbklkKS50b051bWJlcigpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZihjaGFpbklkKSAhPT0gXCJudW1iZXJcIiAmJiByZXN1bHQudiAhPSBudWxsKSB7XG4gICAgICAgICAgICBjaGFpbklkID0gKHJlc3VsdC52IC0gMzUpIC8gMjtcbiAgICAgICAgICAgIGlmIChjaGFpbklkIDwgMCkgeyBjaGFpbklkID0gMDsgfVxuICAgICAgICAgICAgY2hhaW5JZCA9IHBhcnNlSW50KGNoYWluSWQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZihjaGFpbklkKSAhPT0gXCJudW1iZXJcIikgeyBjaGFpbklkID0gMDsgfVxuXG4gICAgICAgIHJlc3VsdC5jaGFpbklkID0gY2hhaW5JZDtcbiAgICB9XG4gICAgKi9cbiAgICAvLyAweDAwMDAuLi4gc2hvdWxkIGFjdHVhbGx5IGJlIG51bGxcbiAgICBpZiAocmVzdWx0LmJsb2NrSGFzaCAmJiBnZXRCaWdJbnQocmVzdWx0LmJsb2NrSGFzaCkgPT09IEJOXzApIHtcbiAgICAgICAgcmVzdWx0LmJsb2NrSGFzaCA9IG51bGw7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1mb3JtYXQuanMubWFwIl0sIm5hbWVzIjpbImdldEFkZHJlc3MiLCJnZXRDcmVhdGVBZGRyZXNzIiwiU2lnbmF0dXJlIiwiYWNjZXNzTGlzdGlmeSIsImdldEJpZ0ludCIsImdldE51bWJlciIsImhleGxpZnkiLCJpc0hleFN0cmluZyIsInplcm9QYWRWYWx1ZSIsImFzc2VydCIsImFzc2VydEFyZ3VtZW50IiwiQk5fMCIsIkJpZ0ludCIsImFsbG93TnVsbCIsImZvcm1hdCIsIm51bGxWYWx1ZSIsInZhbHVlIiwiYXJyYXlPZiIsImFycmF5IiwiQXJyYXkiLCJpc0FycmF5IiwiRXJyb3IiLCJtYXAiLCJpIiwib2JqZWN0IiwiYWx0TmFtZXMiLCJyZXN1bHQiLCJrZXkiLCJzcmNLZXkiLCJhbHRLZXkiLCJudiIsInVuZGVmaW5lZCIsImVycm9yIiwibWVzc2FnZSIsImZvcm1hdEJvb2xlYW4iLCJKU09OIiwic3RyaW5naWZ5IiwiZm9ybWF0RGF0YSIsImZvcm1hdEhhc2giLCJmb3JtYXRVaW50MjU2IiwiX2Zvcm1hdExvZyIsImFkZHJlc3MiLCJibG9ja0hhc2giLCJibG9ja051bWJlciIsImRhdGEiLCJpbmRleCIsInJlbW92ZWQiLCJ0b3BpY3MiLCJ0cmFuc2FjdGlvbkhhc2giLCJ0cmFuc2FjdGlvbkluZGV4IiwiZm9ybWF0TG9nIiwiX2Zvcm1hdEJsb2NrIiwiaGFzaCIsInBhcmVudEhhc2giLCJwYXJlbnRCZWFjb25CbG9ja1Jvb3QiLCJudW1iZXIiLCJ0aW1lc3RhbXAiLCJub25jZSIsImRpZmZpY3VsdHkiLCJnYXNMaW1pdCIsImdhc1VzZWQiLCJzdGF0ZVJvb3QiLCJyZWNlaXB0c1Jvb3QiLCJibG9iR2FzVXNlZCIsImV4Y2Vzc0Jsb2JHYXMiLCJtaW5lciIsInByZXZSYW5kYW8iLCJleHRyYURhdGEiLCJiYXNlRmVlUGVyR2FzIiwiZm9ybWF0QmxvY2siLCJ0cmFuc2FjdGlvbnMiLCJ0eCIsImZvcm1hdFRyYW5zYWN0aW9uUmVzcG9uc2UiLCJfZm9ybWF0UmVjZWlwdExvZyIsImZvcm1hdFJlY2VpcHRMb2ciLCJfZm9ybWF0VHJhbnNhY3Rpb25SZWNlaXB0IiwidG8iLCJmcm9tIiwiY29udHJhY3RBZGRyZXNzIiwicm9vdCIsImxvZ3NCbG9vbSIsImxvZ3MiLCJjdW11bGF0aXZlR2FzVXNlZCIsImVmZmVjdGl2ZUdhc1ByaWNlIiwiYmxvYkdhc1ByaWNlIiwic3RhdHVzIiwidHlwZSIsImZvcm1hdFRyYW5zYWN0aW9uUmVjZWlwdCIsImFjY2Vzc0xpc3QiLCJibG9iVmVyc2lvbmVkSGFzaGVzIiwiYXV0aG9yaXphdGlvbkxpc3QiLCJ2Iiwic2lnIiwic2lnbmF0dXJlIiwieVBhcml0eSIsIk9iamVjdCIsImFzc2lnbiIsImNoYWluSWQiLCJnYXNQcmljZSIsIm1heFByaW9yaXR5RmVlUGVyR2FzIiwibWF4RmVlUGVyR2FzIiwibWF4RmVlUGVyQmxvYkdhcyIsImNyZWF0ZXMiLCJsZWdhY3lDaGFpbklkIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.esm/providers/format.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.esm/providers/network.js":
/*!**********************************************************!*\
  !*** ./node_modules/ethers/lib.esm/providers/network.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Network: () => (/* binding */ Network)\n/* harmony export */ });\n/* harmony import */ var _transaction_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../transaction/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/transaction/accesslist.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/maths.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/errors.js\");\n/* harmony import */ var _plugins_network_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./plugins-network.js */ \"(ssr)/./node_modules/ethers/lib.esm/providers/plugins-network.js\");\n/**\n *  A **Network** encapsulates the various properties required to\n *  interact with a specific chain.\n *\n *  @_subsection: api/providers:Networks  [networks]\n */ \n\n\n/* * * *\n// Networks which operation against an L2 can use this plugin to\n// specify how to access L1, for the purpose of resolving ENS,\n// for example.\nexport class LayerOneConnectionPlugin extends NetworkPlugin {\n    readonly provider!: Provider;\n// @TODO: Rename to ChainAccess and allow for connecting to any chain\n    constructor(provider: Provider) {\n        super(\"org.ethers.plugins.layer-one-connection\");\n        defineProperties<LayerOneConnectionPlugin>(this, { provider });\n    }\n\n    clone(): LayerOneConnectionPlugin {\n        return new LayerOneConnectionPlugin(this.provider);\n    }\n}\n*/ const Networks = new Map();\n/**\n *  A **Network** provides access to a chain's properties and allows\n *  for plug-ins to extend functionality.\n */ class Network {\n    #name;\n    #chainId;\n    #plugins;\n    /**\n     *  Creates a new **Network** for %%name%% and %%chainId%%.\n     */ constructor(name, chainId){\n        this.#name = name;\n        this.#chainId = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBigInt)(chainId);\n        this.#plugins = new Map();\n    }\n    /**\n     *  Returns a JSON-compatible representation of a Network.\n     */ toJSON() {\n        return {\n            name: this.name,\n            chainId: String(this.chainId)\n        };\n    }\n    /**\n     *  The network common name.\n     *\n     *  This is the canonical name, as networks migh have multiple\n     *  names.\n     */ get name() {\n        return this.#name;\n    }\n    set name(value) {\n        this.#name = value;\n    }\n    /**\n     *  The network chain ID.\n     */ get chainId() {\n        return this.#chainId;\n    }\n    set chainId(value) {\n        this.#chainId = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBigInt)(value, \"chainId\");\n    }\n    /**\n     *  Returns true if %%other%% matches this network. Any chain ID\n     *  must match, and if no chain ID is present, the name must match.\n     *\n     *  This method does not currently check for additional properties,\n     *  such as ENS address or plug-in compatibility.\n     */ matches(other) {\n        if (other == null) {\n            return false;\n        }\n        if (typeof other === \"string\") {\n            try {\n                return this.chainId === (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBigInt)(other);\n            } catch (error) {}\n            return this.name === other;\n        }\n        if (typeof other === \"number\" || typeof other === \"bigint\") {\n            try {\n                return this.chainId === (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBigInt)(other);\n            } catch (error) {}\n            return false;\n        }\n        if (typeof other === \"object\") {\n            if (other.chainId != null) {\n                try {\n                    return this.chainId === (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBigInt)(other.chainId);\n                } catch (error) {}\n                return false;\n            }\n            if (other.name != null) {\n                return this.name === other.name;\n            }\n            return false;\n        }\n        return false;\n    }\n    /**\n     *  Returns the list of plugins currently attached to this Network.\n     */ get plugins() {\n        return Array.from(this.#plugins.values());\n    }\n    /**\n     *  Attach a new %%plugin%% to this Network. The network name\n     *  must be unique, excluding any fragment.\n     */ attachPlugin(plugin) {\n        if (this.#plugins.get(plugin.name)) {\n            throw new Error(`cannot replace existing plugin: ${plugin.name} `);\n        }\n        this.#plugins.set(plugin.name, plugin.clone());\n        return this;\n    }\n    /**\n     *  Return the plugin, if any, matching %%name%% exactly. Plugins\n     *  with fragments will not be returned unless %%name%% includes\n     *  a fragment.\n     */ getPlugin(name) {\n        return this.#plugins.get(name) || null;\n    }\n    /**\n     *  Gets a list of all plugins that match %%name%%, with otr without\n     *  a fragment.\n     */ getPlugins(basename) {\n        return this.plugins.filter((p)=>p.name.split(\"#\")[0] === basename);\n    }\n    /**\n     *  Create a copy of this Network.\n     */ clone() {\n        const clone = new Network(this.name, this.chainId);\n        this.plugins.forEach((plugin)=>{\n            clone.attachPlugin(plugin.clone());\n        });\n        return clone;\n    }\n    /**\n     *  Compute the intrinsic gas required for a transaction.\n     *\n     *  A GasCostPlugin can be attached to override the default\n     *  values.\n     */ computeIntrinsicGas(tx) {\n        const costs = this.getPlugin(\"org.ethers.plugins.network.GasCost\") || new _plugins_network_js__WEBPACK_IMPORTED_MODULE_1__.GasCostPlugin();\n        let gas = costs.txBase;\n        if (tx.to == null) {\n            gas += costs.txCreate;\n        }\n        if (tx.data) {\n            for(let i = 2; i < tx.data.length; i += 2){\n                if (tx.data.substring(i, i + 2) === \"00\") {\n                    gas += costs.txDataZero;\n                } else {\n                    gas += costs.txDataNonzero;\n                }\n            }\n        }\n        if (tx.accessList) {\n            const accessList = (0,_transaction_index_js__WEBPACK_IMPORTED_MODULE_2__.accessListify)(tx.accessList);\n            for(const addr in accessList){\n                gas += costs.txAccessListAddress + costs.txAccessListStorageKey * accessList[addr].storageKeys.length;\n            }\n        }\n        return gas;\n    }\n    /**\n     *  Returns a new Network for the %%network%% name or chainId.\n     */ static from(network) {\n        injectCommonNetworks();\n        // Default network\n        if (network == null) {\n            return Network.from(\"mainnet\");\n        }\n        // Canonical name or chain ID\n        if (typeof network === \"number\") {\n            network = BigInt(network);\n        }\n        if (typeof network === \"string\" || typeof network === \"bigint\") {\n            const networkFunc = Networks.get(network);\n            if (networkFunc) {\n                return networkFunc();\n            }\n            if (typeof network === \"bigint\") {\n                return new Network(\"unknown\", network);\n            }\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(false, \"unknown network\", \"network\", network);\n        }\n        // Clonable with network-like abilities\n        if (typeof network.clone === \"function\") {\n            const clone = network.clone();\n            //if (typeof(network.name) !== \"string\" || typeof(network.chainId) !== \"number\") {\n            //}\n            return clone;\n        }\n        // Networkish\n        if (typeof network === \"object\") {\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(typeof network.name === \"string\" && typeof network.chainId === \"number\", \"invalid network object name or chainId\", \"network\", network);\n            const custom = new Network(network.name, network.chainId);\n            if (network.ensAddress || network.ensNetwork != null) {\n                custom.attachPlugin(new _plugins_network_js__WEBPACK_IMPORTED_MODULE_1__.EnsPlugin(network.ensAddress, network.ensNetwork));\n            }\n            //if ((<any>network).layerOneConnection) {\n            //    custom.attachPlugin(new LayerOneConnectionPlugin((<any>network).layerOneConnection));\n            //}\n            return custom;\n        }\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(false, \"invalid network\", \"network\", network);\n    }\n    /**\n     *  Register %%nameOrChainId%% with a function which returns\n     *  an instance of a Network representing that chain.\n     */ static register(nameOrChainId, networkFunc) {\n        if (typeof nameOrChainId === \"number\") {\n            nameOrChainId = BigInt(nameOrChainId);\n        }\n        const existing = Networks.get(nameOrChainId);\n        if (existing) {\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(false, `conflicting network for ${JSON.stringify(existing.name)}`, \"nameOrChainId\", nameOrChainId);\n        }\n        Networks.set(nameOrChainId, networkFunc);\n    }\n}\n// We don't want to bring in formatUnits because it is backed by\n// FixedNumber and we want to keep Networks tiny. The values\n// included by the Gas Stations are also IEEE 754 with lots of\n// rounding issues and exceed the strict checks formatUnits has.\nfunction parseUnits(_value, decimals) {\n    const value = String(_value);\n    if (!value.match(/^[0-9.]+$/)) {\n        throw new Error(`invalid gwei value: ${_value}`);\n    }\n    // Break into [ whole, fraction ]\n    const comps = value.split(\".\");\n    if (comps.length === 1) {\n        comps.push(\"\");\n    }\n    // More than 1 decimal point or too many fractional positions\n    if (comps.length !== 2) {\n        throw new Error(`invalid gwei value: ${_value}`);\n    }\n    // Pad the fraction to 9 decimalplaces\n    while(comps[1].length < decimals){\n        comps[1] += \"0\";\n    }\n    // Too many decimals and some non-zero ending, take the ceiling\n    if (comps[1].length > 9) {\n        let frac = BigInt(comps[1].substring(0, 9));\n        if (!comps[1].substring(9).match(/^0+$/)) {\n            frac++;\n        }\n        comps[1] = frac.toString();\n    }\n    return BigInt(comps[0] + comps[1]);\n}\n// Used by Polygon to use a gas station for fee data\nfunction getGasStationPlugin(url) {\n    return new _plugins_network_js__WEBPACK_IMPORTED_MODULE_1__.FetchUrlFeeDataNetworkPlugin(url, async (fetchFeeData, provider, request)=>{\n        // Prevent Cloudflare from blocking our request in node.js\n        request.setHeader(\"User-Agent\", \"ethers\");\n        let response;\n        try {\n            const [_response, _feeData] = await Promise.all([\n                request.send(),\n                fetchFeeData()\n            ]);\n            response = _response;\n            const payload = response.bodyJson.standard;\n            const feeData = {\n                gasPrice: _feeData.gasPrice,\n                maxFeePerGas: parseUnits(payload.maxFee, 9),\n                maxPriorityFeePerGas: parseUnits(payload.maxPriorityFee, 9)\n            };\n            return feeData;\n        } catch (error) {\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assert)(false, `error encountered with polygon gas station (${JSON.stringify(request.url)})`, \"SERVER_ERROR\", {\n                request,\n                response,\n                error\n            });\n        }\n    });\n}\n// See: https://chainlist.org\nlet injected = false;\nfunction injectCommonNetworks() {\n    if (injected) {\n        return;\n    }\n    injected = true;\n    /// Register popular Ethereum networks\n    function registerEth(name, chainId, options) {\n        const func = function() {\n            const network = new Network(name, chainId);\n            // We use 0 to disable ENS\n            if (options.ensNetwork != null) {\n                network.attachPlugin(new _plugins_network_js__WEBPACK_IMPORTED_MODULE_1__.EnsPlugin(null, options.ensNetwork));\n            }\n            network.attachPlugin(new _plugins_network_js__WEBPACK_IMPORTED_MODULE_1__.GasCostPlugin());\n            (options.plugins || []).forEach((plugin)=>{\n                network.attachPlugin(plugin);\n            });\n            return network;\n        };\n        // Register the network by name and chain ID\n        Network.register(name, func);\n        Network.register(chainId, func);\n        if (options.altNames) {\n            options.altNames.forEach((name)=>{\n                Network.register(name, func);\n            });\n        }\n    }\n    registerEth(\"mainnet\", 1, {\n        ensNetwork: 1,\n        altNames: [\n            \"homestead\"\n        ]\n    });\n    registerEth(\"ropsten\", 3, {\n        ensNetwork: 3\n    });\n    registerEth(\"rinkeby\", 4, {\n        ensNetwork: 4\n    });\n    registerEth(\"goerli\", 5, {\n        ensNetwork: 5\n    });\n    registerEth(\"kovan\", 42, {\n        ensNetwork: 42\n    });\n    registerEth(\"sepolia\", 11155111, {\n        ensNetwork: 11155111\n    });\n    registerEth(\"holesky\", 17000, {\n        ensNetwork: 17000\n    });\n    registerEth(\"classic\", 61, {});\n    registerEth(\"classicKotti\", 6, {});\n    registerEth(\"arbitrum\", 42161, {\n        ensNetwork: 1\n    });\n    registerEth(\"arbitrum-goerli\", 421613, {});\n    registerEth(\"arbitrum-sepolia\", 421614, {});\n    registerEth(\"base\", 8453, {\n        ensNetwork: 1\n    });\n    registerEth(\"base-goerli\", 84531, {});\n    registerEth(\"base-sepolia\", 84532, {});\n    registerEth(\"bnb\", 56, {\n        ensNetwork: 1\n    });\n    registerEth(\"bnbt\", 97, {});\n    registerEth(\"linea\", 59144, {\n        ensNetwork: 1\n    });\n    registerEth(\"linea-goerli\", 59140, {});\n    registerEth(\"linea-sepolia\", 59141, {});\n    registerEth(\"matic\", 137, {\n        ensNetwork: 1,\n        plugins: [\n            getGasStationPlugin(\"https://gasstation.polygon.technology/v2\")\n        ]\n    });\n    registerEth(\"matic-amoy\", 80002, {});\n    registerEth(\"matic-mumbai\", 80001, {\n        altNames: [\n            \"maticMumbai\",\n            \"maticmum\"\n        ],\n        plugins: [\n            getGasStationPlugin(\"https://gasstation-testnet.polygon.technology/v2\")\n        ]\n    });\n    registerEth(\"optimism\", 10, {\n        ensNetwork: 1,\n        plugins: []\n    });\n    registerEth(\"optimism-goerli\", 420, {});\n    registerEth(\"optimism-sepolia\", 11155420, {});\n    registerEth(\"xdai\", 100, {\n        ensNetwork: 1\n    });\n} //# sourceMappingURL=network.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vcHJvdmlkZXJzL25ldHdvcmsuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTs7Ozs7Q0FLQyxHQUN1RDtBQUNjO0FBQ3dCO0FBQzlGOzs7Ozs7Ozs7Ozs7Ozs7O0FBZ0JBLEdBQ0EsTUFBTU8sV0FBVyxJQUFJQztBQUNyQjs7O0NBR0MsR0FDTSxNQUFNQztJQUNULENBQUNDLElBQUksQ0FBQztJQUNOLENBQUNDLE9BQU8sQ0FBQztJQUNULENBQUNDLE9BQU8sQ0FBQztJQUNUOztLQUVDLEdBQ0RDLFlBQVlILElBQUksRUFBRUMsT0FBTyxDQUFFO1FBQ3ZCLElBQUksQ0FBQyxDQUFDRCxJQUFJLEdBQUdBO1FBQ2IsSUFBSSxDQUFDLENBQUNDLE9BQU8sR0FBR1YsMERBQVNBLENBQUNVO1FBQzFCLElBQUksQ0FBQyxDQUFDQyxPQUFPLEdBQUcsSUFBSUo7SUFDeEI7SUFDQTs7S0FFQyxHQUNETSxTQUFTO1FBQ0wsT0FBTztZQUFFSixNQUFNLElBQUksQ0FBQ0EsSUFBSTtZQUFFQyxTQUFTSSxPQUFPLElBQUksQ0FBQ0osT0FBTztRQUFFO0lBQzVEO0lBQ0E7Ozs7O0tBS0MsR0FDRCxJQUFJRCxPQUFPO1FBQUUsT0FBTyxJQUFJLENBQUMsQ0FBQ0EsSUFBSTtJQUFFO0lBQ2hDLElBQUlBLEtBQUtNLEtBQUssRUFBRTtRQUFFLElBQUksQ0FBQyxDQUFDTixJQUFJLEdBQUdNO0lBQU87SUFDdEM7O0tBRUMsR0FDRCxJQUFJTCxVQUFVO1FBQUUsT0FBTyxJQUFJLENBQUMsQ0FBQ0EsT0FBTztJQUFFO0lBQ3RDLElBQUlBLFFBQVFLLEtBQUssRUFBRTtRQUFFLElBQUksQ0FBQyxDQUFDTCxPQUFPLEdBQUdWLDBEQUFTQSxDQUFDZSxPQUFPO0lBQVk7SUFDbEU7Ozs7OztLQU1DLEdBQ0RDLFFBQVFDLEtBQUssRUFBRTtRQUNYLElBQUlBLFNBQVMsTUFBTTtZQUNmLE9BQU87UUFDWDtRQUNBLElBQUksT0FBUUEsVUFBVyxVQUFVO1lBQzdCLElBQUk7Z0JBQ0EsT0FBUSxJQUFJLENBQUNQLE9BQU8sS0FBS1YsMERBQVNBLENBQUNpQjtZQUN2QyxFQUNBLE9BQU9DLE9BQU8sQ0FBRTtZQUNoQixPQUFRLElBQUksQ0FBQ1QsSUFBSSxLQUFLUTtRQUMxQjtRQUNBLElBQUksT0FBUUEsVUFBVyxZQUFZLE9BQVFBLFVBQVcsVUFBVTtZQUM1RCxJQUFJO2dCQUNBLE9BQVEsSUFBSSxDQUFDUCxPQUFPLEtBQUtWLDBEQUFTQSxDQUFDaUI7WUFDdkMsRUFDQSxPQUFPQyxPQUFPLENBQUU7WUFDaEIsT0FBTztRQUNYO1FBQ0EsSUFBSSxPQUFRRCxVQUFXLFVBQVU7WUFDN0IsSUFBSUEsTUFBTVAsT0FBTyxJQUFJLE1BQU07Z0JBQ3ZCLElBQUk7b0JBQ0EsT0FBUSxJQUFJLENBQUNBLE9BQU8sS0FBS1YsMERBQVNBLENBQUNpQixNQUFNUCxPQUFPO2dCQUNwRCxFQUNBLE9BQU9RLE9BQU8sQ0FBRTtnQkFDaEIsT0FBTztZQUNYO1lBQ0EsSUFBSUQsTUFBTVIsSUFBSSxJQUFJLE1BQU07Z0JBQ3BCLE9BQVEsSUFBSSxDQUFDQSxJQUFJLEtBQUtRLE1BQU1SLElBQUk7WUFDcEM7WUFDQSxPQUFPO1FBQ1g7UUFDQSxPQUFPO0lBQ1g7SUFDQTs7S0FFQyxHQUNELElBQUlFLFVBQVU7UUFDVixPQUFPUSxNQUFNQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUNULE9BQU8sQ0FBQ1UsTUFBTTtJQUMxQztJQUNBOzs7S0FHQyxHQUNEQyxhQUFhQyxNQUFNLEVBQUU7UUFDakIsSUFBSSxJQUFJLENBQUMsQ0FBQ1osT0FBTyxDQUFDYSxHQUFHLENBQUNELE9BQU9kLElBQUksR0FBRztZQUNoQyxNQUFNLElBQUlnQixNQUFNLENBQUMsZ0NBQWdDLEVBQUVGLE9BQU9kLElBQUksQ0FBQyxDQUFDLENBQUM7UUFDckU7UUFDQSxJQUFJLENBQUMsQ0FBQ0UsT0FBTyxDQUFDZSxHQUFHLENBQUNILE9BQU9kLElBQUksRUFBRWMsT0FBT0ksS0FBSztRQUMzQyxPQUFPLElBQUk7SUFDZjtJQUNBOzs7O0tBSUMsR0FDREMsVUFBVW5CLElBQUksRUFBRTtRQUNaLE9BQU8sSUFBSyxDQUFDLENBQUNFLE9BQU8sQ0FBQ2EsR0FBRyxDQUFDZixTQUFVO0lBQ3hDO0lBQ0E7OztLQUdDLEdBQ0RvQixXQUFXQyxRQUFRLEVBQUU7UUFDakIsT0FBUSxJQUFJLENBQUNuQixPQUFPLENBQUNvQixNQUFNLENBQUMsQ0FBQ0MsSUFBT0EsRUFBRXZCLElBQUksQ0FBQ3dCLEtBQUssQ0FBQyxJQUFJLENBQUMsRUFBRSxLQUFLSDtJQUNqRTtJQUNBOztLQUVDLEdBQ0RILFFBQVE7UUFDSixNQUFNQSxRQUFRLElBQUluQixRQUFRLElBQUksQ0FBQ0MsSUFBSSxFQUFFLElBQUksQ0FBQ0MsT0FBTztRQUNqRCxJQUFJLENBQUNDLE9BQU8sQ0FBQ3VCLE9BQU8sQ0FBQyxDQUFDWDtZQUNsQkksTUFBTUwsWUFBWSxDQUFDQyxPQUFPSSxLQUFLO1FBQ25DO1FBQ0EsT0FBT0E7SUFDWDtJQUNBOzs7OztLQUtDLEdBQ0RRLG9CQUFvQkMsRUFBRSxFQUFFO1FBQ3BCLE1BQU1DLFFBQVEsSUFBSSxDQUFDVCxTQUFTLENBQUMseUNBQTBDLElBQUl2Qiw4REFBYUE7UUFDeEYsSUFBSWlDLE1BQU1ELE1BQU1FLE1BQU07UUFDdEIsSUFBSUgsR0FBR0ksRUFBRSxJQUFJLE1BQU07WUFDZkYsT0FBT0QsTUFBTUksUUFBUTtRQUN6QjtRQUNBLElBQUlMLEdBQUdNLElBQUksRUFBRTtZQUNULElBQUssSUFBSUMsSUFBSSxHQUFHQSxJQUFJUCxHQUFHTSxJQUFJLENBQUNFLE1BQU0sRUFBRUQsS0FBSyxFQUFHO2dCQUN4QyxJQUFJUCxHQUFHTSxJQUFJLENBQUNHLFNBQVMsQ0FBQ0YsR0FBR0EsSUFBSSxPQUFPLE1BQU07b0JBQ3RDTCxPQUFPRCxNQUFNUyxVQUFVO2dCQUMzQixPQUNLO29CQUNEUixPQUFPRCxNQUFNVSxhQUFhO2dCQUM5QjtZQUNKO1FBQ0o7UUFDQSxJQUFJWCxHQUFHWSxVQUFVLEVBQUU7WUFDZixNQUFNQSxhQUFhakQsb0VBQWFBLENBQUNxQyxHQUFHWSxVQUFVO1lBQzlDLElBQUssTUFBTUMsUUFBUUQsV0FBWTtnQkFDM0JWLE9BQU9ELE1BQU1hLG1CQUFtQixHQUFHYixNQUFNYyxzQkFBc0IsR0FBR0gsVUFBVSxDQUFDQyxLQUFLLENBQUNHLFdBQVcsQ0FBQ1IsTUFBTTtZQUN6RztRQUNKO1FBQ0EsT0FBT047SUFDWDtJQUNBOztLQUVDLEdBQ0QsT0FBT2xCLEtBQUtpQyxPQUFPLEVBQUU7UUFDakJDO1FBQ0Esa0JBQWtCO1FBQ2xCLElBQUlELFdBQVcsTUFBTTtZQUNqQixPQUFPN0MsUUFBUVksSUFBSSxDQUFDO1FBQ3hCO1FBQ0EsNkJBQTZCO1FBQzdCLElBQUksT0FBUWlDLFlBQWEsVUFBVTtZQUMvQkEsVUFBVUUsT0FBT0Y7UUFDckI7UUFDQSxJQUFJLE9BQVFBLFlBQWEsWUFBWSxPQUFRQSxZQUFhLFVBQVU7WUFDaEUsTUFBTUcsY0FBY2xELFNBQVNrQixHQUFHLENBQUM2QjtZQUNqQyxJQUFJRyxhQUFhO2dCQUNiLE9BQU9BO1lBQ1g7WUFDQSxJQUFJLE9BQVFILFlBQWEsVUFBVTtnQkFDL0IsT0FBTyxJQUFJN0MsUUFBUSxXQUFXNkM7WUFDbEM7WUFDQW5ELCtEQUFjQSxDQUFDLE9BQU8sbUJBQW1CLFdBQVdtRDtRQUN4RDtRQUNBLHVDQUF1QztRQUN2QyxJQUFJLE9BQVFBLFFBQVExQixLQUFLLEtBQU0sWUFBWTtZQUN2QyxNQUFNQSxRQUFRMEIsUUFBUTFCLEtBQUs7WUFDM0Isa0ZBQWtGO1lBQ2xGLEdBQUc7WUFDSCxPQUFPQTtRQUNYO1FBQ0EsYUFBYTtRQUNiLElBQUksT0FBUTBCLFlBQWEsVUFBVTtZQUMvQm5ELCtEQUFjQSxDQUFDLE9BQVFtRCxRQUFRNUMsSUFBSSxLQUFNLFlBQVksT0FBUTRDLFFBQVEzQyxPQUFPLEtBQU0sVUFBVSwwQ0FBMEMsV0FBVzJDO1lBQ2pKLE1BQU1JLFNBQVMsSUFBSWpELFFBQVM2QyxRQUFRNUMsSUFBSSxFQUFJNEMsUUFBUTNDLE9BQU87WUFDM0QsSUFBSTJDLFFBQVFLLFVBQVUsSUFBSUwsUUFBUU0sVUFBVSxJQUFJLE1BQU07Z0JBQ2xERixPQUFPbkMsWUFBWSxDQUFDLElBQUluQiwwREFBU0EsQ0FBQ2tELFFBQVFLLFVBQVUsRUFBRUwsUUFBUU0sVUFBVTtZQUM1RTtZQUNBLDBDQUEwQztZQUMxQywyRkFBMkY7WUFDM0YsR0FBRztZQUNILE9BQU9GO1FBQ1g7UUFDQXZELCtEQUFjQSxDQUFDLE9BQU8sbUJBQW1CLFdBQVdtRDtJQUN4RDtJQUNBOzs7S0FHQyxHQUNELE9BQU9PLFNBQVNDLGFBQWEsRUFBRUwsV0FBVyxFQUFFO1FBQ3hDLElBQUksT0FBUUssa0JBQW1CLFVBQVU7WUFDckNBLGdCQUFnQk4sT0FBT007UUFDM0I7UUFDQSxNQUFNQyxXQUFXeEQsU0FBU2tCLEdBQUcsQ0FBQ3FDO1FBQzlCLElBQUlDLFVBQVU7WUFDVjVELCtEQUFjQSxDQUFDLE9BQU8sQ0FBQyx3QkFBd0IsRUFBRTZELEtBQUtDLFNBQVMsQ0FBQ0YsU0FBU3JELElBQUksRUFBRSxDQUFDLEVBQUUsaUJBQWlCb0Q7UUFDdkc7UUFDQXZELFNBQVNvQixHQUFHLENBQUNtQyxlQUFlTDtJQUNoQztBQUNKO0FBQ0EsZ0VBQWdFO0FBQ2hFLDREQUE0RDtBQUM1RCw4REFBOEQ7QUFDOUQsZ0VBQWdFO0FBQ2hFLFNBQVNTLFdBQVdDLE1BQU0sRUFBRUMsUUFBUTtJQUNoQyxNQUFNcEQsUUFBUUQsT0FBT29EO0lBQ3JCLElBQUksQ0FBQ25ELE1BQU1xRCxLQUFLLENBQUMsY0FBYztRQUMzQixNQUFNLElBQUkzQyxNQUFNLENBQUMsb0JBQW9CLEVBQUV5QyxPQUFPLENBQUM7SUFDbkQ7SUFDQSxpQ0FBaUM7SUFDakMsTUFBTUcsUUFBUXRELE1BQU1rQixLQUFLLENBQUM7SUFDMUIsSUFBSW9DLE1BQU16QixNQUFNLEtBQUssR0FBRztRQUNwQnlCLE1BQU1DLElBQUksQ0FBQztJQUNmO0lBQ0EsNkRBQTZEO0lBQzdELElBQUlELE1BQU16QixNQUFNLEtBQUssR0FBRztRQUNwQixNQUFNLElBQUluQixNQUFNLENBQUMsb0JBQW9CLEVBQUV5QyxPQUFPLENBQUM7SUFDbkQ7SUFDQSxzQ0FBc0M7SUFDdEMsTUFBT0csS0FBSyxDQUFDLEVBQUUsQ0FBQ3pCLE1BQU0sR0FBR3VCLFNBQVU7UUFDL0JFLEtBQUssQ0FBQyxFQUFFLElBQUk7SUFDaEI7SUFDQSwrREFBK0Q7SUFDL0QsSUFBSUEsS0FBSyxDQUFDLEVBQUUsQ0FBQ3pCLE1BQU0sR0FBRyxHQUFHO1FBQ3JCLElBQUkyQixPQUFPaEIsT0FBT2MsS0FBSyxDQUFDLEVBQUUsQ0FBQ3hCLFNBQVMsQ0FBQyxHQUFHO1FBQ3hDLElBQUksQ0FBQ3dCLEtBQUssQ0FBQyxFQUFFLENBQUN4QixTQUFTLENBQUMsR0FBR3VCLEtBQUssQ0FBQyxTQUFTO1lBQ3RDRztRQUNKO1FBQ0FGLEtBQUssQ0FBQyxFQUFFLEdBQUdFLEtBQUtDLFFBQVE7SUFDNUI7SUFDQSxPQUFPakIsT0FBT2MsS0FBSyxDQUFDLEVBQUUsR0FBR0EsS0FBSyxDQUFDLEVBQUU7QUFDckM7QUFDQSxvREFBb0Q7QUFDcEQsU0FBU0ksb0JBQW9CQyxHQUFHO0lBQzVCLE9BQU8sSUFBSXRFLDZFQUE0QkEsQ0FBQ3NFLEtBQUssT0FBT0MsY0FBY0MsVUFBVUM7UUFDeEUsMERBQTBEO1FBQzFEQSxRQUFRQyxTQUFTLENBQUMsY0FBYztRQUNoQyxJQUFJQztRQUNKLElBQUk7WUFDQSxNQUFNLENBQUNDLFdBQVdDLFNBQVMsR0FBRyxNQUFNQyxRQUFRQyxHQUFHLENBQUM7Z0JBQzVDTixRQUFRTyxJQUFJO2dCQUFJVDthQUNuQjtZQUNESSxXQUFXQztZQUNYLE1BQU1LLFVBQVVOLFNBQVNPLFFBQVEsQ0FBQ0MsUUFBUTtZQUMxQyxNQUFNQyxVQUFVO2dCQUNaQyxVQUFVUixTQUFTUSxRQUFRO2dCQUMzQkMsY0FBY3pCLFdBQVdvQixRQUFRTSxNQUFNLEVBQUU7Z0JBQ3pDQyxzQkFBc0IzQixXQUFXb0IsUUFBUVEsY0FBYyxFQUFFO1lBQzdEO1lBQ0EsT0FBT0w7UUFDWCxFQUNBLE9BQU90RSxPQUFPO1lBQ1ZqQix1REFBTUEsQ0FBQyxPQUFPLENBQUMsNENBQTRDLEVBQUU4RCxLQUFLQyxTQUFTLENBQUNhLFFBQVFILEdBQUcsRUFBRSxDQUFDLENBQUMsRUFBRSxnQkFBZ0I7Z0JBQUVHO2dCQUFTRTtnQkFBVTdEO1lBQU07UUFDNUk7SUFDSjtBQUNKO0FBQ0EsNkJBQTZCO0FBQzdCLElBQUk0RSxXQUFXO0FBQ2YsU0FBU3hDO0lBQ0wsSUFBSXdDLFVBQVU7UUFDVjtJQUNKO0lBQ0FBLFdBQVc7SUFDWCxzQ0FBc0M7SUFDdEMsU0FBU0MsWUFBWXRGLElBQUksRUFBRUMsT0FBTyxFQUFFc0YsT0FBTztRQUN2QyxNQUFNQyxPQUFPO1lBQ1QsTUFBTTVDLFVBQVUsSUFBSTdDLFFBQVFDLE1BQU1DO1lBQ2xDLDBCQUEwQjtZQUMxQixJQUFJc0YsUUFBUXJDLFVBQVUsSUFBSSxNQUFNO2dCQUM1Qk4sUUFBUS9CLFlBQVksQ0FBQyxJQUFJbkIsMERBQVNBLENBQUMsTUFBTTZGLFFBQVFyQyxVQUFVO1lBQy9EO1lBQ0FOLFFBQVEvQixZQUFZLENBQUMsSUFBSWpCLDhEQUFhQTtZQUNyQzJGLENBQUFBLFFBQVFyRixPQUFPLElBQUksRUFBRSxFQUFFdUIsT0FBTyxDQUFDLENBQUNYO2dCQUM3QjhCLFFBQVEvQixZQUFZLENBQUNDO1lBQ3pCO1lBQ0EsT0FBTzhCO1FBQ1g7UUFDQSw0Q0FBNEM7UUFDNUM3QyxRQUFRb0QsUUFBUSxDQUFDbkQsTUFBTXdGO1FBQ3ZCekYsUUFBUW9ELFFBQVEsQ0FBQ2xELFNBQVN1RjtRQUMxQixJQUFJRCxRQUFRRSxRQUFRLEVBQUU7WUFDbEJGLFFBQVFFLFFBQVEsQ0FBQ2hFLE9BQU8sQ0FBQyxDQUFDekI7Z0JBQ3RCRCxRQUFRb0QsUUFBUSxDQUFDbkQsTUFBTXdGO1lBQzNCO1FBQ0o7SUFDSjtJQUNBRixZQUFZLFdBQVcsR0FBRztRQUFFcEMsWUFBWTtRQUFHdUMsVUFBVTtZQUFDO1NBQVk7SUFBQztJQUNuRUgsWUFBWSxXQUFXLEdBQUc7UUFBRXBDLFlBQVk7SUFBRTtJQUMxQ29DLFlBQVksV0FBVyxHQUFHO1FBQUVwQyxZQUFZO0lBQUU7SUFDMUNvQyxZQUFZLFVBQVUsR0FBRztRQUFFcEMsWUFBWTtJQUFFO0lBQ3pDb0MsWUFBWSxTQUFTLElBQUk7UUFBRXBDLFlBQVk7SUFBRztJQUMxQ29DLFlBQVksV0FBVyxVQUFVO1FBQUVwQyxZQUFZO0lBQVM7SUFDeERvQyxZQUFZLFdBQVcsT0FBTztRQUFFcEMsWUFBWTtJQUFNO0lBQ2xEb0MsWUFBWSxXQUFXLElBQUksQ0FBQztJQUM1QkEsWUFBWSxnQkFBZ0IsR0FBRyxDQUFDO0lBQ2hDQSxZQUFZLFlBQVksT0FBTztRQUMzQnBDLFlBQVk7SUFDaEI7SUFDQW9DLFlBQVksbUJBQW1CLFFBQVEsQ0FBQztJQUN4Q0EsWUFBWSxvQkFBb0IsUUFBUSxDQUFDO0lBQ3pDQSxZQUFZLFFBQVEsTUFBTTtRQUFFcEMsWUFBWTtJQUFFO0lBQzFDb0MsWUFBWSxlQUFlLE9BQU8sQ0FBQztJQUNuQ0EsWUFBWSxnQkFBZ0IsT0FBTyxDQUFDO0lBQ3BDQSxZQUFZLE9BQU8sSUFBSTtRQUFFcEMsWUFBWTtJQUFFO0lBQ3ZDb0MsWUFBWSxRQUFRLElBQUksQ0FBQztJQUN6QkEsWUFBWSxTQUFTLE9BQU87UUFBRXBDLFlBQVk7SUFBRTtJQUM1Q29DLFlBQVksZ0JBQWdCLE9BQU8sQ0FBQztJQUNwQ0EsWUFBWSxpQkFBaUIsT0FBTyxDQUFDO0lBQ3JDQSxZQUFZLFNBQVMsS0FBSztRQUN0QnBDLFlBQVk7UUFDWmhELFNBQVM7WUFDTDhELG9CQUFvQjtTQUN2QjtJQUNMO0lBQ0FzQixZQUFZLGNBQWMsT0FBTyxDQUFDO0lBQ2xDQSxZQUFZLGdCQUFnQixPQUFPO1FBQy9CRyxVQUFVO1lBQUM7WUFBZTtTQUFXO1FBQ3JDdkYsU0FBUztZQUNMOEQsb0JBQW9CO1NBQ3ZCO0lBQ0w7SUFDQXNCLFlBQVksWUFBWSxJQUFJO1FBQ3hCcEMsWUFBWTtRQUNaaEQsU0FBUyxFQUFFO0lBQ2Y7SUFDQW9GLFlBQVksbUJBQW1CLEtBQUssQ0FBQztJQUNyQ0EsWUFBWSxvQkFBb0IsVUFBVSxDQUFDO0lBQzNDQSxZQUFZLFFBQVEsS0FBSztRQUFFcEMsWUFBWTtJQUFFO0FBQzdDLEVBQ0EsbUNBQW1DIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbWVnYXZpYmUtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vcHJvdmlkZXJzL25ldHdvcmsuanM/MzgxYSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqICBBICoqTmV0d29yayoqIGVuY2Fwc3VsYXRlcyB0aGUgdmFyaW91cyBwcm9wZXJ0aWVzIHJlcXVpcmVkIHRvXG4gKiAgaW50ZXJhY3Qgd2l0aCBhIHNwZWNpZmljIGNoYWluLlxuICpcbiAqICBAX3N1YnNlY3Rpb246IGFwaS9wcm92aWRlcnM6TmV0d29ya3MgIFtuZXR3b3Jrc11cbiAqL1xuaW1wb3J0IHsgYWNjZXNzTGlzdGlmeSB9IGZyb20gXCIuLi90cmFuc2FjdGlvbi9pbmRleC5qc1wiO1xuaW1wb3J0IHsgZ2V0QmlnSW50LCBhc3NlcnQsIGFzc2VydEFyZ3VtZW50IH0gZnJvbSBcIi4uL3V0aWxzL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBFbnNQbHVnaW4sIEZldGNoVXJsRmVlRGF0YU5ldHdvcmtQbHVnaW4sIEdhc0Nvc3RQbHVnaW4gfSBmcm9tIFwiLi9wbHVnaW5zLW5ldHdvcmsuanNcIjtcbi8qICogKiAqXG4vLyBOZXR3b3JrcyB3aGljaCBvcGVyYXRpb24gYWdhaW5zdCBhbiBMMiBjYW4gdXNlIHRoaXMgcGx1Z2luIHRvXG4vLyBzcGVjaWZ5IGhvdyB0byBhY2Nlc3MgTDEsIGZvciB0aGUgcHVycG9zZSBvZiByZXNvbHZpbmcgRU5TLFxuLy8gZm9yIGV4YW1wbGUuXG5leHBvcnQgY2xhc3MgTGF5ZXJPbmVDb25uZWN0aW9uUGx1Z2luIGV4dGVuZHMgTmV0d29ya1BsdWdpbiB7XG4gICAgcmVhZG9ubHkgcHJvdmlkZXIhOiBQcm92aWRlcjtcbi8vIEBUT0RPOiBSZW5hbWUgdG8gQ2hhaW5BY2Nlc3MgYW5kIGFsbG93IGZvciBjb25uZWN0aW5nIHRvIGFueSBjaGFpblxuICAgIGNvbnN0cnVjdG9yKHByb3ZpZGVyOiBQcm92aWRlcikge1xuICAgICAgICBzdXBlcihcIm9yZy5ldGhlcnMucGx1Z2lucy5sYXllci1vbmUtY29ubmVjdGlvblwiKTtcbiAgICAgICAgZGVmaW5lUHJvcGVydGllczxMYXllck9uZUNvbm5lY3Rpb25QbHVnaW4+KHRoaXMsIHsgcHJvdmlkZXIgfSk7XG4gICAgfVxuXG4gICAgY2xvbmUoKTogTGF5ZXJPbmVDb25uZWN0aW9uUGx1Z2luIHtcbiAgICAgICAgcmV0dXJuIG5ldyBMYXllck9uZUNvbm5lY3Rpb25QbHVnaW4odGhpcy5wcm92aWRlcik7XG4gICAgfVxufVxuKi9cbmNvbnN0IE5ldHdvcmtzID0gbmV3IE1hcCgpO1xuLyoqXG4gKiAgQSAqKk5ldHdvcmsqKiBwcm92aWRlcyBhY2Nlc3MgdG8gYSBjaGFpbidzIHByb3BlcnRpZXMgYW5kIGFsbG93c1xuICogIGZvciBwbHVnLWlucyB0byBleHRlbmQgZnVuY3Rpb25hbGl0eS5cbiAqL1xuZXhwb3J0IGNsYXNzIE5ldHdvcmsge1xuICAgICNuYW1lO1xuICAgICNjaGFpbklkO1xuICAgICNwbHVnaW5zO1xuICAgIC8qKlxuICAgICAqICBDcmVhdGVzIGEgbmV3ICoqTmV0d29yayoqIGZvciAlJW5hbWUlJSBhbmQgJSVjaGFpbklkJSUuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IobmFtZSwgY2hhaW5JZCkge1xuICAgICAgICB0aGlzLiNuYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy4jY2hhaW5JZCA9IGdldEJpZ0ludChjaGFpbklkKTtcbiAgICAgICAgdGhpcy4jcGx1Z2lucyA9IG5ldyBNYXAoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYSBKU09OLWNvbXBhdGlibGUgcmVwcmVzZW50YXRpb24gb2YgYSBOZXR3b3JrLlxuICAgICAqL1xuICAgIHRvSlNPTigpIHtcbiAgICAgICAgcmV0dXJuIHsgbmFtZTogdGhpcy5uYW1lLCBjaGFpbklkOiBTdHJpbmcodGhpcy5jaGFpbklkKSB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhlIG5ldHdvcmsgY29tbW9uIG5hbWUuXG4gICAgICpcbiAgICAgKiAgVGhpcyBpcyB0aGUgY2Fub25pY2FsIG5hbWUsIGFzIG5ldHdvcmtzIG1pZ2ggaGF2ZSBtdWx0aXBsZVxuICAgICAqICBuYW1lcy5cbiAgICAgKi9cbiAgICBnZXQgbmFtZSgpIHsgcmV0dXJuIHRoaXMuI25hbWU7IH1cbiAgICBzZXQgbmFtZSh2YWx1ZSkgeyB0aGlzLiNuYW1lID0gdmFsdWU7IH1cbiAgICAvKipcbiAgICAgKiAgVGhlIG5ldHdvcmsgY2hhaW4gSUQuXG4gICAgICovXG4gICAgZ2V0IGNoYWluSWQoKSB7IHJldHVybiB0aGlzLiNjaGFpbklkOyB9XG4gICAgc2V0IGNoYWluSWQodmFsdWUpIHsgdGhpcy4jY2hhaW5JZCA9IGdldEJpZ0ludCh2YWx1ZSwgXCJjaGFpbklkXCIpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdHJ1ZSBpZiAlJW90aGVyJSUgbWF0Y2hlcyB0aGlzIG5ldHdvcmsuIEFueSBjaGFpbiBJRFxuICAgICAqICBtdXN0IG1hdGNoLCBhbmQgaWYgbm8gY2hhaW4gSUQgaXMgcHJlc2VudCwgdGhlIG5hbWUgbXVzdCBtYXRjaC5cbiAgICAgKlxuICAgICAqICBUaGlzIG1ldGhvZCBkb2VzIG5vdCBjdXJyZW50bHkgY2hlY2sgZm9yIGFkZGl0aW9uYWwgcHJvcGVydGllcyxcbiAgICAgKiAgc3VjaCBhcyBFTlMgYWRkcmVzcyBvciBwbHVnLWluIGNvbXBhdGliaWxpdHkuXG4gICAgICovXG4gICAgbWF0Y2hlcyhvdGhlcikge1xuICAgICAgICBpZiAob3RoZXIgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgKG90aGVyKSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKHRoaXMuY2hhaW5JZCA9PT0gZ2V0QmlnSW50KG90aGVyKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHsgfVxuICAgICAgICAgICAgcmV0dXJuICh0aGlzLm5hbWUgPT09IG90aGVyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIChvdGhlcikgPT09IFwibnVtYmVyXCIgfHwgdHlwZW9mIChvdGhlcikgPT09IFwiYmlnaW50XCIpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICh0aGlzLmNoYWluSWQgPT09IGdldEJpZ0ludChvdGhlcikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7IH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIChvdGhlcikgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgIGlmIChvdGhlci5jaGFpbklkICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKHRoaXMuY2hhaW5JZCA9PT0gZ2V0QmlnSW50KG90aGVyLmNoYWluSWQpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7IH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob3RoZXIubmFtZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICh0aGlzLm5hbWUgPT09IG90aGVyLm5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdGhlIGxpc3Qgb2YgcGx1Z2lucyBjdXJyZW50bHkgYXR0YWNoZWQgdG8gdGhpcyBOZXR3b3JrLlxuICAgICAqL1xuICAgIGdldCBwbHVnaW5zKCkge1xuICAgICAgICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLiNwbHVnaW5zLnZhbHVlcygpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIEF0dGFjaCBhIG5ldyAlJXBsdWdpbiUlIHRvIHRoaXMgTmV0d29yay4gVGhlIG5ldHdvcmsgbmFtZVxuICAgICAqICBtdXN0IGJlIHVuaXF1ZSwgZXhjbHVkaW5nIGFueSBmcmFnbWVudC5cbiAgICAgKi9cbiAgICBhdHRhY2hQbHVnaW4ocGx1Z2luKSB7XG4gICAgICAgIGlmICh0aGlzLiNwbHVnaW5zLmdldChwbHVnaW4ubmFtZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgY2Fubm90IHJlcGxhY2UgZXhpc3RpbmcgcGx1Z2luOiAke3BsdWdpbi5uYW1lfSBgKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLiNwbHVnaW5zLnNldChwbHVnaW4ubmFtZSwgcGx1Z2luLmNsb25lKCkpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiB0aGUgcGx1Z2luLCBpZiBhbnksIG1hdGNoaW5nICUlbmFtZSUlIGV4YWN0bHkuIFBsdWdpbnNcbiAgICAgKiAgd2l0aCBmcmFnbWVudHMgd2lsbCBub3QgYmUgcmV0dXJuZWQgdW5sZXNzICUlbmFtZSUlIGluY2x1ZGVzXG4gICAgICogIGEgZnJhZ21lbnQuXG4gICAgICovXG4gICAgZ2V0UGx1Z2luKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLiNwbHVnaW5zLmdldChuYW1lKSkgfHwgbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIEdldHMgYSBsaXN0IG9mIGFsbCBwbHVnaW5zIHRoYXQgbWF0Y2ggJSVuYW1lJSUsIHdpdGggb3RyIHdpdGhvdXRcbiAgICAgKiAgYSBmcmFnbWVudC5cbiAgICAgKi9cbiAgICBnZXRQbHVnaW5zKGJhc2VuYW1lKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5wbHVnaW5zLmZpbHRlcigocCkgPT4gKHAubmFtZS5zcGxpdChcIiNcIilbMF0gPT09IGJhc2VuYW1lKSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlIGEgY29weSBvZiB0aGlzIE5ldHdvcmsuXG4gICAgICovXG4gICAgY2xvbmUoKSB7XG4gICAgICAgIGNvbnN0IGNsb25lID0gbmV3IE5ldHdvcmsodGhpcy5uYW1lLCB0aGlzLmNoYWluSWQpO1xuICAgICAgICB0aGlzLnBsdWdpbnMuZm9yRWFjaCgocGx1Z2luKSA9PiB7XG4gICAgICAgICAgICBjbG9uZS5hdHRhY2hQbHVnaW4ocGx1Z2luLmNsb25lKCkpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGNsb25lO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQ29tcHV0ZSB0aGUgaW50cmluc2ljIGdhcyByZXF1aXJlZCBmb3IgYSB0cmFuc2FjdGlvbi5cbiAgICAgKlxuICAgICAqICBBIEdhc0Nvc3RQbHVnaW4gY2FuIGJlIGF0dGFjaGVkIHRvIG92ZXJyaWRlIHRoZSBkZWZhdWx0XG4gICAgICogIHZhbHVlcy5cbiAgICAgKi9cbiAgICBjb21wdXRlSW50cmluc2ljR2FzKHR4KSB7XG4gICAgICAgIGNvbnN0IGNvc3RzID0gdGhpcy5nZXRQbHVnaW4oXCJvcmcuZXRoZXJzLnBsdWdpbnMubmV0d29yay5HYXNDb3N0XCIpIHx8IChuZXcgR2FzQ29zdFBsdWdpbigpKTtcbiAgICAgICAgbGV0IGdhcyA9IGNvc3RzLnR4QmFzZTtcbiAgICAgICAgaWYgKHR4LnRvID09IG51bGwpIHtcbiAgICAgICAgICAgIGdhcyArPSBjb3N0cy50eENyZWF0ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHguZGF0YSkge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDI7IGkgPCB0eC5kYXRhLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR4LmRhdGEuc3Vic3RyaW5nKGksIGkgKyAyKSA9PT0gXCIwMFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGdhcyArPSBjb3N0cy50eERhdGFaZXJvO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZ2FzICs9IGNvc3RzLnR4RGF0YU5vbnplcm87XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0eC5hY2Nlc3NMaXN0KSB7XG4gICAgICAgICAgICBjb25zdCBhY2Nlc3NMaXN0ID0gYWNjZXNzTGlzdGlmeSh0eC5hY2Nlc3NMaXN0KTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgYWRkciBpbiBhY2Nlc3NMaXN0KSB7XG4gICAgICAgICAgICAgICAgZ2FzICs9IGNvc3RzLnR4QWNjZXNzTGlzdEFkZHJlc3MgKyBjb3N0cy50eEFjY2Vzc0xpc3RTdG9yYWdlS2V5ICogYWNjZXNzTGlzdFthZGRyXS5zdG9yYWdlS2V5cy5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGdhcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYSBuZXcgTmV0d29yayBmb3IgdGhlICUlbmV0d29yayUlIG5hbWUgb3IgY2hhaW5JZC5cbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbShuZXR3b3JrKSB7XG4gICAgICAgIGluamVjdENvbW1vbk5ldHdvcmtzKCk7XG4gICAgICAgIC8vIERlZmF1bHQgbmV0d29ya1xuICAgICAgICBpZiAobmV0d29yayA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gTmV0d29yay5mcm9tKFwibWFpbm5ldFwiKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDYW5vbmljYWwgbmFtZSBvciBjaGFpbiBJRFxuICAgICAgICBpZiAodHlwZW9mIChuZXR3b3JrKSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgbmV0d29yayA9IEJpZ0ludChuZXR3b3JrKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIChuZXR3b3JrKSA9PT0gXCJzdHJpbmdcIiB8fCB0eXBlb2YgKG5ldHdvcmspID09PSBcImJpZ2ludFwiKSB7XG4gICAgICAgICAgICBjb25zdCBuZXR3b3JrRnVuYyA9IE5ldHdvcmtzLmdldChuZXR3b3JrKTtcbiAgICAgICAgICAgIGlmIChuZXR3b3JrRnVuYykge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXR3b3JrRnVuYygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiAobmV0d29yaykgPT09IFwiYmlnaW50XCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IE5ldHdvcmsoXCJ1bmtub3duXCIsIG5ldHdvcmspO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoZmFsc2UsIFwidW5rbm93biBuZXR3b3JrXCIsIFwibmV0d29ya1wiLCBuZXR3b3JrKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDbG9uYWJsZSB3aXRoIG5ldHdvcmstbGlrZSBhYmlsaXRpZXNcbiAgICAgICAgaWYgKHR5cGVvZiAobmV0d29yay5jbG9uZSkgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgY29uc3QgY2xvbmUgPSBuZXR3b3JrLmNsb25lKCk7XG4gICAgICAgICAgICAvL2lmICh0eXBlb2YobmV0d29yay5uYW1lKSAhPT0gXCJzdHJpbmdcIiB8fCB0eXBlb2YobmV0d29yay5jaGFpbklkKSAhPT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgLy99XG4gICAgICAgICAgICByZXR1cm4gY2xvbmU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTmV0d29ya2lzaFxuICAgICAgICBpZiAodHlwZW9mIChuZXR3b3JrKSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQodHlwZW9mIChuZXR3b3JrLm5hbWUpID09PSBcInN0cmluZ1wiICYmIHR5cGVvZiAobmV0d29yay5jaGFpbklkKSA9PT0gXCJudW1iZXJcIiwgXCJpbnZhbGlkIG5ldHdvcmsgb2JqZWN0IG5hbWUgb3IgY2hhaW5JZFwiLCBcIm5ldHdvcmtcIiwgbmV0d29yayk7XG4gICAgICAgICAgICBjb25zdCBjdXN0b20gPSBuZXcgTmV0d29yaygobmV0d29yay5uYW1lKSwgKG5ldHdvcmsuY2hhaW5JZCkpO1xuICAgICAgICAgICAgaWYgKG5ldHdvcmsuZW5zQWRkcmVzcyB8fCBuZXR3b3JrLmVuc05ldHdvcmsgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGN1c3RvbS5hdHRhY2hQbHVnaW4obmV3IEVuc1BsdWdpbihuZXR3b3JrLmVuc0FkZHJlc3MsIG5ldHdvcmsuZW5zTmV0d29yaykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy9pZiAoKDxhbnk+bmV0d29yaykubGF5ZXJPbmVDb25uZWN0aW9uKSB7XG4gICAgICAgICAgICAvLyAgICBjdXN0b20uYXR0YWNoUGx1Z2luKG5ldyBMYXllck9uZUNvbm5lY3Rpb25QbHVnaW4oKDxhbnk+bmV0d29yaykubGF5ZXJPbmVDb25uZWN0aW9uKSk7XG4gICAgICAgICAgICAvL31cbiAgICAgICAgICAgIHJldHVybiBjdXN0b207XG4gICAgICAgIH1cbiAgICAgICAgYXNzZXJ0QXJndW1lbnQoZmFsc2UsIFwiaW52YWxpZCBuZXR3b3JrXCIsIFwibmV0d29ya1wiLCBuZXR3b3JrKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJlZ2lzdGVyICUlbmFtZU9yQ2hhaW5JZCUlIHdpdGggYSBmdW5jdGlvbiB3aGljaCByZXR1cm5zXG4gICAgICogIGFuIGluc3RhbmNlIG9mIGEgTmV0d29yayByZXByZXNlbnRpbmcgdGhhdCBjaGFpbi5cbiAgICAgKi9cbiAgICBzdGF0aWMgcmVnaXN0ZXIobmFtZU9yQ2hhaW5JZCwgbmV0d29ya0Z1bmMpIHtcbiAgICAgICAgaWYgKHR5cGVvZiAobmFtZU9yQ2hhaW5JZCkgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgIG5hbWVPckNoYWluSWQgPSBCaWdJbnQobmFtZU9yQ2hhaW5JZCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZXhpc3RpbmcgPSBOZXR3b3Jrcy5nZXQobmFtZU9yQ2hhaW5JZCk7XG4gICAgICAgIGlmIChleGlzdGluZykge1xuICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoZmFsc2UsIGBjb25mbGljdGluZyBuZXR3b3JrIGZvciAke0pTT04uc3RyaW5naWZ5KGV4aXN0aW5nLm5hbWUpfWAsIFwibmFtZU9yQ2hhaW5JZFwiLCBuYW1lT3JDaGFpbklkKTtcbiAgICAgICAgfVxuICAgICAgICBOZXR3b3Jrcy5zZXQobmFtZU9yQ2hhaW5JZCwgbmV0d29ya0Z1bmMpO1xuICAgIH1cbn1cbi8vIFdlIGRvbid0IHdhbnQgdG8gYnJpbmcgaW4gZm9ybWF0VW5pdHMgYmVjYXVzZSBpdCBpcyBiYWNrZWQgYnlcbi8vIEZpeGVkTnVtYmVyIGFuZCB3ZSB3YW50IHRvIGtlZXAgTmV0d29ya3MgdGlueS4gVGhlIHZhbHVlc1xuLy8gaW5jbHVkZWQgYnkgdGhlIEdhcyBTdGF0aW9ucyBhcmUgYWxzbyBJRUVFIDc1NCB3aXRoIGxvdHMgb2Zcbi8vIHJvdW5kaW5nIGlzc3VlcyBhbmQgZXhjZWVkIHRoZSBzdHJpY3QgY2hlY2tzIGZvcm1hdFVuaXRzIGhhcy5cbmZ1bmN0aW9uIHBhcnNlVW5pdHMoX3ZhbHVlLCBkZWNpbWFscykge1xuICAgIGNvbnN0IHZhbHVlID0gU3RyaW5nKF92YWx1ZSk7XG4gICAgaWYgKCF2YWx1ZS5tYXRjaCgvXlswLTkuXSskLykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIGd3ZWkgdmFsdWU6ICR7X3ZhbHVlfWApO1xuICAgIH1cbiAgICAvLyBCcmVhayBpbnRvIFsgd2hvbGUsIGZyYWN0aW9uIF1cbiAgICBjb25zdCBjb21wcyA9IHZhbHVlLnNwbGl0KFwiLlwiKTtcbiAgICBpZiAoY29tcHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIGNvbXBzLnB1c2goXCJcIik7XG4gICAgfVxuICAgIC8vIE1vcmUgdGhhbiAxIGRlY2ltYWwgcG9pbnQgb3IgdG9vIG1hbnkgZnJhY3Rpb25hbCBwb3NpdGlvbnNcbiAgICBpZiAoY29tcHMubGVuZ3RoICE9PSAyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCBnd2VpIHZhbHVlOiAke192YWx1ZX1gKTtcbiAgICB9XG4gICAgLy8gUGFkIHRoZSBmcmFjdGlvbiB0byA5IGRlY2ltYWxwbGFjZXNcbiAgICB3aGlsZSAoY29tcHNbMV0ubGVuZ3RoIDwgZGVjaW1hbHMpIHtcbiAgICAgICAgY29tcHNbMV0gKz0gXCIwXCI7XG4gICAgfVxuICAgIC8vIFRvbyBtYW55IGRlY2ltYWxzIGFuZCBzb21lIG5vbi16ZXJvIGVuZGluZywgdGFrZSB0aGUgY2VpbGluZ1xuICAgIGlmIChjb21wc1sxXS5sZW5ndGggPiA5KSB7XG4gICAgICAgIGxldCBmcmFjID0gQmlnSW50KGNvbXBzWzFdLnN1YnN0cmluZygwLCA5KSk7XG4gICAgICAgIGlmICghY29tcHNbMV0uc3Vic3RyaW5nKDkpLm1hdGNoKC9eMCskLykpIHtcbiAgICAgICAgICAgIGZyYWMrKztcbiAgICAgICAgfVxuICAgICAgICBjb21wc1sxXSA9IGZyYWMudG9TdHJpbmcoKTtcbiAgICB9XG4gICAgcmV0dXJuIEJpZ0ludChjb21wc1swXSArIGNvbXBzWzFdKTtcbn1cbi8vIFVzZWQgYnkgUG9seWdvbiB0byB1c2UgYSBnYXMgc3RhdGlvbiBmb3IgZmVlIGRhdGFcbmZ1bmN0aW9uIGdldEdhc1N0YXRpb25QbHVnaW4odXJsKSB7XG4gICAgcmV0dXJuIG5ldyBGZXRjaFVybEZlZURhdGFOZXR3b3JrUGx1Z2luKHVybCwgYXN5bmMgKGZldGNoRmVlRGF0YSwgcHJvdmlkZXIsIHJlcXVlc3QpID0+IHtcbiAgICAgICAgLy8gUHJldmVudCBDbG91ZGZsYXJlIGZyb20gYmxvY2tpbmcgb3VyIHJlcXVlc3QgaW4gbm9kZS5qc1xuICAgICAgICByZXF1ZXN0LnNldEhlYWRlcihcIlVzZXItQWdlbnRcIiwgXCJldGhlcnNcIik7XG4gICAgICAgIGxldCByZXNwb25zZTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IFtfcmVzcG9uc2UsIF9mZWVEYXRhXSA9IGF3YWl0IFByb21pc2UuYWxsKFtcbiAgICAgICAgICAgICAgICByZXF1ZXN0LnNlbmQoKSwgZmV0Y2hGZWVEYXRhKClcbiAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgcmVzcG9uc2UgPSBfcmVzcG9uc2U7XG4gICAgICAgICAgICBjb25zdCBwYXlsb2FkID0gcmVzcG9uc2UuYm9keUpzb24uc3RhbmRhcmQ7XG4gICAgICAgICAgICBjb25zdCBmZWVEYXRhID0ge1xuICAgICAgICAgICAgICAgIGdhc1ByaWNlOiBfZmVlRGF0YS5nYXNQcmljZSxcbiAgICAgICAgICAgICAgICBtYXhGZWVQZXJHYXM6IHBhcnNlVW5pdHMocGF5bG9hZC5tYXhGZWUsIDkpLFxuICAgICAgICAgICAgICAgIG1heFByaW9yaXR5RmVlUGVyR2FzOiBwYXJzZVVuaXRzKHBheWxvYWQubWF4UHJpb3JpdHlGZWUsIDkpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiBmZWVEYXRhO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgYXNzZXJ0KGZhbHNlLCBgZXJyb3IgZW5jb3VudGVyZWQgd2l0aCBwb2x5Z29uIGdhcyBzdGF0aW9uICgke0pTT04uc3RyaW5naWZ5KHJlcXVlc3QudXJsKX0pYCwgXCJTRVJWRVJfRVJST1JcIiwgeyByZXF1ZXN0LCByZXNwb25zZSwgZXJyb3IgfSk7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbi8vIFNlZTogaHR0cHM6Ly9jaGFpbmxpc3Qub3JnXG5sZXQgaW5qZWN0ZWQgPSBmYWxzZTtcbmZ1bmN0aW9uIGluamVjdENvbW1vbk5ldHdvcmtzKCkge1xuICAgIGlmIChpbmplY3RlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGluamVjdGVkID0gdHJ1ZTtcbiAgICAvLy8gUmVnaXN0ZXIgcG9wdWxhciBFdGhlcmV1bSBuZXR3b3Jrc1xuICAgIGZ1bmN0aW9uIHJlZ2lzdGVyRXRoKG5hbWUsIGNoYWluSWQsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgZnVuYyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGNvbnN0IG5ldHdvcmsgPSBuZXcgTmV0d29yayhuYW1lLCBjaGFpbklkKTtcbiAgICAgICAgICAgIC8vIFdlIHVzZSAwIHRvIGRpc2FibGUgRU5TXG4gICAgICAgICAgICBpZiAob3B0aW9ucy5lbnNOZXR3b3JrICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBuZXR3b3JrLmF0dGFjaFBsdWdpbihuZXcgRW5zUGx1Z2luKG51bGwsIG9wdGlvbnMuZW5zTmV0d29yaykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbmV0d29yay5hdHRhY2hQbHVnaW4obmV3IEdhc0Nvc3RQbHVnaW4oKSk7XG4gICAgICAgICAgICAob3B0aW9ucy5wbHVnaW5zIHx8IFtdKS5mb3JFYWNoKChwbHVnaW4pID0+IHtcbiAgICAgICAgICAgICAgICBuZXR3b3JrLmF0dGFjaFBsdWdpbihwbHVnaW4pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gbmV0d29yaztcbiAgICAgICAgfTtcbiAgICAgICAgLy8gUmVnaXN0ZXIgdGhlIG5ldHdvcmsgYnkgbmFtZSBhbmQgY2hhaW4gSURcbiAgICAgICAgTmV0d29yay5yZWdpc3RlcihuYW1lLCBmdW5jKTtcbiAgICAgICAgTmV0d29yay5yZWdpc3RlcihjaGFpbklkLCBmdW5jKTtcbiAgICAgICAgaWYgKG9wdGlvbnMuYWx0TmFtZXMpIHtcbiAgICAgICAgICAgIG9wdGlvbnMuYWx0TmFtZXMuZm9yRWFjaCgobmFtZSkgPT4ge1xuICAgICAgICAgICAgICAgIE5ldHdvcmsucmVnaXN0ZXIobmFtZSwgZnVuYyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZWdpc3RlckV0aChcIm1haW5uZXRcIiwgMSwgeyBlbnNOZXR3b3JrOiAxLCBhbHROYW1lczogW1wiaG9tZXN0ZWFkXCJdIH0pO1xuICAgIHJlZ2lzdGVyRXRoKFwicm9wc3RlblwiLCAzLCB7IGVuc05ldHdvcms6IDMgfSk7XG4gICAgcmVnaXN0ZXJFdGgoXCJyaW5rZWJ5XCIsIDQsIHsgZW5zTmV0d29yazogNCB9KTtcbiAgICByZWdpc3RlckV0aChcImdvZXJsaVwiLCA1LCB7IGVuc05ldHdvcms6IDUgfSk7XG4gICAgcmVnaXN0ZXJFdGgoXCJrb3ZhblwiLCA0MiwgeyBlbnNOZXR3b3JrOiA0MiB9KTtcbiAgICByZWdpc3RlckV0aChcInNlcG9saWFcIiwgMTExNTUxMTEsIHsgZW5zTmV0d29yazogMTExNTUxMTEgfSk7XG4gICAgcmVnaXN0ZXJFdGgoXCJob2xlc2t5XCIsIDE3MDAwLCB7IGVuc05ldHdvcms6IDE3MDAwIH0pO1xuICAgIHJlZ2lzdGVyRXRoKFwiY2xhc3NpY1wiLCA2MSwge30pO1xuICAgIHJlZ2lzdGVyRXRoKFwiY2xhc3NpY0tvdHRpXCIsIDYsIHt9KTtcbiAgICByZWdpc3RlckV0aChcImFyYml0cnVtXCIsIDQyMTYxLCB7XG4gICAgICAgIGVuc05ldHdvcms6IDEsXG4gICAgfSk7XG4gICAgcmVnaXN0ZXJFdGgoXCJhcmJpdHJ1bS1nb2VybGlcIiwgNDIxNjEzLCB7fSk7XG4gICAgcmVnaXN0ZXJFdGgoXCJhcmJpdHJ1bS1zZXBvbGlhXCIsIDQyMTYxNCwge30pO1xuICAgIHJlZ2lzdGVyRXRoKFwiYmFzZVwiLCA4NDUzLCB7IGVuc05ldHdvcms6IDEgfSk7XG4gICAgcmVnaXN0ZXJFdGgoXCJiYXNlLWdvZXJsaVwiLCA4NDUzMSwge30pO1xuICAgIHJlZ2lzdGVyRXRoKFwiYmFzZS1zZXBvbGlhXCIsIDg0NTMyLCB7fSk7XG4gICAgcmVnaXN0ZXJFdGgoXCJibmJcIiwgNTYsIHsgZW5zTmV0d29yazogMSB9KTtcbiAgICByZWdpc3RlckV0aChcImJuYnRcIiwgOTcsIHt9KTtcbiAgICByZWdpc3RlckV0aChcImxpbmVhXCIsIDU5MTQ0LCB7IGVuc05ldHdvcms6IDEgfSk7XG4gICAgcmVnaXN0ZXJFdGgoXCJsaW5lYS1nb2VybGlcIiwgNTkxNDAsIHt9KTtcbiAgICByZWdpc3RlckV0aChcImxpbmVhLXNlcG9saWFcIiwgNTkxNDEsIHt9KTtcbiAgICByZWdpc3RlckV0aChcIm1hdGljXCIsIDEzNywge1xuICAgICAgICBlbnNOZXR3b3JrOiAxLFxuICAgICAgICBwbHVnaW5zOiBbXG4gICAgICAgICAgICBnZXRHYXNTdGF0aW9uUGx1Z2luKFwiaHR0cHM6L1xcL2dhc3N0YXRpb24ucG9seWdvbi50ZWNobm9sb2d5L3YyXCIpXG4gICAgICAgIF1cbiAgICB9KTtcbiAgICByZWdpc3RlckV0aChcIm1hdGljLWFtb3lcIiwgODAwMDIsIHt9KTtcbiAgICByZWdpc3RlckV0aChcIm1hdGljLW11bWJhaVwiLCA4MDAwMSwge1xuICAgICAgICBhbHROYW1lczogW1wibWF0aWNNdW1iYWlcIiwgXCJtYXRpY211bVwiXSxcbiAgICAgICAgcGx1Z2luczogW1xuICAgICAgICAgICAgZ2V0R2FzU3RhdGlvblBsdWdpbihcImh0dHBzOi9cXC9nYXNzdGF0aW9uLXRlc3RuZXQucG9seWdvbi50ZWNobm9sb2d5L3YyXCIpXG4gICAgICAgIF1cbiAgICB9KTtcbiAgICByZWdpc3RlckV0aChcIm9wdGltaXNtXCIsIDEwLCB7XG4gICAgICAgIGVuc05ldHdvcms6IDEsXG4gICAgICAgIHBsdWdpbnM6IFtdXG4gICAgfSk7XG4gICAgcmVnaXN0ZXJFdGgoXCJvcHRpbWlzbS1nb2VybGlcIiwgNDIwLCB7fSk7XG4gICAgcmVnaXN0ZXJFdGgoXCJvcHRpbWlzbS1zZXBvbGlhXCIsIDExMTU1NDIwLCB7fSk7XG4gICAgcmVnaXN0ZXJFdGgoXCJ4ZGFpXCIsIDEwMCwgeyBlbnNOZXR3b3JrOiAxIH0pO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bmV0d29yay5qcy5tYXAiXSwibmFtZXMiOlsiYWNjZXNzTGlzdGlmeSIsImdldEJpZ0ludCIsImFzc2VydCIsImFzc2VydEFyZ3VtZW50IiwiRW5zUGx1Z2luIiwiRmV0Y2hVcmxGZWVEYXRhTmV0d29ya1BsdWdpbiIsIkdhc0Nvc3RQbHVnaW4iLCJOZXR3b3JrcyIsIk1hcCIsIk5ldHdvcmsiLCJuYW1lIiwiY2hhaW5JZCIsInBsdWdpbnMiLCJjb25zdHJ1Y3RvciIsInRvSlNPTiIsIlN0cmluZyIsInZhbHVlIiwibWF0Y2hlcyIsIm90aGVyIiwiZXJyb3IiLCJBcnJheSIsImZyb20iLCJ2YWx1ZXMiLCJhdHRhY2hQbHVnaW4iLCJwbHVnaW4iLCJnZXQiLCJFcnJvciIsInNldCIsImNsb25lIiwiZ2V0UGx1Z2luIiwiZ2V0UGx1Z2lucyIsImJhc2VuYW1lIiwiZmlsdGVyIiwicCIsInNwbGl0IiwiZm9yRWFjaCIsImNvbXB1dGVJbnRyaW5zaWNHYXMiLCJ0eCIsImNvc3RzIiwiZ2FzIiwidHhCYXNlIiwidG8iLCJ0eENyZWF0ZSIsImRhdGEiLCJpIiwibGVuZ3RoIiwic3Vic3RyaW5nIiwidHhEYXRhWmVybyIsInR4RGF0YU5vbnplcm8iLCJhY2Nlc3NMaXN0IiwiYWRkciIsInR4QWNjZXNzTGlzdEFkZHJlc3MiLCJ0eEFjY2Vzc0xpc3RTdG9yYWdlS2V5Iiwic3RvcmFnZUtleXMiLCJuZXR3b3JrIiwiaW5qZWN0Q29tbW9uTmV0d29ya3MiLCJCaWdJbnQiLCJuZXR3b3JrRnVuYyIsImN1c3RvbSIsImVuc0FkZHJlc3MiLCJlbnNOZXR3b3JrIiwicmVnaXN0ZXIiLCJuYW1lT3JDaGFpbklkIiwiZXhpc3RpbmciLCJKU09OIiwic3RyaW5naWZ5IiwicGFyc2VVbml0cyIsIl92YWx1ZSIsImRlY2ltYWxzIiwibWF0Y2giLCJjb21wcyIsInB1c2giLCJmcmFjIiwidG9TdHJpbmciLCJnZXRHYXNTdGF0aW9uUGx1Z2luIiwidXJsIiwiZmV0Y2hGZWVEYXRhIiwicHJvdmlkZXIiLCJyZXF1ZXN0Iiwic2V0SGVhZGVyIiwicmVzcG9uc2UiLCJfcmVzcG9uc2UiLCJfZmVlRGF0YSIsIlByb21pc2UiLCJhbGwiLCJzZW5kIiwicGF5bG9hZCIsImJvZHlKc29uIiwic3RhbmRhcmQiLCJmZWVEYXRhIiwiZ2FzUHJpY2UiLCJtYXhGZWVQZXJHYXMiLCJtYXhGZWUiLCJtYXhQcmlvcml0eUZlZVBlckdhcyIsIm1heFByaW9yaXR5RmVlIiwiaW5qZWN0ZWQiLCJyZWdpc3RlckV0aCIsIm9wdGlvbnMiLCJmdW5jIiwiYWx0TmFtZXMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.esm/providers/network.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.esm/providers/plugins-network.js":
/*!******************************************************************!*\
  !*** ./node_modules/ethers/lib.esm/providers/plugins-network.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   EnsPlugin: () => (/* binding */ EnsPlugin),\n/* harmony export */   FeeDataNetworkPlugin: () => (/* binding */ FeeDataNetworkPlugin),\n/* harmony export */   FetchUrlFeeDataNetworkPlugin: () => (/* binding */ FetchUrlFeeDataNetworkPlugin),\n/* harmony export */   GasCostPlugin: () => (/* binding */ GasCostPlugin),\n/* harmony export */   NetworkPlugin: () => (/* binding */ NetworkPlugin)\n/* harmony export */ });\n/* harmony import */ var _utils_properties_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/properties.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/properties.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/errors.js\");\n\n\nconst EnsAddress = \"0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e\";\n/**\n *  A **NetworkPlugin** provides additional functionality on a [[Network]].\n */ class NetworkPlugin {\n    /**\n     *  Creates a new **NetworkPlugin**.\n     */ constructor(name){\n        (0,_utils_properties_js__WEBPACK_IMPORTED_MODULE_0__.defineProperties)(this, {\n            name\n        });\n    }\n    /**\n     *  Creates a copy of this plugin.\n     */ clone() {\n        return new NetworkPlugin(this.name);\n    }\n}\n/**\n *  A **GasCostPlugin** allows a network to provide alternative values when\n *  computing the intrinsic gas required for a transaction.\n */ class GasCostPlugin extends NetworkPlugin {\n    /**\n     *  Creates a new GasCostPlugin from %%effectiveBlock%% until the\n     *  latest block or another GasCostPlugin supercedes that block number,\n     *  with the associated %%costs%%.\n     */ constructor(effectiveBlock, costs){\n        if (effectiveBlock == null) {\n            effectiveBlock = 0;\n        }\n        super(`org.ethers.network.plugins.GasCost#${effectiveBlock || 0}`);\n        const props = {\n            effectiveBlock\n        };\n        function set(name, nullish) {\n            let value = (costs || {})[name];\n            if (value == null) {\n                value = nullish;\n            }\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(typeof value === \"number\", `invalud value for ${name}`, \"costs\", costs);\n            props[name] = value;\n        }\n        set(\"txBase\", 21000);\n        set(\"txCreate\", 32000);\n        set(\"txDataZero\", 4);\n        set(\"txDataNonzero\", 16);\n        set(\"txAccessListStorageKey\", 1900);\n        set(\"txAccessListAddress\", 2400);\n        (0,_utils_properties_js__WEBPACK_IMPORTED_MODULE_0__.defineProperties)(this, props);\n    }\n    clone() {\n        return new GasCostPlugin(this.effectiveBlock, this);\n    }\n}\n/**\n *  An **EnsPlugin** allows a [[Network]] to specify the ENS Registry\n *  Contract address and the target network to use when using that\n *  contract.\n *\n *  Various testnets have their own instance of the contract to use, but\n *  in general, the mainnet instance supports multi-chain addresses and\n *  should be used.\n */ class EnsPlugin extends NetworkPlugin {\n    /**\n     *  Creates a new **EnsPlugin** connected to %%address%% on the\n     *  %%targetNetwork%%. The default ENS address and mainnet is used\n     *  if unspecified.\n     */ constructor(address, targetNetwork){\n        super(\"org.ethers.plugins.network.Ens\");\n        (0,_utils_properties_js__WEBPACK_IMPORTED_MODULE_0__.defineProperties)(this, {\n            address: address || EnsAddress,\n            targetNetwork: targetNetwork == null ? 1 : targetNetwork\n        });\n    }\n    clone() {\n        return new EnsPlugin(this.address, this.targetNetwork);\n    }\n}\n/**\n *  A **FeeDataNetworkPlugin** allows a network to provide and alternate\n *  means to specify its fee data.\n *\n *  For example, a network which does not support [[link-eip-1559]] may\n *  choose to use a Gas Station site to approximate the gas price.\n */ class FeeDataNetworkPlugin extends NetworkPlugin {\n    #feeDataFunc;\n    /**\n     *  The fee data function provided to the constructor.\n     */ get feeDataFunc() {\n        return this.#feeDataFunc;\n    }\n    /**\n     *  Creates a new **FeeDataNetworkPlugin**.\n     */ constructor(feeDataFunc){\n        super(\"org.ethers.plugins.network.FeeData\");\n        this.#feeDataFunc = feeDataFunc;\n    }\n    /**\n     *  Resolves to the fee data.\n     */ async getFeeData(provider) {\n        return await this.#feeDataFunc(provider);\n    }\n    clone() {\n        return new FeeDataNetworkPlugin(this.#feeDataFunc);\n    }\n}\nclass FetchUrlFeeDataNetworkPlugin extends NetworkPlugin {\n    #url;\n    #processFunc;\n    /**\n     *  The URL to initialize the FetchRequest with in %%processFunc%%.\n     */ get url() {\n        return this.#url;\n    }\n    /**\n     *  The callback to use when computing the FeeData.\n     */ get processFunc() {\n        return this.#processFunc;\n    }\n    /**\n     *  Creates a new **FetchUrlFeeDataNetworkPlugin** which will\n     *  be used when computing the fee data for the network.\n     */ constructor(url, processFunc){\n        super(\"org.ethers.plugins.network.FetchUrlFeeDataPlugin\");\n        this.#url = url;\n        this.#processFunc = processFunc;\n    }\n    // We are immutable, so we can serve as our own clone\n    clone() {\n        return this;\n    }\n} /*\nexport class CustomBlockNetworkPlugin extends NetworkPlugin {\n    readonly #blockFunc: (provider: Provider, block: BlockParams<string>) => Block<string>;\n    readonly #blockWithTxsFunc: (provider: Provider, block: BlockParams<TransactionResponseParams>) => Block<TransactionResponse>;\n\n    constructor(blockFunc: (provider: Provider, block: BlockParams<string>) => Block<string>, blockWithTxsFunc: (provider: Provider, block: BlockParams<TransactionResponseParams>) => Block<TransactionResponse>) {\n        super(\"org.ethers.network-plugins.custom-block\");\n        this.#blockFunc = blockFunc;\n        this.#blockWithTxsFunc = blockWithTxsFunc;\n    }\n\n    async getBlock(provider: Provider, block: BlockParams<string>): Promise<Block<string>> {\n        return await this.#blockFunc(provider, block);\n    }\n\n    async getBlockions(provider: Provider, block: BlockParams<TransactionResponseParams>): Promise<Block<TransactionResponse>> {\n        return await this.#blockWithTxsFunc(provider, block);\n    }\n\n    clone(): CustomBlockNetworkPlugin {\n        return new CustomBlockNetworkPlugin(this.#blockFunc, this.#blockWithTxsFunc);\n    }\n}\n*/  //# sourceMappingURL=plugins-network.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vcHJvdmlkZXJzL3BsdWdpbnMtbmV0d29yay5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQTBEO0FBQ1A7QUFDbkQsTUFBTUUsYUFBYTtBQUNuQjs7Q0FFQyxHQUNNLE1BQU1DO0lBUVQ7O0tBRUMsR0FDREMsWUFBWUMsSUFBSSxDQUFFO1FBQ2RMLHNFQUFnQkEsQ0FBQyxJQUFJLEVBQUU7WUFBRUs7UUFBSztJQUNsQztJQUNBOztLQUVDLEdBQ0RDLFFBQVE7UUFDSixPQUFPLElBQUlILGNBQWMsSUFBSSxDQUFDRSxJQUFJO0lBQ3RDO0FBQ0o7QUFDQTs7O0NBR0MsR0FDTSxNQUFNRSxzQkFBc0JKO0lBZ0MvQjs7OztLQUlDLEdBQ0RDLFlBQVlJLGNBQWMsRUFBRUMsS0FBSyxDQUFFO1FBQy9CLElBQUlELGtCQUFrQixNQUFNO1lBQ3hCQSxpQkFBaUI7UUFDckI7UUFDQSxLQUFLLENBQUMsQ0FBQyxtQ0FBbUMsRUFBR0Esa0JBQWtCLEVBQUcsQ0FBQztRQUNuRSxNQUFNRSxRQUFRO1lBQUVGO1FBQWU7UUFDL0IsU0FBU0csSUFBSU4sSUFBSSxFQUFFTyxPQUFPO1lBQ3RCLElBQUlDLFFBQVEsQ0FBQ0osU0FBUyxDQUFDLEVBQUUsQ0FBQ0osS0FBSztZQUMvQixJQUFJUSxTQUFTLE1BQU07Z0JBQ2ZBLFFBQVFEO1lBQ1o7WUFDQVgsK0RBQWNBLENBQUMsT0FBUVksVUFBVyxVQUFVLENBQUMsa0JBQWtCLEVBQUVSLEtBQUssQ0FBQyxFQUFFLFNBQVNJO1lBQ2xGQyxLQUFLLENBQUNMLEtBQUssR0FBR1E7UUFDbEI7UUFDQUYsSUFBSSxVQUFVO1FBQ2RBLElBQUksWUFBWTtRQUNoQkEsSUFBSSxjQUFjO1FBQ2xCQSxJQUFJLGlCQUFpQjtRQUNyQkEsSUFBSSwwQkFBMEI7UUFDOUJBLElBQUksdUJBQXVCO1FBQzNCWCxzRUFBZ0JBLENBQUMsSUFBSSxFQUFFVTtJQUMzQjtJQUNBSixRQUFRO1FBQ0osT0FBTyxJQUFJQyxjQUFjLElBQUksQ0FBQ0MsY0FBYyxFQUFFLElBQUk7SUFDdEQ7QUFDSjtBQUNBOzs7Ozs7OztDQVFDLEdBQ00sTUFBTU0sa0JBQWtCWDtJQVMzQjs7OztLQUlDLEdBQ0RDLFlBQVlXLE9BQU8sRUFBRUMsYUFBYSxDQUFFO1FBQ2hDLEtBQUssQ0FBQztRQUNOaEIsc0VBQWdCQSxDQUFDLElBQUksRUFBRTtZQUNuQmUsU0FBVUEsV0FBV2I7WUFDckJjLGVBQWdCLGlCQUFrQixPQUFRLElBQUlBO1FBQ2xEO0lBQ0o7SUFDQVYsUUFBUTtRQUNKLE9BQU8sSUFBSVEsVUFBVSxJQUFJLENBQUNDLE9BQU8sRUFBRSxJQUFJLENBQUNDLGFBQWE7SUFDekQ7QUFDSjtBQUNBOzs7Ozs7Q0FNQyxHQUNNLE1BQU1DLDZCQUE2QmQ7SUFDdEMsQ0FBQ2UsV0FBVyxDQUFDO0lBQ2I7O0tBRUMsR0FDRCxJQUFJQSxjQUFjO1FBQ2QsT0FBTyxJQUFJLENBQUMsQ0FBQ0EsV0FBVztJQUM1QjtJQUNBOztLQUVDLEdBQ0RkLFlBQVljLFdBQVcsQ0FBRTtRQUNyQixLQUFLLENBQUM7UUFDTixJQUFJLENBQUMsQ0FBQ0EsV0FBVyxHQUFHQTtJQUN4QjtJQUNBOztLQUVDLEdBQ0QsTUFBTUMsV0FBV0MsUUFBUSxFQUFFO1FBQ3ZCLE9BQU8sTUFBTSxJQUFJLENBQUMsQ0FBQ0YsV0FBVyxDQUFDRTtJQUNuQztJQUNBZCxRQUFRO1FBQ0osT0FBTyxJQUFJVyxxQkFBcUIsSUFBSSxDQUFDLENBQUNDLFdBQVc7SUFDckQ7QUFDSjtBQUNPLE1BQU1HLHFDQUFxQ2xCO0lBQzlDLENBQUNtQixHQUFHLENBQUM7SUFDTCxDQUFDQyxXQUFXLENBQUM7SUFDYjs7S0FFQyxHQUNELElBQUlELE1BQU07UUFBRSxPQUFPLElBQUksQ0FBQyxDQUFDQSxHQUFHO0lBQUU7SUFDOUI7O0tBRUMsR0FDRCxJQUFJQyxjQUFjO1FBQUUsT0FBTyxJQUFJLENBQUMsQ0FBQ0EsV0FBVztJQUFFO0lBQzlDOzs7S0FHQyxHQUNEbkIsWUFBWWtCLEdBQUcsRUFBRUMsV0FBVyxDQUFFO1FBQzFCLEtBQUssQ0FBQztRQUNOLElBQUksQ0FBQyxDQUFDRCxHQUFHLEdBQUdBO1FBQ1osSUFBSSxDQUFDLENBQUNDLFdBQVcsR0FBR0E7SUFDeEI7SUFDQSxxREFBcUQ7SUFDckRqQixRQUFRO1FBQUUsT0FBTyxJQUFJO0lBQUU7QUFDM0IsRUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUF1QkEsSUFDQSwyQ0FBMkMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tZWdhdmliZS1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9wcm92aWRlcnMvcGx1Z2lucy1uZXR3b3JrLmpzPzQxMjkiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZGVmaW5lUHJvcGVydGllcyB9IGZyb20gXCIuLi91dGlscy9wcm9wZXJ0aWVzLmpzXCI7XG5pbXBvcnQgeyBhc3NlcnRBcmd1bWVudCB9IGZyb20gXCIuLi91dGlscy9pbmRleC5qc1wiO1xuY29uc3QgRW5zQWRkcmVzcyA9IFwiMHgwMDAwMDAwMDAwMEMyRTA3NGVDNjlBMGRGYjI5OTdCQTZDN2QyZTFlXCI7XG4vKipcbiAqICBBICoqTmV0d29ya1BsdWdpbioqIHByb3ZpZGVzIGFkZGl0aW9uYWwgZnVuY3Rpb25hbGl0eSBvbiBhIFtbTmV0d29ya11dLlxuICovXG5leHBvcnQgY2xhc3MgTmV0d29ya1BsdWdpbiB7XG4gICAgLyoqXG4gICAgICogIFRoZSBuYW1lIG9mIHRoZSBwbHVnaW4uXG4gICAgICpcbiAgICAgKiAgSXQgaXMgcmVjb21tZW5kZWQgdG8gdXNlIHJldmVyc2UtZG9tYWluLW5vdGF0aW9uLCB3aGljaCBwZXJtaXRzXG4gICAgICogIHVuaXF1ZSBuYW1lcyB3aXRoIGEga25vd24gYXV0aG9yaXR5IGFzIHdlbGwgYXMgaGllcmFyY2hhbCBlbnRyaWVzLlxuICAgICAqL1xuICAgIG5hbWU7XG4gICAgLyoqXG4gICAgICogIENyZWF0ZXMgYSBuZXcgKipOZXR3b3JrUGx1Z2luKiouXG4gICAgICovXG4gICAgY29uc3RydWN0b3IobmFtZSkge1xuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHsgbmFtZSB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIENyZWF0ZXMgYSBjb3B5IG9mIHRoaXMgcGx1Z2luLlxuICAgICAqL1xuICAgIGNsb25lKCkge1xuICAgICAgICByZXR1cm4gbmV3IE5ldHdvcmtQbHVnaW4odGhpcy5uYW1lKTtcbiAgICB9XG59XG4vKipcbiAqICBBICoqR2FzQ29zdFBsdWdpbioqIGFsbG93cyBhIG5ldHdvcmsgdG8gcHJvdmlkZSBhbHRlcm5hdGl2ZSB2YWx1ZXMgd2hlblxuICogIGNvbXB1dGluZyB0aGUgaW50cmluc2ljIGdhcyByZXF1aXJlZCBmb3IgYSB0cmFuc2FjdGlvbi5cbiAqL1xuZXhwb3J0IGNsYXNzIEdhc0Nvc3RQbHVnaW4gZXh0ZW5kcyBOZXR3b3JrUGx1Z2luIHtcbiAgICAvKipcbiAgICAgKiAgVGhlIGJsb2NrIG51bWJlciB0byB0cmVhdCB0aGVzZSB2YWx1ZXMgYXMgdmFsaWQgZnJvbS5cbiAgICAgKlxuICAgICAqICBUaGlzIGFsbG93cyBhIGhhcmRmb3JrIHRvIGhhdmUgdXBkYXRlZCB2YWx1ZXMgaW5jbHVkZWQgYXMgd2VsbCBhc1xuICAgICAqICBtdWx1dGlwbGUgaGFyZGZvcmtzIHRvIGJlIHN1cHBvcnRlZC5cbiAgICAgKi9cbiAgICBlZmZlY3RpdmVCbG9jaztcbiAgICAvKipcbiAgICAgKiAgVGhlIHRyYW5zYWN0aW9ucyBiYXNlIGZlZS5cbiAgICAgKi9cbiAgICB0eEJhc2U7XG4gICAgLyoqXG4gICAgICogIFRoZSBmZWUgZm9yIGNyZWF0aW5nIGEgbmV3IGFjY291bnQuXG4gICAgICovXG4gICAgdHhDcmVhdGU7XG4gICAgLyoqXG4gICAgICogIFRoZSBmZWUgcGVyIHplcm8tYnl0ZSBpbiB0aGUgZGF0YS5cbiAgICAgKi9cbiAgICB0eERhdGFaZXJvO1xuICAgIC8qKlxuICAgICAqICBUaGUgZmVlIHBlciBub24temVyby1ieXRlIGluIHRoZSBkYXRhLlxuICAgICAqL1xuICAgIHR4RGF0YU5vbnplcm87XG4gICAgLyoqXG4gICAgICogIFRoZSBmZWUgcGVyIHN0b3JhZ2Uga2V5IGluIHRoZSBbW2xpbmstZWlwLTI5MzBdXSBhY2Nlc3MgbGlzdC5cbiAgICAgKi9cbiAgICB0eEFjY2Vzc0xpc3RTdG9yYWdlS2V5O1xuICAgIC8qKlxuICAgICAqICBUaGUgZmVlIHBlciBhZGRyZXNzIGluIHRoZSBbW2xpbmstZWlwLTI5MzBdXSBhY2Nlc3MgbGlzdC5cbiAgICAgKi9cbiAgICB0eEFjY2Vzc0xpc3RBZGRyZXNzO1xuICAgIC8qKlxuICAgICAqICBDcmVhdGVzIGEgbmV3IEdhc0Nvc3RQbHVnaW4gZnJvbSAlJWVmZmVjdGl2ZUJsb2NrJSUgdW50aWwgdGhlXG4gICAgICogIGxhdGVzdCBibG9jayBvciBhbm90aGVyIEdhc0Nvc3RQbHVnaW4gc3VwZXJjZWRlcyB0aGF0IGJsb2NrIG51bWJlcixcbiAgICAgKiAgd2l0aCB0aGUgYXNzb2NpYXRlZCAlJWNvc3RzJSUuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoZWZmZWN0aXZlQmxvY2ssIGNvc3RzKSB7XG4gICAgICAgIGlmIChlZmZlY3RpdmVCbG9jayA9PSBudWxsKSB7XG4gICAgICAgICAgICBlZmZlY3RpdmVCbG9jayA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgc3VwZXIoYG9yZy5ldGhlcnMubmV0d29yay5wbHVnaW5zLkdhc0Nvc3QjJHsoZWZmZWN0aXZlQmxvY2sgfHwgMCl9YCk7XG4gICAgICAgIGNvbnN0IHByb3BzID0geyBlZmZlY3RpdmVCbG9jayB9O1xuICAgICAgICBmdW5jdGlvbiBzZXQobmFtZSwgbnVsbGlzaCkge1xuICAgICAgICAgICAgbGV0IHZhbHVlID0gKGNvc3RzIHx8IHt9KVtuYW1lXTtcbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBudWxsaXNoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQodHlwZW9mICh2YWx1ZSkgPT09IFwibnVtYmVyXCIsIGBpbnZhbHVkIHZhbHVlIGZvciAke25hbWV9YCwgXCJjb3N0c1wiLCBjb3N0cyk7XG4gICAgICAgICAgICBwcm9wc1tuYW1lXSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHNldChcInR4QmFzZVwiLCAyMTAwMCk7XG4gICAgICAgIHNldChcInR4Q3JlYXRlXCIsIDMyMDAwKTtcbiAgICAgICAgc2V0KFwidHhEYXRhWmVyb1wiLCA0KTtcbiAgICAgICAgc2V0KFwidHhEYXRhTm9uemVyb1wiLCAxNik7XG4gICAgICAgIHNldChcInR4QWNjZXNzTGlzdFN0b3JhZ2VLZXlcIiwgMTkwMCk7XG4gICAgICAgIHNldChcInR4QWNjZXNzTGlzdEFkZHJlc3NcIiwgMjQwMCk7XG4gICAgICAgIGRlZmluZVByb3BlcnRpZXModGhpcywgcHJvcHMpO1xuICAgIH1cbiAgICBjbG9uZSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBHYXNDb3N0UGx1Z2luKHRoaXMuZWZmZWN0aXZlQmxvY2ssIHRoaXMpO1xuICAgIH1cbn1cbi8qKlxuICogIEFuICoqRW5zUGx1Z2luKiogYWxsb3dzIGEgW1tOZXR3b3JrXV0gdG8gc3BlY2lmeSB0aGUgRU5TIFJlZ2lzdHJ5XG4gKiAgQ29udHJhY3QgYWRkcmVzcyBhbmQgdGhlIHRhcmdldCBuZXR3b3JrIHRvIHVzZSB3aGVuIHVzaW5nIHRoYXRcbiAqICBjb250cmFjdC5cbiAqXG4gKiAgVmFyaW91cyB0ZXN0bmV0cyBoYXZlIHRoZWlyIG93biBpbnN0YW5jZSBvZiB0aGUgY29udHJhY3QgdG8gdXNlLCBidXRcbiAqICBpbiBnZW5lcmFsLCB0aGUgbWFpbm5ldCBpbnN0YW5jZSBzdXBwb3J0cyBtdWx0aS1jaGFpbiBhZGRyZXNzZXMgYW5kXG4gKiAgc2hvdWxkIGJlIHVzZWQuXG4gKi9cbmV4cG9ydCBjbGFzcyBFbnNQbHVnaW4gZXh0ZW5kcyBOZXR3b3JrUGx1Z2luIHtcbiAgICAvKipcbiAgICAgKiAgVGhlIEVOUyBSZWdpc3RydHkgQ29udHJhY3QgYWRkcmVzcy5cbiAgICAgKi9cbiAgICBhZGRyZXNzO1xuICAgIC8qKlxuICAgICAqICBUaGUgY2hhaW4gSUQgdGhhdCB0aGUgRU5TIGNvbnRyYWN0IGxpdmVzIG9uLlxuICAgICAqL1xuICAgIHRhcmdldE5ldHdvcms7XG4gICAgLyoqXG4gICAgICogIENyZWF0ZXMgYSBuZXcgKipFbnNQbHVnaW4qKiBjb25uZWN0ZWQgdG8gJSVhZGRyZXNzJSUgb24gdGhlXG4gICAgICogICUldGFyZ2V0TmV0d29yayUlLiBUaGUgZGVmYXVsdCBFTlMgYWRkcmVzcyBhbmQgbWFpbm5ldCBpcyB1c2VkXG4gICAgICogIGlmIHVuc3BlY2lmaWVkLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGFkZHJlc3MsIHRhcmdldE5ldHdvcmspIHtcbiAgICAgICAgc3VwZXIoXCJvcmcuZXRoZXJzLnBsdWdpbnMubmV0d29yay5FbnNcIik7XG4gICAgICAgIGRlZmluZVByb3BlcnRpZXModGhpcywge1xuICAgICAgICAgICAgYWRkcmVzczogKGFkZHJlc3MgfHwgRW5zQWRkcmVzcyksXG4gICAgICAgICAgICB0YXJnZXROZXR3b3JrOiAoKHRhcmdldE5ldHdvcmsgPT0gbnVsbCkgPyAxIDogdGFyZ2V0TmV0d29yaylcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNsb25lKCkge1xuICAgICAgICByZXR1cm4gbmV3IEVuc1BsdWdpbih0aGlzLmFkZHJlc3MsIHRoaXMudGFyZ2V0TmV0d29yayk7XG4gICAgfVxufVxuLyoqXG4gKiAgQSAqKkZlZURhdGFOZXR3b3JrUGx1Z2luKiogYWxsb3dzIGEgbmV0d29yayB0byBwcm92aWRlIGFuZCBhbHRlcm5hdGVcbiAqICBtZWFucyB0byBzcGVjaWZ5IGl0cyBmZWUgZGF0YS5cbiAqXG4gKiAgRm9yIGV4YW1wbGUsIGEgbmV0d29yayB3aGljaCBkb2VzIG5vdCBzdXBwb3J0IFtbbGluay1laXAtMTU1OV1dIG1heVxuICogIGNob29zZSB0byB1c2UgYSBHYXMgU3RhdGlvbiBzaXRlIHRvIGFwcHJveGltYXRlIHRoZSBnYXMgcHJpY2UuXG4gKi9cbmV4cG9ydCBjbGFzcyBGZWVEYXRhTmV0d29ya1BsdWdpbiBleHRlbmRzIE5ldHdvcmtQbHVnaW4ge1xuICAgICNmZWVEYXRhRnVuYztcbiAgICAvKipcbiAgICAgKiAgVGhlIGZlZSBkYXRhIGZ1bmN0aW9uIHByb3ZpZGVkIHRvIHRoZSBjb25zdHJ1Y3Rvci5cbiAgICAgKi9cbiAgICBnZXQgZmVlRGF0YUZ1bmMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiNmZWVEYXRhRnVuYztcbiAgICB9XG4gICAgLyoqXG4gICAgICogIENyZWF0ZXMgYSBuZXcgKipGZWVEYXRhTmV0d29ya1BsdWdpbioqLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGZlZURhdGFGdW5jKSB7XG4gICAgICAgIHN1cGVyKFwib3JnLmV0aGVycy5wbHVnaW5zLm5ldHdvcmsuRmVlRGF0YVwiKTtcbiAgICAgICAgdGhpcy4jZmVlRGF0YUZ1bmMgPSBmZWVEYXRhRnVuYztcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJlc29sdmVzIHRvIHRoZSBmZWUgZGF0YS5cbiAgICAgKi9cbiAgICBhc3luYyBnZXRGZWVEYXRhKHByb3ZpZGVyKSB7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLiNmZWVEYXRhRnVuYyhwcm92aWRlcik7XG4gICAgfVxuICAgIGNsb25lKCkge1xuICAgICAgICByZXR1cm4gbmV3IEZlZURhdGFOZXR3b3JrUGx1Z2luKHRoaXMuI2ZlZURhdGFGdW5jKTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgRmV0Y2hVcmxGZWVEYXRhTmV0d29ya1BsdWdpbiBleHRlbmRzIE5ldHdvcmtQbHVnaW4ge1xuICAgICN1cmw7XG4gICAgI3Byb2Nlc3NGdW5jO1xuICAgIC8qKlxuICAgICAqICBUaGUgVVJMIHRvIGluaXRpYWxpemUgdGhlIEZldGNoUmVxdWVzdCB3aXRoIGluICUlcHJvY2Vzc0Z1bmMlJS5cbiAgICAgKi9cbiAgICBnZXQgdXJsKCkgeyByZXR1cm4gdGhpcy4jdXJsOyB9XG4gICAgLyoqXG4gICAgICogIFRoZSBjYWxsYmFjayB0byB1c2Ugd2hlbiBjb21wdXRpbmcgdGhlIEZlZURhdGEuXG4gICAgICovXG4gICAgZ2V0IHByb2Nlc3NGdW5jKCkgeyByZXR1cm4gdGhpcy4jcHJvY2Vzc0Z1bmM7IH1cbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlcyBhIG5ldyAqKkZldGNoVXJsRmVlRGF0YU5ldHdvcmtQbHVnaW4qKiB3aGljaCB3aWxsXG4gICAgICogIGJlIHVzZWQgd2hlbiBjb21wdXRpbmcgdGhlIGZlZSBkYXRhIGZvciB0aGUgbmV0d29yay5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih1cmwsIHByb2Nlc3NGdW5jKSB7XG4gICAgICAgIHN1cGVyKFwib3JnLmV0aGVycy5wbHVnaW5zLm5ldHdvcmsuRmV0Y2hVcmxGZWVEYXRhUGx1Z2luXCIpO1xuICAgICAgICB0aGlzLiN1cmwgPSB1cmw7XG4gICAgICAgIHRoaXMuI3Byb2Nlc3NGdW5jID0gcHJvY2Vzc0Z1bmM7XG4gICAgfVxuICAgIC8vIFdlIGFyZSBpbW11dGFibGUsIHNvIHdlIGNhbiBzZXJ2ZSBhcyBvdXIgb3duIGNsb25lXG4gICAgY2xvbmUoKSB7IHJldHVybiB0aGlzOyB9XG59XG4vKlxuZXhwb3J0IGNsYXNzIEN1c3RvbUJsb2NrTmV0d29ya1BsdWdpbiBleHRlbmRzIE5ldHdvcmtQbHVnaW4ge1xuICAgIHJlYWRvbmx5ICNibG9ja0Z1bmM6IChwcm92aWRlcjogUHJvdmlkZXIsIGJsb2NrOiBCbG9ja1BhcmFtczxzdHJpbmc+KSA9PiBCbG9jazxzdHJpbmc+O1xuICAgIHJlYWRvbmx5ICNibG9ja1dpdGhUeHNGdW5jOiAocHJvdmlkZXI6IFByb3ZpZGVyLCBibG9jazogQmxvY2tQYXJhbXM8VHJhbnNhY3Rpb25SZXNwb25zZVBhcmFtcz4pID0+IEJsb2NrPFRyYW5zYWN0aW9uUmVzcG9uc2U+O1xuXG4gICAgY29uc3RydWN0b3IoYmxvY2tGdW5jOiAocHJvdmlkZXI6IFByb3ZpZGVyLCBibG9jazogQmxvY2tQYXJhbXM8c3RyaW5nPikgPT4gQmxvY2s8c3RyaW5nPiwgYmxvY2tXaXRoVHhzRnVuYzogKHByb3ZpZGVyOiBQcm92aWRlciwgYmxvY2s6IEJsb2NrUGFyYW1zPFRyYW5zYWN0aW9uUmVzcG9uc2VQYXJhbXM+KSA9PiBCbG9jazxUcmFuc2FjdGlvblJlc3BvbnNlPikge1xuICAgICAgICBzdXBlcihcIm9yZy5ldGhlcnMubmV0d29yay1wbHVnaW5zLmN1c3RvbS1ibG9ja1wiKTtcbiAgICAgICAgdGhpcy4jYmxvY2tGdW5jID0gYmxvY2tGdW5jO1xuICAgICAgICB0aGlzLiNibG9ja1dpdGhUeHNGdW5jID0gYmxvY2tXaXRoVHhzRnVuYztcbiAgICB9XG5cbiAgICBhc3luYyBnZXRCbG9jayhwcm92aWRlcjogUHJvdmlkZXIsIGJsb2NrOiBCbG9ja1BhcmFtczxzdHJpbmc+KTogUHJvbWlzZTxCbG9jazxzdHJpbmc+PiB7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLiNibG9ja0Z1bmMocHJvdmlkZXIsIGJsb2NrKTtcbiAgICB9XG5cbiAgICBhc3luYyBnZXRCbG9ja2lvbnMocHJvdmlkZXI6IFByb3ZpZGVyLCBibG9jazogQmxvY2tQYXJhbXM8VHJhbnNhY3Rpb25SZXNwb25zZVBhcmFtcz4pOiBQcm9taXNlPEJsb2NrPFRyYW5zYWN0aW9uUmVzcG9uc2U+PiB7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLiNibG9ja1dpdGhUeHNGdW5jKHByb3ZpZGVyLCBibG9jayk7XG4gICAgfVxuXG4gICAgY2xvbmUoKTogQ3VzdG9tQmxvY2tOZXR3b3JrUGx1Z2luIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDdXN0b21CbG9ja05ldHdvcmtQbHVnaW4odGhpcy4jYmxvY2tGdW5jLCB0aGlzLiNibG9ja1dpdGhUeHNGdW5jKTtcbiAgICB9XG59XG4qL1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGx1Z2lucy1uZXR3b3JrLmpzLm1hcCJdLCJuYW1lcyI6WyJkZWZpbmVQcm9wZXJ0aWVzIiwiYXNzZXJ0QXJndW1lbnQiLCJFbnNBZGRyZXNzIiwiTmV0d29ya1BsdWdpbiIsImNvbnN0cnVjdG9yIiwibmFtZSIsImNsb25lIiwiR2FzQ29zdFBsdWdpbiIsImVmZmVjdGl2ZUJsb2NrIiwiY29zdHMiLCJwcm9wcyIsInNldCIsIm51bGxpc2giLCJ2YWx1ZSIsIkVuc1BsdWdpbiIsImFkZHJlc3MiLCJ0YXJnZXROZXR3b3JrIiwiRmVlRGF0YU5ldHdvcmtQbHVnaW4iLCJmZWVEYXRhRnVuYyIsImdldEZlZURhdGEiLCJwcm92aWRlciIsIkZldGNoVXJsRmVlRGF0YU5ldHdvcmtQbHVnaW4iLCJ1cmwiLCJwcm9jZXNzRnVuYyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.esm/providers/plugins-network.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.esm/providers/provider-browser.js":
/*!*******************************************************************!*\
  !*** ./node_modules/ethers/lib.esm/providers/provider-browser.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BrowserProvider: () => (/* binding */ BrowserProvider)\n/* harmony export */ });\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/errors.js\");\n/* harmony import */ var _provider_jsonrpc_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./provider-jsonrpc.js */ \"(ssr)/./node_modules/ethers/lib.esm/providers/provider-jsonrpc.js\");\n\n\n;\n/**\n *  A **BrowserProvider** is intended to wrap an injected provider which\n *  adheres to the [[link-eip-1193]] standard, which most (if not all)\n *  currently do.\n */ class BrowserProvider extends _provider_jsonrpc_js__WEBPACK_IMPORTED_MODULE_0__.JsonRpcApiPollingProvider {\n    #request;\n    #providerInfo;\n    /**\n     *  Connect to the %%ethereum%% provider, optionally forcing the\n     *  %%network%%.\n     */ constructor(ethereum, network, _options){\n        // Copy the options\n        const options = Object.assign({}, _options != null ? _options : {}, {\n            batchMaxCount: 1\n        });\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(ethereum && ethereum.request, \"invalid EIP-1193 provider\", \"ethereum\", ethereum);\n        super(network, options);\n        this.#providerInfo = null;\n        if (_options && _options.providerInfo) {\n            this.#providerInfo = _options.providerInfo;\n        }\n        this.#request = async (method, params)=>{\n            const payload = {\n                method,\n                params\n            };\n            this.emit(\"debug\", {\n                action: \"sendEip1193Request\",\n                payload\n            });\n            try {\n                const result = await ethereum.request(payload);\n                this.emit(\"debug\", {\n                    action: \"receiveEip1193Result\",\n                    result\n                });\n                return result;\n            } catch (e) {\n                const error = new Error(e.message);\n                error.code = e.code;\n                error.data = e.data;\n                error.payload = payload;\n                this.emit(\"debug\", {\n                    action: \"receiveEip1193Error\",\n                    error\n                });\n                throw error;\n            }\n        };\n    }\n    get providerInfo() {\n        return this.#providerInfo;\n    }\n    async send(method, params) {\n        await this._start();\n        return await super.send(method, params);\n    }\n    async _send(payload) {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(!Array.isArray(payload), \"EIP-1193 does not support batch request\", \"payload\", payload);\n        try {\n            const result = await this.#request(payload.method, payload.params || []);\n            return [\n                {\n                    id: payload.id,\n                    result\n                }\n            ];\n        } catch (e) {\n            return [\n                {\n                    id: payload.id,\n                    error: {\n                        code: e.code,\n                        data: e.data,\n                        message: e.message\n                    }\n                }\n            ];\n        }\n    }\n    getRpcError(payload, error) {\n        error = JSON.parse(JSON.stringify(error));\n        // EIP-1193 gives us some machine-readable error codes, so rewrite\n        // them into Ethers standard errors.\n        switch(error.error.code || -1){\n            case 4001:\n                error.error.message = `ethers-user-denied: ${error.error.message}`;\n                break;\n            case 4200:\n                error.error.message = `ethers-unsupported: ${error.error.message}`;\n                break;\n        }\n        return super.getRpcError(payload, error);\n    }\n    /**\n     *  Resolves to ``true`` if the provider manages the %%address%%.\n     */ async hasSigner(address) {\n        if (address == null) {\n            address = 0;\n        }\n        const accounts = await this.send(\"eth_accounts\", []);\n        if (typeof address === \"number\") {\n            return accounts.length > address;\n        }\n        address = address.toLowerCase();\n        return accounts.filter((a)=>a.toLowerCase() === address).length !== 0;\n    }\n    async getSigner(address) {\n        if (address == null) {\n            address = 0;\n        }\n        if (!await this.hasSigner(address)) {\n            try {\n                await this.#request(\"eth_requestAccounts\", []);\n            } catch (error) {\n                const payload = error.payload;\n                throw this.getRpcError(payload, {\n                    id: payload.id,\n                    error\n                });\n            }\n        }\n        return await super.getSigner(address);\n    }\n    /**\n     *  Discover and connect to a Provider in the Browser using the\n     *  [[link-eip-6963]] discovery mechanism. If no providers are\n     *  present, ``null`` is resolved.\n     */ static async discover(options) {\n        if (options == null) {\n            options = {};\n        }\n        if (options.provider) {\n            return new BrowserProvider(options.provider);\n        }\n        const context = options.window ? options.window : typeof window !== \"undefined\" ? window : null;\n        if (context == null) {\n            return null;\n        }\n        const anyProvider = options.anyProvider;\n        if (anyProvider && context.ethereum) {\n            return new BrowserProvider(context.ethereum);\n        }\n        if (!(\"addEventListener\" in context && \"dispatchEvent\" in context && \"removeEventListener\" in context)) {\n            return null;\n        }\n        const timeout = options.timeout ? options.timeout : 300;\n        if (timeout === 0) {\n            return null;\n        }\n        return await new Promise((resolve, reject)=>{\n            let found = [];\n            const addProvider = (event)=>{\n                found.push(event.detail);\n                if (anyProvider) {\n                    finalize();\n                }\n            };\n            const finalize = ()=>{\n                clearTimeout(timer);\n                if (found.length) {\n                    // If filtering is provided:\n                    if (options && options.filter) {\n                        // Call filter, with a copies of found provider infos\n                        const filtered = options.filter(found.map((i)=>Object.assign({}, i.info)));\n                        if (filtered == null) {\n                            // No provider selected\n                            resolve(null);\n                        } else if (filtered instanceof BrowserProvider) {\n                            // Custom provider created\n                            resolve(filtered);\n                        } else {\n                            // Find the matching provider\n                            let match = null;\n                            if (filtered.uuid) {\n                                const matches = found.filter((f)=>filtered.uuid === f.info.uuid);\n                                // @TODO: What should happen if multiple values\n                                //        for the same UUID?\n                                match = matches[0];\n                            }\n                            if (match) {\n                                const { provider, info } = match;\n                                resolve(new BrowserProvider(provider, undefined, {\n                                    providerInfo: info\n                                }));\n                            } else {\n                                reject((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.makeError)(\"filter returned unknown info\", \"UNSUPPORTED_OPERATION\", {\n                                    value: filtered\n                                }));\n                            }\n                        }\n                    } else {\n                        // Pick the first found provider\n                        const { provider, info } = found[0];\n                        resolve(new BrowserProvider(provider, undefined, {\n                            providerInfo: info\n                        }));\n                    }\n                } else {\n                    // Nothing found\n                    resolve(null);\n                }\n                context.removeEventListener(\"eip6963:announceProvider\", addProvider);\n            };\n            const timer = setTimeout(()=>{\n                finalize();\n            }, timeout);\n            context.addEventListener(\"eip6963:announceProvider\", addProvider);\n            context.dispatchEvent(new Event(\"eip6963:requestProvider\"));\n        });\n    }\n} //# sourceMappingURL=provider-browser.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vcHJvdmlkZXJzL3Byb3ZpZGVyLWJyb3dzZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQThEO0FBQ0k7O0FBRWxFOzs7O0NBSUMsR0FDTSxNQUFNRyx3QkFBd0JELDJFQUF5QkE7SUFDMUQsQ0FBQ0UsT0FBTyxDQUFDO0lBQ1QsQ0FBQ0MsWUFBWSxDQUFDO0lBQ2Q7OztLQUdDLEdBQ0RDLFlBQVlDLFFBQVEsRUFBRUMsT0FBTyxFQUFFQyxRQUFRLENBQUU7UUFDckMsbUJBQW1CO1FBQ25CLE1BQU1DLFVBQVVDLE9BQU9DLE1BQU0sQ0FBQyxDQUFDLEdBQUksWUFBYSxPQUFRSCxXQUFXLENBQUMsR0FBSTtZQUFFSSxlQUFlO1FBQUU7UUFDM0ZiLCtEQUFjQSxDQUFDTyxZQUFZQSxTQUFTSCxPQUFPLEVBQUUsNkJBQTZCLFlBQVlHO1FBQ3RGLEtBQUssQ0FBQ0MsU0FBU0U7UUFDZixJQUFJLENBQUMsQ0FBQ0wsWUFBWSxHQUFHO1FBQ3JCLElBQUlJLFlBQVlBLFNBQVNKLFlBQVksRUFBRTtZQUNuQyxJQUFJLENBQUMsQ0FBQ0EsWUFBWSxHQUFHSSxTQUFTSixZQUFZO1FBQzlDO1FBQ0EsSUFBSSxDQUFDLENBQUNELE9BQU8sR0FBRyxPQUFPVSxRQUFRQztZQUMzQixNQUFNQyxVQUFVO2dCQUFFRjtnQkFBUUM7WUFBTztZQUNqQyxJQUFJLENBQUNFLElBQUksQ0FBQyxTQUFTO2dCQUFFQyxRQUFRO2dCQUFzQkY7WUFBUTtZQUMzRCxJQUFJO2dCQUNBLE1BQU1HLFNBQVMsTUFBTVosU0FBU0gsT0FBTyxDQUFDWTtnQkFDdEMsSUFBSSxDQUFDQyxJQUFJLENBQUMsU0FBUztvQkFBRUMsUUFBUTtvQkFBd0JDO2dCQUFPO2dCQUM1RCxPQUFPQTtZQUNYLEVBQ0EsT0FBT0MsR0FBRztnQkFDTixNQUFNQyxRQUFRLElBQUlDLE1BQU1GLEVBQUVHLE9BQU87Z0JBQ2pDRixNQUFNRyxJQUFJLEdBQUdKLEVBQUVJ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QyxJQUFJQyxNQUFNO1FBQ3BDO0lBQ0o7QUFDSixFQUNBLDRDQUE0QyIsInNvdXJjZXMiOlsid2VicGFjazovL21lZ2F2aWJlLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL3Byb3ZpZGVycy9wcm92aWRlci1icm93c2VyLmpzP2M2ZTEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgYXNzZXJ0QXJndW1lbnQsIG1ha2VFcnJvciB9IGZyb20gXCIuLi91dGlscy9pbmRleC5qc1wiO1xuaW1wb3J0IHsgSnNvblJwY0FwaVBvbGxpbmdQcm92aWRlciB9IGZyb20gXCIuL3Byb3ZpZGVyLWpzb25ycGMuanNcIjtcbjtcbi8qKlxuICogIEEgKipCcm93c2VyUHJvdmlkZXIqKiBpcyBpbnRlbmRlZCB0byB3cmFwIGFuIGluamVjdGVkIHByb3ZpZGVyIHdoaWNoXG4gKiAgYWRoZXJlcyB0byB0aGUgW1tsaW5rLWVpcC0xMTkzXV0gc3RhbmRhcmQsIHdoaWNoIG1vc3QgKGlmIG5vdCBhbGwpXG4gKiAgY3VycmVudGx5IGRvLlxuICovXG5leHBvcnQgY2xhc3MgQnJvd3NlclByb3ZpZGVyIGV4dGVuZHMgSnNvblJwY0FwaVBvbGxpbmdQcm92aWRlciB7XG4gICAgI3JlcXVlc3Q7XG4gICAgI3Byb3ZpZGVySW5mbztcbiAgICAvKipcbiAgICAgKiAgQ29ubmVjdCB0byB0aGUgJSVldGhlcmV1bSUlIHByb3ZpZGVyLCBvcHRpb25hbGx5IGZvcmNpbmcgdGhlXG4gICAgICogICUlbmV0d29yayUlLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGV0aGVyZXVtLCBuZXR3b3JrLCBfb3B0aW9ucykge1xuICAgICAgICAvLyBDb3B5IHRoZSBvcHRpb25zXG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCAoKF9vcHRpb25zICE9IG51bGwpID8gX29wdGlvbnMgOiB7fSksIHsgYmF0Y2hNYXhDb3VudDogMSB9KTtcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQoZXRoZXJldW0gJiYgZXRoZXJldW0ucmVxdWVzdCwgXCJpbnZhbGlkIEVJUC0xMTkzIHByb3ZpZGVyXCIsIFwiZXRoZXJldW1cIiwgZXRoZXJldW0pO1xuICAgICAgICBzdXBlcihuZXR3b3JrLCBvcHRpb25zKTtcbiAgICAgICAgdGhpcy4jcHJvdmlkZXJJbmZvID0gbnVsbDtcbiAgICAgICAgaWYgKF9vcHRpb25zICYmIF9vcHRpb25zLnByb3ZpZGVySW5mbykge1xuICAgICAgICAgICAgdGhpcy4jcHJvdmlkZXJJbmZvID0gX29wdGlvbnMucHJvdmlkZXJJbmZvO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuI3JlcXVlc3QgPSBhc3luYyAobWV0aG9kLCBwYXJhbXMpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHBheWxvYWQgPSB7IG1ldGhvZCwgcGFyYW1zIH07XG4gICAgICAgICAgICB0aGlzLmVtaXQoXCJkZWJ1Z1wiLCB7IGFjdGlvbjogXCJzZW5kRWlwMTE5M1JlcXVlc3RcIiwgcGF5bG9hZCB9KTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgZXRoZXJldW0ucmVxdWVzdChwYXlsb2FkKTtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJkZWJ1Z1wiLCB7IGFjdGlvbjogXCJyZWNlaXZlRWlwMTE5M1Jlc3VsdFwiLCByZXN1bHQgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoZS5tZXNzYWdlKTtcbiAgICAgICAgICAgICAgICBlcnJvci5jb2RlID0gZS5jb2RlO1xuICAgICAgICAgICAgICAgIGVycm9yLmRhdGEgPSBlLmRhdGE7XG4gICAgICAgICAgICAgICAgZXJyb3IucGF5bG9hZCA9IHBheWxvYWQ7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwiZGVidWdcIiwgeyBhY3Rpb246IFwicmVjZWl2ZUVpcDExOTNFcnJvclwiLCBlcnJvciB9KTtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgZ2V0IHByb3ZpZGVySW5mbygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI3Byb3ZpZGVySW5mbztcbiAgICB9XG4gICAgYXN5bmMgc2VuZChtZXRob2QsIHBhcmFtcykge1xuICAgICAgICBhd2FpdCB0aGlzLl9zdGFydCgpO1xuICAgICAgICByZXR1cm4gYXdhaXQgc3VwZXIuc2VuZChtZXRob2QsIHBhcmFtcyk7XG4gICAgfVxuICAgIGFzeW5jIF9zZW5kKHBheWxvYWQpIHtcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQoIUFycmF5LmlzQXJyYXkocGF5bG9hZCksIFwiRUlQLTExOTMgZG9lcyBub3Qgc3VwcG9ydCBiYXRjaCByZXF1ZXN0XCIsIFwicGF5bG9hZFwiLCBwYXlsb2FkKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuI3JlcXVlc3QocGF5bG9hZC5tZXRob2QsIHBheWxvYWQucGFyYW1zIHx8IFtdKTtcbiAgICAgICAgICAgIHJldHVybiBbeyBpZDogcGF5bG9hZC5pZCwgcmVzdWx0IH1dO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICByZXR1cm4gW3tcbiAgICAgICAgICAgICAgICAgICAgaWQ6IHBheWxvYWQuaWQsXG4gICAgICAgICAgICAgICAgICAgIGVycm9yOiB7IGNvZGU6IGUuY29kZSwgZGF0YTogZS5kYXRhLCBtZXNzYWdlOiBlLm1lc3NhZ2UgfVxuICAgICAgICAgICAgICAgIH1dO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldFJwY0Vycm9yKHBheWxvYWQsIGVycm9yKSB7XG4gICAgICAgIGVycm9yID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShlcnJvcikpO1xuICAgICAgICAvLyBFSVAtMTE5MyBnaXZlcyB1cyBzb21lIG1hY2hpbmUtcmVhZGFibGUgZXJyb3IgY29kZXMsIHNvIHJld3JpdGVcbiAgICAgICAgLy8gdGhlbSBpbnRvIEV0aGVycyBzdGFuZGFyZCBlcnJvcnMuXG4gICAgICAgIHN3aXRjaCAoZXJyb3IuZXJyb3IuY29kZSB8fCAtMSkge1xuICAgICAgICAgICAgY2FzZSA0MDAxOlxuICAgICAgICAgICAgICAgIGVycm9yLmVycm9yLm1lc3NhZ2UgPSBgZXRoZXJzLXVzZXItZGVuaWVkOiAke2Vycm9yLmVycm9yLm1lc3NhZ2V9YDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgNDIwMDpcbiAgICAgICAgICAgICAgICBlcnJvci5lcnJvci5tZXNzYWdlID0gYGV0aGVycy11bnN1cHBvcnRlZDogJHtlcnJvci5lcnJvci5tZXNzYWdlfWA7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN1cGVyLmdldFJwY0Vycm9yKHBheWxvYWQsIGVycm9yKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJlc29sdmVzIHRvIGBgdHJ1ZWBgIGlmIHRoZSBwcm92aWRlciBtYW5hZ2VzIHRoZSAlJWFkZHJlc3MlJS5cbiAgICAgKi9cbiAgICBhc3luYyBoYXNTaWduZXIoYWRkcmVzcykge1xuICAgICAgICBpZiAoYWRkcmVzcyA9PSBudWxsKSB7XG4gICAgICAgICAgICBhZGRyZXNzID0gMDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhY2NvdW50cyA9IGF3YWl0IHRoaXMuc2VuZChcImV0aF9hY2NvdW50c1wiLCBbXSk7XG4gICAgICAgIGlmICh0eXBlb2YgKGFkZHJlc3MpID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICByZXR1cm4gKGFjY291bnRzLmxlbmd0aCA+IGFkZHJlc3MpO1xuICAgICAgICB9XG4gICAgICAgIGFkZHJlc3MgPSBhZGRyZXNzLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIHJldHVybiBhY2NvdW50cy5maWx0ZXIoKGEpID0+IChhLnRvTG93ZXJDYXNlKCkgPT09IGFkZHJlc3MpKS5sZW5ndGggIT09IDA7XG4gICAgfVxuICAgIGFzeW5jIGdldFNpZ25lcihhZGRyZXNzKSB7XG4gICAgICAgIGlmIChhZGRyZXNzID09IG51bGwpIHtcbiAgICAgICAgICAgIGFkZHJlc3MgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGlmICghKGF3YWl0IHRoaXMuaGFzU2lnbmVyKGFkZHJlc3MpKSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLiNyZXF1ZXN0KFwiZXRoX3JlcXVlc3RBY2NvdW50c1wiLCBbXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXlsb2FkID0gZXJyb3IucGF5bG9hZDtcbiAgICAgICAgICAgICAgICB0aHJvdyB0aGlzLmdldFJwY0Vycm9yKHBheWxvYWQsIHsgaWQ6IHBheWxvYWQuaWQsIGVycm9yIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhd2FpdCBzdXBlci5nZXRTaWduZXIoYWRkcmVzcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBEaXNjb3ZlciBhbmQgY29ubmVjdCB0byBhIFByb3ZpZGVyIGluIHRoZSBCcm93c2VyIHVzaW5nIHRoZVxuICAgICAqICBbW2xpbmstZWlwLTY5NjNdXSBkaXNjb3ZlcnkgbWVjaGFuaXNtLiBJZiBubyBwcm92aWRlcnMgYXJlXG4gICAgICogIHByZXNlbnQsIGBgbnVsbGBgIGlzIHJlc29sdmVkLlxuICAgICAqL1xuICAgIHN0YXRpYyBhc3luYyBkaXNjb3ZlcihvcHRpb25zKSB7XG4gICAgICAgIGlmIChvcHRpb25zID09IG51bGwpIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5wcm92aWRlcikge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBCcm93c2VyUHJvdmlkZXIob3B0aW9ucy5wcm92aWRlcik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY29udGV4dCA9IG9wdGlvbnMud2luZG93ID8gb3B0aW9ucy53aW5kb3cgOlxuICAgICAgICAgICAgKHR5cGVvZiAod2luZG93KSAhPT0gXCJ1bmRlZmluZWRcIikgPyB3aW5kb3cgOiBudWxsO1xuICAgICAgICBpZiAoY29udGV4dCA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhbnlQcm92aWRlciA9IG9wdGlvbnMuYW55UHJvdmlkZXI7XG4gICAgICAgIGlmIChhbnlQcm92aWRlciAmJiBjb250ZXh0LmV0aGVyZXVtKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEJyb3dzZXJQcm92aWRlcihjb250ZXh0LmV0aGVyZXVtKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIShcImFkZEV2ZW50TGlzdGVuZXJcIiBpbiBjb250ZXh0ICYmIFwiZGlzcGF0Y2hFdmVudFwiIGluIGNvbnRleHRcbiAgICAgICAgICAgICYmIFwicmVtb3ZlRXZlbnRMaXN0ZW5lclwiIGluIGNvbnRleHQpKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0aW1lb3V0ID0gb3B0aW9ucy50aW1lb3V0ID8gb3B0aW9ucy50aW1lb3V0IDogMzAwO1xuICAgICAgICBpZiAodGltZW91dCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGF3YWl0IChuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBsZXQgZm91bmQgPSBbXTtcbiAgICAgICAgICAgIGNvbnN0IGFkZFByb3ZpZGVyID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgZm91bmQucHVzaChldmVudC5kZXRhaWwpO1xuICAgICAgICAgICAgICAgIGlmIChhbnlQcm92aWRlcikge1xuICAgICAgICAgICAgICAgICAgICBmaW5hbGl6ZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCBmaW5hbGl6ZSA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZXIpO1xuICAgICAgICAgICAgICAgIGlmIChmb3VuZC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgZmlsdGVyaW5nIGlzIHByb3ZpZGVkOlxuICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmZpbHRlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2FsbCBmaWx0ZXIsIHdpdGggYSBjb3BpZXMgb2YgZm91bmQgcHJvdmlkZXIgaW5mb3NcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGZpbHRlcmVkID0gb3B0aW9ucy5maWx0ZXIoZm91bmQubWFwKGkgPT4gT2JqZWN0LmFzc2lnbih7fSwgKGkuaW5mbykpKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZmlsdGVyZWQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5vIHByb3ZpZGVyIHNlbGVjdGVkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGZpbHRlcmVkIGluc3RhbmNlb2YgQnJvd3NlclByb3ZpZGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ3VzdG9tIHByb3ZpZGVyIGNyZWF0ZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKGZpbHRlcmVkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZpbmQgdGhlIG1hdGNoaW5nIHByb3ZpZGVyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG1hdGNoID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZmlsdGVyZWQudXVpZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBtYXRjaGVzID0gZm91bmQuZmlsdGVyKGYgPT4gKGZpbHRlcmVkLnV1aWQgPT09IGYuaW5mby51dWlkKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEBUT0RPOiBXaGF0IHNob3VsZCBoYXBwZW4gaWYgbXVsdGlwbGUgdmFsdWVzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgICAgICBmb3IgdGhlIHNhbWUgVVVJRD9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2ggPSBtYXRjaGVzWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBwcm92aWRlciwgaW5mbyB9ID0gbWF0Y2g7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUobmV3IEJyb3dzZXJQcm92aWRlcihwcm92aWRlciwgdW5kZWZpbmVkLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm92aWRlckluZm86IGluZm9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KG1ha2VFcnJvcihcImZpbHRlciByZXR1cm5lZCB1bmtub3duIGluZm9cIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGZpbHRlcmVkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBQaWNrIHRoZSBmaXJzdCBmb3VuZCBwcm92aWRlclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBwcm92aWRlciwgaW5mbyB9ID0gZm91bmRbMF07XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKG5ldyBCcm93c2VyUHJvdmlkZXIocHJvdmlkZXIsIHVuZGVmaW5lZCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3ZpZGVySW5mbzogaW5mb1xuICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBOb3RoaW5nIGZvdW5kXG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUobnVsbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnRleHQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImVpcDY5NjM6YW5ub3VuY2VQcm92aWRlclwiLCBhZGRQcm92aWRlcik7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3QgdGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHsgZmluYWxpemUoKTsgfSwgdGltZW91dCk7XG4gICAgICAgICAgICBjb250ZXh0LmFkZEV2ZW50TGlzdGVuZXIoXCJlaXA2OTYzOmFubm91bmNlUHJvdmlkZXJcIiwgYWRkUHJvdmlkZXIpO1xuICAgICAgICAgICAgY29udGV4dC5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudChcImVpcDY5NjM6cmVxdWVzdFByb3ZpZGVyXCIpKTtcbiAgICAgICAgfSkpO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXByb3ZpZGVyLWJyb3dzZXIuanMubWFwIl0sIm5hbWVzIjpbImFzc2VydEFyZ3VtZW50IiwibWFrZUVycm9yIiwiSnNvblJwY0FwaVBvbGxpbmdQcm92aWRlciIsIkJyb3dzZXJQcm92aWRlciIsInJlcXVlc3QiLCJwcm92aWRlckluZm8iLCJjb25zdHJ1Y3RvciIsImV0aGVyZXVtIiwibmV0d29yayIsIl9vcHRpb25zIiwib3B0aW9ucyIsIk9iamVjdCIsImFzc2lnbiIsImJhdGNoTWF4Q291bnQiLCJtZXRob2QiLCJwYXJhbXMiLCJwYXlsb2FkIiwiZW1pdCIsImFjdGlvbiIsInJlc3VsdCIsImUiLCJlcnJvciIsIkVycm9yIiwibWVzc2FnZSIsImNvZGUiLCJkYXRhIiwic2VuZCIsIl9zdGFydCIsIl9zZW5kIiwiQXJyYXkiLCJpc0FycmF5IiwiaWQiLCJnZXRScGNFcnJvciIsIkpTT04iLCJwYXJzZSIsInN0cmluZ2lmeSIsImhhc1NpZ25lciIsImFkZHJlc3MiLCJhY2NvdW50cyIsImxlbmd0aCIsInRvTG93ZXJDYXNlIiwiZmlsdGVyIiwiYSIsImdldFNpZ25lciIsImRpc2NvdmVyIiwicHJvdmlkZXIiLCJjb250ZXh0Iiwid2luZG93IiwiYW55UHJvdmlkZXIiLCJ0aW1lb3V0IiwiUHJvbWlzZSIsInJlc29sdmUiLCJyZWplY3QiLCJmb3VuZCIsImFkZFByb3ZpZGVyIiwiZXZlbnQiLCJwdXNoIiwiZGV0YWlsIiwiZmluYWxpemUiLCJjbGVhclRpbWVvdXQiLCJ0aW1lciIsImZpbHRlcmVkIiwibWFwIiwiaSIsImluZm8iLCJtYXRjaCIsInV1aWQiLCJtYXRjaGVzIiwiZiIsInVuZGVmaW5lZCIsInZhbHVlIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsInNldFRpbWVvdXQiLCJhZGRFdmVudExpc3RlbmVyIiwiZGlzcGF0Y2hFdmVudCIsIkV2ZW50Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.esm/providers/provider-browser.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.esm/providers/provider-jsonrpc.js":
/*!*******************************************************************!*\
  !*** ./node_modules/ethers/lib.esm/providers/provider-jsonrpc.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   JsonRpcApiPollingProvider: () => (/* binding */ JsonRpcApiPollingProvider),\n/* harmony export */   JsonRpcApiProvider: () => (/* binding */ JsonRpcApiProvider),\n/* harmony export */   JsonRpcProvider: () => (/* binding */ JsonRpcProvider),\n/* harmony export */   JsonRpcSigner: () => (/* binding */ JsonRpcSigner)\n/* harmony export */ });\n/* harmony import */ var _abi_index_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../abi/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/abi/abi-coder.js\");\n/* harmony import */ var _address_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../address/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/address/address.js\");\n/* harmony import */ var _address_index_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../address/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/address/checks.js\");\n/* harmony import */ var _hash_index_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../hash/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/hash/typed-data.js\");\n/* harmony import */ var _transaction_index_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../transaction/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/transaction/accesslist.js\");\n/* harmony import */ var _transaction_index_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../transaction/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/transaction/authorization.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/properties.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/errors.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/utf8.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/data.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/maths.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/fetch.js\");\n/* harmony import */ var _abstract_provider_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./abstract-provider.js */ \"(ssr)/./node_modules/ethers/lib.esm/providers/abstract-provider.js\");\n/* harmony import */ var _abstract_signer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract-signer.js */ \"(ssr)/./node_modules/ethers/lib.esm/providers/abstract-signer.js\");\n/* harmony import */ var _network_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./network.js */ \"(ssr)/./node_modules/ethers/lib.esm/providers/network.js\");\n/* harmony import */ var _subscriber_filterid_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./subscriber-filterid.js */ \"(ssr)/./node_modules/ethers/lib.esm/providers/subscriber-filterid.js\");\n/* harmony import */ var _subscriber_polling_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./subscriber-polling.js */ \"(ssr)/./node_modules/ethers/lib.esm/providers/subscriber-polling.js\");\n/**\n *  One of the most common ways to interact with the blockchain is\n *  by a node running a JSON-RPC interface which can be connected to,\n *  based on the transport, using:\n *\n *  - HTTP or HTTPS - [[JsonRpcProvider]]\n *  - WebSocket - [[WebSocketProvider]]\n *  - IPC - [[IpcSocketProvider]]\n *\n * @_section: api/providers/jsonrpc:JSON-RPC Provider  [about-jsonrpcProvider]\n */ // @TODO:\n// - Add the batching API\n// https://playground.open-rpc.org/?schemaUrl=https://raw.githubusercontent.com/ethereum/eth1.0-apis/assembled-spec/openrpc.json&uiSchema%5BappBar%5D%5Bui:splitView%5D=true&uiSchema%5BappBar%5D%5Bui:input%5D=false&uiSchema%5BappBar%5D%5Bui:examplesDropdown%5D=false\n\n\n\n\n\n\n\n\n\n\nconst Primitive = \"bigint,boolean,function,number,string,symbol\".split(/,/g);\n//const Methods = \"getAddress,then\".split(/,/g);\nfunction deepCopy(value) {\n    if (value == null || Primitive.indexOf(typeof value) >= 0) {\n        return value;\n    }\n    // Keep any Addressable\n    if (typeof value.getAddress === \"function\") {\n        return value;\n    }\n    if (Array.isArray(value)) {\n        return value.map(deepCopy);\n    }\n    if (typeof value === \"object\") {\n        return Object.keys(value).reduce((accum, key)=>{\n            accum[key] = value[key];\n            return accum;\n        }, {});\n    }\n    throw new Error(`should not happen: ${value} (${typeof value})`);\n}\nfunction stall(duration) {\n    return new Promise((resolve)=>{\n        setTimeout(resolve, duration);\n    });\n}\nfunction getLowerCase(value) {\n    if (value) {\n        return value.toLowerCase();\n    }\n    return value;\n}\nfunction isPollable(value) {\n    return value && typeof value.pollingInterval === \"number\";\n}\nconst defaultOptions = {\n    polling: false,\n    staticNetwork: null,\n    batchStallTime: 10,\n    batchMaxSize: 1 << 20,\n    batchMaxCount: 100,\n    cacheTimeout: 250,\n    pollingInterval: 4000\n};\n// @TODO: Unchecked Signers\nclass JsonRpcSigner extends _abstract_signer_js__WEBPACK_IMPORTED_MODULE_0__.AbstractSigner {\n    constructor(provider, address){\n        super(provider);\n        address = (0,_address_index_js__WEBPACK_IMPORTED_MODULE_1__.getAddress)(address);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.defineProperties)(this, {\n            address\n        });\n    }\n    connect(provider) {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assert)(false, \"cannot reconnect JsonRpcSigner\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"signer.connect\"\n        });\n    }\n    async getAddress() {\n        return this.address;\n    }\n    // JSON-RPC will automatially fill in nonce, etc. so we just check from\n    async populateTransaction(tx) {\n        return await this.populateCall(tx);\n    }\n    // Returns just the hash of the transaction after sent, which is what\n    // the bare JSON-RPC API does;\n    async sendUncheckedTransaction(_tx) {\n        const tx = deepCopy(_tx);\n        const promises = [];\n        // Make sure the from matches the sender\n        if (tx.from) {\n            const _from = tx.from;\n            promises.push((async ()=>{\n                const from = await (0,_address_index_js__WEBPACK_IMPORTED_MODULE_4__.resolveAddress)(_from, this.provider);\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(from != null && from.toLowerCase() === this.address.toLowerCase(), \"from address mismatch\", \"transaction\", _tx);\n                tx.from = from;\n            })());\n        } else {\n            tx.from = this.address;\n        }\n        // The JSON-RPC for eth_sendTransaction uses 90000 gas; if the user\n        // wishes to use this, it is easy to specify explicitly, otherwise\n        // we look it up for them.\n        if (tx.gasLimit == null) {\n            promises.push((async ()=>{\n                tx.gasLimit = await this.provider.estimateGas({\n                    ...tx,\n                    from: this.address\n                });\n            })());\n        }\n        // The address may be an ENS name or Addressable\n        if (tx.to != null) {\n            const _to = tx.to;\n            promises.push((async ()=>{\n                tx.to = await (0,_address_index_js__WEBPACK_IMPORTED_MODULE_4__.resolveAddress)(_to, this.provider);\n            })());\n        }\n        // Wait until all of our properties are filled in\n        if (promises.length) {\n            await Promise.all(promises);\n        }\n        const hexTx = this.provider.getRpcTransaction(tx);\n        return this.provider.send(\"eth_sendTransaction\", [\n            hexTx\n        ]);\n    }\n    async sendTransaction(tx) {\n        // This cannot be mined any earlier than any recent block\n        const blockNumber = await this.provider.getBlockNumber();\n        // Send the transaction\n        const hash = await this.sendUncheckedTransaction(tx);\n        // Unfortunately, JSON-RPC only provides and opaque transaction hash\n        // for a response, and we need the actual transaction, so we poll\n        // for it; it should show up very quickly\n        return await new Promise((resolve, reject)=>{\n            const timeouts = [\n                1000,\n                100\n            ];\n            let invalids = 0;\n            const checkTx = async ()=>{\n                try {\n                    // Try getting the transaction\n                    const tx = await this.provider.getTransaction(hash);\n                    if (tx != null) {\n                        resolve(tx.replaceableTransaction(blockNumber));\n                        return;\n                    }\n                } catch (error) {\n                    // If we were cancelled: stop polling.\n                    // If the data is bad: the node returns bad transactions\n                    // If the network changed: calling again will also fail\n                    // If unsupported: likely destroyed\n                    if ((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.isError)(error, \"CANCELLED\") || (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.isError)(error, \"BAD_DATA\") || (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.isError)(error, \"NETWORK_ERROR\") || (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.isError)(error, \"UNSUPPORTED_OPERATION\")) {\n                        if (error.info == null) {\n                            error.info = {};\n                        }\n                        error.info.sendTransactionHash = hash;\n                        reject(error);\n                        return;\n                    }\n                    // Stop-gap for misbehaving backends; see #4513\n                    if ((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.isError)(error, \"INVALID_ARGUMENT\")) {\n                        invalids++;\n                        if (error.info == null) {\n                            error.info = {};\n                        }\n                        error.info.sendTransactionHash = hash;\n                        if (invalids > 10) {\n                            reject(error);\n                            return;\n                        }\n                    }\n                    // Notify anyone that cares; but we will try again, since\n                    // it is likely an intermittent service error\n                    this.provider.emit(\"error\", (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.makeError)(\"failed to fetch transation after sending (will try again)\", \"UNKNOWN_ERROR\", {\n                        error\n                    }));\n                }\n                // Wait another 4 seconds\n                this.provider._setTimeout(()=>{\n                    checkTx();\n                }, timeouts.pop() || 4000);\n            };\n            checkTx();\n        });\n    }\n    async signTransaction(_tx) {\n        const tx = deepCopy(_tx);\n        // Make sure the from matches the sender\n        if (tx.from) {\n            const from = await (0,_address_index_js__WEBPACK_IMPORTED_MODULE_4__.resolveAddress)(tx.from, this.provider);\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(from != null && from.toLowerCase() === this.address.toLowerCase(), \"from address mismatch\", \"transaction\", _tx);\n            tx.from = from;\n        } else {\n            tx.from = this.address;\n        }\n        const hexTx = this.provider.getRpcTransaction(tx);\n        return await this.provider.send(\"eth_signTransaction\", [\n            hexTx\n        ]);\n    }\n    async signMessage(_message) {\n        const message = typeof _message === \"string\" ? (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.toUtf8Bytes)(_message) : _message;\n        return await this.provider.send(\"personal_sign\", [\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_6__.hexlify)(message),\n            this.address.toLowerCase()\n        ]);\n    }\n    async signTypedData(domain, types, _value) {\n        const value = deepCopy(_value);\n        // Populate any ENS names (in-place)\n        const populated = await _hash_index_js__WEBPACK_IMPORTED_MODULE_7__.TypedDataEncoder.resolveNames(domain, types, value, async (value)=>{\n            const address = await (0,_address_index_js__WEBPACK_IMPORTED_MODULE_4__.resolveAddress)(value);\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(address != null, \"TypedData does not support null address\", \"value\", value);\n            return address;\n        });\n        return await this.provider.send(\"eth_signTypedData_v4\", [\n            this.address.toLowerCase(),\n            JSON.stringify(_hash_index_js__WEBPACK_IMPORTED_MODULE_7__.TypedDataEncoder.getPayload(populated.domain, types, populated.value))\n        ]);\n    }\n    async unlock(password) {\n        return this.provider.send(\"personal_unlockAccount\", [\n            this.address.toLowerCase(),\n            password,\n            null\n        ]);\n    }\n    // https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_sign\n    async _legacySignMessage(_message) {\n        const message = typeof _message === \"string\" ? (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.toUtf8Bytes)(_message) : _message;\n        return await this.provider.send(\"eth_sign\", [\n            this.address.toLowerCase(),\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_6__.hexlify)(message)\n        ]);\n    }\n}\n/**\n *  The JsonRpcApiProvider is an abstract class and **MUST** be\n *  sub-classed.\n *\n *  It provides the base for all JSON-RPC-based Provider interaction.\n *\n *  Sub-classing Notes:\n *  - a sub-class MUST override _send\n *  - a sub-class MUST call the `_start()` method once connected\n */ class JsonRpcApiProvider extends _abstract_provider_js__WEBPACK_IMPORTED_MODULE_8__.AbstractProvider {\n    #options;\n    // The next ID to use for the JSON-RPC ID field\n    #nextId;\n    // Payloads are queued and triggered in batches using the drainTimer\n    #payloads;\n    #drainTimer;\n    #notReady;\n    #network;\n    #pendingDetectNetwork;\n    #scheduleDrain() {\n        if (this.#drainTimer) {\n            return;\n        }\n        // If we aren't using batching, no harm in sending it immediately\n        const stallTime = this._getOption(\"batchMaxCount\") === 1 ? 0 : this._getOption(\"batchStallTime\");\n        this.#drainTimer = setTimeout(()=>{\n            this.#drainTimer = null;\n            const payloads = this.#payloads;\n            this.#payloads = [];\n            while(payloads.length){\n                // Create payload batches that satisfy our batch constraints\n                const batch = [\n                    payloads.shift()\n                ];\n                while(payloads.length){\n                    if (batch.length === this.#options.batchMaxCount) {\n                        break;\n                    }\n                    batch.push(payloads.shift());\n                    const bytes = JSON.stringify(batch.map((p)=>p.payload));\n                    if (bytes.length > this.#options.batchMaxSize) {\n                        payloads.unshift(batch.pop());\n                        break;\n                    }\n                }\n                // Process the result to each payload\n                (async ()=>{\n                    const payload = batch.length === 1 ? batch[0].payload : batch.map((p)=>p.payload);\n                    this.emit(\"debug\", {\n                        action: \"sendRpcPayload\",\n                        payload\n                    });\n                    try {\n                        const result = await this._send(payload);\n                        this.emit(\"debug\", {\n                            action: \"receiveRpcResult\",\n                            result\n                        });\n                        // Process results in batch order\n                        for (const { resolve, reject, payload } of batch){\n                            if (this.destroyed) {\n                                reject((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.makeError)(\"provider destroyed; cancelled request\", \"UNSUPPORTED_OPERATION\", {\n                                    operation: payload.method\n                                }));\n                                continue;\n                            }\n                            // Find the matching result\n                            const resp = result.filter((r)=>r.id === payload.id)[0];\n                            // No result; the node failed us in unexpected ways\n                            if (resp == null) {\n                                const error = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.makeError)(\"missing response for request\", \"BAD_DATA\", {\n                                    value: result,\n                                    info: {\n                                        payload\n                                    }\n                                });\n                                this.emit(\"error\", error);\n                                reject(error);\n                                continue;\n                            }\n                            // The response is an error\n                            if (\"error\" in resp) {\n                                reject(this.getRpcError(payload, resp));\n                                continue;\n                            }\n                            // All good; send the result\n                            resolve(resp.result);\n                        }\n                    } catch (error) {\n                        this.emit(\"debug\", {\n                            action: \"receiveRpcError\",\n                            error\n                        });\n                        for (const { reject } of batch){\n                            // @TODO: augment the error with the payload\n                            reject(error);\n                        }\n                    }\n                })();\n            }\n        }, stallTime);\n    }\n    constructor(network, options){\n        super(network, options);\n        this.#nextId = 1;\n        this.#options = Object.assign({}, defaultOptions, options || {});\n        this.#payloads = [];\n        this.#drainTimer = null;\n        this.#network = null;\n        this.#pendingDetectNetwork = null;\n        {\n            let resolve = null;\n            const promise = new Promise((_resolve)=>{\n                resolve = _resolve;\n            });\n            this.#notReady = {\n                promise,\n                resolve\n            };\n        }\n        const staticNetwork = this._getOption(\"staticNetwork\");\n        if (typeof staticNetwork === \"boolean\") {\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(!staticNetwork || network !== \"any\", \"staticNetwork cannot be used on special network 'any'\", \"options\", options);\n            if (staticNetwork && network != null) {\n                this.#network = _network_js__WEBPACK_IMPORTED_MODULE_9__.Network.from(network);\n            }\n        } else if (staticNetwork) {\n            // Make sure any static network is compatbile with the provided netwrok\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(network == null || staticNetwork.matches(network), \"staticNetwork MUST match network object\", \"options\", options);\n            this.#network = staticNetwork;\n        }\n    }\n    /**\n     *  Returns the value associated with the option %%key%%.\n     *\n     *  Sub-classes can use this to inquire about configuration options.\n     */ _getOption(key) {\n        return this.#options[key];\n    }\n    /**\n     *  Gets the [[Network]] this provider has committed to. On each call, the network\n     *  is detected, and if it has changed, the call will reject.\n     */ get _network() {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assert)(this.#network, \"network is not available yet\", \"NETWORK_ERROR\");\n        return this.#network;\n    }\n    /**\n     *  Resolves to the non-normalized value by performing %%req%%.\n     *\n     *  Sub-classes may override this to modify behavior of actions,\n     *  and should generally call ``super._perform`` as a fallback.\n     */ async _perform(req) {\n        // Legacy networks do not like the type field being passed along (which\n        // is fair), so we delete type if it is 0 and a non-EIP-1559 network\n        if (req.method === \"call\" || req.method === \"estimateGas\") {\n            let tx = req.transaction;\n            if (tx && tx.type != null && (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_10__.getBigInt)(tx.type)) {\n                // If there are no EIP-1559 or newer properties, it might be pre-EIP-1559\n                if (tx.maxFeePerGas == null && tx.maxPriorityFeePerGas == null) {\n                    const feeData = await this.getFeeData();\n                    if (feeData.maxFeePerGas == null && feeData.maxPriorityFeePerGas == null) {\n                        // Network doesn't know about EIP-1559 (and hence type)\n                        req = Object.assign({}, req, {\n                            transaction: Object.assign({}, tx, {\n                                type: undefined\n                            })\n                        });\n                    }\n                }\n            }\n        }\n        const request = this.getRpcRequest(req);\n        if (request != null) {\n            return await this.send(request.method, request.args);\n        }\n        return super._perform(req);\n    }\n    /**\n     *  Sub-classes may override this; it detects the *actual* network that\n     *  we are **currently** connected to.\n     *\n     *  Keep in mind that [[send]] may only be used once [[ready]], otherwise the\n     *  _send primitive must be used instead.\n     */ async _detectNetwork() {\n        const network = this._getOption(\"staticNetwork\");\n        if (network) {\n            if (network === true) {\n                if (this.#network) {\n                    return this.#network;\n                }\n            } else {\n                return network;\n            }\n        }\n        if (this.#pendingDetectNetwork) {\n            return await this.#pendingDetectNetwork;\n        }\n        // If we are ready, use ``send``, which enabled requests to be batched\n        if (this.ready) {\n            this.#pendingDetectNetwork = (async ()=>{\n                try {\n                    const result = _network_js__WEBPACK_IMPORTED_MODULE_9__.Network.from((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_10__.getBigInt)(await this.send(\"eth_chainId\", [])));\n                    this.#pendingDetectNetwork = null;\n                    return result;\n                } catch (error) {\n                    this.#pendingDetectNetwork = null;\n                    throw error;\n                }\n            })();\n            return await this.#pendingDetectNetwork;\n        }\n        // We are not ready yet; use the primitive _send\n        this.#pendingDetectNetwork = (async ()=>{\n            const payload = {\n                id: this.#nextId++,\n                method: \"eth_chainId\",\n                params: [],\n                jsonrpc: \"2.0\"\n            };\n            this.emit(\"debug\", {\n                action: \"sendRpcPayload\",\n                payload\n            });\n            let result;\n            try {\n                result = (await this._send(payload))[0];\n                this.#pendingDetectNetwork = null;\n            } catch (error) {\n                this.#pendingDetectNetwork = null;\n                this.emit(\"debug\", {\n                    action: \"receiveRpcError\",\n                    error\n                });\n                throw error;\n            }\n            this.emit(\"debug\", {\n                action: \"receiveRpcResult\",\n                result\n            });\n            if (\"result\" in result) {\n                return _network_js__WEBPACK_IMPORTED_MODULE_9__.Network.from((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_10__.getBigInt)(result.result));\n            }\n            throw this.getRpcError(payload, result);\n        })();\n        return await this.#pendingDetectNetwork;\n    }\n    /**\n     *  Sub-classes **MUST** call this. Until [[_start]] has been called, no calls\n     *  will be passed to [[_send]] from [[send]]. If it is overridden, then\n     *  ``super._start()`` **MUST** be called.\n     *\n     *  Calling it multiple times is safe and has no effect.\n     */ _start() {\n        if (this.#notReady == null || this.#notReady.resolve == null) {\n            return;\n        }\n        this.#notReady.resolve();\n        this.#notReady = null;\n        (async ()=>{\n            // Bootstrap the network\n            while(this.#network == null && !this.destroyed){\n                try {\n                    this.#network = await this._detectNetwork();\n                } catch (error) {\n                    if (this.destroyed) {\n                        break;\n                    }\n                    console.log(\"JsonRpcProvider failed to detect network and cannot start up; retry in 1s (perhaps the URL is wrong or the node is not started)\");\n                    this.emit(\"error\", (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.makeError)(\"failed to bootstrap network detection\", \"NETWORK_ERROR\", {\n                        event: \"initial-network-discovery\",\n                        info: {\n                            error\n                        }\n                    }));\n                    await stall(1000);\n                }\n            }\n            // Start dispatching requests\n            this.#scheduleDrain();\n        })();\n    }\n    /**\n     *  Resolves once the [[_start]] has been called. This can be used in\n     *  sub-classes to defer sending data until the connection has been\n     *  established.\n     */ async _waitUntilReady() {\n        if (this.#notReady == null) {\n            return;\n        }\n        return await this.#notReady.promise;\n    }\n    /**\n     *  Return a Subscriber that will manage the %%sub%%.\n     *\n     *  Sub-classes may override this to modify the behavior of\n     *  subscription management.\n     */ _getSubscriber(sub) {\n        // Pending Filters aren't availble via polling\n        if (sub.type === \"pending\") {\n            return new _subscriber_filterid_js__WEBPACK_IMPORTED_MODULE_11__.FilterIdPendingSubscriber(this);\n        }\n        if (sub.type === \"event\") {\n            if (this._getOption(\"polling\")) {\n                return new _subscriber_polling_js__WEBPACK_IMPORTED_MODULE_12__.PollingEventSubscriber(this, sub.filter);\n            }\n            return new _subscriber_filterid_js__WEBPACK_IMPORTED_MODULE_11__.FilterIdEventSubscriber(this, sub.filter);\n        }\n        // Orphaned Logs are handled automatically, by the filter, since\n        // logs with removed are emitted by it\n        if (sub.type === \"orphan\" && sub.filter.orphan === \"drop-log\") {\n            return new _abstract_provider_js__WEBPACK_IMPORTED_MODULE_8__.UnmanagedSubscriber(\"orphan\");\n        }\n        return super._getSubscriber(sub);\n    }\n    /**\n     *  Returns true only if the [[_start]] has been called.\n     */ get ready() {\n        return this.#notReady == null;\n    }\n    /**\n     *  Returns %%tx%% as a normalized JSON-RPC transaction request,\n     *  which has all values hexlified and any numeric values converted\n     *  to Quantity values.\n     */ getRpcTransaction(tx) {\n        const result = {};\n        // JSON-RPC now requires numeric values to be \"quantity\" values\n        [\n            \"chainId\",\n            \"gasLimit\",\n            \"gasPrice\",\n            \"type\",\n            \"maxFeePerGas\",\n            \"maxPriorityFeePerGas\",\n            \"nonce\",\n            \"value\"\n        ].forEach((key)=>{\n            if (tx[key] == null) {\n                return;\n            }\n            let dstKey = key;\n            if (key === \"gasLimit\") {\n                dstKey = \"gas\";\n            }\n            result[dstKey] = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_10__.toQuantity)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_10__.getBigInt)(tx[key], `tx.${key}`));\n        });\n        // Make sure addresses and data are lowercase\n        [\n            \"from\",\n            \"to\",\n            \"data\"\n        ].forEach((key)=>{\n            if (tx[key] == null) {\n                return;\n            }\n            result[key] = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_6__.hexlify)(tx[key]);\n        });\n        // Normalize the access list object\n        if (tx.accessList) {\n            result[\"accessList\"] = (0,_transaction_index_js__WEBPACK_IMPORTED_MODULE_13__.accessListify)(tx.accessList);\n        }\n        if (tx.blobVersionedHashes) {\n            // @TODO: Remove this <any> case once EIP-4844 added to prepared tx\n            result[\"blobVersionedHashes\"] = tx.blobVersionedHashes.map((h)=>h.toLowerCase());\n        }\n        if (tx.authorizationList) {\n            result[\"authorizationList\"] = tx.authorizationList.map((_a)=>{\n                const a = (0,_transaction_index_js__WEBPACK_IMPORTED_MODULE_14__.authorizationify)(_a);\n                return {\n                    address: a.address,\n                    nonce: (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_10__.toQuantity)(a.nonce),\n                    chainId: (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_10__.toQuantity)(a.chainId),\n                    yParity: (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_10__.toQuantity)(a.signature.yParity),\n                    r: (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_10__.toQuantity)(a.signature.r),\n                    s: (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_10__.toQuantity)(a.signature.s)\n                };\n            });\n        }\n        // @TODO: blobs should probably also be copied over, optionally\n        // accounting for the kzg property to backfill blobVersionedHashes\n        // using the commitment. Or should that be left as an exercise to\n        // the caller?\n        return result;\n    }\n    /**\n     *  Returns the request method and arguments required to perform\n     *  %%req%%.\n     */ getRpcRequest(req) {\n        switch(req.method){\n            case \"chainId\":\n                return {\n                    method: \"eth_chainId\",\n                    args: []\n                };\n            case \"getBlockNumber\":\n                return {\n                    method: \"eth_blockNumber\",\n                    args: []\n                };\n            case \"getGasPrice\":\n                return {\n                    method: \"eth_gasPrice\",\n                    args: []\n                };\n            case \"getPriorityFee\":\n                return {\n                    method: \"eth_maxPriorityFeePerGas\",\n                    args: []\n                };\n            case \"getBalance\":\n                return {\n                    method: \"eth_getBalance\",\n                    args: [\n                        getLowerCase(req.address),\n                        req.blockTag\n                    ]\n                };\n            case \"getTransactionCount\":\n                return {\n                    method: \"eth_getTransactionCount\",\n                    args: [\n                        getLowerCase(req.address),\n                        req.blockTag\n                    ]\n                };\n            case \"getCode\":\n                return {\n                    method: \"eth_getCode\",\n                    args: [\n                        getLowerCase(req.address),\n                        req.blockTag\n                    ]\n                };\n            case \"getStorage\":\n                return {\n                    method: \"eth_getStorageAt\",\n                    args: [\n                        getLowerCase(req.address),\n                        \"0x\" + req.position.toString(16),\n                        req.blockTag\n                    ]\n                };\n            case \"broadcastTransaction\":\n                return {\n                    method: \"eth_sendRawTransaction\",\n                    args: [\n                        req.signedTransaction\n                    ]\n                };\n            case \"getBlock\":\n                if (\"blockTag\" in req) {\n                    return {\n                        method: \"eth_getBlockByNumber\",\n                        args: [\n                            req.blockTag,\n                            !!req.includeTransactions\n                        ]\n                    };\n                } else if (\"blockHash\" in req) {\n                    return {\n                        method: \"eth_getBlockByHash\",\n                        args: [\n                            req.blockHash,\n                            !!req.includeTransactions\n                        ]\n                    };\n                }\n                break;\n            case \"getTransaction\":\n                return {\n                    method: \"eth_getTransactionByHash\",\n                    args: [\n                        req.hash\n                    ]\n                };\n            case \"getTransactionReceipt\":\n                return {\n                    method: \"eth_getTransactionReceipt\",\n                    args: [\n                        req.hash\n                    ]\n                };\n            case \"call\":\n                return {\n                    method: \"eth_call\",\n                    args: [\n                        this.getRpcTransaction(req.transaction),\n                        req.blockTag\n                    ]\n                };\n            case \"estimateGas\":\n                {\n                    return {\n                        method: \"eth_estimateGas\",\n                        args: [\n                            this.getRpcTransaction(req.transaction)\n                        ]\n                    };\n                }\n            case \"getLogs\":\n                if (req.filter && req.filter.address != null) {\n                    if (Array.isArray(req.filter.address)) {\n                        req.filter.address = req.filter.address.map(getLowerCase);\n                    } else {\n                        req.filter.address = getLowerCase(req.filter.address);\n                    }\n                }\n                return {\n                    method: \"eth_getLogs\",\n                    args: [\n                        req.filter\n                    ]\n                };\n        }\n        return null;\n    }\n    /**\n     *  Returns an ethers-style Error for the given JSON-RPC error\n     *  %%payload%%, coalescing the various strings and error shapes\n     *  that different nodes return, coercing them into a machine-readable\n     *  standardized error.\n     */ getRpcError(payload, _error) {\n        const { method } = payload;\n        const { error } = _error;\n        if (method === \"eth_estimateGas\" && error.message) {\n            const msg = error.message;\n            if (!msg.match(/revert/i) && msg.match(/insufficient funds/i)) {\n                return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.makeError)(\"insufficient funds\", \"INSUFFICIENT_FUNDS\", {\n                    transaction: payload.params[0],\n                    info: {\n                        payload,\n                        error\n                    }\n                });\n            } else if (msg.match(/nonce/i) && msg.match(/too low/i)) {\n                return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.makeError)(\"nonce has already been used\", \"NONCE_EXPIRED\", {\n                    transaction: payload.params[0],\n                    info: {\n                        payload,\n                        error\n                    }\n                });\n            }\n        }\n        if (method === \"eth_call\" || method === \"eth_estimateGas\") {\n            const result = spelunkData(error);\n            const e = _abi_index_js__WEBPACK_IMPORTED_MODULE_15__.AbiCoder.getBuiltinCallException(method === \"eth_call\" ? \"call\" : \"estimateGas\", payload.params[0], result ? result.data : null);\n            e.info = {\n                error,\n                payload\n            };\n            return e;\n        }\n        // Only estimateGas and call can return arbitrary contract-defined text, so now we\n        // we can process text safely.\n        const message = JSON.stringify(spelunkMessage(error));\n        if (typeof error.message === \"string\" && error.message.match(/user denied|ethers-user-denied/i)) {\n            const actionMap = {\n                eth_sign: \"signMessage\",\n                personal_sign: \"signMessage\",\n                eth_signTypedData_v4: \"signTypedData\",\n                eth_signTransaction: \"signTransaction\",\n                eth_sendTransaction: \"sendTransaction\",\n                eth_requestAccounts: \"requestAccess\",\n                wallet_requestAccounts: \"requestAccess\"\n            };\n            return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.makeError)(`user rejected action`, \"ACTION_REJECTED\", {\n                action: actionMap[method] || \"unknown\",\n                reason: \"rejected\",\n                info: {\n                    payload,\n                    error\n                }\n            });\n        }\n        if (method === \"eth_sendRawTransaction\" || method === \"eth_sendTransaction\") {\n            const transaction = payload.params[0];\n            if (message.match(/insufficient funds|base fee exceeds gas limit/i)) {\n                return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.makeError)(\"insufficient funds for intrinsic transaction cost\", \"INSUFFICIENT_FUNDS\", {\n                    transaction,\n                    info: {\n                        error\n                    }\n                });\n            }\n            if (message.match(/nonce/i) && message.match(/too low/i)) {\n                return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.makeError)(\"nonce has already been used\", \"NONCE_EXPIRED\", {\n                    transaction,\n                    info: {\n                        error\n                    }\n                });\n            }\n            // \"replacement transaction underpriced\"\n            if (message.match(/replacement transaction/i) && message.match(/underpriced/i)) {\n                return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.makeError)(\"replacement fee too low\", \"REPLACEMENT_UNDERPRICED\", {\n                    transaction,\n                    info: {\n                        error\n                    }\n                });\n            }\n            if (message.match(/only replay-protected/i)) {\n                return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.makeError)(\"legacy pre-eip-155 transactions not supported\", \"UNSUPPORTED_OPERATION\", {\n                    operation: method,\n                    info: {\n                        transaction,\n                        info: {\n                            error\n                        }\n                    }\n                });\n            }\n        }\n        let unsupported = !!message.match(/the method .* does not exist/i);\n        if (!unsupported) {\n            if (error && error.details && error.details.startsWith(\"Unauthorized method:\")) {\n                unsupported = true;\n            }\n        }\n        if (unsupported) {\n            return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.makeError)(\"unsupported operation\", \"UNSUPPORTED_OPERATION\", {\n                operation: payload.method,\n                info: {\n                    error,\n                    payload\n                }\n            });\n        }\n        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.makeError)(\"could not coalesce error\", \"UNKNOWN_ERROR\", {\n            error,\n            payload\n        });\n    }\n    /**\n     *  Requests the %%method%% with %%params%% via the JSON-RPC protocol\n     *  over the underlying channel. This can be used to call methods\n     *  on the backend that do not have a high-level API within the Provider\n     *  API.\n     *\n     *  This method queues requests according to the batch constraints\n     *  in the options, assigns the request a unique ID.\n     *\n     *  **Do NOT override** this method in sub-classes; instead\n     *  override [[_send]] or force the options values in the\n     *  call to the constructor to modify this method's behavior.\n     */ send(method, params) {\n        // @TODO: cache chainId?? purge on switch_networks\n        // We have been destroyed; no operations are supported anymore\n        if (this.destroyed) {\n            return Promise.reject((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.makeError)(\"provider destroyed; cancelled request\", \"UNSUPPORTED_OPERATION\", {\n                operation: method\n            }));\n        }\n        const id = this.#nextId++;\n        const promise = new Promise((resolve, reject)=>{\n            this.#payloads.push({\n                resolve,\n                reject,\n                payload: {\n                    method,\n                    params,\n                    id,\n                    jsonrpc: \"2.0\"\n                }\n            });\n        });\n        // If there is not a pending drainTimer, set one\n        this.#scheduleDrain();\n        return promise;\n    }\n    /**\n     *  Resolves to the [[Signer]] account for  %%address%% managed by\n     *  the client.\n     *\n     *  If the %%address%% is a number, it is used as an index in the\n     *  the accounts from [[listAccounts]].\n     *\n     *  This can only be used on clients which manage accounts (such as\n     *  Geth with imported account or MetaMask).\n     *\n     *  Throws if the account doesn't exist.\n     */ async getSigner(address) {\n        if (address == null) {\n            address = 0;\n        }\n        const accountsPromise = this.send(\"eth_accounts\", []);\n        // Account index\n        if (typeof address === \"number\") {\n            const accounts = await accountsPromise;\n            if (address >= accounts.length) {\n                throw new Error(\"no such account\");\n            }\n            return new JsonRpcSigner(this, accounts[address]);\n        }\n        const { accounts } = await (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.resolveProperties)({\n            network: this.getNetwork(),\n            accounts: accountsPromise\n        });\n        // Account address\n        address = (0,_address_index_js__WEBPACK_IMPORTED_MODULE_1__.getAddress)(address);\n        for (const account of accounts){\n            if ((0,_address_index_js__WEBPACK_IMPORTED_MODULE_1__.getAddress)(account) === address) {\n                return new JsonRpcSigner(this, address);\n            }\n        }\n        throw new Error(\"invalid account\");\n    }\n    async listAccounts() {\n        const accounts = await this.send(\"eth_accounts\", []);\n        return accounts.map((a)=>new JsonRpcSigner(this, a));\n    }\n    destroy() {\n        // Stop processing requests\n        if (this.#drainTimer) {\n            clearTimeout(this.#drainTimer);\n            this.#drainTimer = null;\n        }\n        // Cancel all pending requests\n        for (const { payload, reject } of this.#payloads){\n            reject((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.makeError)(\"provider destroyed; cancelled request\", \"UNSUPPORTED_OPERATION\", {\n                operation: payload.method\n            }));\n        }\n        this.#payloads = [];\n        // Parent clean-up\n        super.destroy();\n    }\n}\n// @TODO: remove this in v7, it is not exported because this functionality\n// is exposed in the JsonRpcApiProvider by setting polling to true. It should\n// be safe to remove regardless, because it isn't reachable, but just in case.\n/**\n *  @_ignore:\n */ class JsonRpcApiPollingProvider extends JsonRpcApiProvider {\n    #pollingInterval;\n    constructor(network, options){\n        super(network, options);\n        let pollingInterval = this._getOption(\"pollingInterval\");\n        if (pollingInterval == null) {\n            pollingInterval = defaultOptions.pollingInterval;\n        }\n        this.#pollingInterval = pollingInterval;\n    }\n    _getSubscriber(sub) {\n        const subscriber = super._getSubscriber(sub);\n        if (isPollable(subscriber)) {\n            subscriber.pollingInterval = this.#pollingInterval;\n        }\n        return subscriber;\n    }\n    /**\n     *  The polling interval (default: 4000 ms)\n     */ get pollingInterval() {\n        return this.#pollingInterval;\n    }\n    set pollingInterval(value) {\n        if (!Number.isInteger(value) || value < 0) {\n            throw new Error(\"invalid interval\");\n        }\n        this.#pollingInterval = value;\n        this._forEachSubscriber((sub)=>{\n            if (isPollable(sub)) {\n                sub.pollingInterval = this.#pollingInterval;\n            }\n        });\n    }\n}\n/**\n *  The JsonRpcProvider is one of the most common Providers,\n *  which performs all operations over HTTP (or HTTPS) requests.\n *\n *  Events are processed by polling the backend for the current block\n *  number; when it advances, all block-base events are then checked\n *  for updates.\n */ class JsonRpcProvider extends JsonRpcApiPollingProvider {\n    #connect;\n    constructor(url, network, options){\n        if (url == null) {\n            url = \"http://localhost:8545\";\n        }\n        super(network, options);\n        if (typeof url === \"string\") {\n            this.#connect = new _utils_index_js__WEBPACK_IMPORTED_MODULE_16__.FetchRequest(url);\n        } else {\n            this.#connect = url.clone();\n        }\n    }\n    _getConnection() {\n        return this.#connect.clone();\n    }\n    async send(method, params) {\n        // All requests are over HTTP, so we can just start handling requests\n        // We do this here rather than the constructor so that we don't send any\n        // requests to the network (i.e. eth_chainId) until we absolutely have to.\n        await this._start();\n        return await super.send(method, params);\n    }\n    async _send(payload) {\n        // Configure a POST connection for the requested method\n        const request = this._getConnection();\n        request.body = JSON.stringify(payload);\n        request.setHeader(\"content-type\", \"application/json\");\n        const response = await request.send();\n        response.assertOk();\n        let resp = response.bodyJson;\n        if (!Array.isArray(resp)) {\n            resp = [\n                resp\n            ];\n        }\n        return resp;\n    }\n}\nfunction spelunkData(value) {\n    if (value == null) {\n        return null;\n    }\n    // These *are* the droids we're looking for.\n    if (typeof value.message === \"string\" && value.message.match(/revert/i) && (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_6__.isHexString)(value.data)) {\n        return {\n            message: value.message,\n            data: value.data\n        };\n    }\n    // Spelunk further...\n    if (typeof value === \"object\") {\n        for(const key in value){\n            const result = spelunkData(value[key]);\n            if (result) {\n                return result;\n            }\n        }\n        return null;\n    }\n    // Might be a JSON string we can further descend...\n    if (typeof value === \"string\") {\n        try {\n            return spelunkData(JSON.parse(value));\n        } catch (error) {}\n    }\n    return null;\n}\nfunction _spelunkMessage(value, result) {\n    if (value == null) {\n        return;\n    }\n    // These *are* the droids we're looking for.\n    if (typeof value.message === \"string\") {\n        result.push(value.message);\n    }\n    // Spelunk further...\n    if (typeof value === \"object\") {\n        for(const key in value){\n            _spelunkMessage(value[key], result);\n        }\n    }\n    // Might be a JSON string we can further descend...\n    if (typeof value === \"string\") {\n        try {\n            return _spelunkMessage(JSON.parse(value), result);\n        } catch (error) {}\n    }\n}\nfunction spelunkMessage(value) {\n    const result = [];\n    _spelunkMessage(value, result);\n    return result;\n} //# sourceMappingURL=provider-jsonrpc.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vcHJvdmlkZXJzL3Byb3ZpZGVyLWpzb25ycGMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7Ozs7Ozs7Ozs7Q0FVQyxHQUNELFNBQVM7QUFDVCx5QkFBeUI7QUFDekIseVFBQXlRO0FBQzlOO0FBQ3NCO0FBQ2I7QUFDc0I7QUFDa0g7QUFDN0c7QUFDekI7QUFDZjtBQUN1RDtBQUM3QjtBQUNqRSxNQUFNeUIsWUFBWSwrQ0FBK0NDLEtBQUssQ0FBQztBQUN2RSxnREFBZ0Q7QUFDaEQsU0FBU0MsU0FBU0MsS0FBSztJQUNuQixJQUFJQSxTQUFTLFFBQVFILFVBQVVJLE9BQU8sQ0FBQyxPQUFRRCxVQUFXLEdBQUc7UUFDekQsT0FBT0E7SUFDWDtJQUNBLHVCQUF1QjtJQUN2QixJQUFJLE9BQVFBLE1BQU0zQixVQUFVLEtBQU0sWUFBWTtRQUMxQyxPQUFPMkI7SUFDWDtJQUNBLElBQUlFLE1BQU1DLE9BQU8sQ0FBQ0gsUUFBUTtRQUN0QixPQUFRQSxNQUFNSSxHQUFHLENBQUNMO0lBQ3RCO0lBQ0EsSUFBSSxPQUFRQyxVQUFXLFVBQVU7UUFDN0IsT0FBT0ssT0FBT0MsSUFBSSxDQUFDTixPQUFPTyxNQUFNLENBQUMsQ0FBQ0MsT0FBT0M7WUFDckNELEtBQUssQ0FBQ0MsSUFBSSxHQUFHVCxLQUFLLENBQUNTLElBQUk7WUFDdkIsT0FBT0Q7UUFDWCxHQUFHLENBQUM7SUFDUjtJQUNBLE1BQU0sSUFBSUUsTUFBTSxDQUFDLG1CQUFtQixFQUFFVixNQUFNLEVBQUUsRUFBRSxPQUFRQSxNQUFPLENBQUMsQ0FBQztBQUNyRTtBQUNBLFNBQVNXLE1BQU1DLFFBQVE7SUFDbkIsT0FBTyxJQUFJQyxRQUFRLENBQUNDO1FBQWNDLFdBQVdELFNBQVNGO0lBQVc7QUFDckU7QUFDQSxTQUFTSSxhQUFhaEIsS0FBSztJQUN2QixJQUFJQSxPQUFPO1FBQ1AsT0FBT0EsTUFBTWlCLFdBQVc7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NEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tZWdhdmliZS1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9wcm92aWRlcnMvcHJvdmlkZXItanNvbnJwYy5qcz83ZTRlIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogIE9uZSBvZiB0aGUgbW9zdCBjb21tb24gd2F5cyB0byBpbnRlcmFjdCB3aXRoIHRoZSBibG9ja2NoYWluIGlzXG4gKiAgYnkgYSBub2RlIHJ1bm5pbmcgYSBKU09OLVJQQyBpbnRlcmZhY2Ugd2hpY2ggY2FuIGJlIGNvbm5lY3RlZCB0byxcbiAqICBiYXNlZCBvbiB0aGUgdHJhbnNwb3J0LCB1c2luZzpcbiAqXG4gKiAgLSBIVFRQIG9yIEhUVFBTIC0gW1tKc29uUnBjUHJvdmlkZXJdXVxuICogIC0gV2ViU29ja2V0IC0gW1tXZWJTb2NrZXRQcm92aWRlcl1dXG4gKiAgLSBJUEMgLSBbW0lwY1NvY2tldFByb3ZpZGVyXV1cbiAqXG4gKiBAX3NlY3Rpb246IGFwaS9wcm92aWRlcnMvanNvbnJwYzpKU09OLVJQQyBQcm92aWRlciAgW2Fib3V0LWpzb25ycGNQcm92aWRlcl1cbiAqL1xuLy8gQFRPRE86XG4vLyAtIEFkZCB0aGUgYmF0Y2hpbmcgQVBJXG4vLyBodHRwczovL3BsYXlncm91bmQub3Blbi1ycGMub3JnLz9zY2hlbWFVcmw9aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2V0aGVyZXVtL2V0aDEuMC1hcGlzL2Fzc2VtYmxlZC1zcGVjL29wZW5ycGMuanNvbiZ1aVNjaGVtYSU1QmFwcEJhciU1RCU1QnVpOnNwbGl0VmlldyU1RD10cnVlJnVpU2NoZW1hJTVCYXBwQmFyJTVEJTVCdWk6aW5wdXQlNUQ9ZmFsc2UmdWlTY2hlbWElNUJhcHBCYXIlNUQlNUJ1aTpleGFtcGxlc0Ryb3Bkb3duJTVEPWZhbHNlXG5pbXBvcnQgeyBBYmlDb2RlciB9IGZyb20gXCIuLi9hYmkvaW5kZXguanNcIjtcbmltcG9ydCB7IGdldEFkZHJlc3MsIHJlc29sdmVBZGRyZXNzIH0gZnJvbSBcIi4uL2FkZHJlc3MvaW5kZXguanNcIjtcbmltcG9ydCB7IFR5cGVkRGF0YUVuY29kZXIgfSBmcm9tIFwiLi4vaGFzaC9pbmRleC5qc1wiO1xuaW1wb3J0IHsgYWNjZXNzTGlzdGlmeSwgYXV0aG9yaXphdGlvbmlmeSB9IGZyb20gXCIuLi90cmFuc2FjdGlvbi9pbmRleC5qc1wiO1xuaW1wb3J0IHsgZGVmaW5lUHJvcGVydGllcywgZ2V0QmlnSW50LCBoZXhsaWZ5LCBpc0hleFN0cmluZywgdG9RdWFudGl0eSwgdG9VdGY4Qnl0ZXMsIGlzRXJyb3IsIG1ha2VFcnJvciwgYXNzZXJ0LCBhc3NlcnRBcmd1bWVudCwgRmV0Y2hSZXF1ZXN0LCByZXNvbHZlUHJvcGVydGllcyB9IGZyb20gXCIuLi91dGlscy9pbmRleC5qc1wiO1xuaW1wb3J0IHsgQWJzdHJhY3RQcm92aWRlciwgVW5tYW5hZ2VkU3Vic2NyaWJlciB9IGZyb20gXCIuL2Fic3RyYWN0LXByb3ZpZGVyLmpzXCI7XG5pbXBvcnQgeyBBYnN0cmFjdFNpZ25lciB9IGZyb20gXCIuL2Fic3RyYWN0LXNpZ25lci5qc1wiO1xuaW1wb3J0IHsgTmV0d29yayB9IGZyb20gXCIuL25ldHdvcmsuanNcIjtcbmltcG9ydCB7IEZpbHRlcklkRXZlbnRTdWJzY3JpYmVyLCBGaWx0ZXJJZFBlbmRpbmdTdWJzY3JpYmVyIH0gZnJvbSBcIi4vc3Vic2NyaWJlci1maWx0ZXJpZC5qc1wiO1xuaW1wb3J0IHsgUG9sbGluZ0V2ZW50U3Vic2NyaWJlciB9IGZyb20gXCIuL3N1YnNjcmliZXItcG9sbGluZy5qc1wiO1xuY29uc3QgUHJpbWl0aXZlID0gXCJiaWdpbnQsYm9vbGVhbixmdW5jdGlvbixudW1iZXIsc3RyaW5nLHN5bWJvbFwiLnNwbGl0KC8sL2cpO1xuLy9jb25zdCBNZXRob2RzID0gXCJnZXRBZGRyZXNzLHRoZW5cIi5zcGxpdCgvLC9nKTtcbmZ1bmN0aW9uIGRlZXBDb3B5KHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlID09IG51bGwgfHwgUHJpbWl0aXZlLmluZGV4T2YodHlwZW9mICh2YWx1ZSkpID49IDApIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICAvLyBLZWVwIGFueSBBZGRyZXNzYWJsZVxuICAgIGlmICh0eXBlb2YgKHZhbHVlLmdldEFkZHJlc3MpID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuICh2YWx1ZS5tYXAoZGVlcENvcHkpKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiAodmFsdWUpID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIHJldHVybiBPYmplY3Qua2V5cyh2YWx1ZSkucmVkdWNlKChhY2N1bSwga2V5KSA9PiB7XG4gICAgICAgICAgICBhY2N1bVtrZXldID0gdmFsdWVba2V5XTtcbiAgICAgICAgICAgIHJldHVybiBhY2N1bTtcbiAgICAgICAgfSwge30pO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoYHNob3VsZCBub3QgaGFwcGVuOiAke3ZhbHVlfSAoJHt0eXBlb2YgKHZhbHVlKX0pYCk7XG59XG5mdW5jdGlvbiBzdGFsbChkdXJhdGlvbikge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4geyBzZXRUaW1lb3V0KHJlc29sdmUsIGR1cmF0aW9uKTsgfSk7XG59XG5mdW5jdGlvbiBnZXRMb3dlckNhc2UodmFsdWUpIHtcbiAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlLnRvTG93ZXJDYXNlKCk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbn1cbmZ1bmN0aW9uIGlzUG9sbGFibGUodmFsdWUpIHtcbiAgICByZXR1cm4gKHZhbHVlICYmIHR5cGVvZiAodmFsdWUucG9sbGluZ0ludGVydmFsKSA9PT0gXCJudW1iZXJcIik7XG59XG5jb25zdCBkZWZhdWx0T3B0aW9ucyA9IHtcbiAgICBwb2xsaW5nOiBmYWxzZSxcbiAgICBzdGF0aWNOZXR3b3JrOiBudWxsLFxuICAgIGJhdGNoU3RhbGxUaW1lOiAxMCxcbiAgICBiYXRjaE1heFNpemU6ICgxIDw8IDIwKSxcbiAgICBiYXRjaE1heENvdW50OiAxMDAsXG4gICAgY2FjaGVUaW1lb3V0OiAyNTAsXG4gICAgcG9sbGluZ0ludGVydmFsOiA0MDAwXG59O1xuLy8gQFRPRE86IFVuY2hlY2tlZCBTaWduZXJzXG5leHBvcnQgY2xhc3MgSnNvblJwY1NpZ25lciBleHRlbmRzIEFic3RyYWN0U2lnbmVyIHtcbiAgICBhZGRyZXNzO1xuICAgIGNvbnN0cnVjdG9yKHByb3ZpZGVyLCBhZGRyZXNzKSB7XG4gICAgICAgIHN1cGVyKHByb3ZpZGVyKTtcbiAgICAgICAgYWRkcmVzcyA9IGdldEFkZHJlc3MoYWRkcmVzcyk7XG4gICAgICAgIGRlZmluZVByb3BlcnRpZXModGhpcywgeyBhZGRyZXNzIH0pO1xuICAgIH1cbiAgICBjb25uZWN0KHByb3ZpZGVyKSB7XG4gICAgICAgIGFzc2VydChmYWxzZSwgXCJjYW5ub3QgcmVjb25uZWN0IEpzb25ScGNTaWduZXJcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwge1xuICAgICAgICAgICAgb3BlcmF0aW9uOiBcInNpZ25lci5jb25uZWN0XCJcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFzeW5jIGdldEFkZHJlc3MoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFkZHJlc3M7XG4gICAgfVxuICAgIC8vIEpTT04tUlBDIHdpbGwgYXV0b21hdGlhbGx5IGZpbGwgaW4gbm9uY2UsIGV0Yy4gc28gd2UganVzdCBjaGVjayBmcm9tXG4gICAgYXN5bmMgcG9wdWxhdGVUcmFuc2FjdGlvbih0eCkge1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5wb3B1bGF0ZUNhbGwodHgpO1xuICAgIH1cbiAgICAvLyBSZXR1cm5zIGp1c3QgdGhlIGhhc2ggb2YgdGhlIHRyYW5zYWN0aW9uIGFmdGVyIHNlbnQsIHdoaWNoIGlzIHdoYXRcbiAgICAvLyB0aGUgYmFyZSBKU09OLVJQQyBBUEkgZG9lcztcbiAgICBhc3luYyBzZW5kVW5jaGVja2VkVHJhbnNhY3Rpb24oX3R4KSB7XG4gICAgICAgIGNvbnN0IHR4ID0gZGVlcENvcHkoX3R4KTtcbiAgICAgICAgY29uc3QgcHJvbWlzZXMgPSBbXTtcbiAgICAgICAgLy8gTWFrZSBzdXJlIHRoZSBmcm9tIG1hdGNoZXMgdGhlIHNlbmRlclxuICAgICAgICBpZiAodHguZnJvbSkge1xuICAgICAgICAgICAgY29uc3QgX2Zyb20gPSB0eC5mcm9tO1xuICAgICAgICAgICAgcHJvbWlzZXMucHVzaCgoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGZyb20gPSBhd2FpdCByZXNvbHZlQWRkcmVzcyhfZnJvbSwgdGhpcy5wcm92aWRlcik7XG4gICAgICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoZnJvbSAhPSBudWxsICYmIGZyb20udG9Mb3dlckNhc2UoKSA9PT0gdGhpcy5hZGRyZXNzLnRvTG93ZXJDYXNlKCksIFwiZnJvbSBhZGRyZXNzIG1pc21hdGNoXCIsIFwidHJhbnNhY3Rpb25cIiwgX3R4KTtcbiAgICAgICAgICAgICAgICB0eC5mcm9tID0gZnJvbTtcbiAgICAgICAgICAgIH0pKCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdHguZnJvbSA9IHRoaXMuYWRkcmVzcztcbiAgICAgICAgfVxuICAgICAgICAvLyBUaGUgSlNPTi1SUEMgZm9yIGV0aF9zZW5kVHJhbnNhY3Rpb24gdXNlcyA5MDAwMCBnYXM7IGlmIHRoZSB1c2VyXG4gICAgICAgIC8vIHdpc2hlcyB0byB1c2UgdGhpcywgaXQgaXMgZWFzeSB0byBzcGVjaWZ5IGV4cGxpY2l0bHksIG90aGVyd2lzZVxuICAgICAgICAvLyB3ZSBsb29rIGl0IHVwIGZvciB0aGVtLlxuICAgICAgICBpZiAodHguZ2FzTGltaXQgPT0gbnVsbCkge1xuICAgICAgICAgICAgcHJvbWlzZXMucHVzaCgoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHR4Lmdhc0xpbWl0ID0gYXdhaXQgdGhpcy5wcm92aWRlci5lc3RpbWF0ZUdhcyh7IC4uLnR4LCBmcm9tOiB0aGlzLmFkZHJlc3MgfSk7XG4gICAgICAgICAgICB9KSgpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUaGUgYWRkcmVzcyBtYXkgYmUgYW4gRU5TIG5hbWUgb3IgQWRkcmVzc2FibGVcbiAgICAgICAgaWYgKHR4LnRvICE9IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnN0IF90byA9IHR4LnRvO1xuICAgICAgICAgICAgcHJvbWlzZXMucHVzaCgoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHR4LnRvID0gYXdhaXQgcmVzb2x2ZUFkZHJlc3MoX3RvLCB0aGlzLnByb3ZpZGVyKTtcbiAgICAgICAgICAgIH0pKCkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFdhaXQgdW50aWwgYWxsIG9mIG91ciBwcm9wZXJ0aWVzIGFyZSBmaWxsZWQgaW5cbiAgICAgICAgaWYgKHByb21pc2VzLmxlbmd0aCkge1xuICAgICAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwocHJvbWlzZXMpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGhleFR4ID0gdGhpcy5wcm92aWRlci5nZXRScGNUcmFuc2FjdGlvbih0eCk7XG4gICAgICAgIHJldHVybiB0aGlzLnByb3ZpZGVyLnNlbmQoXCJldGhfc2VuZFRyYW5zYWN0aW9uXCIsIFtoZXhUeF0pO1xuICAgIH1cbiAgICBhc3luYyBzZW5kVHJhbnNhY3Rpb24odHgpIHtcbiAgICAgICAgLy8gVGhpcyBjYW5ub3QgYmUgbWluZWQgYW55IGVhcmxpZXIgdGhhbiBhbnkgcmVjZW50IGJsb2NrXG4gICAgICAgIGNvbnN0IGJsb2NrTnVtYmVyID0gYXdhaXQgdGhpcy5wcm92aWRlci5nZXRCbG9ja051bWJlcigpO1xuICAgICAgICAvLyBTZW5kIHRoZSB0cmFuc2FjdGlvblxuICAgICAgICBjb25zdCBoYXNoID0gYXdhaXQgdGhpcy5zZW5kVW5jaGVja2VkVHJhbnNhY3Rpb24odHgpO1xuICAgICAgICAvLyBVbmZvcnR1bmF0ZWx5LCBKU09OLVJQQyBvbmx5IHByb3ZpZGVzIGFuZCBvcGFxdWUgdHJhbnNhY3Rpb24gaGFzaFxuICAgICAgICAvLyBmb3IgYSByZXNwb25zZSwgYW5kIHdlIG5lZWQgdGhlIGFjdHVhbCB0cmFuc2FjdGlvbiwgc28gd2UgcG9sbFxuICAgICAgICAvLyBmb3IgaXQ7IGl0IHNob3VsZCBzaG93IHVwIHZlcnkgcXVpY2tseVxuICAgICAgICByZXR1cm4gYXdhaXQgKG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHRpbWVvdXRzID0gWzEwMDAsIDEwMF07XG4gICAgICAgICAgICBsZXQgaW52YWxpZHMgPSAwO1xuICAgICAgICAgICAgY29uc3QgY2hlY2tUeCA9IGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAvLyBUcnkgZ2V0dGluZyB0aGUgdHJhbnNhY3Rpb25cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdHggPSBhd2FpdCB0aGlzLnByb3ZpZGVyLmdldFRyYW5zYWN0aW9uKGhhc2gpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHggIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSh0eC5yZXBsYWNlYWJsZVRyYW5zYWN0aW9uKGJsb2NrTnVtYmVyKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHdlIHdlcmUgY2FuY2VsbGVkOiBzdG9wIHBvbGxpbmcuXG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZSBkYXRhIGlzIGJhZDogdGhlIG5vZGUgcmV0dXJucyBiYWQgdHJhbnNhY3Rpb25zXG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZSBuZXR3b3JrIGNoYW5nZWQ6IGNhbGxpbmcgYWdhaW4gd2lsbCBhbHNvIGZhaWxcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgdW5zdXBwb3J0ZWQ6IGxpa2VseSBkZXN0cm95ZWRcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzRXJyb3IoZXJyb3IsIFwiQ0FOQ0VMTEVEXCIpIHx8IGlzRXJyb3IoZXJyb3IsIFwiQkFEX0RBVEFcIikgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzRXJyb3IoZXJyb3IsIFwiTkVUV09SS19FUlJPUlwiKSB8fCBpc0Vycm9yKGVycm9yLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yLmluZm8gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yLmluZm8gPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yLmluZm8uc2VuZFRyYW5zYWN0aW9uSGFzaCA9IGhhc2g7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIFN0b3AtZ2FwIGZvciBtaXNiZWhhdmluZyBiYWNrZW5kczsgc2VlICM0NTEzXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0Vycm9yKGVycm9yLCBcIklOVkFMSURfQVJHVU1FTlRcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGludmFsaWRzKys7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3IuaW5mbyA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3IuaW5mbyA9IHt9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3IuaW5mby5zZW5kVHJhbnNhY3Rpb25IYXNoID0gaGFzaDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbnZhbGlkcyA+IDEwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gTm90aWZ5IGFueW9uZSB0aGF0IGNhcmVzOyBidXQgd2Ugd2lsbCB0cnkgYWdhaW4sIHNpbmNlXG4gICAgICAgICAgICAgICAgICAgIC8vIGl0IGlzIGxpa2VseSBhbiBpbnRlcm1pdHRlbnQgc2VydmljZSBlcnJvclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnByb3ZpZGVyLmVtaXQoXCJlcnJvclwiLCBtYWtlRXJyb3IoXCJmYWlsZWQgdG8gZmV0Y2ggdHJhbnNhdGlvbiBhZnRlciBzZW5kaW5nICh3aWxsIHRyeSBhZ2FpbilcIiwgXCJVTktOT1dOX0VSUk9SXCIsIHsgZXJyb3IgfSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBXYWl0IGFub3RoZXIgNCBzZWNvbmRzXG4gICAgICAgICAgICAgICAgdGhpcy5wcm92aWRlci5fc2V0VGltZW91dCgoKSA9PiB7IGNoZWNrVHgoKTsgfSwgdGltZW91dHMucG9wKCkgfHwgNDAwMCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY2hlY2tUeCgpO1xuICAgICAgICB9KSk7XG4gICAgfVxuICAgIGFzeW5jIHNpZ25UcmFuc2FjdGlvbihfdHgpIHtcbiAgICAgICAgY29uc3QgdHggPSBkZWVwQ29weShfdHgpO1xuICAgICAgICAvLyBNYWtlIHN1cmUgdGhlIGZyb20gbWF0Y2hlcyB0aGUgc2VuZGVyXG4gICAgICAgIGlmICh0eC5mcm9tKSB7XG4gICAgICAgICAgICBjb25zdCBmcm9tID0gYXdhaXQgcmVzb2x2ZUFkZHJlc3ModHguZnJvbSwgdGhpcy5wcm92aWRlcik7XG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudChmcm9tICE9IG51bGwgJiYgZnJvbS50b0xvd2VyQ2FzZSgpID09PSB0aGlzLmFkZHJlc3MudG9Mb3dlckNhc2UoKSwgXCJmcm9tIGFkZHJlc3MgbWlzbWF0Y2hcIiwgXCJ0cmFuc2FjdGlvblwiLCBfdHgpO1xuICAgICAgICAgICAgdHguZnJvbSA9IGZyb207XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0eC5mcm9tID0gdGhpcy5hZGRyZXNzO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGhleFR4ID0gdGhpcy5wcm92aWRlci5nZXRScGNUcmFuc2FjdGlvbih0eCk7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnByb3ZpZGVyLnNlbmQoXCJldGhfc2lnblRyYW5zYWN0aW9uXCIsIFtoZXhUeF0pO1xuICAgIH1cbiAgICBhc3luYyBzaWduTWVzc2FnZShfbWVzc2FnZSkge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gKCh0eXBlb2YgKF9tZXNzYWdlKSA9PT0gXCJzdHJpbmdcIikgPyB0b1V0ZjhCeXRlcyhfbWVzc2FnZSkgOiBfbWVzc2FnZSk7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnByb3ZpZGVyLnNlbmQoXCJwZXJzb25hbF9zaWduXCIsIFtcbiAgICAgICAgICAgIGhleGxpZnkobWVzc2FnZSksIHRoaXMuYWRkcmVzcy50b0xvd2VyQ2FzZSgpXG4gICAgICAgIF0pO1xuICAgIH1cbiAgICBhc3luYyBzaWduVHlwZWREYXRhKGRvbWFpbiwgdHlwZXMsIF92YWx1ZSkge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IGRlZXBDb3B5KF92YWx1ZSk7XG4gICAgICAgIC8vIFBvcHVsYXRlIGFueSBFTlMgbmFtZXMgKGluLXBsYWNlKVxuICAgICAgICBjb25zdCBwb3B1bGF0ZWQgPSBhd2FpdCBUeXBlZERhdGFFbmNvZGVyLnJlc29sdmVOYW1lcyhkb21haW4sIHR5cGVzLCB2YWx1ZSwgYXN5bmMgKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBhZGRyZXNzID0gYXdhaXQgcmVzb2x2ZUFkZHJlc3ModmFsdWUpO1xuICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoYWRkcmVzcyAhPSBudWxsLCBcIlR5cGVkRGF0YSBkb2VzIG5vdCBzdXBwb3J0IG51bGwgYWRkcmVzc1wiLCBcInZhbHVlXCIsIHZhbHVlKTtcbiAgICAgICAgICAgIHJldHVybiBhZGRyZXNzO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMucHJvdmlkZXIuc2VuZChcImV0aF9zaWduVHlwZWREYXRhX3Y0XCIsIFtcbiAgICAgICAgICAgIHRoaXMuYWRkcmVzcy50b0xvd2VyQ2FzZSgpLFxuICAgICAgICAgICAgSlNPTi5zdHJpbmdpZnkoVHlwZWREYXRhRW5jb2Rlci5nZXRQYXlsb2FkKHBvcHVsYXRlZC5kb21haW4sIHR5cGVzLCBwb3B1bGF0ZWQudmFsdWUpKVxuICAgICAgICBdKTtcbiAgICB9XG4gICAgYXN5bmMgdW5sb2NrKHBhc3N3b3JkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnByb3ZpZGVyLnNlbmQoXCJwZXJzb25hbF91bmxvY2tBY2NvdW50XCIsIFtcbiAgICAgICAgICAgIHRoaXMuYWRkcmVzcy50b0xvd2VyQ2FzZSgpLCBwYXNzd29yZCwgbnVsbFxuICAgICAgICBdKTtcbiAgICB9XG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2V0aGVyZXVtL3dpa2kvd2lraS9KU09OLVJQQyNldGhfc2lnblxuICAgIGFzeW5jIF9sZWdhY3lTaWduTWVzc2FnZShfbWVzc2FnZSkge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gKCh0eXBlb2YgKF9tZXNzYWdlKSA9PT0gXCJzdHJpbmdcIikgPyB0b1V0ZjhCeXRlcyhfbWVzc2FnZSkgOiBfbWVzc2FnZSk7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnByb3ZpZGVyLnNlbmQoXCJldGhfc2lnblwiLCBbXG4gICAgICAgICAgICB0aGlzLmFkZHJlc3MudG9Mb3dlckNhc2UoKSwgaGV4bGlmeShtZXNzYWdlKVxuICAgICAgICBdKTtcbiAgICB9XG59XG4vKipcbiAqICBUaGUgSnNvblJwY0FwaVByb3ZpZGVyIGlzIGFuIGFic3RyYWN0IGNsYXNzIGFuZCAqKk1VU1QqKiBiZVxuICogIHN1Yi1jbGFzc2VkLlxuICpcbiAqICBJdCBwcm92aWRlcyB0aGUgYmFzZSBmb3IgYWxsIEpTT04tUlBDLWJhc2VkIFByb3ZpZGVyIGludGVyYWN0aW9uLlxuICpcbiAqICBTdWItY2xhc3NpbmcgTm90ZXM6XG4gKiAgLSBhIHN1Yi1jbGFzcyBNVVNUIG92ZXJyaWRlIF9zZW5kXG4gKiAgLSBhIHN1Yi1jbGFzcyBNVVNUIGNhbGwgdGhlIGBfc3RhcnQoKWAgbWV0aG9kIG9uY2UgY29ubmVjdGVkXG4gKi9cbmV4cG9ydCBjbGFzcyBKc29uUnBjQXBpUHJvdmlkZXIgZXh0ZW5kcyBBYnN0cmFjdFByb3ZpZGVyIHtcbiAgICAjb3B0aW9ucztcbiAgICAvLyBUaGUgbmV4dCBJRCB0byB1c2UgZm9yIHRoZSBKU09OLVJQQyBJRCBmaWVsZFxuICAgICNuZXh0SWQ7XG4gICAgLy8gUGF5bG9hZHMgYXJlIHF1ZXVlZCBhbmQgdHJpZ2dlcmVkIGluIGJhdGNoZXMgdXNpbmcgdGhlIGRyYWluVGltZXJcbiAgICAjcGF5bG9hZHM7XG4gICAgI2RyYWluVGltZXI7XG4gICAgI25vdFJlYWR5O1xuICAgICNuZXR3b3JrO1xuICAgICNwZW5kaW5nRGV0ZWN0TmV0d29yaztcbiAgICAjc2NoZWR1bGVEcmFpbigpIHtcbiAgICAgICAgaWYgKHRoaXMuI2RyYWluVGltZXIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB3ZSBhcmVuJ3QgdXNpbmcgYmF0Y2hpbmcsIG5vIGhhcm0gaW4gc2VuZGluZyBpdCBpbW1lZGlhdGVseVxuICAgICAgICBjb25zdCBzdGFsbFRpbWUgPSAodGhpcy5fZ2V0T3B0aW9uKFwiYmF0Y2hNYXhDb3VudFwiKSA9PT0gMSkgPyAwIDogdGhpcy5fZ2V0T3B0aW9uKFwiYmF0Y2hTdGFsbFRpbWVcIik7XG4gICAgICAgIHRoaXMuI2RyYWluVGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuI2RyYWluVGltZXIgPSBudWxsO1xuICAgICAgICAgICAgY29uc3QgcGF5bG9hZHMgPSB0aGlzLiNwYXlsb2FkcztcbiAgICAgICAgICAgIHRoaXMuI3BheWxvYWRzID0gW107XG4gICAgICAgICAgICB3aGlsZSAocGF5bG9hZHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgLy8gQ3JlYXRlIHBheWxvYWQgYmF0Y2hlcyB0aGF0IHNhdGlzZnkgb3VyIGJhdGNoIGNvbnN0cmFpbnRzXG4gICAgICAgICAgICAgICAgY29uc3QgYmF0Y2ggPSBbKHBheWxvYWRzLnNoaWZ0KCkpXTtcbiAgICAgICAgICAgICAgICB3aGlsZSAocGF5bG9hZHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChiYXRjaC5sZW5ndGggPT09IHRoaXMuI29wdGlvbnMuYmF0Y2hNYXhDb3VudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYmF0Y2gucHVzaCgocGF5bG9hZHMuc2hpZnQoKSkpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBieXRlcyA9IEpTT04uc3RyaW5naWZ5KGJhdGNoLm1hcCgocCkgPT4gcC5wYXlsb2FkKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChieXRlcy5sZW5ndGggPiB0aGlzLiNvcHRpb25zLmJhdGNoTWF4U2l6ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGF5bG9hZHMudW5zaGlmdCgoYmF0Y2gucG9wKCkpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFByb2Nlc3MgdGhlIHJlc3VsdCB0byBlYWNoIHBheWxvYWRcbiAgICAgICAgICAgICAgICAoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwYXlsb2FkID0gKChiYXRjaC5sZW5ndGggPT09IDEpID8gYmF0Y2hbMF0ucGF5bG9hZCA6IGJhdGNoLm1hcCgocCkgPT4gcC5wYXlsb2FkKSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcImRlYnVnXCIsIHsgYWN0aW9uOiBcInNlbmRScGNQYXlsb2FkXCIsIHBheWxvYWQgfSk7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLl9zZW5kKHBheWxvYWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwiZGVidWdcIiwgeyBhY3Rpb246IFwicmVjZWl2ZVJwY1Jlc3VsdFwiLCByZXN1bHQgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBQcm9jZXNzIHJlc3VsdHMgaW4gYmF0Y2ggb3JkZXJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgeyByZXNvbHZlLCByZWplY3QsIHBheWxvYWQgfSBvZiBiYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmRlc3Ryb3llZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWplY3QobWFrZUVycm9yKFwicHJvdmlkZXIgZGVzdHJveWVkOyBjYW5jZWxsZWQgcmVxdWVzdFwiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7IG9wZXJhdGlvbjogcGF5bG9hZC5tZXRob2QgfSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRmluZCB0aGUgbWF0Y2hpbmcgcmVzdWx0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzcCA9IHJlc3VsdC5maWx0ZXIoKHIpID0+IChyLmlkID09PSBwYXlsb2FkLmlkKSlbMF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTm8gcmVzdWx0OyB0aGUgbm9kZSBmYWlsZWQgdXMgaW4gdW5leHBlY3RlZCB3YXlzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3AgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBlcnJvciA9IG1ha2VFcnJvcihcIm1pc3NpbmcgcmVzcG9uc2UgZm9yIHJlcXVlc3RcIiwgXCJCQURfREFUQVwiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogcmVzdWx0LCBpbmZvOiB7IHBheWxvYWQgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwiZXJyb3JcIiwgZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIHJlc3BvbnNlIGlzIGFuIGVycm9yXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFwiZXJyb3JcIiBpbiByZXNwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdCh0aGlzLmdldFJwY0Vycm9yKHBheWxvYWQsIHJlc3ApKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFsbCBnb29kOyBzZW5kIHRoZSByZXN1bHRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHJlc3AucmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcImRlYnVnXCIsIHsgYWN0aW9uOiBcInJlY2VpdmVScGNFcnJvclwiLCBlcnJvciB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgeyByZWplY3QgfSBvZiBiYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEBUT0RPOiBhdWdtZW50IHRoZSBlcnJvciB3aXRoIHRoZSBwYXlsb2FkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHN0YWxsVGltZSk7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKG5ldHdvcmssIG9wdGlvbnMpIHtcbiAgICAgICAgc3VwZXIobmV0d29yaywgb3B0aW9ucyk7XG4gICAgICAgIHRoaXMuI25leHRJZCA9IDE7XG4gICAgICAgIHRoaXMuI29wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0T3B0aW9ucywgb3B0aW9ucyB8fCB7fSk7XG4gICAgICAgIHRoaXMuI3BheWxvYWRzID0gW107XG4gICAgICAgIHRoaXMuI2RyYWluVGltZXIgPSBudWxsO1xuICAgICAgICB0aGlzLiNuZXR3b3JrID0gbnVsbDtcbiAgICAgICAgdGhpcy4jcGVuZGluZ0RldGVjdE5ldHdvcmsgPSBudWxsO1xuICAgICAgICB7XG4gICAgICAgICAgICBsZXQgcmVzb2x2ZSA9IG51bGw7XG4gICAgICAgICAgICBjb25zdCBwcm9taXNlID0gbmV3IFByb21pc2UoKF9yZXNvbHZlKSA9PiB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZSA9IF9yZXNvbHZlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLiNub3RSZWFkeSA9IHsgcHJvbWlzZSwgcmVzb2x2ZSB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHN0YXRpY05ldHdvcmsgPSB0aGlzLl9nZXRPcHRpb24oXCJzdGF0aWNOZXR3b3JrXCIpO1xuICAgICAgICBpZiAodHlwZW9mIChzdGF0aWNOZXR3b3JrKSA9PT0gXCJib29sZWFuXCIpIHtcbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KCFzdGF0aWNOZXR3b3JrIHx8IG5ldHdvcmsgIT09IFwiYW55XCIsIFwic3RhdGljTmV0d29yayBjYW5ub3QgYmUgdXNlZCBvbiBzcGVjaWFsIG5ldHdvcmsgJ2FueSdcIiwgXCJvcHRpb25zXCIsIG9wdGlvbnMpO1xuICAgICAgICAgICAgaWYgKHN0YXRpY05ldHdvcmsgJiYgbmV0d29yayAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy4jbmV0d29yayA9IE5ldHdvcmsuZnJvbShuZXR3b3JrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzdGF0aWNOZXR3b3JrKSB7XG4gICAgICAgICAgICAvLyBNYWtlIHN1cmUgYW55IHN0YXRpYyBuZXR3b3JrIGlzIGNvbXBhdGJpbGUgd2l0aCB0aGUgcHJvdmlkZWQgbmV0d3Jva1xuICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQobmV0d29yayA9PSBudWxsIHx8IHN0YXRpY05ldHdvcmsubWF0Y2hlcyhuZXR3b3JrKSwgXCJzdGF0aWNOZXR3b3JrIE1VU1QgbWF0Y2ggbmV0d29yayBvYmplY3RcIiwgXCJvcHRpb25zXCIsIG9wdGlvbnMpO1xuICAgICAgICAgICAgdGhpcy4jbmV0d29yayA9IHN0YXRpY05ldHdvcms7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdGhlIHZhbHVlIGFzc29jaWF0ZWQgd2l0aCB0aGUgb3B0aW9uICUla2V5JSUuXG4gICAgICpcbiAgICAgKiAgU3ViLWNsYXNzZXMgY2FuIHVzZSB0aGlzIHRvIGlucXVpcmUgYWJvdXQgY29uZmlndXJhdGlvbiBvcHRpb25zLlxuICAgICAqL1xuICAgIF9nZXRPcHRpb24oa2V5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLiNvcHRpb25zW2tleV07XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBHZXRzIHRoZSBbW05ldHdvcmtdXSB0aGlzIHByb3ZpZGVyIGhhcyBjb21taXR0ZWQgdG8uIE9uIGVhY2ggY2FsbCwgdGhlIG5ldHdvcmtcbiAgICAgKiAgaXMgZGV0ZWN0ZWQsIGFuZCBpZiBpdCBoYXMgY2hhbmdlZCwgdGhlIGNhbGwgd2lsbCByZWplY3QuXG4gICAgICovXG4gICAgZ2V0IF9uZXR3b3JrKCkge1xuICAgICAgICBhc3NlcnQodGhpcy4jbmV0d29yaywgXCJuZXR3b3JrIGlzIG5vdCBhdmFpbGFibGUgeWV0XCIsIFwiTkVUV09SS19FUlJPUlwiKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuI25ldHdvcms7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXNvbHZlcyB0byB0aGUgbm9uLW5vcm1hbGl6ZWQgdmFsdWUgYnkgcGVyZm9ybWluZyAlJXJlcSUlLlxuICAgICAqXG4gICAgICogIFN1Yi1jbGFzc2VzIG1heSBvdmVycmlkZSB0aGlzIHRvIG1vZGlmeSBiZWhhdmlvciBvZiBhY3Rpb25zLFxuICAgICAqICBhbmQgc2hvdWxkIGdlbmVyYWxseSBjYWxsIGBgc3VwZXIuX3BlcmZvcm1gYCBhcyBhIGZhbGxiYWNrLlxuICAgICAqL1xuICAgIGFzeW5jIF9wZXJmb3JtKHJlcSkge1xuICAgICAgICAvLyBMZWdhY3kgbmV0d29ya3MgZG8gbm90IGxpa2UgdGhlIHR5cGUgZmllbGQgYmVpbmcgcGFzc2VkIGFsb25nICh3aGljaFxuICAgICAgICAvLyBpcyBmYWlyKSwgc28gd2UgZGVsZXRlIHR5cGUgaWYgaXQgaXMgMCBhbmQgYSBub24tRUlQLTE1NTkgbmV0d29ya1xuICAgICAgICBpZiAocmVxLm1ldGhvZCA9PT0gXCJjYWxsXCIgfHwgcmVxLm1ldGhvZCA9PT0gXCJlc3RpbWF0ZUdhc1wiKSB7XG4gICAgICAgICAgICBsZXQgdHggPSByZXEudHJhbnNhY3Rpb247XG4gICAgICAgICAgICBpZiAodHggJiYgdHgudHlwZSAhPSBudWxsICYmIGdldEJpZ0ludCh0eC50eXBlKSkge1xuICAgICAgICAgICAgICAgIC8vIElmIHRoZXJlIGFyZSBubyBFSVAtMTU1OSBvciBuZXdlciBwcm9wZXJ0aWVzLCBpdCBtaWdodCBiZSBwcmUtRUlQLTE1NTlcbiAgICAgICAgICAgICAgICBpZiAodHgubWF4RmVlUGVyR2FzID09IG51bGwgJiYgdHgubWF4UHJpb3JpdHlGZWVQZXJHYXMgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBmZWVEYXRhID0gYXdhaXQgdGhpcy5nZXRGZWVEYXRhKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChmZWVEYXRhLm1heEZlZVBlckdhcyA9PSBudWxsICYmIGZlZURhdGEubWF4UHJpb3JpdHlGZWVQZXJHYXMgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTmV0d29yayBkb2Vzbid0IGtub3cgYWJvdXQgRUlQLTE1NTkgKGFuZCBoZW5jZSB0eXBlKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmVxID0gT2JqZWN0LmFzc2lnbih7fSwgcmVxLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNhY3Rpb246IE9iamVjdC5hc3NpZ24oe30sIHR4LCB7IHR5cGU6IHVuZGVmaW5lZCB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVxdWVzdCA9IHRoaXMuZ2V0UnBjUmVxdWVzdChyZXEpO1xuICAgICAgICBpZiAocmVxdWVzdCAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5zZW5kKHJlcXVlc3QubWV0aG9kLCByZXF1ZXN0LmFyZ3MpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdXBlci5fcGVyZm9ybShyZXEpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgU3ViLWNsYXNzZXMgbWF5IG92ZXJyaWRlIHRoaXM7IGl0IGRldGVjdHMgdGhlICphY3R1YWwqIG5ldHdvcmsgdGhhdFxuICAgICAqICB3ZSBhcmUgKipjdXJyZW50bHkqKiBjb25uZWN0ZWQgdG8uXG4gICAgICpcbiAgICAgKiAgS2VlcCBpbiBtaW5kIHRoYXQgW1tzZW5kXV0gbWF5IG9ubHkgYmUgdXNlZCBvbmNlIFtbcmVhZHldXSwgb3RoZXJ3aXNlIHRoZVxuICAgICAqICBfc2VuZCBwcmltaXRpdmUgbXVzdCBiZSB1c2VkIGluc3RlYWQuXG4gICAgICovXG4gICAgYXN5bmMgX2RldGVjdE5ldHdvcmsoKSB7XG4gICAgICAgIGNvbnN0IG5ldHdvcmsgPSB0aGlzLl9nZXRPcHRpb24oXCJzdGF0aWNOZXR3b3JrXCIpO1xuICAgICAgICBpZiAobmV0d29yaykge1xuICAgICAgICAgICAgaWYgKG5ldHdvcmsgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy4jbmV0d29yaykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4jbmV0d29yaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV0d29yaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy4jcGVuZGluZ0RldGVjdE5ldHdvcmspIHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLiNwZW5kaW5nRGV0ZWN0TmV0d29yaztcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB3ZSBhcmUgcmVhZHksIHVzZSBgYHNlbmRgYCwgd2hpY2ggZW5hYmxlZCByZXF1ZXN0cyB0byBiZSBiYXRjaGVkXG4gICAgICAgIGlmICh0aGlzLnJlYWR5KSB7XG4gICAgICAgICAgICB0aGlzLiNwZW5kaW5nRGV0ZWN0TmV0d29yayA9IChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gTmV0d29yay5mcm9tKGdldEJpZ0ludChhd2FpdCB0aGlzLnNlbmQoXCJldGhfY2hhaW5JZFwiLCBbXSkpKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4jcGVuZGluZ0RldGVjdE5ldHdvcmsgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4jcGVuZGluZ0RldGVjdE5ldHdvcmsgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSgpO1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuI3BlbmRpbmdEZXRlY3ROZXR3b3JrO1xuICAgICAgICB9XG4gICAgICAgIC8vIFdlIGFyZSBub3QgcmVhZHkgeWV0OyB1c2UgdGhlIHByaW1pdGl2ZSBfc2VuZFxuICAgICAgICB0aGlzLiNwZW5kaW5nRGV0ZWN0TmV0d29yayA9IChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBwYXlsb2FkID0ge1xuICAgICAgICAgICAgICAgIGlkOiB0aGlzLiNuZXh0SWQrKywgbWV0aG9kOiBcImV0aF9jaGFpbklkXCIsIHBhcmFtczogW10sIGpzb25ycGM6IFwiMi4wXCJcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLmVtaXQoXCJkZWJ1Z1wiLCB7IGFjdGlvbjogXCJzZW5kUnBjUGF5bG9hZFwiLCBwYXlsb2FkIH0pO1xuICAgICAgICAgICAgbGV0IHJlc3VsdDtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gKGF3YWl0IHRoaXMuX3NlbmQocGF5bG9hZCkpWzBdO1xuICAgICAgICAgICAgICAgIHRoaXMuI3BlbmRpbmdEZXRlY3ROZXR3b3JrID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIHRoaXMuI3BlbmRpbmdEZXRlY3ROZXR3b3JrID0gbnVsbDtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJkZWJ1Z1wiLCB7IGFjdGlvbjogXCJyZWNlaXZlUnBjRXJyb3JcIiwgZXJyb3IgfSk7XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmVtaXQoXCJkZWJ1Z1wiLCB7IGFjdGlvbjogXCJyZWNlaXZlUnBjUmVzdWx0XCIsIHJlc3VsdCB9KTtcbiAgICAgICAgICAgIGlmIChcInJlc3VsdFwiIGluIHJlc3VsdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBOZXR3b3JrLmZyb20oZ2V0QmlnSW50KHJlc3VsdC5yZXN1bHQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IHRoaXMuZ2V0UnBjRXJyb3IocGF5bG9hZCwgcmVzdWx0KTtcbiAgICAgICAgfSkoKTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuI3BlbmRpbmdEZXRlY3ROZXR3b3JrO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgU3ViLWNsYXNzZXMgKipNVVNUKiogY2FsbCB0aGlzLiBVbnRpbCBbW19zdGFydF1dIGhhcyBiZWVuIGNhbGxlZCwgbm8gY2FsbHNcbiAgICAgKiAgd2lsbCBiZSBwYXNzZWQgdG8gW1tfc2VuZF1dIGZyb20gW1tzZW5kXV0uIElmIGl0IGlzIG92ZXJyaWRkZW4sIHRoZW5cbiAgICAgKiAgYGBzdXBlci5fc3RhcnQoKWBgICoqTVVTVCoqIGJlIGNhbGxlZC5cbiAgICAgKlxuICAgICAqICBDYWxsaW5nIGl0IG11bHRpcGxlIHRpbWVzIGlzIHNhZmUgYW5kIGhhcyBubyBlZmZlY3QuXG4gICAgICovXG4gICAgX3N0YXJ0KCkge1xuICAgICAgICBpZiAodGhpcy4jbm90UmVhZHkgPT0gbnVsbCB8fCB0aGlzLiNub3RSZWFkeS5yZXNvbHZlID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLiNub3RSZWFkeS5yZXNvbHZlKCk7XG4gICAgICAgIHRoaXMuI25vdFJlYWR5ID0gbnVsbDtcbiAgICAgICAgKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIC8vIEJvb3RzdHJhcCB0aGUgbmV0d29ya1xuICAgICAgICAgICAgd2hpbGUgKHRoaXMuI25ldHdvcmsgPT0gbnVsbCAmJiAhdGhpcy5kZXN0cm95ZWQpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLiNuZXR3b3JrID0gYXdhaXQgdGhpcy5fZGV0ZWN0TmV0d29yaygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuZGVzdHJveWVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIkpzb25ScGNQcm92aWRlciBmYWlsZWQgdG8gZGV0ZWN0IG5ldHdvcmsgYW5kIGNhbm5vdCBzdGFydCB1cDsgcmV0cnkgaW4gMXMgKHBlcmhhcHMgdGhlIFVSTCBpcyB3cm9uZyBvciB0aGUgbm9kZSBpcyBub3Qgc3RhcnRlZClcIik7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcImVycm9yXCIsIG1ha2VFcnJvcihcImZhaWxlZCB0byBib290c3RyYXAgbmV0d29yayBkZXRlY3Rpb25cIiwgXCJORVRXT1JLX0VSUk9SXCIsIHsgZXZlbnQ6IFwiaW5pdGlhbC1uZXR3b3JrLWRpc2NvdmVyeVwiLCBpbmZvOiB7IGVycm9yIH0gfSkpO1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCBzdGFsbCgxMDAwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBTdGFydCBkaXNwYXRjaGluZyByZXF1ZXN0c1xuICAgICAgICAgICAgdGhpcy4jc2NoZWR1bGVEcmFpbigpO1xuICAgICAgICB9KSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmVzb2x2ZXMgb25jZSB0aGUgW1tfc3RhcnRdXSBoYXMgYmVlbiBjYWxsZWQuIFRoaXMgY2FuIGJlIHVzZWQgaW5cbiAgICAgKiAgc3ViLWNsYXNzZXMgdG8gZGVmZXIgc2VuZGluZyBkYXRhIHVudGlsIHRoZSBjb25uZWN0aW9uIGhhcyBiZWVuXG4gICAgICogIGVzdGFibGlzaGVkLlxuICAgICAqL1xuICAgIGFzeW5jIF93YWl0VW50aWxSZWFkeSgpIHtcbiAgICAgICAgaWYgKHRoaXMuI25vdFJlYWR5ID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy4jbm90UmVhZHkucHJvbWlzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIFN1YnNjcmliZXIgdGhhdCB3aWxsIG1hbmFnZSB0aGUgJSVzdWIlJS5cbiAgICAgKlxuICAgICAqICBTdWItY2xhc3NlcyBtYXkgb3ZlcnJpZGUgdGhpcyB0byBtb2RpZnkgdGhlIGJlaGF2aW9yIG9mXG4gICAgICogIHN1YnNjcmlwdGlvbiBtYW5hZ2VtZW50LlxuICAgICAqL1xuICAgIF9nZXRTdWJzY3JpYmVyKHN1Yikge1xuICAgICAgICAvLyBQZW5kaW5nIEZpbHRlcnMgYXJlbid0IGF2YWlsYmxlIHZpYSBwb2xsaW5nXG4gICAgICAgIGlmIChzdWIudHlwZSA9PT0gXCJwZW5kaW5nXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRmlsdGVySWRQZW5kaW5nU3Vic2NyaWJlcih0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3ViLnR5cGUgPT09IFwiZXZlbnRcIikge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2dldE9wdGlvbihcInBvbGxpbmdcIikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFBvbGxpbmdFdmVudFN1YnNjcmliZXIodGhpcywgc3ViLmZpbHRlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IEZpbHRlcklkRXZlbnRTdWJzY3JpYmVyKHRoaXMsIHN1Yi5maWx0ZXIpO1xuICAgICAgICB9XG4gICAgICAgIC8vIE9ycGhhbmVkIExvZ3MgYXJlIGhhbmRsZWQgYXV0b21hdGljYWxseSwgYnkgdGhlIGZpbHRlciwgc2luY2VcbiAgICAgICAgLy8gbG9ncyB3aXRoIHJlbW92ZWQgYXJlIGVtaXR0ZWQgYnkgaXRcbiAgICAgICAgaWYgKHN1Yi50eXBlID09PSBcIm9ycGhhblwiICYmIHN1Yi5maWx0ZXIub3JwaGFuID09PSBcImRyb3AtbG9nXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgVW5tYW5hZ2VkU3Vic2NyaWJlcihcIm9ycGhhblwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3VwZXIuX2dldFN1YnNjcmliZXIoc3ViKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdHJ1ZSBvbmx5IGlmIHRoZSBbW19zdGFydF1dIGhhcyBiZWVuIGNhbGxlZC5cbiAgICAgKi9cbiAgICBnZXQgcmVhZHkoKSB7IHJldHVybiB0aGlzLiNub3RSZWFkeSA9PSBudWxsOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgJSV0eCUlIGFzIGEgbm9ybWFsaXplZCBKU09OLVJQQyB0cmFuc2FjdGlvbiByZXF1ZXN0LFxuICAgICAqICB3aGljaCBoYXMgYWxsIHZhbHVlcyBoZXhsaWZpZWQgYW5kIGFueSBudW1lcmljIHZhbHVlcyBjb252ZXJ0ZWRcbiAgICAgKiAgdG8gUXVhbnRpdHkgdmFsdWVzLlxuICAgICAqL1xuICAgIGdldFJwY1RyYW5zYWN0aW9uKHR4KSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xuICAgICAgICAvLyBKU09OLVJQQyBub3cgcmVxdWlyZXMgbnVtZXJpYyB2YWx1ZXMgdG8gYmUgXCJxdWFudGl0eVwiIHZhbHVlc1xuICAgICAgICBbXCJjaGFpbklkXCIsIFwiZ2FzTGltaXRcIiwgXCJnYXNQcmljZVwiLCBcInR5cGVcIiwgXCJtYXhGZWVQZXJHYXNcIiwgXCJtYXhQcmlvcml0eUZlZVBlckdhc1wiLCBcIm5vbmNlXCIsIFwidmFsdWVcIl0uZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgICAgICBpZiAodHhba2V5XSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGRzdEtleSA9IGtleTtcbiAgICAgICAgICAgIGlmIChrZXkgPT09IFwiZ2FzTGltaXRcIikge1xuICAgICAgICAgICAgICAgIGRzdEtleSA9IFwiZ2FzXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHRbZHN0S2V5XSA9IHRvUXVhbnRpdHkoZ2V0QmlnSW50KHR4W2tleV0sIGB0eC4ke2tleX1gKSk7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBNYWtlIHN1cmUgYWRkcmVzc2VzIGFuZCBkYXRhIGFyZSBsb3dlcmNhc2VcbiAgICAgICAgW1wiZnJvbVwiLCBcInRvXCIsIFwiZGF0YVwiXS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgICAgIGlmICh0eFtrZXldID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHRba2V5XSA9IGhleGxpZnkodHhba2V5XSk7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBOb3JtYWxpemUgdGhlIGFjY2VzcyBsaXN0IG9iamVjdFxuICAgICAgICBpZiAodHguYWNjZXNzTGlzdCkge1xuICAgICAgICAgICAgcmVzdWx0W1wiYWNjZXNzTGlzdFwiXSA9IGFjY2Vzc0xpc3RpZnkodHguYWNjZXNzTGlzdCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR4LmJsb2JWZXJzaW9uZWRIYXNoZXMpIHtcbiAgICAgICAgICAgIC8vIEBUT0RPOiBSZW1vdmUgdGhpcyA8YW55PiBjYXNlIG9uY2UgRUlQLTQ4NDQgYWRkZWQgdG8gcHJlcGFyZWQgdHhcbiAgICAgICAgICAgIHJlc3VsdFtcImJsb2JWZXJzaW9uZWRIYXNoZXNcIl0gPSB0eC5ibG9iVmVyc2lvbmVkSGFzaGVzLm1hcChoID0+IGgudG9Mb3dlckNhc2UoKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR4LmF1dGhvcml6YXRpb25MaXN0KSB7XG4gICAgICAgICAgICByZXN1bHRbXCJhdXRob3JpemF0aW9uTGlzdFwiXSA9IHR4LmF1dGhvcml6YXRpb25MaXN0Lm1hcCgoX2EpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBhID0gYXV0aG9yaXphdGlvbmlmeShfYSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgYWRkcmVzczogYS5hZGRyZXNzLFxuICAgICAgICAgICAgICAgICAgICBub25jZTogdG9RdWFudGl0eShhLm5vbmNlKSxcbiAgICAgICAgICAgICAgICAgICAgY2hhaW5JZDogdG9RdWFudGl0eShhLmNoYWluSWQpLFxuICAgICAgICAgICAgICAgICAgICB5UGFyaXR5OiB0b1F1YW50aXR5KGEuc2lnbmF0dXJlLnlQYXJpdHkpLFxuICAgICAgICAgICAgICAgICAgICByOiB0b1F1YW50aXR5KGEuc2lnbmF0dXJlLnIpLFxuICAgICAgICAgICAgICAgICAgICBzOiB0b1F1YW50aXR5KGEuc2lnbmF0dXJlLnMpLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBAVE9ETzogYmxvYnMgc2hvdWxkIHByb2JhYmx5IGFsc28gYmUgY29waWVkIG92ZXIsIG9wdGlvbmFsbHlcbiAgICAgICAgLy8gYWNjb3VudGluZyBmb3IgdGhlIGt6ZyBwcm9wZXJ0eSB0byBiYWNrZmlsbCBibG9iVmVyc2lvbmVkSGFzaGVzXG4gICAgICAgIC8vIHVzaW5nIHRoZSBjb21taXRtZW50LiBPciBzaG91bGQgdGhhdCBiZSBsZWZ0IGFzIGFuIGV4ZXJjaXNlIHRvXG4gICAgICAgIC8vIHRoZSBjYWxsZXI/XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRoZSByZXF1ZXN0IG1ldGhvZCBhbmQgYXJndW1lbnRzIHJlcXVpcmVkIHRvIHBlcmZvcm1cbiAgICAgKiAgJSVyZXElJS5cbiAgICAgKi9cbiAgICBnZXRScGNSZXF1ZXN0KHJlcSkge1xuICAgICAgICBzd2l0Y2ggKHJlcS5tZXRob2QpIHtcbiAgICAgICAgICAgIGNhc2UgXCJjaGFpbklkXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgbWV0aG9kOiBcImV0aF9jaGFpbklkXCIsIGFyZ3M6IFtdIH07XG4gICAgICAgICAgICBjYXNlIFwiZ2V0QmxvY2tOdW1iZXJcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4geyBtZXRob2Q6IFwiZXRoX2Jsb2NrTnVtYmVyXCIsIGFyZ3M6IFtdIH07XG4gICAgICAgICAgICBjYXNlIFwiZ2V0R2FzUHJpY2VcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4geyBtZXRob2Q6IFwiZXRoX2dhc1ByaWNlXCIsIGFyZ3M6IFtdIH07XG4gICAgICAgICAgICBjYXNlIFwiZ2V0UHJpb3JpdHlGZWVcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4geyBtZXRob2Q6IFwiZXRoX21heFByaW9yaXR5RmVlUGVyR2FzXCIsIGFyZ3M6IFtdIH07XG4gICAgICAgICAgICBjYXNlIFwiZ2V0QmFsYW5jZVwiOlxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZDogXCJldGhfZ2V0QmFsYW5jZVwiLFxuICAgICAgICAgICAgICAgICAgICBhcmdzOiBbZ2V0TG93ZXJDYXNlKHJlcS5hZGRyZXNzKSwgcmVxLmJsb2NrVGFnXVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjYXNlIFwiZ2V0VHJhbnNhY3Rpb25Db3VudFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZDogXCJldGhfZ2V0VHJhbnNhY3Rpb25Db3VudFwiLFxuICAgICAgICAgICAgICAgICAgICBhcmdzOiBbZ2V0TG93ZXJDYXNlKHJlcS5hZGRyZXNzKSwgcmVxLmJsb2NrVGFnXVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjYXNlIFwiZ2V0Q29kZVwiOlxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZDogXCJldGhfZ2V0Q29kZVwiLFxuICAgICAgICAgICAgICAgICAgICBhcmdzOiBbZ2V0TG93ZXJDYXNlKHJlcS5hZGRyZXNzKSwgcmVxLmJsb2NrVGFnXVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjYXNlIFwiZ2V0U3RvcmFnZVwiOlxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZDogXCJldGhfZ2V0U3RvcmFnZUF0XCIsXG4gICAgICAgICAgICAgICAgICAgIGFyZ3M6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldExvd2VyQ2FzZShyZXEuYWRkcmVzcyksXG4gICAgICAgICAgICAgICAgICAgICAgICAoXCIweFwiICsgcmVxLnBvc2l0aW9uLnRvU3RyaW5nKDE2KSksXG4gICAgICAgICAgICAgICAgICAgICAgICByZXEuYmxvY2tUYWdcbiAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjYXNlIFwiYnJvYWRjYXN0VHJhbnNhY3Rpb25cIjpcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBtZXRob2Q6IFwiZXRoX3NlbmRSYXdUcmFuc2FjdGlvblwiLFxuICAgICAgICAgICAgICAgICAgICBhcmdzOiBbcmVxLnNpZ25lZFRyYW5zYWN0aW9uXVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjYXNlIFwiZ2V0QmxvY2tcIjpcbiAgICAgICAgICAgICAgICBpZiAoXCJibG9ja1RhZ1wiIGluIHJlcSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiBcImV0aF9nZXRCbG9ja0J5TnVtYmVyXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBhcmdzOiBbcmVxLmJsb2NrVGFnLCAhIXJlcS5pbmNsdWRlVHJhbnNhY3Rpb25zXVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChcImJsb2NrSGFzaFwiIGluIHJlcSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiBcImV0aF9nZXRCbG9ja0J5SGFzaFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgYXJnczogW3JlcS5ibG9ja0hhc2gsICEhcmVxLmluY2x1ZGVUcmFuc2FjdGlvbnNdXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcImdldFRyYW5zYWN0aW9uXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiBcImV0aF9nZXRUcmFuc2FjdGlvbkJ5SGFzaFwiLFxuICAgICAgICAgICAgICAgICAgICBhcmdzOiBbcmVxLmhhc2hdXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNhc2UgXCJnZXRUcmFuc2FjdGlvblJlY2VpcHRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBtZXRob2Q6IFwiZXRoX2dldFRyYW5zYWN0aW9uUmVjZWlwdFwiLFxuICAgICAgICAgICAgICAgICAgICBhcmdzOiBbcmVxLmhhc2hdXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNhc2UgXCJjYWxsXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiBcImV0aF9jYWxsXCIsXG4gICAgICAgICAgICAgICAgICAgIGFyZ3M6IFt0aGlzLmdldFJwY1RyYW5zYWN0aW9uKHJlcS50cmFuc2FjdGlvbiksIHJlcS5ibG9ja1RhZ11cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgY2FzZSBcImVzdGltYXRlR2FzXCI6IHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBtZXRob2Q6IFwiZXRoX2VzdGltYXRlR2FzXCIsXG4gICAgICAgICAgICAgICAgICAgIGFyZ3M6IFt0aGlzLmdldFJwY1RyYW5zYWN0aW9uKHJlcS50cmFuc2FjdGlvbildXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJnZXRMb2dzXCI6XG4gICAgICAgICAgICAgICAgaWYgKHJlcS5maWx0ZXIgJiYgcmVxLmZpbHRlci5hZGRyZXNzICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocmVxLmZpbHRlci5hZGRyZXNzKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVxLmZpbHRlci5hZGRyZXNzID0gcmVxLmZpbHRlci5hZGRyZXNzLm1hcChnZXRMb3dlckNhc2UpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVxLmZpbHRlci5hZGRyZXNzID0gZ2V0TG93ZXJDYXNlKHJlcS5maWx0ZXIuYWRkcmVzcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgbWV0aG9kOiBcImV0aF9nZXRMb2dzXCIsIGFyZ3M6IFtyZXEuZmlsdGVyXSB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBhbiBldGhlcnMtc3R5bGUgRXJyb3IgZm9yIHRoZSBnaXZlbiBKU09OLVJQQyBlcnJvclxuICAgICAqICAlJXBheWxvYWQlJSwgY29hbGVzY2luZyB0aGUgdmFyaW91cyBzdHJpbmdzIGFuZCBlcnJvciBzaGFwZXNcbiAgICAgKiAgdGhhdCBkaWZmZXJlbnQgbm9kZXMgcmV0dXJuLCBjb2VyY2luZyB0aGVtIGludG8gYSBtYWNoaW5lLXJlYWRhYmxlXG4gICAgICogIHN0YW5kYXJkaXplZCBlcnJvci5cbiAgICAgKi9cbiAgICBnZXRScGNFcnJvcihwYXlsb2FkLCBfZXJyb3IpIHtcbiAgICAgICAgY29uc3QgeyBtZXRob2QgfSA9IHBheWxvYWQ7XG4gICAgICAgIGNvbnN0IHsgZXJyb3IgfSA9IF9lcnJvcjtcbiAgICAgICAgaWYgKG1ldGhvZCA9PT0gXCJldGhfZXN0aW1hdGVHYXNcIiAmJiBlcnJvci5tZXNzYWdlKSB7XG4gICAgICAgICAgICBjb25zdCBtc2cgPSBlcnJvci5tZXNzYWdlO1xuICAgICAgICAgICAgaWYgKCFtc2cubWF0Y2goL3JldmVydC9pKSAmJiBtc2cubWF0Y2goL2luc3VmZmljaWVudCBmdW5kcy9pKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBtYWtlRXJyb3IoXCJpbnN1ZmZpY2llbnQgZnVuZHNcIiwgXCJJTlNVRkZJQ0lFTlRfRlVORFNcIiwge1xuICAgICAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbjogKHBheWxvYWQucGFyYW1zWzBdKSxcbiAgICAgICAgICAgICAgICAgICAgaW5mbzogeyBwYXlsb2FkLCBlcnJvciB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChtc2cubWF0Y2goL25vbmNlL2kpICYmIG1zZy5tYXRjaCgvdG9vIGxvdy9pKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBtYWtlRXJyb3IoXCJub25jZSBoYXMgYWxyZWFkeSBiZWVuIHVzZWRcIiwgXCJOT05DRV9FWFBJUkVEXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNhY3Rpb246IChwYXlsb2FkLnBhcmFtc1swXSksXG4gICAgICAgICAgICAgICAgICAgIGluZm86IHsgcGF5bG9hZCwgZXJyb3IgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChtZXRob2QgPT09IFwiZXRoX2NhbGxcIiB8fCBtZXRob2QgPT09IFwiZXRoX2VzdGltYXRlR2FzXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHNwZWx1bmtEYXRhKGVycm9yKTtcbiAgICAgICAgICAgIGNvbnN0IGUgPSBBYmlDb2Rlci5nZXRCdWlsdGluQ2FsbEV4Y2VwdGlvbigobWV0aG9kID09PSBcImV0aF9jYWxsXCIpID8gXCJjYWxsXCIgOiBcImVzdGltYXRlR2FzXCIsIChwYXlsb2FkLnBhcmFtc1swXSksIChyZXN1bHQgPyByZXN1bHQuZGF0YSA6IG51bGwpKTtcbiAgICAgICAgICAgIGUuaW5mbyA9IHsgZXJyb3IsIHBheWxvYWQgfTtcbiAgICAgICAgICAgIHJldHVybiBlO1xuICAgICAgICB9XG4gICAgICAgIC8vIE9ubHkgZXN0aW1hdGVHYXMgYW5kIGNhbGwgY2FuIHJldHVybiBhcmJpdHJhcnkgY29udHJhY3QtZGVmaW5lZCB0ZXh0LCBzbyBub3cgd2VcbiAgICAgICAgLy8gd2UgY2FuIHByb2Nlc3MgdGV4dCBzYWZlbHkuXG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBKU09OLnN0cmluZ2lmeShzcGVsdW5rTWVzc2FnZShlcnJvcikpO1xuICAgICAgICBpZiAodHlwZW9mIChlcnJvci5tZXNzYWdlKSA9PT0gXCJzdHJpbmdcIiAmJiBlcnJvci5tZXNzYWdlLm1hdGNoKC91c2VyIGRlbmllZHxldGhlcnMtdXNlci1kZW5pZWQvaSkpIHtcbiAgICAgICAgICAgIGNvbnN0IGFjdGlvbk1hcCA9IHtcbiAgICAgICAgICAgICAgICBldGhfc2lnbjogXCJzaWduTWVzc2FnZVwiLFxuICAgICAgICAgICAgICAgIHBlcnNvbmFsX3NpZ246IFwic2lnbk1lc3NhZ2VcIixcbiAgICAgICAgICAgICAgICBldGhfc2lnblR5cGVkRGF0YV92NDogXCJzaWduVHlwZWREYXRhXCIsXG4gICAgICAgICAgICAgICAgZXRoX3NpZ25UcmFuc2FjdGlvbjogXCJzaWduVHJhbnNhY3Rpb25cIixcbiAgICAgICAgICAgICAgICBldGhfc2VuZFRyYW5zYWN0aW9uOiBcInNlbmRUcmFuc2FjdGlvblwiLFxuICAgICAgICAgICAgICAgIGV0aF9yZXF1ZXN0QWNjb3VudHM6IFwicmVxdWVzdEFjY2Vzc1wiLFxuICAgICAgICAgICAgICAgIHdhbGxldF9yZXF1ZXN0QWNjb3VudHM6IFwicmVxdWVzdEFjY2Vzc1wiLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiBtYWtlRXJyb3IoYHVzZXIgcmVqZWN0ZWQgYWN0aW9uYCwgXCJBQ1RJT05fUkVKRUNURURcIiwge1xuICAgICAgICAgICAgICAgIGFjdGlvbjogKGFjdGlvbk1hcFttZXRob2RdIHx8IFwidW5rbm93blwiKSxcbiAgICAgICAgICAgICAgICByZWFzb246IFwicmVqZWN0ZWRcIixcbiAgICAgICAgICAgICAgICBpbmZvOiB7IHBheWxvYWQsIGVycm9yIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXRob2QgPT09IFwiZXRoX3NlbmRSYXdUcmFuc2FjdGlvblwiIHx8IG1ldGhvZCA9PT0gXCJldGhfc2VuZFRyYW5zYWN0aW9uXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gKHBheWxvYWQucGFyYW1zWzBdKTtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLm1hdGNoKC9pbnN1ZmZpY2llbnQgZnVuZHN8YmFzZSBmZWUgZXhjZWVkcyBnYXMgbGltaXQvaSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWFrZUVycm9yKFwiaW5zdWZmaWNpZW50IGZ1bmRzIGZvciBpbnRyaW5zaWMgdHJhbnNhY3Rpb24gY29zdFwiLCBcIklOU1VGRklDSUVOVF9GVU5EU1wiLCB7XG4gICAgICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uLCBpbmZvOiB7IGVycm9yIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtZXNzYWdlLm1hdGNoKC9ub25jZS9pKSAmJiBtZXNzYWdlLm1hdGNoKC90b28gbG93L2kpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1ha2VFcnJvcihcIm5vbmNlIGhhcyBhbHJlYWR5IGJlZW4gdXNlZFwiLCBcIk5PTkNFX0VYUElSRURcIiwgeyB0cmFuc2FjdGlvbiwgaW5mbzogeyBlcnJvciB9IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gXCJyZXBsYWNlbWVudCB0cmFuc2FjdGlvbiB1bmRlcnByaWNlZFwiXG4gICAgICAgICAgICBpZiAobWVzc2FnZS5tYXRjaCgvcmVwbGFjZW1lbnQgdHJhbnNhY3Rpb24vaSkgJiYgbWVzc2FnZS5tYXRjaCgvdW5kZXJwcmljZWQvaSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWFrZUVycm9yKFwicmVwbGFjZW1lbnQgZmVlIHRvbyBsb3dcIiwgXCJSRVBMQUNFTUVOVF9VTkRFUlBSSUNFRFwiLCB7IHRyYW5zYWN0aW9uLCBpbmZvOiB7IGVycm9yIH0gfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5tYXRjaCgvb25seSByZXBsYXktcHJvdGVjdGVkL2kpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1ha2VFcnJvcihcImxlZ2FjeSBwcmUtZWlwLTE1NSB0cmFuc2FjdGlvbnMgbm90IHN1cHBvcnRlZFwiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7XG4gICAgICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogbWV0aG9kLCBpbmZvOiB7IHRyYW5zYWN0aW9uLCBpbmZvOiB7IGVycm9yIH0gfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCB1bnN1cHBvcnRlZCA9ICEhbWVzc2FnZS5tYXRjaCgvdGhlIG1ldGhvZCAuKiBkb2VzIG5vdCBleGlzdC9pKTtcbiAgICAgICAgaWYgKCF1bnN1cHBvcnRlZCkge1xuICAgICAgICAgICAgaWYgKGVycm9yICYmIGVycm9yLmRldGFpbHMgJiYgZXJyb3IuZGV0YWlscy5zdGFydHNXaXRoKFwiVW5hdXRob3JpemVkIG1ldGhvZDpcIikpIHtcbiAgICAgICAgICAgICAgICB1bnN1cHBvcnRlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHVuc3VwcG9ydGVkKSB7XG4gICAgICAgICAgICByZXR1cm4gbWFrZUVycm9yKFwidW5zdXBwb3J0ZWQgb3BlcmF0aW9uXCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHtcbiAgICAgICAgICAgICAgICBvcGVyYXRpb246IHBheWxvYWQubWV0aG9kLCBpbmZvOiB7IGVycm9yLCBwYXlsb2FkIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtYWtlRXJyb3IoXCJjb3VsZCBub3QgY29hbGVzY2UgZXJyb3JcIiwgXCJVTktOT1dOX0VSUk9SXCIsIHsgZXJyb3IsIHBheWxvYWQgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXF1ZXN0cyB0aGUgJSVtZXRob2QlJSB3aXRoICUlcGFyYW1zJSUgdmlhIHRoZSBKU09OLVJQQyBwcm90b2NvbFxuICAgICAqICBvdmVyIHRoZSB1bmRlcmx5aW5nIGNoYW5uZWwuIFRoaXMgY2FuIGJlIHVzZWQgdG8gY2FsbCBtZXRob2RzXG4gICAgICogIG9uIHRoZSBiYWNrZW5kIHRoYXQgZG8gbm90IGhhdmUgYSBoaWdoLWxldmVsIEFQSSB3aXRoaW4gdGhlIFByb3ZpZGVyXG4gICAgICogIEFQSS5cbiAgICAgKlxuICAgICAqICBUaGlzIG1ldGhvZCBxdWV1ZXMgcmVxdWVzdHMgYWNjb3JkaW5nIHRvIHRoZSBiYXRjaCBjb25zdHJhaW50c1xuICAgICAqICBpbiB0aGUgb3B0aW9ucywgYXNzaWducyB0aGUgcmVxdWVzdCBhIHVuaXF1ZSBJRC5cbiAgICAgKlxuICAgICAqICAqKkRvIE5PVCBvdmVycmlkZSoqIHRoaXMgbWV0aG9kIGluIHN1Yi1jbGFzc2VzOyBpbnN0ZWFkXG4gICAgICogIG92ZXJyaWRlIFtbX3NlbmRdXSBvciBmb3JjZSB0aGUgb3B0aW9ucyB2YWx1ZXMgaW4gdGhlXG4gICAgICogIGNhbGwgdG8gdGhlIGNvbnN0cnVjdG9yIHRvIG1vZGlmeSB0aGlzIG1ldGhvZCdzIGJlaGF2aW9yLlxuICAgICAqL1xuICAgIHNlbmQobWV0aG9kLCBwYXJhbXMpIHtcbiAgICAgICAgLy8gQFRPRE86IGNhY2hlIGNoYWluSWQ/PyBwdXJnZSBvbiBzd2l0Y2hfbmV0d29ya3NcbiAgICAgICAgLy8gV2UgaGF2ZSBiZWVuIGRlc3Ryb3llZDsgbm8gb3BlcmF0aW9ucyBhcmUgc3VwcG9ydGVkIGFueW1vcmVcbiAgICAgICAgaWYgKHRoaXMuZGVzdHJveWVkKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobWFrZUVycm9yKFwicHJvdmlkZXIgZGVzdHJveWVkOyBjYW5jZWxsZWQgcmVxdWVzdFwiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7IG9wZXJhdGlvbjogbWV0aG9kIH0pKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpZCA9IHRoaXMuI25leHRJZCsrO1xuICAgICAgICBjb25zdCBwcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgdGhpcy4jcGF5bG9hZHMucHVzaCh7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZSwgcmVqZWN0LFxuICAgICAgICAgICAgICAgIHBheWxvYWQ6IHsgbWV0aG9kLCBwYXJhbXMsIGlkLCBqc29ucnBjOiBcIjIuMFwiIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gSWYgdGhlcmUgaXMgbm90IGEgcGVuZGluZyBkcmFpblRpbWVyLCBzZXQgb25lXG4gICAgICAgIHRoaXMuI3NjaGVkdWxlRHJhaW4oKTtcbiAgICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXNvbHZlcyB0byB0aGUgW1tTaWduZXJdXSBhY2NvdW50IGZvciAgJSVhZGRyZXNzJSUgbWFuYWdlZCBieVxuICAgICAqICB0aGUgY2xpZW50LlxuICAgICAqXG4gICAgICogIElmIHRoZSAlJWFkZHJlc3MlJSBpcyBhIG51bWJlciwgaXQgaXMgdXNlZCBhcyBhbiBpbmRleCBpbiB0aGVcbiAgICAgKiAgdGhlIGFjY291bnRzIGZyb20gW1tsaXN0QWNjb3VudHNdXS5cbiAgICAgKlxuICAgICAqICBUaGlzIGNhbiBvbmx5IGJlIHVzZWQgb24gY2xpZW50cyB3aGljaCBtYW5hZ2UgYWNjb3VudHMgKHN1Y2ggYXNcbiAgICAgKiAgR2V0aCB3aXRoIGltcG9ydGVkIGFjY291bnQgb3IgTWV0YU1hc2spLlxuICAgICAqXG4gICAgICogIFRocm93cyBpZiB0aGUgYWNjb3VudCBkb2Vzbid0IGV4aXN0LlxuICAgICAqL1xuICAgIGFzeW5jIGdldFNpZ25lcihhZGRyZXNzKSB7XG4gICAgICAgIGlmIChhZGRyZXNzID09IG51bGwpIHtcbiAgICAgICAgICAgIGFkZHJlc3MgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFjY291bnRzUHJvbWlzZSA9IHRoaXMuc2VuZChcImV0aF9hY2NvdW50c1wiLCBbXSk7XG4gICAgICAgIC8vIEFjY291bnQgaW5kZXhcbiAgICAgICAgaWYgKHR5cGVvZiAoYWRkcmVzcykgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IGFjY291bnRzID0gKGF3YWl0IGFjY291bnRzUHJvbWlzZSk7XG4gICAgICAgICAgICBpZiAoYWRkcmVzcyA+PSBhY2NvdW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJubyBzdWNoIGFjY291bnRcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IEpzb25ScGNTaWduZXIodGhpcywgYWNjb3VudHNbYWRkcmVzc10pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgYWNjb3VudHMgfSA9IGF3YWl0IHJlc29sdmVQcm9wZXJ0aWVzKHtcbiAgICAgICAgICAgIG5ldHdvcms6IHRoaXMuZ2V0TmV0d29yaygpLFxuICAgICAgICAgICAgYWNjb3VudHM6IGFjY291bnRzUHJvbWlzZVxuICAgICAgICB9KTtcbiAgICAgICAgLy8gQWNjb3VudCBhZGRyZXNzXG4gICAgICAgIGFkZHJlc3MgPSBnZXRBZGRyZXNzKGFkZHJlc3MpO1xuICAgICAgICBmb3IgKGNvbnN0IGFjY291bnQgb2YgYWNjb3VudHMpIHtcbiAgICAgICAgICAgIGlmIChnZXRBZGRyZXNzKGFjY291bnQpID09PSBhZGRyZXNzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBKc29uUnBjU2lnbmVyKHRoaXMsIGFkZHJlc3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgYWNjb3VudFwiKTtcbiAgICB9XG4gICAgYXN5bmMgbGlzdEFjY291bnRzKCkge1xuICAgICAgICBjb25zdCBhY2NvdW50cyA9IGF3YWl0IHRoaXMuc2VuZChcImV0aF9hY2NvdW50c1wiLCBbXSk7XG4gICAgICAgIHJldHVybiBhY2NvdW50cy5tYXAoKGEpID0+IG5ldyBKc29uUnBjU2lnbmVyKHRoaXMsIGEpKTtcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgLy8gU3RvcCBwcm9jZXNzaW5nIHJlcXVlc3RzXG4gICAgICAgIGlmICh0aGlzLiNkcmFpblRpbWVyKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy4jZHJhaW5UaW1lcik7XG4gICAgICAgICAgICB0aGlzLiNkcmFpblRpbWVyID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICAvLyBDYW5jZWwgYWxsIHBlbmRpbmcgcmVxdWVzdHNcbiAgICAgICAgZm9yIChjb25zdCB7IHBheWxvYWQsIHJlamVjdCB9IG9mIHRoaXMuI3BheWxvYWRzKSB7XG4gICAgICAgICAgICByZWplY3QobWFrZUVycm9yKFwicHJvdmlkZXIgZGVzdHJveWVkOyBjYW5jZWxsZWQgcmVxdWVzdFwiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7IG9wZXJhdGlvbjogcGF5bG9hZC5tZXRob2QgfSkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuI3BheWxvYWRzID0gW107XG4gICAgICAgIC8vIFBhcmVudCBjbGVhbi11cFxuICAgICAgICBzdXBlci5kZXN0cm95KCk7XG4gICAgfVxufVxuLy8gQFRPRE86IHJlbW92ZSB0aGlzIGluIHY3LCBpdCBpcyBub3QgZXhwb3J0ZWQgYmVjYXVzZSB0aGlzIGZ1bmN0aW9uYWxpdHlcbi8vIGlzIGV4cG9zZWQgaW4gdGhlIEpzb25ScGNBcGlQcm92aWRlciBieSBzZXR0aW5nIHBvbGxpbmcgdG8gdHJ1ZS4gSXQgc2hvdWxkXG4vLyBiZSBzYWZlIHRvIHJlbW92ZSByZWdhcmRsZXNzLCBiZWNhdXNlIGl0IGlzbid0IHJlYWNoYWJsZSwgYnV0IGp1c3QgaW4gY2FzZS5cbi8qKlxuICogIEBfaWdub3JlOlxuICovXG5leHBvcnQgY2xhc3MgSnNvblJwY0FwaVBvbGxpbmdQcm92aWRlciBleHRlbmRzIEpzb25ScGNBcGlQcm92aWRlciB7XG4gICAgI3BvbGxpbmdJbnRlcnZhbDtcbiAgICBjb25zdHJ1Y3RvcihuZXR3b3JrLCBvcHRpb25zKSB7XG4gICAgICAgIHN1cGVyKG5ldHdvcmssIG9wdGlvbnMpO1xuICAgICAgICBsZXQgcG9sbGluZ0ludGVydmFsID0gdGhpcy5fZ2V0T3B0aW9uKFwicG9sbGluZ0ludGVydmFsXCIpO1xuICAgICAgICBpZiAocG9sbGluZ0ludGVydmFsID09IG51bGwpIHtcbiAgICAgICAgICAgIHBvbGxpbmdJbnRlcnZhbCA9IGRlZmF1bHRPcHRpb25zLnBvbGxpbmdJbnRlcnZhbDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLiNwb2xsaW5nSW50ZXJ2YWwgPSBwb2xsaW5nSW50ZXJ2YWw7XG4gICAgfVxuICAgIF9nZXRTdWJzY3JpYmVyKHN1Yikge1xuICAgICAgICBjb25zdCBzdWJzY3JpYmVyID0gc3VwZXIuX2dldFN1YnNjcmliZXIoc3ViKTtcbiAgICAgICAgaWYgKGlzUG9sbGFibGUoc3Vic2NyaWJlcikpIHtcbiAgICAgICAgICAgIHN1YnNjcmliZXIucG9sbGluZ0ludGVydmFsID0gdGhpcy4jcG9sbGluZ0ludGVydmFsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdWJzY3JpYmVyO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhlIHBvbGxpbmcgaW50ZXJ2YWwgKGRlZmF1bHQ6IDQwMDAgbXMpXG4gICAgICovXG4gICAgZ2V0IHBvbGxpbmdJbnRlcnZhbCgpIHsgcmV0dXJuIHRoaXMuI3BvbGxpbmdJbnRlcnZhbDsgfVxuICAgIHNldCBwb2xsaW5nSW50ZXJ2YWwodmFsdWUpIHtcbiAgICAgICAgaWYgKCFOdW1iZXIuaXNJbnRlZ2VyKHZhbHVlKSB8fCB2YWx1ZSA8IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgaW50ZXJ2YWxcIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4jcG9sbGluZ0ludGVydmFsID0gdmFsdWU7XG4gICAgICAgIHRoaXMuX2ZvckVhY2hTdWJzY3JpYmVyKChzdWIpID0+IHtcbiAgICAgICAgICAgIGlmIChpc1BvbGxhYmxlKHN1YikpIHtcbiAgICAgICAgICAgICAgICBzdWIucG9sbGluZ0ludGVydmFsID0gdGhpcy4jcG9sbGluZ0ludGVydmFsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG59XG4vKipcbiAqICBUaGUgSnNvblJwY1Byb3ZpZGVyIGlzIG9uZSBvZiB0aGUgbW9zdCBjb21tb24gUHJvdmlkZXJzLFxuICogIHdoaWNoIHBlcmZvcm1zIGFsbCBvcGVyYXRpb25zIG92ZXIgSFRUUCAob3IgSFRUUFMpIHJlcXVlc3RzLlxuICpcbiAqICBFdmVudHMgYXJlIHByb2Nlc3NlZCBieSBwb2xsaW5nIHRoZSBiYWNrZW5kIGZvciB0aGUgY3VycmVudCBibG9ja1xuICogIG51bWJlcjsgd2hlbiBpdCBhZHZhbmNlcywgYWxsIGJsb2NrLWJhc2UgZXZlbnRzIGFyZSB0aGVuIGNoZWNrZWRcbiAqICBmb3IgdXBkYXRlcy5cbiAqL1xuZXhwb3J0IGNsYXNzIEpzb25ScGNQcm92aWRlciBleHRlbmRzIEpzb25ScGNBcGlQb2xsaW5nUHJvdmlkZXIge1xuICAgICNjb25uZWN0O1xuICAgIGNvbnN0cnVjdG9yKHVybCwgbmV0d29yaywgb3B0aW9ucykge1xuICAgICAgICBpZiAodXJsID09IG51bGwpIHtcbiAgICAgICAgICAgIHVybCA9IFwiaHR0cDovXFwvbG9jYWxob3N0Ojg1NDVcIjtcbiAgICAgICAgfVxuICAgICAgICBzdXBlcihuZXR3b3JrLCBvcHRpb25zKTtcbiAgICAgICAgaWYgKHR5cGVvZiAodXJsKSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgdGhpcy4jY29ubmVjdCA9IG5ldyBGZXRjaFJlcXVlc3QodXJsKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuI2Nvbm5lY3QgPSB1cmwuY2xvbmUoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfZ2V0Q29ubmVjdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI2Nvbm5lY3QuY2xvbmUoKTtcbiAgICB9XG4gICAgYXN5bmMgc2VuZChtZXRob2QsIHBhcmFtcykge1xuICAgICAgICAvLyBBbGwgcmVxdWVzdHMgYXJlIG92ZXIgSFRUUCwgc28gd2UgY2FuIGp1c3Qgc3RhcnQgaGFuZGxpbmcgcmVxdWVzdHNcbiAgICAgICAgLy8gV2UgZG8gdGhpcyBoZXJlIHJhdGhlciB0aGFuIHRoZSBjb25zdHJ1Y3RvciBzbyB0aGF0IHdlIGRvbid0IHNlbmQgYW55XG4gICAgICAgIC8vIHJlcXVlc3RzIHRvIHRoZSBuZXR3b3JrIChpLmUuIGV0aF9jaGFpbklkKSB1bnRpbCB3ZSBhYnNvbHV0ZWx5IGhhdmUgdG8uXG4gICAgICAgIGF3YWl0IHRoaXMuX3N0YXJ0KCk7XG4gICAgICAgIHJldHVybiBhd2FpdCBzdXBlci5zZW5kKG1ldGhvZCwgcGFyYW1zKTtcbiAgICB9XG4gICAgYXN5bmMgX3NlbmQocGF5bG9hZCkge1xuICAgICAgICAvLyBDb25maWd1cmUgYSBQT1NUIGNvbm5lY3Rpb24gZm9yIHRoZSByZXF1ZXN0ZWQgbWV0aG9kXG4gICAgICAgIGNvbnN0IHJlcXVlc3QgPSB0aGlzLl9nZXRDb25uZWN0aW9uKCk7XG4gICAgICAgIHJlcXVlc3QuYm9keSA9IEpTT04uc3RyaW5naWZ5KHBheWxvYWQpO1xuICAgICAgICByZXF1ZXN0LnNldEhlYWRlcihcImNvbnRlbnQtdHlwZVwiLCBcImFwcGxpY2F0aW9uL2pzb25cIik7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgcmVxdWVzdC5zZW5kKCk7XG4gICAgICAgIHJlc3BvbnNlLmFzc2VydE9rKCk7XG4gICAgICAgIGxldCByZXNwID0gcmVzcG9uc2UuYm9keUpzb247XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShyZXNwKSkge1xuICAgICAgICAgICAgcmVzcCA9IFtyZXNwXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzcDtcbiAgICB9XG59XG5mdW5jdGlvbiBzcGVsdW5rRGF0YSh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvLyBUaGVzZSAqYXJlKiB0aGUgZHJvaWRzIHdlJ3JlIGxvb2tpbmcgZm9yLlxuICAgIGlmICh0eXBlb2YgKHZhbHVlLm1lc3NhZ2UpID09PSBcInN0cmluZ1wiICYmIHZhbHVlLm1lc3NhZ2UubWF0Y2goL3JldmVydC9pKSAmJiBpc0hleFN0cmluZyh2YWx1ZS5kYXRhKSkge1xuICAgICAgICByZXR1cm4geyBtZXNzYWdlOiB2YWx1ZS5tZXNzYWdlLCBkYXRhOiB2YWx1ZS5kYXRhIH07XG4gICAgfVxuICAgIC8vIFNwZWx1bmsgZnVydGhlci4uLlxuICAgIGlmICh0eXBlb2YgKHZhbHVlKSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiB2YWx1ZSkge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gc3BlbHVua0RhdGEodmFsdWVba2V5XSk7XG4gICAgICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLy8gTWlnaHQgYmUgYSBKU09OIHN0cmluZyB3ZSBjYW4gZnVydGhlciBkZXNjZW5kLi4uXG4gICAgaWYgKHR5cGVvZiAodmFsdWUpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gc3BlbHVua0RhdGEoSlNPTi5wYXJzZSh2YWx1ZSkpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikgeyB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gX3NwZWx1bmtNZXNzYWdlKHZhbHVlLCByZXN1bHQpIHtcbiAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIFRoZXNlICphcmUqIHRoZSBkcm9pZHMgd2UncmUgbG9va2luZyBmb3IuXG4gICAgaWYgKHR5cGVvZiAodmFsdWUubWVzc2FnZSkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgcmVzdWx0LnB1c2godmFsdWUubWVzc2FnZSk7XG4gICAgfVxuICAgIC8vIFNwZWx1bmsgZnVydGhlci4uLlxuICAgIGlmICh0eXBlb2YgKHZhbHVlKSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiB2YWx1ZSkge1xuICAgICAgICAgICAgX3NwZWx1bmtNZXNzYWdlKHZhbHVlW2tleV0sIHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gTWlnaHQgYmUgYSBKU09OIHN0cmluZyB3ZSBjYW4gZnVydGhlciBkZXNjZW5kLi4uXG4gICAgaWYgKHR5cGVvZiAodmFsdWUpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gX3NwZWx1bmtNZXNzYWdlKEpTT04ucGFyc2UodmFsdWUpLCByZXN1bHQpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikgeyB9XG4gICAgfVxufVxuZnVuY3Rpb24gc3BlbHVua01lc3NhZ2UodmFsdWUpIHtcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICBfc3BlbHVua01lc3NhZ2UodmFsdWUsIHJlc3VsdCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXByb3ZpZGVyLWpzb25ycGMuanMubWFwIl0sIm5hbWVzIjpbIkFiaUNvZGVyIiwiZ2V0QWRkcmVzcyIsInJlc29sdmVBZGRyZXNzIiwiVHlwZWREYXRhRW5jb2RlciIsImFjY2Vzc0xpc3RpZnkiLCJhdXRob3JpemF0aW9uaWZ5IiwiZGVmaW5lUHJvcGVydGllcyIsImdldEJpZ0ludCIsImhleGxpZnkiLCJpc0hleFN0cmluZyIsInRvUXVhbnRpdHkiLCJ0b1V0ZjhCeXRlcyIsImlzRXJyb3IiLCJtYWtlRXJyb3IiLCJhc3NlcnQiLCJhc3NlcnRBcmd1bWVudCIsIkZldGNoUmVxdWVzdCIsInJlc29sdmVQcm9wZXJ0aWVzIiwiQWJzdHJhY3RQcm92aWRlciIsIlVubWFuYWdlZFN1YnNjcmliZXIiLCJBYnN0cmFjdFNpZ25lciIsIk5ldHdvcmsiLCJGaWx0ZXJJZEV2ZW50U3Vic2NyaWJlciIsIkZpbHRlcklkUGVuZGluZ1N1YnNjcmliZXIiLCJQb2xsaW5nRXZlbnRTdWJzY3JpYmVyIiwiUHJpbWl0aXZlIiwic3BsaXQiLCJkZWVwQ29weSIsInZhbHVlIiwiaW5kZXhPZiIsIkFycmF5IiwiaXNBcnJheSIsIm1hcCIsIk9iamVjdCIsImtleXMiLCJyZWR1Y2UiLCJhY2N1bSIsImtleSIsIkVycm9yIiwic3RhbGwiLCJkdXJhdGlvbiIsIlByb21pc2UiLCJyZXNvbHZlIiwic2V0VGltZW91dCIsImdldExvd2VyQ2FzZSIsInRvTG93ZXJDYXNlIiwiaXNQb2xsYWJsZSIsInBvbGxpbmdJbnRlcnZhbCIsImRlZmF1bHRPcHRpb25zIiwicG9sbGluZyIsInN0YXRpY05ldHdvcmsiLCJiYXRjaFN0YWxsVGltZSIsImJhdGNoTWF4U2l6ZSIsImJhdGNoTWF4Q291bnQiLCJjYWNoZVRpbWVvdXQiLCJKc29uUnBjU2lnbmVyIiwiY29uc3RydWN0b3IiLCJwcm92aWRlciIsImFkZHJlc3MiLCJjb25uZWN0Iiwib3BlcmF0aW9uIiwicG9wdWxhdGVUcmFuc2FjdGlvbiIsInR4IiwicG9wdWxhdGVDYWxsIiwic2VuZFVuY2hlY2tlZFRyYW5zYWN0aW9uIiwiX3R4IiwicHJvbWlzZXMiLCJmcm9tIiwiX2Zyb20iLCJwdXNoIiwiZ2FzTGltaXQiLCJlc3RpbWF0ZUdhcyIsInRvIiwiX3RvIiwibGVuZ3RoIiwiYWxsIiwiaGV4VHgiLCJnZXRScGNUcmFuc2FjdGlvbiIsInNlbmQiLCJzZW5kVHJhbnNhY3Rpb24iLCJibG9ja051bWJlciIsImdldEJsb2NrTnVtYmVyIiwiaGFzaCIsInJlamVjdCIsInRpbWVvdXRzIiwiaW52YWxpZHMiLCJjaGVja1R4IiwiZ2V0VHJhbnNhY3Rpb24iLCJyZXBsYWNlYWJsZVRyYW5zYWN0aW9uIiwiZXJyb3IiLCJpbmZvIiwic2VuZFRyYW5zYWN0aW9uSGFzaCIsImVtaXQiLCJfc2V0VGltZW91dCIsInBvcCIsInNpZ25UcmFuc2FjdGlvbiIsInNpZ25NZXNzYWdlIiwiX21lc3NhZ2UiLCJtZXNzYWdlIiwic2lnblR5cGVkRGF0YSIsImRvbWFpbiIsInR5cGVzIiwiX3ZhbHVlIiwicG9wdWxhdGVkIiwicmVzb2x2ZU5hbWVzIiwiSlNPTiIsInN0cmluZ2lmeSIsImdldFBheWxvYWQiLCJ1bmxvY2siLCJwYXNzd29yZCIsIl9sZWdhY3lTaWduTWVzc2FnZSIsIkpzb25ScGNBcGlQcm92aWRlciIsIm9wdGlvbnMiLCJuZXh0SWQiLCJwYXlsb2FkcyIsImRyYWluVGltZXIiLCJub3RSZWFkeSIsIm5ldHdvcmsiLCJwZW5kaW5nRGV0ZWN0TmV0d29yayIsInNjaGVkdWxlRHJhaW4iLCJzdGFsbFRpbWUiLCJfZ2V0T3B0aW9uIiwiYmF0Y2giLCJzaGlmdCIsImJ5dGVzIiwicCIsInBheWxvYWQiLCJ1bnNoaWZ0IiwiYWN0aW9uIiwicmVzdWx0IiwiX3NlbmQiLCJkZXN0cm95ZWQiLCJtZXRob2QiLCJyZXNwIiwiZmlsdGVyIiwiciIsImlkIiwiZ2V0UnBjRXJyb3IiLCJhc3NpZ24iLCJwcm9taXNlIiwiX3Jlc29sdmUiLCJtYXRjaGVzIiwiX25ldHdvcmsiLCJfcGVyZm9ybSIsInJlcSIsInRyYW5zYWN0aW9uIiwidHlwZSIsIm1heEZlZVBlckdhcyIsIm1heFByaW9yaXR5RmVlUGVyR2FzIiwiZmVlRGF0YSIsImdldEZlZURhdGEiLCJ1bmRlZmluZWQiLCJyZXF1ZXN0IiwiZ2V0UnBjUmVxdWVzdCIsImFyZ3MiLCJfZGV0ZWN0TmV0d29yayIsInJlYWR5IiwicGFyYW1zIiwianNvbnJwYyIsIl9zdGFydCIsImNvbnNvbGUiLCJsb2ciLCJldmVudCIsIl93YWl0VW50aWxSZWFkeSIsIl9nZXRTdWJzY3JpYmVyIiwic3ViIiwib3JwaGFuIiwiZm9yRWFjaCIsImRzdEtleSIsImFjY2Vzc0xpc3QiLCJibG9iVmVyc2lvbmVkSGFzaGVzIiwiaCIsImF1dGhvcml6YXRpb25MaXN0IiwiX2EiLCJhIiwibm9uY2UiLCJjaGFpbklkIiwieVBhcml0eSIsInNpZ25hdHVyZSIsInMiLCJibG9ja1RhZyIsInBvc2l0aW9uIiwidG9TdHJpbmciLCJzaWduZWRUcmFuc2FjdGlvbiIsImluY2x1ZGVUcmFuc2FjdGlvbnMiLCJibG9ja0hhc2giLCJfZXJyb3IiLCJtc2ciLCJtYXRjaCIsInNwZWx1bmtEYXRhIiwiZSIsImdldEJ1aWx0aW5DYWxsRXhjZXB0aW9uIiwiZGF0YSIsInNwZWx1bmtNZXNzYWdlIiwiYWN0aW9uTWFwIiwiZXRoX3NpZ24iLCJwZXJzb25hbF9zaWduIiwiZXRoX3NpZ25UeXBlZERhdGFfdjQiLCJldGhfc2lnblRyYW5zYWN0aW9uIiwiZXRoX3NlbmRUcmFuc2FjdGlvbiIsImV0aF9yZXF1ZXN0QWNjb3VudHMiLCJ3YWxsZXRfcmVxdWVzdEFjY291bnRzIiwicmVhc29uIiwidW5zdXBwb3J0ZWQiLCJkZXRhaWxzIiwic3RhcnRzV2l0aCIsImdldFNpZ25lciIsImFjY291bnRzUHJvbWlzZSIsImFjY291bnRzIiwiZ2V0TmV0d29yayIsImFjY291bnQiLCJsaXN0QWNjb3VudHMiLCJkZXN0cm95IiwiY2xlYXJUaW1lb3V0IiwiSnNvblJwY0FwaVBvbGxpbmdQcm92aWRlciIsInN1YnNjcmliZXIiLCJOdW1iZXIiLCJpc0ludGVnZXIiLCJfZm9yRWFjaFN1YnNjcmliZXIiLCJKc29uUnBjUHJvdmlkZXIiLCJ1cmwiLCJjbG9uZSIsIl9nZXRDb25uZWN0aW9uIiwiYm9keSIsInNldEhlYWRlciIsInJlc3BvbnNlIiwiYXNzZXJ0T2siLCJib2R5SnNvbiIsInBhcnNlIiwiX3NwZWx1bmtNZXNzYWdlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.esm/providers/provider-jsonrpc.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.esm/providers/provider.js":
/*!***********************************************************!*\
  !*** ./node_modules/ethers/lib.esm/providers/provider.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Block: () => (/* binding */ Block),\n/* harmony export */   FeeData: () => (/* binding */ FeeData),\n/* harmony export */   Log: () => (/* binding */ Log),\n/* harmony export */   TransactionReceipt: () => (/* binding */ TransactionReceipt),\n/* harmony export */   TransactionResponse: () => (/* binding */ TransactionResponse),\n/* harmony export */   copyRequest: () => (/* binding */ copyRequest)\n/* harmony export */ });\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/properties.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/data.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/maths.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/errors.js\");\n/* harmony import */ var _transaction_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../transaction/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/transaction/accesslist.js\");\n//import { resolveAddress } from \"@ethersproject/address\";\n\n\nconst BN_0 = BigInt(0);\n// -----------------------\nfunction getValue(value) {\n    if (value == null) {\n        return null;\n    }\n    return value;\n}\nfunction toJson(value) {\n    if (value == null) {\n        return null;\n    }\n    return value.toString();\n}\n// @TODO? <T extends FeeData = { }> implements Required<T>\n/**\n *  A **FeeData** wraps all the fee-related values associated with\n *  the network.\n */ class FeeData {\n    /**\n     *  Creates a new FeeData for %%gasPrice%%, %%maxFeePerGas%% and\n     *  %%maxPriorityFeePerGas%%.\n     */ constructor(gasPrice, maxFeePerGas, maxPriorityFeePerGas){\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.defineProperties)(this, {\n            gasPrice: getValue(gasPrice),\n            maxFeePerGas: getValue(maxFeePerGas),\n            maxPriorityFeePerGas: getValue(maxPriorityFeePerGas)\n        });\n    }\n    /**\n     *  Returns a JSON-friendly value.\n     */ toJSON() {\n        const { gasPrice, maxFeePerGas, maxPriorityFeePerGas } = this;\n        return {\n            _type: \"FeeData\",\n            gasPrice: toJson(gasPrice),\n            maxFeePerGas: toJson(maxFeePerGas),\n            maxPriorityFeePerGas: toJson(maxPriorityFeePerGas)\n        };\n    }\n}\n;\n/**\n *  Returns a copy of %%req%% with all properties coerced to their strict\n *  types.\n */ function copyRequest(req) {\n    const result = {};\n    // These could be addresses, ENS names or Addressables\n    if (req.to) {\n        result.to = req.to;\n    }\n    if (req.from) {\n        result.from = req.from;\n    }\n    if (req.data) {\n        result.data = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.hexlify)(req.data);\n    }\n    const bigIntKeys = \"chainId,gasLimit,gasPrice,maxFeePerBlobGas,maxFeePerGas,maxPriorityFeePerGas,value\".split(/,/);\n    for (const key of bigIntKeys){\n        if (!(key in req) || req[key] == null) {\n            continue;\n        }\n        result[key] = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.getBigInt)(req[key], `request.${key}`);\n    }\n    const numberKeys = \"type,nonce\".split(/,/);\n    for (const key of numberKeys){\n        if (!(key in req) || req[key] == null) {\n            continue;\n        }\n        result[key] = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.getNumber)(req[key], `request.${key}`);\n    }\n    if (req.accessList) {\n        result.accessList = (0,_transaction_index_js__WEBPACK_IMPORTED_MODULE_3__.accessListify)(req.accessList);\n    }\n    if (req.authorizationList) {\n        result.authorizationList = req.authorizationList.slice();\n    }\n    if (\"blockTag\" in req) {\n        result.blockTag = req.blockTag;\n    }\n    if (\"enableCcipRead\" in req) {\n        result.enableCcipRead = !!req.enableCcipRead;\n    }\n    if (\"customData\" in req) {\n        result.customData = req.customData;\n    }\n    if (\"blobVersionedHashes\" in req && req.blobVersionedHashes) {\n        result.blobVersionedHashes = req.blobVersionedHashes.slice();\n    }\n    if (\"kzg\" in req) {\n        result.kzg = req.kzg;\n    }\n    if (\"blobs\" in req && req.blobs) {\n        result.blobs = req.blobs.map((b)=>{\n            if ((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.isBytesLike)(b)) {\n                return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.hexlify)(b);\n            }\n            return Object.assign({}, b);\n        });\n    }\n    return result;\n}\n/**\n *  A **Block** represents the data associated with a full block on\n *  Ethereum.\n */ class Block {\n    #transactions;\n    /**\n     *  Create a new **Block** object.\n     *\n     *  This should generally not be necessary as the unless implementing a\n     *  low-level library.\n     */ constructor(block, provider){\n        this.#transactions = block.transactions.map((tx)=>{\n            if (typeof tx !== \"string\") {\n                return new TransactionResponse(tx, provider);\n            }\n            return tx;\n        });\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.defineProperties)(this, {\n            provider,\n            hash: getValue(block.hash),\n            number: block.number,\n            timestamp: block.timestamp,\n            parentHash: block.parentHash,\n            parentBeaconBlockRoot: block.parentBeaconBlockRoot,\n            nonce: block.nonce,\n            difficulty: block.difficulty,\n            gasLimit: block.gasLimit,\n            gasUsed: block.gasUsed,\n            blobGasUsed: block.blobGasUsed,\n            excessBlobGas: block.excessBlobGas,\n            miner: block.miner,\n            prevRandao: getValue(block.prevRandao),\n            extraData: block.extraData,\n            baseFeePerGas: getValue(block.baseFeePerGas),\n            stateRoot: block.stateRoot,\n            receiptsRoot: block.receiptsRoot\n        });\n    }\n    /**\n     *  Returns the list of transaction hashes, in the order\n     *  they were executed within the block.\n     */ get transactions() {\n        return this.#transactions.map((tx)=>{\n            if (typeof tx === \"string\") {\n                return tx;\n            }\n            return tx.hash;\n        });\n    }\n    /**\n     *  Returns the complete transactions, in the order they\n     *  were executed within the block.\n     *\n     *  This is only available for blocks which prefetched\n     *  transactions, by passing ``true`` to %%prefetchTxs%%\n     *  into [[Provider-getBlock]].\n     */ get prefetchedTransactions() {\n        const txs = this.#transactions.slice();\n        // Doesn't matter...\n        if (txs.length === 0) {\n            return [];\n        }\n        // Make sure we prefetched the transactions\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_4__.assert)(typeof txs[0] === \"object\", \"transactions were not prefetched with block request\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"transactionResponses()\"\n        });\n        return txs;\n    }\n    /**\n     *  Returns a JSON-friendly value.\n     */ toJSON() {\n        const { baseFeePerGas, difficulty, extraData, gasLimit, gasUsed, hash, miner, prevRandao, nonce, number, parentHash, parentBeaconBlockRoot, stateRoot, receiptsRoot, timestamp, transactions } = this;\n        return {\n            _type: \"Block\",\n            baseFeePerGas: toJson(baseFeePerGas),\n            difficulty: toJson(difficulty),\n            extraData,\n            gasLimit: toJson(gasLimit),\n            gasUsed: toJson(gasUsed),\n            blobGasUsed: toJson(this.blobGasUsed),\n            excessBlobGas: toJson(this.excessBlobGas),\n            hash,\n            miner,\n            prevRandao,\n            nonce,\n            number,\n            parentHash,\n            timestamp,\n            parentBeaconBlockRoot,\n            stateRoot,\n            receiptsRoot,\n            transactions\n        };\n    }\n    [Symbol.iterator]() {\n        let index = 0;\n        const txs = this.transactions;\n        return {\n            next: ()=>{\n                if (index < this.length) {\n                    return {\n                        value: txs[index++],\n                        done: false\n                    };\n                }\n                return {\n                    value: undefined,\n                    done: true\n                };\n            }\n        };\n    }\n    /**\n     *  The number of transactions in this block.\n     */ get length() {\n        return this.#transactions.length;\n    }\n    /**\n     *  The [[link-js-date]] this block was included at.\n     */ get date() {\n        if (this.timestamp == null) {\n            return null;\n        }\n        return new Date(this.timestamp * 1000);\n    }\n    /**\n     *  Get the transaction at %%indexe%% within this block.\n     */ async getTransaction(indexOrHash) {\n        // Find the internal value by its index or hash\n        let tx = undefined;\n        if (typeof indexOrHash === \"number\") {\n            tx = this.#transactions[indexOrHash];\n        } else {\n            const hash = indexOrHash.toLowerCase();\n            for (const v of this.#transactions){\n                if (typeof v === \"string\") {\n                    if (v !== hash) {\n                        continue;\n                    }\n                    tx = v;\n                    break;\n                } else {\n                    if (v.hash !== hash) {\n                        continue;\n                    }\n                    tx = v;\n                    break;\n                }\n            }\n        }\n        if (tx == null) {\n            throw new Error(\"no such tx\");\n        }\n        if (typeof tx === \"string\") {\n            return await this.provider.getTransaction(tx);\n        } else {\n            return tx;\n        }\n    }\n    /**\n     *  If a **Block** was fetched with a request to include the transactions\n     *  this will allow synchronous access to those transactions.\n     *\n     *  If the transactions were not prefetched, this will throw.\n     */ getPrefetchedTransaction(indexOrHash) {\n        const txs = this.prefetchedTransactions;\n        if (typeof indexOrHash === \"number\") {\n            return txs[indexOrHash];\n        }\n        indexOrHash = indexOrHash.toLowerCase();\n        for (const tx of txs){\n            if (tx.hash === indexOrHash) {\n                return tx;\n            }\n        }\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_4__.assertArgument)(false, \"no matching transaction\", \"indexOrHash\", indexOrHash);\n    }\n    /**\n     *  Returns true if this block been mined. This provides a type guard\n     *  for all properties on a [[MinedBlock]].\n     */ isMined() {\n        return !!this.hash;\n    }\n    /**\n     *  Returns true if this block is an [[link-eip-2930]] block.\n     */ isLondon() {\n        return !!this.baseFeePerGas;\n    }\n    /**\n     *  @_ignore:\n     */ orphanedEvent() {\n        if (!this.isMined()) {\n            throw new Error(\"\");\n        }\n        return createOrphanedBlockFilter(this);\n    }\n}\n//////////////////////\n// Log\n/**\n *  A **Log** in Ethereum represents an event that has been included in a\n *  transaction using the ``LOG*`` opcodes, which are most commonly used by\n *  Solidity's emit for announcing events.\n */ class Log {\n    /**\n     *  @_ignore:\n     */ constructor(log, provider){\n        this.provider = provider;\n        const topics = Object.freeze(log.topics.slice());\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.defineProperties)(this, {\n            transactionHash: log.transactionHash,\n            blockHash: log.blockHash,\n            blockNumber: log.blockNumber,\n            removed: log.removed,\n            address: log.address,\n            data: log.data,\n            topics,\n            index: log.index,\n            transactionIndex: log.transactionIndex\n        });\n    }\n    /**\n     *  Returns a JSON-compatible object.\n     */ toJSON() {\n        const { address, blockHash, blockNumber, data, index, removed, topics, transactionHash, transactionIndex } = this;\n        return {\n            _type: \"log\",\n            address,\n            blockHash,\n            blockNumber,\n            data,\n            index,\n            removed,\n            topics,\n            transactionHash,\n            transactionIndex\n        };\n    }\n    /**\n     *  Returns the block that this log occurred in.\n     */ async getBlock() {\n        const block = await this.provider.getBlock(this.blockHash);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_4__.assert)(!!block, \"failed to find transaction\", \"UNKNOWN_ERROR\", {});\n        return block;\n    }\n    /**\n     *  Returns the transaction that this log occurred in.\n     */ async getTransaction() {\n        const tx = await this.provider.getTransaction(this.transactionHash);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_4__.assert)(!!tx, \"failed to find transaction\", \"UNKNOWN_ERROR\", {});\n        return tx;\n    }\n    /**\n     *  Returns the transaction receipt fot the transaction that this\n     *  log occurred in.\n     */ async getTransactionReceipt() {\n        const receipt = await this.provider.getTransactionReceipt(this.transactionHash);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_4__.assert)(!!receipt, \"failed to find transaction receipt\", \"UNKNOWN_ERROR\", {});\n        return receipt;\n    }\n    /**\n     *  @_ignore:\n     */ removedEvent() {\n        return createRemovedLogFilter(this);\n    }\n}\n//////////////////////\n// Transaction Receipt\n/*\nexport interface LegacyTransactionReceipt {\n    byzantium: false;\n    status: null;\n    root: string;\n}\n\nexport interface ByzantiumTransactionReceipt {\n    byzantium: true;\n    status: number;\n    root: null;\n}\n*/ /**\n *  A **TransactionReceipt** includes additional information about a\n *  transaction that is only available after it has been mined.\n */ class TransactionReceipt {\n    #logs;\n    /**\n     *  @_ignore:\n     */ constructor(tx, provider){\n        this.#logs = Object.freeze(tx.logs.map((log)=>{\n            return new Log(log, provider);\n        }));\n        let gasPrice = BN_0;\n        if (tx.effectiveGasPrice != null) {\n            gasPrice = tx.effectiveGasPrice;\n        } else if (tx.gasPrice != null) {\n            gasPrice = tx.gasPrice;\n        }\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.defineProperties)(this, {\n            provider,\n            to: tx.to,\n            from: tx.from,\n            contractAddress: tx.contractAddress,\n            hash: tx.hash,\n            index: tx.index,\n            blockHash: tx.blockHash,\n            blockNumber: tx.blockNumber,\n            logsBloom: tx.logsBloom,\n            gasUsed: tx.gasUsed,\n            cumulativeGasUsed: tx.cumulativeGasUsed,\n            blobGasUsed: tx.blobGasUsed,\n            gasPrice,\n            blobGasPrice: tx.blobGasPrice,\n            type: tx.type,\n            //byzantium: tx.byzantium,\n            status: tx.status,\n            root: tx.root\n        });\n    }\n    /**\n     *  The logs for this transaction.\n     */ get logs() {\n        return this.#logs;\n    }\n    /**\n     *  Returns a JSON-compatible representation.\n     */ toJSON() {\n        const { to, from, contractAddress, hash, index, blockHash, blockNumber, logsBloom, logs, status, root } = this;\n        return {\n            _type: \"TransactionReceipt\",\n            blockHash,\n            blockNumber,\n            //byzantium, \n            contractAddress,\n            cumulativeGasUsed: toJson(this.cumulativeGasUsed),\n            from,\n            gasPrice: toJson(this.gasPrice),\n            blobGasUsed: toJson(this.blobGasUsed),\n            blobGasPrice: toJson(this.blobGasPrice),\n            gasUsed: toJson(this.gasUsed),\n            hash,\n            index,\n            logs,\n            logsBloom,\n            root,\n            status,\n            to\n        };\n    }\n    /**\n     *  @_ignore:\n     */ get length() {\n        return this.logs.length;\n    }\n    [Symbol.iterator]() {\n        let index = 0;\n        return {\n            next: ()=>{\n                if (index < this.length) {\n                    return {\n                        value: this.logs[index++],\n                        done: false\n                    };\n                }\n                return {\n                    value: undefined,\n                    done: true\n                };\n            }\n        };\n    }\n    /**\n     *  The total fee for this transaction, in wei.\n     */ get fee() {\n        return this.gasUsed * this.gasPrice;\n    }\n    /**\n     *  Resolves to the block this transaction occurred in.\n     */ async getBlock() {\n        const block = await this.provider.getBlock(this.blockHash);\n        if (block == null) {\n            throw new Error(\"TODO\");\n        }\n        return block;\n    }\n    /**\n     *  Resolves to the transaction this transaction occurred in.\n     */ async getTransaction() {\n        const tx = await this.provider.getTransaction(this.hash);\n        if (tx == null) {\n            throw new Error(\"TODO\");\n        }\n        return tx;\n    }\n    /**\n     *  Resolves to the return value of the execution of this transaction.\n     *\n     *  Support for this feature is limited, as it requires an archive node\n     *  with the ``debug_`` or ``trace_`` API enabled.\n     */ async getResult() {\n        return await this.provider.getTransactionResult(this.hash);\n    }\n    /**\n     *  Resolves to the number of confirmations this transaction has.\n     */ async confirmations() {\n        return await this.provider.getBlockNumber() - this.blockNumber + 1;\n    }\n    /**\n     *  @_ignore:\n     */ removedEvent() {\n        return createRemovedTransactionFilter(this);\n    }\n    /**\n     *  @_ignore:\n     */ reorderedEvent(other) {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_4__.assert)(!other || other.isMined(), \"unmined 'other' transction cannot be orphaned\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"reorderedEvent(other)\"\n        });\n        return createReorderedTransactionFilter(this, other);\n    }\n}\n/**\n *  A **TransactionResponse** includes all properties about a transaction\n *  that was sent to the network, which may or may not be included in a\n *  block.\n *\n *  The [[TransactionResponse-isMined]] can be used to check if the\n *  transaction has been mined as well as type guard that the otherwise\n *  possibly ``null`` properties are defined.\n */ class TransactionResponse {\n    #startBlock;\n    /**\n     *  @_ignore:\n     */ constructor(tx, provider){\n        this.provider = provider;\n        this.blockNumber = tx.blockNumber != null ? tx.blockNumber : null;\n        this.blockHash = tx.blockHash != null ? tx.blockHash : null;\n        this.hash = tx.hash;\n        this.index = tx.index;\n        this.type = tx.type;\n        this.from = tx.from;\n        this.to = tx.to || null;\n        this.gasLimit = tx.gasLimit;\n        this.nonce = tx.nonce;\n        this.data = tx.data;\n        this.value = tx.value;\n        this.gasPrice = tx.gasPrice;\n        this.maxPriorityFeePerGas = tx.maxPriorityFeePerGas != null ? tx.maxPriorityFeePerGas : null;\n        this.maxFeePerGas = tx.maxFeePerGas != null ? tx.maxFeePerGas : null;\n        this.maxFeePerBlobGas = tx.maxFeePerBlobGas != null ? tx.maxFeePerBlobGas : null;\n        this.chainId = tx.chainId;\n        this.signature = tx.signature;\n        this.accessList = tx.accessList != null ? tx.accessList : null;\n        this.blobVersionedHashes = tx.blobVersionedHashes != null ? tx.blobVersionedHashes : null;\n        this.authorizationList = tx.authorizationList != null ? tx.authorizationList : null;\n        this.#startBlock = -1;\n    }\n    /**\n     *  Returns a JSON-compatible representation of this transaction.\n     */ toJSON() {\n        const { blockNumber, blockHash, index, hash, type, to, from, nonce, data, signature, accessList, blobVersionedHashes } = this;\n        return {\n            _type: \"TransactionResponse\",\n            accessList,\n            blockNumber,\n            blockHash,\n            blobVersionedHashes,\n            chainId: toJson(this.chainId),\n            data,\n            from,\n            gasLimit: toJson(this.gasLimit),\n            gasPrice: toJson(this.gasPrice),\n            hash,\n            maxFeePerGas: toJson(this.maxFeePerGas),\n            maxPriorityFeePerGas: toJson(this.maxPriorityFeePerGas),\n            maxFeePerBlobGas: toJson(this.maxFeePerBlobGas),\n            nonce,\n            signature,\n            to,\n            index,\n            type,\n            value: toJson(this.value)\n        };\n    }\n    /**\n     *  Resolves to the Block that this transaction was included in.\n     *\n     *  This will return null if the transaction has not been included yet.\n     */ async getBlock() {\n        let blockNumber = this.blockNumber;\n        if (blockNumber == null) {\n            const tx = await this.getTransaction();\n            if (tx) {\n                blockNumber = tx.blockNumber;\n            }\n        }\n        if (blockNumber == null) {\n            return null;\n        }\n        const block = this.provider.getBlock(blockNumber);\n        if (block == null) {\n            throw new Error(\"TODO\");\n        }\n        return block;\n    }\n    /**\n     *  Resolves to this transaction being re-requested from the\n     *  provider. This can be used if you have an unmined transaction\n     *  and wish to get an up-to-date populated instance.\n     */ async getTransaction() {\n        return this.provider.getTransaction(this.hash);\n    }\n    /**\n     *  Resolve to the number of confirmations this transaction has.\n     */ async confirmations() {\n        if (this.blockNumber == null) {\n            const { tx, blockNumber } = await (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.resolveProperties)({\n                tx: this.getTransaction(),\n                blockNumber: this.provider.getBlockNumber()\n            });\n            // Not mined yet...\n            if (tx == null || tx.blockNumber == null) {\n                return 0;\n            }\n            return blockNumber - tx.blockNumber + 1;\n        }\n        const blockNumber = await this.provider.getBlockNumber();\n        return blockNumber - this.blockNumber + 1;\n    }\n    /**\n     *  Resolves once this transaction has been mined and has\n     *  %%confirms%% blocks including it (default: ``1``) with an\n     *  optional %%timeout%%.\n     *\n     *  This can resolve to ``null`` only if %%confirms%% is ``0``\n     *  and the transaction has not been mined, otherwise this will\n     *  wait until enough confirmations have completed.\n     */ async wait(_confirms, _timeout) {\n        const confirms = _confirms == null ? 1 : _confirms;\n        const timeout = _timeout == null ? 0 : _timeout;\n        let startBlock = this.#startBlock;\n        let nextScan = -1;\n        let stopScanning = startBlock === -1 ? true : false;\n        const checkReplacement = async ()=>{\n            // Get the current transaction count for this sender\n            if (stopScanning) {\n                return null;\n            }\n            const { blockNumber, nonce } = await (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.resolveProperties)({\n                blockNumber: this.provider.getBlockNumber(),\n                nonce: this.provider.getTransactionCount(this.from)\n            });\n            // No transaction or our nonce has not been mined yet; but we\n            // can start scanning later when we do start\n            if (nonce < this.nonce) {\n                startBlock = blockNumber;\n                return;\n            }\n            // We were mined; no replacement\n            if (stopScanning) {\n                return null;\n            }\n            const mined = await this.getTransaction();\n            if (mined && mined.blockNumber != null) {\n                return;\n            }\n            // We were replaced; start scanning for that transaction\n            // Starting to scan; look back a few extra blocks for safety\n            if (nextScan === -1) {\n                nextScan = startBlock - 3;\n                if (nextScan < this.#startBlock) {\n                    nextScan = this.#startBlock;\n                }\n            }\n            while(nextScan <= blockNumber){\n                // Get the next block to scan\n                if (stopScanning) {\n                    return null;\n                }\n                const block = await this.provider.getBlock(nextScan, true);\n                // This should not happen; but we'll try again shortly\n                if (block == null) {\n                    return;\n                }\n                // We were mined; no replacement\n                for (const hash of block){\n                    if (hash === this.hash) {\n                        return;\n                    }\n                }\n                // Search for the transaction that replaced us\n                for(let i = 0; i < block.length; i++){\n                    const tx = await block.getTransaction(i);\n                    if (tx.from === this.from && tx.nonce === this.nonce) {\n                        // Get the receipt\n                        if (stopScanning) {\n                            return null;\n                        }\n                        const receipt = await this.provider.getTransactionReceipt(tx.hash);\n                        // This should not happen; but we'll try again shortly\n                        if (receipt == null) {\n                            return;\n                        }\n                        // We will retry this on the next block (this case could be optimized)\n                        if (blockNumber - receipt.blockNumber + 1 < confirms) {\n                            return;\n                        }\n                        // The reason we were replaced\n                        let reason = \"replaced\";\n                        if (tx.data === this.data && tx.to === this.to && tx.value === this.value) {\n                            reason = \"repriced\";\n                        } else if (tx.data === \"0x\" && tx.from === tx.to && tx.value === BN_0) {\n                            reason = \"cancelled\";\n                        }\n                        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_4__.assert)(false, \"transaction was replaced\", \"TRANSACTION_REPLACED\", {\n                            cancelled: reason === \"replaced\" || reason === \"cancelled\",\n                            reason,\n                            replacement: tx.replaceableTransaction(startBlock),\n                            hash: tx.hash,\n                            receipt\n                        });\n                    }\n                }\n                nextScan++;\n            }\n            return;\n        };\n        const checkReceipt = (receipt)=>{\n            if (receipt == null || receipt.status !== 0) {\n                return receipt;\n            }\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_4__.assert)(false, \"transaction execution reverted\", \"CALL_EXCEPTION\", {\n                action: \"sendTransaction\",\n                data: null,\n                reason: null,\n                invocation: null,\n                revert: null,\n                transaction: {\n                    to: receipt.to,\n                    from: receipt.from,\n                    data: \"\" // @TODO: in v7, split out sendTransaction properties\n                },\n                receipt\n            });\n        };\n        const receipt = await this.provider.getTransactionReceipt(this.hash);\n        if (confirms === 0) {\n            return checkReceipt(receipt);\n        }\n        if (receipt) {\n            if (confirms === 1 || await receipt.confirmations() >= confirms) {\n                return checkReceipt(receipt);\n            }\n        } else {\n            // Check for a replacement; throws if a replacement was found\n            await checkReplacement();\n            // Allow null only when the confirms is 0\n            if (confirms === 0) {\n                return null;\n            }\n        }\n        const waiter = new Promise((resolve, reject)=>{\n            // List of things to cancel when we have a result (one way or the other)\n            const cancellers = [];\n            const cancel = ()=>{\n                cancellers.forEach((c)=>c());\n            };\n            // On cancel, stop scanning for replacements\n            cancellers.push(()=>{\n                stopScanning = true;\n            });\n            // Set up any timeout requested\n            if (timeout > 0) {\n                const timer = setTimeout(()=>{\n                    cancel();\n                    reject((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_4__.makeError)(\"wait for transaction timeout\", \"TIMEOUT\"));\n                }, timeout);\n                cancellers.push(()=>{\n                    clearTimeout(timer);\n                });\n            }\n            const txListener = async (receipt)=>{\n                // Done; return it!\n                if (await receipt.confirmations() >= confirms) {\n                    cancel();\n                    try {\n                        resolve(checkReceipt(receipt));\n                    } catch (error) {\n                        reject(error);\n                    }\n                }\n            };\n            cancellers.push(()=>{\n                this.provider.off(this.hash, txListener);\n            });\n            this.provider.on(this.hash, txListener);\n            // We support replacement detection; start checking\n            if (startBlock >= 0) {\n                const replaceListener = async ()=>{\n                    try {\n                        // Check for a replacement; this throws only if one is found\n                        await checkReplacement();\n                    } catch (error) {\n                        // We were replaced (with enough confirms); re-throw the error\n                        if ((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_4__.isError)(error, \"TRANSACTION_REPLACED\")) {\n                            cancel();\n                            reject(error);\n                            return;\n                        }\n                    }\n                    // Rescheudle a check on the next block\n                    if (!stopScanning) {\n                        this.provider.once(\"block\", replaceListener);\n                    }\n                };\n                cancellers.push(()=>{\n                    this.provider.off(\"block\", replaceListener);\n                });\n                this.provider.once(\"block\", replaceListener);\n            }\n        });\n        return await waiter;\n    }\n    /**\n     *  Returns ``true`` if this transaction has been included.\n     *\n     *  This is effective only as of the time the TransactionResponse\n     *  was instantiated. To get up-to-date information, use\n     *  [[getTransaction]].\n     *\n     *  This provides a Type Guard that this transaction will have\n     *  non-null property values for properties that are null for\n     *  unmined transactions.\n     */ isMined() {\n        return this.blockHash != null;\n    }\n    /**\n     *  Returns true if the transaction is a legacy (i.e. ``type == 0``)\n     *  transaction.\n     *\n     *  This provides a Type Guard that this transaction will have\n     *  the ``null``-ness for hardfork-specific properties set correctly.\n     */ isLegacy() {\n        return this.type === 0;\n    }\n    /**\n     *  Returns true if the transaction is a Berlin (i.e. ``type == 1``)\n     *  transaction. See [[link-eip-2070]].\n     *\n     *  This provides a Type Guard that this transaction will have\n     *  the ``null``-ness for hardfork-specific properties set correctly.\n     */ isBerlin() {\n        return this.type === 1;\n    }\n    /**\n     *  Returns true if the transaction is a London (i.e. ``type == 2``)\n     *  transaction. See [[link-eip-1559]].\n     *\n     *  This provides a Type Guard that this transaction will have\n     *  the ``null``-ness for hardfork-specific properties set correctly.\n     */ isLondon() {\n        return this.type === 2;\n    }\n    /**\n     *  Returns true if hte transaction is a Cancun (i.e. ``type == 3``)\n     *  transaction. See [[link-eip-4844]].\n     */ isCancun() {\n        return this.type === 3;\n    }\n    /**\n     *  Returns a filter which can be used to listen for orphan events\n     *  that evict this transaction.\n     */ removedEvent() {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_4__.assert)(this.isMined(), \"unmined transaction canot be orphaned\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"removeEvent()\"\n        });\n        return createRemovedTransactionFilter(this);\n    }\n    /**\n     *  Returns a filter which can be used to listen for orphan events\n     *  that re-order this event against %%other%%.\n     */ reorderedEvent(other) {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_4__.assert)(this.isMined(), \"unmined transaction canot be orphaned\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"removeEvent()\"\n        });\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_4__.assert)(!other || other.isMined(), \"unmined 'other' transaction canot be orphaned\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"removeEvent()\"\n        });\n        return createReorderedTransactionFilter(this, other);\n    }\n    /**\n     *  Returns a new TransactionResponse instance which has the ability to\n     *  detect (and throw an error) if the transaction is replaced, which\n     *  will begin scanning at %%startBlock%%.\n     *\n     *  This should generally not be used by developers and is intended\n     *  primarily for internal use. Setting an incorrect %%startBlock%% can\n     *  have devastating performance consequences if used incorrectly.\n     */ replaceableTransaction(startBlock) {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_4__.assertArgument)(Number.isInteger(startBlock) && startBlock >= 0, \"invalid startBlock\", \"startBlock\", startBlock);\n        const tx = new TransactionResponse(this, this.provider);\n        tx.#startBlock = startBlock;\n        return tx;\n    }\n}\nfunction createOrphanedBlockFilter(block) {\n    return {\n        orphan: \"drop-block\",\n        hash: block.hash,\n        number: block.number\n    };\n}\nfunction createReorderedTransactionFilter(tx, other) {\n    return {\n        orphan: \"reorder-transaction\",\n        tx,\n        other\n    };\n}\nfunction createRemovedTransactionFilter(tx) {\n    return {\n        orphan: \"drop-transaction\",\n        tx\n    };\n}\nfunction createRemovedLogFilter(log) {\n    return {\n        orphan: \"drop-log\",\n        log: {\n            transactionHash: log.transactionHash,\n            blockHash: log.blockHash,\n            blockNumber: log.blockNumber,\n            address: log.address,\n            data: log.data,\n            topics: Object.freeze(log.topics.slice()),\n            index: log.index\n        }\n    };\n} //# sourceMappingURL=provider.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vcHJvdmlkZXJzL3Byb3ZpZGVyLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0FBQUEsMERBQTBEO0FBQ3NHO0FBQ3hHO0FBQ3hELE1BQU1XLE9BQU9DLE9BQU87QUFDcEIsMEJBQTBCO0FBQzFCLFNBQVNDLFNBQVNDLEtBQUs7SUFDbkIsSUFBSUEsU0FBUyxNQUFNO1FBQ2YsT0FBTztJQUNYO0lBQ0EsT0FBT0E7QUFDWDtBQUNBLFNBQVNDLE9BQU9ELEtBQUs7SUFDakIsSUFBSUEsU0FBUyxNQUFNO1FBQ2YsT0FBTztJQUNYO0lBQ0EsT0FBT0EsTUFBTUUsUUFBUTtBQUN6QjtBQUNBLDBEQUEwRDtBQUMxRDs7O0NBR0MsR0FDTSxNQUFNQztJQTRCVDs7O0tBR0MsR0FDREMsWUFBWUMsUUFBUSxFQUFFQyxZQUFZLEVBQUVDLG9CQUFvQixDQUFFO1FBQ3REckIsaUVBQWdCQSxDQUFDLElBQUksRUFBRTtZQUNuQm1CLFVBQVVOLFNBQVNNO1lBQ25CQyxjQUFjUCxTQUFTTztZQUN2QkMsc0JBQXNCUixTQUFTUTtRQUNuQztJQUNKO0lBQ0E7O0tBRUMsR0FDREMsU0FBUztRQUNMLE1BQU0sRUFBRUgsUUFBUSxFQUFFQyxZQUFZLEVBQUVDLG9CQUFvQixFQUFFLEdBQUcsSUFBSTtRQUM3RCxPQUFPO1lBQ0hFLE9BQU87WUFDUEosVUFBVUosT0FBT0k7WUFDakJDLGNBQWNMLE9BQU9LO1lBQ3JCQyxzQkFBc0JOLE9BQU9NO1FBQ2pDO0lBQ0o7QUFDSjs7QUFFQTs7O0NBR0MsR0FDTSxTQUFTRyxZQUFZQyxHQUFHO0lBQzNCLE1BQU1DLFNBQVMsQ0FBQztJQUNoQixzREFBc0Q7SUFDdEQsSUFBSUQsSUFBSUUsRUFBRSxFQUFFO1FBQ1JELE9BQU9DLEVBQUUsR0FBR0YsSUFBSUUsRUFBRTtJQUN0QjtJQUNBLElBQUlGLElBQUlHLElBQUksRUFBRTtRQUNWRixPQUFPRSxJQUFJLEdBQUdILElBQUlHLElB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QzVCRSxTQUFTUCxJQUFJTyxPQUFPO1lBQ3BCdkUsTUFBTWdFLElBQUloRSxJQUFJO1lBQ2RpRSxRQUFRakQsT0FBT2tELE1BQU0sQ0FBQ0YsSUFBSUMsTUFBTSxDQUFDMUQsS0FBSztZQUN0Q3dDLE9BQU9pQixJQUFJakIsS0FBSztRQUNwQjtJQUFFO0FBQ1YsRUFDQSxvQ0FBb0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tZWdhdmliZS1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9wcm92aWRlcnMvcHJvdmlkZXIuanM/NjhhNSJdLCJzb3VyY2VzQ29udGVudCI6WyIvL2ltcG9ydCB7IHJlc29sdmVBZGRyZXNzIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2FkZHJlc3NcIjtcbmltcG9ydCB7IGRlZmluZVByb3BlcnRpZXMsIGdldEJpZ0ludCwgZ2V0TnVtYmVyLCBoZXhsaWZ5LCBpc0J5dGVzTGlrZSwgcmVzb2x2ZVByb3BlcnRpZXMsIGFzc2VydCwgYXNzZXJ0QXJndW1lbnQsIGlzRXJyb3IsIG1ha2VFcnJvciB9IGZyb20gXCIuLi91dGlscy9pbmRleC5qc1wiO1xuaW1wb3J0IHsgYWNjZXNzTGlzdGlmeSB9IGZyb20gXCIuLi90cmFuc2FjdGlvbi9pbmRleC5qc1wiO1xuY29uc3QgQk5fMCA9IEJpZ0ludCgwKTtcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5mdW5jdGlvbiBnZXRWYWx1ZSh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG59XG5mdW5jdGlvbiB0b0pzb24odmFsdWUpIHtcbiAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlLnRvU3RyaW5nKCk7XG59XG4vLyBAVE9ETz8gPFQgZXh0ZW5kcyBGZWVEYXRhID0geyB9PiBpbXBsZW1lbnRzIFJlcXVpcmVkPFQ+XG4vKipcbiAqICBBICoqRmVlRGF0YSoqIHdyYXBzIGFsbCB0aGUgZmVlLXJlbGF0ZWQgdmFsdWVzIGFzc29jaWF0ZWQgd2l0aFxuICogIHRoZSBuZXR3b3JrLlxuICovXG5leHBvcnQgY2xhc3MgRmVlRGF0YSB7XG4gICAgLyoqXG4gICAgICogIFRoZSBnYXMgcHJpY2UgZm9yIGxlZ2FjeSBuZXR3b3Jrcy5cbiAgICAgKi9cbiAgICBnYXNQcmljZTtcbiAgICAvKipcbiAgICAgKiAgVGhlIG1heGltdW0gZmVlIHRvIHBheSBwZXIgZ2FzLlxuICAgICAqXG4gICAgICogIFRoZSBiYXNlIGZlZSBwZXIgZ2FzIGlzIGRlZmluZWQgYnkgdGhlIG5ldHdvcmsgYW5kIGJhc2VkIG9uXG4gICAgICogIGNvbmdlc3Rpb24sIGluY3JlYXNpbmcgdGhlIGNvc3QgZHVyaW5nIHRpbWVzIG9mIGhlYXZ5IGxvYWRcbiAgICAgKiAgYW5kIGxvd2VyaW5nIHdoZW4gbGVzcyBidXN5LlxuICAgICAqXG4gICAgICogIFRoZSBhY3R1YWwgZmVlIHBlciBnYXMgd2lsbCBiZSB0aGUgYmFzZSBmZWUgZm9yIHRoZSBibG9ja1xuICAgICAqICBhbmQgdGhlIHByaW9yaXR5IGZlZSwgdXAgdG8gdGhlIG1heCBmZWUgcGVyIGdhcy5cbiAgICAgKlxuICAgICAqICBUaGlzIHdpbGwgYmUgYGBudWxsYGAgb24gbGVnYWN5IG5ldHdvcmtzIChpLmUuIFtwcmUtRUlQLTE1NTldKGxpbmstZWlwLTE1NTkpKVxuICAgICAqL1xuICAgIG1heEZlZVBlckdhcztcbiAgICAvKipcbiAgICAgKiAgVGhlIGFkZGl0aW9uYWwgYW1vdXQgdG8gcGF5IHBlciBnYXMgdG8gZW5jb3VyYWdlIGEgdmFsaWRhdG9yXG4gICAgICogIHRvIGluY2x1ZGUgdGhlIHRyYW5zYWN0aW9uLlxuICAgICAqXG4gICAgICogIFRoZSBwdXJwb3NlIG9mIHRoaXMgaXMgdG8gY29tcGVuc2F0ZSB0aGUgdmFsaWRhdG9yIGZvciB0aGVcbiAgICAgKiAgYWRqdXN0ZWQgcmlzayBmb3IgaW5jbHVkaW5nIGEgZ2l2ZW4gdHJhbnNhY3Rpb24uXG4gICAgICpcbiAgICAgKiAgVGhpcyB3aWxsIGJlIGBgbnVsbGBgIG9uIGxlZ2FjeSBuZXR3b3JrcyAoaS5lLiBbcHJlLUVJUC0xNTU5XShsaW5rLWVpcC0xNTU5KSlcbiAgICAgKi9cbiAgICBtYXhQcmlvcml0eUZlZVBlckdhcztcbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlcyBhIG5ldyBGZWVEYXRhIGZvciAlJWdhc1ByaWNlJSUsICUlbWF4RmVlUGVyR2FzJSUgYW5kXG4gICAgICogICUlbWF4UHJpb3JpdHlGZWVQZXJHYXMlJS5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihnYXNQcmljZSwgbWF4RmVlUGVyR2FzLCBtYXhQcmlvcml0eUZlZVBlckdhcykge1xuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHtcbiAgICAgICAgICAgIGdhc1ByaWNlOiBnZXRWYWx1ZShnYXNQcmljZSksXG4gICAgICAgICAgICBtYXhGZWVQZXJHYXM6IGdldFZhbHVlKG1heEZlZVBlckdhcyksXG4gICAgICAgICAgICBtYXhQcmlvcml0eUZlZVBlckdhczogZ2V0VmFsdWUobWF4UHJpb3JpdHlGZWVQZXJHYXMpXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBhIEpTT04tZnJpZW5kbHkgdmFsdWUuXG4gICAgICovXG4gICAgdG9KU09OKCkge1xuICAgICAgICBjb25zdCB7IGdhc1ByaWNlLCBtYXhGZWVQZXJHYXMsIG1heFByaW9yaXR5RmVlUGVyR2FzIH0gPSB0aGlzO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgX3R5cGU6IFwiRmVlRGF0YVwiLFxuICAgICAgICAgICAgZ2FzUHJpY2U6IHRvSnNvbihnYXNQcmljZSksXG4gICAgICAgICAgICBtYXhGZWVQZXJHYXM6IHRvSnNvbihtYXhGZWVQZXJHYXMpLFxuICAgICAgICAgICAgbWF4UHJpb3JpdHlGZWVQZXJHYXM6IHRvSnNvbihtYXhQcmlvcml0eUZlZVBlckdhcyksXG4gICAgICAgIH07XG4gICAgfVxufVxuO1xuLyoqXG4gKiAgUmV0dXJucyBhIGNvcHkgb2YgJSVyZXElJSB3aXRoIGFsbCBwcm9wZXJ0aWVzIGNvZXJjZWQgdG8gdGhlaXIgc3RyaWN0XG4gKiAgdHlwZXMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb3B5UmVxdWVzdChyZXEpIHtcbiAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICAvLyBUaGVzZSBjb3VsZCBiZSBhZGRyZXNzZXMsIEVOUyBuYW1lcyBvciBBZGRyZXNzYWJsZXNcbiAgICBpZiAocmVxLnRvKSB7XG4gICAgICAgIHJlc3VsdC50byA9IHJlcS50bztcbiAgICB9XG4gICAgaWYgKHJlcS5mcm9tKSB7XG4gICAgICAgIHJlc3VsdC5mcm9tID0gcmVxLmZyb207XG4gICAgfVxuICAgIGlmIChyZXEuZGF0YSkge1xuICAgICAgICByZXN1bHQuZGF0YSA9IGhleGxpZnkocmVxLmRhdGEpO1xuICAgIH1cbiAgICBjb25zdCBiaWdJbnRLZXlzID0gXCJjaGFpbklkLGdhc0xpbWl0LGdhc1ByaWNlLG1heEZlZVBlckJsb2JHYXMsbWF4RmVlUGVyR2FzLG1heFByaW9yaXR5RmVlUGVyR2FzLHZhbHVlXCIuc3BsaXQoLywvKTtcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBiaWdJbnRLZXlzKSB7XG4gICAgICAgIGlmICghKGtleSBpbiByZXEpIHx8IHJlcVtrZXldID09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdFtrZXldID0gZ2V0QmlnSW50KHJlcVtrZXldLCBgcmVxdWVzdC4ke2tleX1gKTtcbiAgICB9XG4gICAgY29uc3QgbnVtYmVyS2V5cyA9IFwidHlwZSxub25jZVwiLnNwbGl0KC8sLyk7XG4gICAgZm9yIChjb25zdCBrZXkgb2YgbnVtYmVyS2V5cykge1xuICAgICAgICBpZiAoIShrZXkgaW4gcmVxKSB8fCByZXFba2V5XSA9PSBudWxsKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHRba2V5XSA9IGdldE51bWJlcihyZXFba2V5XSwgYHJlcXVlc3QuJHtrZXl9YCk7XG4gICAgfVxuICAgIGlmIChyZXEuYWNjZXNzTGlzdCkge1xuICAgICAgICByZXN1bHQuYWNjZXNzTGlzdCA9IGFjY2Vzc0xpc3RpZnkocmVxLmFjY2Vzc0xpc3QpO1xuICAgIH1cbiAgICBpZiAocmVxLmF1dGhvcml6YXRpb25MaXN0KSB7XG4gICAgICAgIHJlc3VsdC5hdXRob3JpemF0aW9uTGlzdCA9IHJlcS5hdXRob3JpemF0aW9uTGlzdC5zbGljZSgpO1xuICAgIH1cbiAgICBpZiAoXCJibG9ja1RhZ1wiIGluIHJlcSkge1xuICAgICAgICByZXN1bHQuYmxvY2tUYWcgPSByZXEuYmxvY2tUYWc7XG4gICAgfVxuICAgIGlmIChcImVuYWJsZUNjaXBSZWFkXCIgaW4gcmVxKSB7XG4gICAgICAgIHJlc3VsdC5lbmFibGVDY2lwUmVhZCA9ICEhcmVxLmVuYWJsZUNjaXBSZWFkO1xuICAgIH1cbiAgICBpZiAoXCJjdXN0b21EYXRhXCIgaW4gcmVxKSB7XG4gICAgICAgIHJlc3VsdC5jdXN0b21EYXRhID0gcmVxLmN1c3RvbURhdGE7XG4gICAgfVxuICAgIGlmIChcImJsb2JWZXJzaW9uZWRIYXNoZXNcIiBpbiByZXEgJiYgcmVxLmJsb2JWZXJzaW9uZWRIYXNoZXMpIHtcbiAgICAgICAgcmVzdWx0LmJsb2JWZXJzaW9uZWRIYXNoZXMgPSByZXEuYmxvYlZlcnNpb25lZEhhc2hlcy5zbGljZSgpO1xuICAgIH1cbiAgICBpZiAoXCJremdcIiBpbiByZXEpIHtcbiAgICAgICAgcmVzdWx0Lmt6ZyA9IHJlcS5remc7XG4gICAgfVxuICAgIGlmIChcImJsb2JzXCIgaW4gcmVxICYmIHJlcS5ibG9icykge1xuICAgICAgICByZXN1bHQuYmxvYnMgPSByZXEuYmxvYnMubWFwKChiKSA9PiB7XG4gICAgICAgICAgICBpZiAoaXNCeXRlc0xpa2UoYikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaGV4bGlmeShiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBiKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG4vKipcbiAqICBBICoqQmxvY2sqKiByZXByZXNlbnRzIHRoZSBkYXRhIGFzc29jaWF0ZWQgd2l0aCBhIGZ1bGwgYmxvY2sgb25cbiAqICBFdGhlcmV1bS5cbiAqL1xuZXhwb3J0IGNsYXNzIEJsb2NrIHtcbiAgICAvKipcbiAgICAgKiAgVGhlIHByb3ZpZGVyIGNvbm5lY3RlZCB0byB0aGUgYmxvY2sgdXNlZCB0byBmZXRjaCBhZGRpdGlvbmFsIGRldGFpbHNcbiAgICAgKiAgaWYgbmVjZXNzYXJ5LlxuICAgICAqL1xuICAgIHByb3ZpZGVyO1xuICAgIC8qKlxuICAgICAqICBUaGUgYmxvY2sgbnVtYmVyLCBzb21ldGltZXMgY2FsbGVkIHRoZSBibG9jayBoZWlnaHQuIFRoaXMgaXMgYVxuICAgICAqICBzZXF1ZW50aWFsIG51bWJlciB0aGF0IGlzIG9uZSBoaWdoZXIgdGhhbiB0aGUgcGFyZW50IGJsb2NrLlxuICAgICAqL1xuICAgIG51bWJlcjtcbiAgICAvKipcbiAgICAgKiAgVGhlIGJsb2NrIGhhc2guXG4gICAgICpcbiAgICAgKiAgVGhpcyBoYXNoIGluY2x1ZGVzIGFsbCBwcm9wZXJ0aWVzLCBzbyBjYW4gYmUgc2FmZWx5IHVzZWQgdG8gaWRlbnRpZnlcbiAgICAgKiAgYW4gZXhhY3Qgc2V0IG9mIGJsb2NrIHByb3BlcnRpZXMuXG4gICAgICovXG4gICAgaGFzaDtcbiAgICAvKipcbiAgICAgKiAgVGhlIHRpbWVzdGFtcCBmb3IgdGhpcyBibG9jaywgd2hpY2ggaXMgdGhlIG51bWJlciBvZiBzZWNvbmRzIHNpbmNlXG4gICAgICogIGVwb2NoIHRoYXQgdGhpcyBibG9jayB3YXMgaW5jbHVkZWQuXG4gICAgICovXG4gICAgdGltZXN0YW1wO1xuICAgIC8qKlxuICAgICAqICBUaGUgYmxvY2sgaGFzaCBvZiB0aGUgcGFyZW50IGJsb2NrLlxuICAgICAqL1xuICAgIHBhcmVudEhhc2g7XG4gICAgLyoqXG4gICAgICogIFRoZSBoYXNoIHRyZWUgcm9vdCBvZiB0aGUgcGFyZW50IGJlYWNvbiBibG9jayBmb3IgdGhlIGdpdmVuXG4gICAgICogIGV4ZWN1dGlvbiBibG9jay4gU2VlIFtbbGluay1laXAtNDc4OF1dLlxuICAgICAqL1xuICAgIHBhcmVudEJlYWNvbkJsb2NrUm9vdDtcbiAgICAvKipcbiAgICAgKiAgVGhlIG5vbmNlLlxuICAgICAqXG4gICAgICogIE9uIGxlZ2FjeSBuZXR3b3JrcywgdGhpcyBpcyB0aGUgcmFuZG9tIG51bWJlciBpbnNlcnRlZCB3aGljaFxuICAgICAqICBwZXJtaXR0ZWQgdGhlIGRpZmZpY3VsdHkgdGFyZ2V0IHRvIGJlIHJlYWNoZWQuXG4gICAgICovXG4gICAgbm9uY2U7XG4gICAgLyoqXG4gICAgICogIFRoZSBkaWZmaWN1bHR5IHRhcmdldC5cbiAgICAgKlxuICAgICAqICBPbiBsZWdhY3kgbmV0d29ya3MsIHRoaXMgaXMgdGhlIHByb29mLW9mLXdvcmsgdGFyZ2V0IHJlcXVpcmVkXG4gICAgICogIGZvciBhIGJsb2NrIHRvIG1lZXQgdGhlIHByb3RvY29sIHJ1bGVzIHRvIGJlIGluY2x1ZGVkLlxuICAgICAqXG4gICAgICogIE9uIG1vZGVybiBuZXR3b3JrcywgdGhpcyBpcyBhIHJhbmRvbSBudW1iZXIgYXJyaXZlZCBhdCB1c2luZ1xuICAgICAqICByYW5kYW8uICBAVE9ETzogRmluZCBsaW5rcz9cbiAgICAgKi9cbiAgICBkaWZmaWN1bHR5O1xuICAgIC8qKlxuICAgICAqICBUaGUgdG90YWwgZ2FzIGxpbWl0IGZvciB0aGlzIGJsb2NrLlxuICAgICAqL1xuICAgIGdhc0xpbWl0O1xuICAgIC8qKlxuICAgICAqICBUaGUgdG90YWwgZ2FzIHVzZWQgaW4gdGhpcyBibG9jay5cbiAgICAgKi9cbiAgICBnYXNVc2VkO1xuICAgIC8qKlxuICAgICAqICBUaGUgcm9vdCBoYXNoIGZvciB0aGUgZ2xvYmFsIHN0YXRlIGFmdGVyIGFwcGx5aW5nIGNoYW5nZXNcbiAgICAgKiAgaW4gdGhpcyBibG9jay5cbiAgICAgKi9cbiAgICBzdGF0ZVJvb3Q7XG4gICAgLyoqXG4gICAgICogIFRoZSBoYXNoIG9mIHRoZSB0cmFuc2FjdGlvbiByZWNlaXB0cyB0cmllLlxuICAgICAqL1xuICAgIHJlY2VpcHRzUm9vdDtcbiAgICAvKipcbiAgICAgKiAgVGhlIHRvdGFsIGFtb3VudCBvZiBibG9iIGdhcyBjb25zdW1lZCBieSB0aGUgdHJhbnNhY3Rpb25zXG4gICAgICogIHdpdGhpbiB0aGUgYmxvY2suIFNlZSBbW2xpbmstZWlwLTQ4NDRdXS5cbiAgICAgKi9cbiAgICBibG9iR2FzVXNlZDtcbiAgICAvKipcbiAgICAgKiAgVGhlIHJ1bm5pbmcgdG90YWwgb2YgYmxvYiBnYXMgY29uc3VtZWQgaW4gZXhjZXNzIG9mIHRoZVxuICAgICAqICB0YXJnZXQsIHByaW9yIHRvIHRoZSBibG9jay4gU2VlIFtbbGluay1laXAtNDg0NF1dLlxuICAgICAqL1xuICAgIGV4Y2Vzc0Jsb2JHYXM7XG4gICAgLyoqXG4gICAgICogIFRoZSBtaW5lciBjb2luYmFzZSBhZGRyZXNzLCB3aWhjaCByZWNlaXZlcyBhbnkgc3Vic2lkaWVzIGZvclxuICAgICAqICBpbmNsdWRpbmcgdGhpcyBibG9jay5cbiAgICAgKi9cbiAgICBtaW5lcjtcbiAgICAvKipcbiAgICAgKiAgVGhlIGxhdGVzdCBSQU5EQU8gbWl4IG9mIHRoZSBwb3N0IGJlYWNvbiBzdGF0ZSBvZlxuICAgICAqICB0aGUgcHJldmlvdXMgYmxvY2suXG4gICAgICovXG4gICAgcHJldlJhbmRhbztcbiAgICAvKipcbiAgICAgKiAgQW55IGV4dHJhIGRhdGEgdGhlIHZhbGlkYXRvciB3aXNoZWQgdG8gaW5jbHVkZS5cbiAgICAgKi9cbiAgICBleHRyYURhdGE7XG4gICAgLyoqXG4gICAgICogIFRoZSBiYXNlIGZlZSBwZXIgZ2FzIHRoYXQgYWxsIHRyYW5zYWN0aW9ucyBpbiB0aGlzIGJsb2NrIHdlcmVcbiAgICAgKiAgY2hhcmdlZC5cbiAgICAgKlxuICAgICAqICBUaGlzIGFkanVzdHMgYWZ0ZXIgZWFjaCBibG9jaywgZGVwZW5kaW5nIG9uIGhvdyBjb25nZXN0ZWQgdGhlIG5ldHdvcmtcbiAgICAgKiAgaXMuXG4gICAgICovXG4gICAgYmFzZUZlZVBlckdhcztcbiAgICAjdHJhbnNhY3Rpb25zO1xuICAgIC8qKlxuICAgICAqICBDcmVhdGUgYSBuZXcgKipCbG9jayoqIG9iamVjdC5cbiAgICAgKlxuICAgICAqICBUaGlzIHNob3VsZCBnZW5lcmFsbHkgbm90IGJlIG5lY2Vzc2FyeSBhcyB0aGUgdW5sZXNzIGltcGxlbWVudGluZyBhXG4gICAgICogIGxvdy1sZXZlbCBsaWJyYXJ5LlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGJsb2NrLCBwcm92aWRlcikge1xuICAgICAgICB0aGlzLiN0cmFuc2FjdGlvbnMgPSBibG9jay50cmFuc2FjdGlvbnMubWFwKCh0eCkgPT4ge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiAodHgpICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBUcmFuc2FjdGlvblJlc3BvbnNlKHR4LCBwcm92aWRlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHg7XG4gICAgICAgIH0pO1xuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHtcbiAgICAgICAgICAgIHByb3ZpZGVyLFxuICAgICAgICAgICAgaGFzaDogZ2V0VmFsdWUoYmxvY2suaGFzaCksXG4gICAgICAgICAgICBudW1iZXI6IGJsb2NrLm51bWJlcixcbiAgICAgICAgICAgIHRpbWVzdGFtcDogYmxvY2sudGltZXN0YW1wLFxuICAgICAgICAgICAgcGFyZW50SGFzaDogYmxvY2sucGFyZW50SGFzaCxcbiAgICAgICAgICAgIHBhcmVudEJlYWNvbkJsb2NrUm9vdDogYmxvY2sucGFyZW50QmVhY29uQmxvY2tSb290LFxuICAgICAgICAgICAgbm9uY2U6IGJsb2NrLm5vbmNlLFxuICAgICAgICAgICAgZGlmZmljdWx0eTogYmxvY2suZGlmZmljdWx0eSxcbiAgICAgICAgICAgIGdhc0xpbWl0OiBibG9jay5nYXNMaW1pdCxcbiAgICAgICAgICAgIGdhc1VzZWQ6IGJsb2NrLmdhc1VzZWQsXG4gICAgICAgICAgICBibG9iR2FzVXNlZDogYmxvY2suYmxvYkdhc1VzZWQsXG4gICAgICAgICAgICBleGNlc3NCbG9iR2FzOiBibG9jay5leGNlc3NCbG9iR2FzLFxuICAgICAgICAgICAgbWluZXI6IGJsb2NrLm1pbmVyLFxuICAgICAgICAgICAgcHJldlJhbmRhbzogZ2V0VmFsdWUoYmxvY2sucHJldlJhbmRhbyksXG4gICAgICAgICAgICBleHRyYURhdGE6IGJsb2NrLmV4dHJhRGF0YSxcbiAgICAgICAgICAgIGJhc2VGZWVQZXJHYXM6IGdldFZhbHVlKGJsb2NrLmJhc2VGZWVQZXJHYXMpLFxuICAgICAgICAgICAgc3RhdGVSb290OiBibG9jay5zdGF0ZVJvb3QsXG4gICAgICAgICAgICByZWNlaXB0c1Jvb3Q6IGJsb2NrLnJlY2VpcHRzUm9vdCxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRoZSBsaXN0IG9mIHRyYW5zYWN0aW9uIGhhc2hlcywgaW4gdGhlIG9yZGVyXG4gICAgICogIHRoZXkgd2VyZSBleGVjdXRlZCB3aXRoaW4gdGhlIGJsb2NrLlxuICAgICAqL1xuICAgIGdldCB0cmFuc2FjdGlvbnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiN0cmFuc2FjdGlvbnMubWFwKCh0eCkgPT4ge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiAodHgpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHR4Lmhhc2g7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0aGUgY29tcGxldGUgdHJhbnNhY3Rpb25zLCBpbiB0aGUgb3JkZXIgdGhleVxuICAgICAqICB3ZXJlIGV4ZWN1dGVkIHdpdGhpbiB0aGUgYmxvY2suXG4gICAgICpcbiAgICAgKiAgVGhpcyBpcyBvbmx5IGF2YWlsYWJsZSBmb3IgYmxvY2tzIHdoaWNoIHByZWZldGNoZWRcbiAgICAgKiAgdHJhbnNhY3Rpb25zLCBieSBwYXNzaW5nIGBgdHJ1ZWBgIHRvICUlcHJlZmV0Y2hUeHMlJVxuICAgICAqICBpbnRvIFtbUHJvdmlkZXItZ2V0QmxvY2tdXS5cbiAgICAgKi9cbiAgICBnZXQgcHJlZmV0Y2hlZFRyYW5zYWN0aW9ucygpIHtcbiAgICAgICAgY29uc3QgdHhzID0gdGhpcy4jdHJhbnNhY3Rpb25zLnNsaWNlKCk7XG4gICAgICAgIC8vIERvZXNuJ3QgbWF0dGVyLi4uXG4gICAgICAgIGlmICh0eHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICAgICAgLy8gTWFrZSBzdXJlIHdlIHByZWZldGNoZWQgdGhlIHRyYW5zYWN0aW9uc1xuICAgICAgICBhc3NlcnQodHlwZW9mICh0eHNbMF0pID09PSBcIm9iamVjdFwiLCBcInRyYW5zYWN0aW9ucyB3ZXJlIG5vdCBwcmVmZXRjaGVkIHdpdGggYmxvY2sgcmVxdWVzdFwiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7XG4gICAgICAgICAgICBvcGVyYXRpb246IFwidHJhbnNhY3Rpb25SZXNwb25zZXMoKVwiXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdHhzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBhIEpTT04tZnJpZW5kbHkgdmFsdWUuXG4gICAgICovXG4gICAgdG9KU09OKCkge1xuICAgICAgICBjb25zdCB7IGJhc2VGZWVQZXJHYXMsIGRpZmZpY3VsdHksIGV4dHJhRGF0YSwgZ2FzTGltaXQsIGdhc1VzZWQsIGhhc2gsIG1pbmVyLCBwcmV2UmFuZGFvLCBub25jZSwgbnVtYmVyLCBwYXJlbnRIYXNoLCBwYXJlbnRCZWFjb25CbG9ja1Jvb3QsIHN0YXRlUm9vdCwgcmVjZWlwdHNSb290LCB0aW1lc3RhbXAsIHRyYW5zYWN0aW9ucyB9ID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIF90eXBlOiBcIkJsb2NrXCIsXG4gICAgICAgICAgICBiYXNlRmVlUGVyR2FzOiB0b0pzb24oYmFzZUZlZVBlckdhcyksXG4gICAgICAgICAgICBkaWZmaWN1bHR5OiB0b0pzb24oZGlmZmljdWx0eSksXG4gICAgICAgICAgICBleHRyYURhdGEsXG4gICAgICAgICAgICBnYXNMaW1pdDogdG9Kc29uKGdhc0xpbWl0KSxcbiAgICAgICAgICAgIGdhc1VzZWQ6IHRvSnNvbihnYXNVc2VkKSxcbiAgICAgICAgICAgIGJsb2JHYXNVc2VkOiB0b0pzb24odGhpcy5ibG9iR2FzVXNlZCksXG4gICAgICAgICAgICBleGNlc3NCbG9iR2FzOiB0b0pzb24odGhpcy5leGNlc3NCbG9iR2FzKSxcbiAgICAgICAgICAgIGhhc2gsIG1pbmVyLCBwcmV2UmFuZGFvLCBub25jZSwgbnVtYmVyLCBwYXJlbnRIYXNoLCB0aW1lc3RhbXAsXG4gICAgICAgICAgICBwYXJlbnRCZWFjb25CbG9ja1Jvb3QsIHN0YXRlUm9vdCwgcmVjZWlwdHNSb290LFxuICAgICAgICAgICAgdHJhbnNhY3Rpb25zLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBbU3ltYm9sLml0ZXJhdG9yXSgpIHtcbiAgICAgICAgbGV0IGluZGV4ID0gMDtcbiAgICAgICAgY29uc3QgdHhzID0gdGhpcy50cmFuc2FjdGlvbnM7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBuZXh0OiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGluZGV4IDwgdGhpcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiB0eHNbaW5kZXgrK10sIGRvbmU6IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiB1bmRlZmluZWQsIGRvbmU6IHRydWUgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRoZSBudW1iZXIgb2YgdHJhbnNhY3Rpb25zIGluIHRoaXMgYmxvY2suXG4gICAgICovXG4gICAgZ2V0IGxlbmd0aCgpIHsgcmV0dXJuIHRoaXMuI3RyYW5zYWN0aW9ucy5sZW5ndGg7IH1cbiAgICAvKipcbiAgICAgKiAgVGhlIFtbbGluay1qcy1kYXRlXV0gdGhpcyBibG9jayB3YXMgaW5jbHVkZWQgYXQuXG4gICAgICovXG4gICAgZ2V0IGRhdGUoKSB7XG4gICAgICAgIGlmICh0aGlzLnRpbWVzdGFtcCA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IERhdGUodGhpcy50aW1lc3RhbXAgKiAxMDAwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIEdldCB0aGUgdHJhbnNhY3Rpb24gYXQgJSVpbmRleGUlJSB3aXRoaW4gdGhpcyBibG9jay5cbiAgICAgKi9cbiAgICBhc3luYyBnZXRUcmFuc2FjdGlvbihpbmRleE9ySGFzaCkge1xuICAgICAgICAvLyBGaW5kIHRoZSBpbnRlcm5hbCB2YWx1ZSBieSBpdHMgaW5kZXggb3IgaGFzaFxuICAgICAgICBsZXQgdHggPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmICh0eXBlb2YgKGluZGV4T3JIYXNoKSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgdHggPSB0aGlzLiN0cmFuc2FjdGlvbnNbaW5kZXhPckhhc2hdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgaGFzaCA9IGluZGV4T3JIYXNoLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHYgb2YgdGhpcy4jdHJhbnNhY3Rpb25zKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiAodikgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHYgIT09IGhhc2gpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHR4ID0gdjtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAodi5oYXNoICE9PSBoYXNoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0eCA9IHY7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodHggPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibm8gc3VjaCB0eFwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mICh0eCkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHJldHVybiAoYXdhaXQgdGhpcy5wcm92aWRlci5nZXRUcmFuc2FjdGlvbih0eCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHR4O1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBJZiBhICoqQmxvY2sqKiB3YXMgZmV0Y2hlZCB3aXRoIGEgcmVxdWVzdCB0byBpbmNsdWRlIHRoZSB0cmFuc2FjdGlvbnNcbiAgICAgKiAgdGhpcyB3aWxsIGFsbG93IHN5bmNocm9ub3VzIGFjY2VzcyB0byB0aG9zZSB0cmFuc2FjdGlvbnMuXG4gICAgICpcbiAgICAgKiAgSWYgdGhlIHRyYW5zYWN0aW9ucyB3ZXJlIG5vdCBwcmVmZXRjaGVkLCB0aGlzIHdpbGwgdGhyb3cuXG4gICAgICovXG4gICAgZ2V0UHJlZmV0Y2hlZFRyYW5zYWN0aW9uKGluZGV4T3JIYXNoKSB7XG4gICAgICAgIGNvbnN0IHR4cyA9IHRoaXMucHJlZmV0Y2hlZFRyYW5zYWN0aW9ucztcbiAgICAgICAgaWYgKHR5cGVvZiAoaW5kZXhPckhhc2gpID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICByZXR1cm4gdHhzW2luZGV4T3JIYXNoXTtcbiAgICAgICAgfVxuICAgICAgICBpbmRleE9ySGFzaCA9IGluZGV4T3JIYXNoLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGZvciAoY29uc3QgdHggb2YgdHhzKSB7XG4gICAgICAgICAgICBpZiAodHguaGFzaCA9PT0gaW5kZXhPckhhc2gpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYXNzZXJ0QXJndW1lbnQoZmFsc2UsIFwibm8gbWF0Y2hpbmcgdHJhbnNhY3Rpb25cIiwgXCJpbmRleE9ySGFzaFwiLCBpbmRleE9ySGFzaCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRydWUgaWYgdGhpcyBibG9jayBiZWVuIG1pbmVkLiBUaGlzIHByb3ZpZGVzIGEgdHlwZSBndWFyZFxuICAgICAqICBmb3IgYWxsIHByb3BlcnRpZXMgb24gYSBbW01pbmVkQmxvY2tdXS5cbiAgICAgKi9cbiAgICBpc01pbmVkKCkgeyByZXR1cm4gISF0aGlzLmhhc2g7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0cnVlIGlmIHRoaXMgYmxvY2sgaXMgYW4gW1tsaW5rLWVpcC0yOTMwXV0gYmxvY2suXG4gICAgICovXG4gICAgaXNMb25kb24oKSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMuYmFzZUZlZVBlckdhcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogIEBfaWdub3JlOlxuICAgICAqL1xuICAgIG9ycGhhbmVkRXZlbnQoKSB7XG4gICAgICAgIGlmICghdGhpcy5pc01pbmVkKCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY3JlYXRlT3JwaGFuZWRCbG9ja0ZpbHRlcih0aGlzKTtcbiAgICB9XG59XG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBMb2dcbi8qKlxuICogIEEgKipMb2cqKiBpbiBFdGhlcmV1bSByZXByZXNlbnRzIGFuIGV2ZW50IHRoYXQgaGFzIGJlZW4gaW5jbHVkZWQgaW4gYVxuICogIHRyYW5zYWN0aW9uIHVzaW5nIHRoZSBgYExPRypgYCBvcGNvZGVzLCB3aGljaCBhcmUgbW9zdCBjb21tb25seSB1c2VkIGJ5XG4gKiAgU29saWRpdHkncyBlbWl0IGZvciBhbm5vdW5jaW5nIGV2ZW50cy5cbiAqL1xuZXhwb3J0IGNsYXNzIExvZyB7XG4gICAgLyoqXG4gICAgICogIFRoZSBwcm92aWRlciBjb25uZWN0ZWQgdG8gdGhlIGxvZyB1c2VkIHRvIGZldGNoIGFkZGl0aW9uYWwgZGV0YWlsc1xuICAgICAqICBpZiBuZWNlc3NhcnkuXG4gICAgICovXG4gICAgcHJvdmlkZXI7XG4gICAgLyoqXG4gICAgICogIFRoZSB0cmFuc2FjdGlvbiBoYXNoIG9mIHRoZSB0cmFuc2FjdGlvbiB0aGlzIGxvZyBvY2N1cnJlZCBpbi4gVXNlIHRoZVxuICAgICAqICBbW0xvZy1nZXRUcmFuc2FjdGlvbl1dIHRvIGdldCB0aGUgW1tUcmFuc2FjdGlvblJlc3BvbnNlXV0uXG4gICAgICovXG4gICAgdHJhbnNhY3Rpb25IYXNoO1xuICAgIC8qKlxuICAgICAqICBUaGUgYmxvY2sgaGFzaCBvZiB0aGUgYmxvY2sgdGhpcyBsb2cgb2NjdXJyZWQgaW4uIFVzZSB0aGVcbiAgICAgKiAgW1tMb2ctZ2V0QmxvY2tdXSB0byBnZXQgdGhlIFtbQmxvY2tdXS5cbiAgICAgKi9cbiAgICBibG9ja0hhc2g7XG4gICAgLyoqXG4gICAgICogIFRoZSBibG9jayBudW1iZXIgb2YgdGhlIGJsb2NrIHRoaXMgbG9nIG9jY3VycmVkIGluLiBJdCBpcyBwcmVmZXJyZWRcbiAgICAgKiAgdG8gdXNlIHRoZSBbW0Jsb2NrLWhhc2hdXSB3aGVuIGZldGNoaW5nIHRoZSByZWxhdGVkIFtbQmxvY2tdXSxcbiAgICAgKiAgc2luY2UgaW4gdGhlIGNhc2Ugb2YgYW4gb3JwaGFuZWQgYmxvY2ssIHRoZSBibG9jayBhdCB0aGF0IGhlaWdodCBtYXlcbiAgICAgKiAgaGF2ZSBjaGFuZ2VkLlxuICAgICAqL1xuICAgIGJsb2NrTnVtYmVyO1xuICAgIC8qKlxuICAgICAqICBJZiB0aGUgKipMb2cqKiByZXByZXNlbnRzIGEgYmxvY2sgdGhhdCB3YXMgcmVtb3ZlZCBkdWUgdG8gYW4gb3JwaGFuZWRcbiAgICAgKiAgYmxvY2ssIHRoaXMgd2lsbCBiZSB0cnVlLlxuICAgICAqXG4gICAgICogIFRoaXMgY2FuIG9ubHkgaGFwcGVuIHdpdGhpbiBhbiBvcnBoYW4gZXZlbnQgbGlzdGVuZXIuXG4gICAgICovXG4gICAgcmVtb3ZlZDtcbiAgICAvKipcbiAgICAgKiAgVGhlIGFkZHJlc3Mgb2YgdGhlIGNvbnRyYWN0IHRoYXQgZW1pdHRlZCB0aGlzIGxvZy5cbiAgICAgKi9cbiAgICBhZGRyZXNzO1xuICAgIC8qKlxuICAgICAqICBUaGUgZGF0YSBpbmNsdWRlZCBpbiB0aGlzIGxvZyB3aGVuIGl0IHdhcyBlbWl0dGVkLlxuICAgICAqL1xuICAgIGRhdGE7XG4gICAgLyoqXG4gICAgICogIFRoZSBpbmRleGVkIHRvcGljcyBpbmNsdWRlZCBpbiB0aGlzIGxvZyB3aGVuIGl0IHdhcyBlbWl0dGVkLlxuICAgICAqXG4gICAgICogIEFsbCB0b3BpY3MgYXJlIGluY2x1ZGVkIGluIHRoZSBibG9vbSBmaWx0ZXJzLCBzbyB0aGV5IGNhbiBiZVxuICAgICAqICBlZmZpY2llbnRseSBmaWx0ZXJlZCB1c2luZyB0aGUgW1tQcm92aWRlci1nZXRMb2dzXV0gbWV0aG9kLlxuICAgICAqL1xuICAgIHRvcGljcztcbiAgICAvKipcbiAgICAgKiAgVGhlIGluZGV4IHdpdGhpbiB0aGUgYmxvY2sgdGhpcyBsb2cgb2NjdXJyZWQgYXQuIFRoaXMgaXMgZ2VuZXJhbGx5XG4gICAgICogIG5vdCB1c2VmdWwgdG8gZGV2ZWxvcGVycywgYnV0IGNhbiBiZSB1c2VkIHdpdGggdGhlIHZhcmlvdXMgcm9vdHNcbiAgICAgKiAgdG8gcHJvb2YgaW5jbHVzaW9uIHdpdGhpbiBhIGJsb2NrLlxuICAgICAqL1xuICAgIGluZGV4O1xuICAgIC8qKlxuICAgICAqICBUaGUgaW5kZXggd2l0aGluIHRoZSB0cmFuc2FjdGlvbiBvZiB0aGlzIGxvZy5cbiAgICAgKi9cbiAgICB0cmFuc2FjdGlvbkluZGV4O1xuICAgIC8qKlxuICAgICAqICBAX2lnbm9yZTpcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihsb2csIHByb3ZpZGVyKSB7XG4gICAgICAgIHRoaXMucHJvdmlkZXIgPSBwcm92aWRlcjtcbiAgICAgICAgY29uc3QgdG9waWNzID0gT2JqZWN0LmZyZWV6ZShsb2cudG9waWNzLnNsaWNlKCkpO1xuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHtcbiAgICAgICAgICAgIHRyYW5zYWN0aW9uSGFzaDogbG9nLnRyYW5zYWN0aW9uSGFzaCxcbiAgICAgICAgICAgIGJsb2NrSGFzaDogbG9nLmJsb2NrSGFzaCxcbiAgICAgICAgICAgIGJsb2NrTnVtYmVyOiBsb2cuYmxvY2tOdW1iZXIsXG4gICAgICAgICAgICByZW1vdmVkOiBsb2cucmVtb3ZlZCxcbiAgICAgICAgICAgIGFkZHJlc3M6IGxvZy5hZGRyZXNzLFxuICAgICAgICAgICAgZGF0YTogbG9nLmRhdGEsXG4gICAgICAgICAgICB0b3BpY3MsXG4gICAgICAgICAgICBpbmRleDogbG9nLmluZGV4LFxuICAgICAgICAgICAgdHJhbnNhY3Rpb25JbmRleDogbG9nLnRyYW5zYWN0aW9uSW5kZXgsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBhIEpTT04tY29tcGF0aWJsZSBvYmplY3QuXG4gICAgICovXG4gICAgdG9KU09OKCkge1xuICAgICAgICBjb25zdCB7IGFkZHJlc3MsIGJsb2NrSGFzaCwgYmxvY2tOdW1iZXIsIGRhdGEsIGluZGV4LCByZW1vdmVkLCB0b3BpY3MsIHRyYW5zYWN0aW9uSGFzaCwgdHJhbnNhY3Rpb25JbmRleCB9ID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIF90eXBlOiBcImxvZ1wiLFxuICAgICAgICAgICAgYWRkcmVzcywgYmxvY2tIYXNoLCBibG9ja051bWJlciwgZGF0YSwgaW5kZXgsXG4gICAgICAgICAgICByZW1vdmVkLCB0b3BpY3MsIHRyYW5zYWN0aW9uSGFzaCwgdHJhbnNhY3Rpb25JbmRleFxuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0aGUgYmxvY2sgdGhhdCB0aGlzIGxvZyBvY2N1cnJlZCBpbi5cbiAgICAgKi9cbiAgICBhc3luYyBnZXRCbG9jaygpIHtcbiAgICAgICAgY29uc3QgYmxvY2sgPSBhd2FpdCB0aGlzLnByb3ZpZGVyLmdldEJsb2NrKHRoaXMuYmxvY2tIYXNoKTtcbiAgICAgICAgYXNzZXJ0KCEhYmxvY2ssIFwiZmFpbGVkIHRvIGZpbmQgdHJhbnNhY3Rpb25cIiwgXCJVTktOT1dOX0VSUk9SXCIsIHt9KTtcbiAgICAgICAgcmV0dXJuIGJsb2NrO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0aGUgdHJhbnNhY3Rpb24gdGhhdCB0aGlzIGxvZyBvY2N1cnJlZCBpbi5cbiAgICAgKi9cbiAgICBhc3luYyBnZXRUcmFuc2FjdGlvbigpIHtcbiAgICAgICAgY29uc3QgdHggPSBhd2FpdCB0aGlzLnByb3ZpZGVyLmdldFRyYW5zYWN0aW9uKHRoaXMudHJhbnNhY3Rpb25IYXNoKTtcbiAgICAgICAgYXNzZXJ0KCEhdHgsIFwiZmFpbGVkIHRvIGZpbmQgdHJhbnNhY3Rpb25cIiwgXCJVTktOT1dOX0VSUk9SXCIsIHt9KTtcbiAgICAgICAgcmV0dXJuIHR4O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0aGUgdHJhbnNhY3Rpb24gcmVjZWlwdCBmb3QgdGhlIHRyYW5zYWN0aW9uIHRoYXQgdGhpc1xuICAgICAqICBsb2cgb2NjdXJyZWQgaW4uXG4gICAgICovXG4gICAgYXN5bmMgZ2V0VHJhbnNhY3Rpb25SZWNlaXB0KCkge1xuICAgICAgICBjb25zdCByZWNlaXB0ID0gYXdhaXQgdGhpcy5wcm92aWRlci5nZXRUcmFuc2FjdGlvblJlY2VpcHQodGhpcy50cmFuc2FjdGlvbkhhc2gpO1xuICAgICAgICBhc3NlcnQoISFyZWNlaXB0LCBcImZhaWxlZCB0byBmaW5kIHRyYW5zYWN0aW9uIHJlY2VpcHRcIiwgXCJVTktOT1dOX0VSUk9SXCIsIHt9KTtcbiAgICAgICAgcmV0dXJuIHJlY2VpcHQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBAX2lnbm9yZTpcbiAgICAgKi9cbiAgICByZW1vdmVkRXZlbnQoKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVSZW1vdmVkTG9nRmlsdGVyKHRoaXMpO1xuICAgIH1cbn1cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFRyYW5zYWN0aW9uIFJlY2VpcHRcbi8qXG5leHBvcnQgaW50ZXJmYWNlIExlZ2FjeVRyYW5zYWN0aW9uUmVjZWlwdCB7XG4gICAgYnl6YW50aXVtOiBmYWxzZTtcbiAgICBzdGF0dXM6IG51bGw7XG4gICAgcm9vdDogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEJ5emFudGl1bVRyYW5zYWN0aW9uUmVjZWlwdCB7XG4gICAgYnl6YW50aXVtOiB0cnVlO1xuICAgIHN0YXR1czogbnVtYmVyO1xuICAgIHJvb3Q6IG51bGw7XG59XG4qL1xuLyoqXG4gKiAgQSAqKlRyYW5zYWN0aW9uUmVjZWlwdCoqIGluY2x1ZGVzIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24gYWJvdXQgYVxuICogIHRyYW5zYWN0aW9uIHRoYXQgaXMgb25seSBhdmFpbGFibGUgYWZ0ZXIgaXQgaGFzIGJlZW4gbWluZWQuXG4gKi9cbmV4cG9ydCBjbGFzcyBUcmFuc2FjdGlvblJlY2VpcHQge1xuICAgIC8qKlxuICAgICAqICBUaGUgcHJvdmlkZXIgY29ubmVjdGVkIHRvIHRoZSBsb2cgdXNlZCB0byBmZXRjaCBhZGRpdGlvbmFsIGRldGFpbHNcbiAgICAgKiAgaWYgbmVjZXNzYXJ5LlxuICAgICAqL1xuICAgIHByb3ZpZGVyO1xuICAgIC8qKlxuICAgICAqICBUaGUgYWRkcmVzcyB0aGUgdHJhbnNhY3Rpb24gd2FzIHNlbnQgdG8uXG4gICAgICovXG4gICAgdG87XG4gICAgLyoqXG4gICAgICogIFRoZSBzZW5kZXIgb2YgdGhlIHRyYW5zYWN0aW9uLlxuICAgICAqL1xuICAgIGZyb207XG4gICAgLyoqXG4gICAgICogIFRoZSBhZGRyZXNzIG9mIHRoZSBjb250cmFjdCBpZiB0aGUgdHJhbnNhY3Rpb24gd2FzIGRpcmVjdGx5XG4gICAgICogIHJlc3BvbnNpYmxlIGZvciBkZXBsb3lpbmcgb25lLlxuICAgICAqXG4gICAgICogIFRoaXMgaXMgbm9uLW51bGwgKipvbmx5KiogaWYgdGhlIGBgdG9gYCBpcyBlbXB0eSBhbmQgdGhlIGBgZGF0YWBgXG4gICAgICogIHdhcyBzdWNjZXNzZnVsbHkgZXhlY3V0ZWQgYXMgaW5pdGNvZGUuXG4gICAgICovXG4gICAgY29udHJhY3RBZGRyZXNzO1xuICAgIC8qKlxuICAgICAqICBUaGUgdHJhbnNhY3Rpb24gaGFzaC5cbiAgICAgKi9cbiAgICBoYXNoO1xuICAgIC8qKlxuICAgICAqICBUaGUgaW5kZXggb2YgdGhpcyB0cmFuc2FjdGlvbiB3aXRoaW4gdGhlIGJsb2NrIHRyYW5zYWN0aW9ucy5cbiAgICAgKi9cbiAgICBpbmRleDtcbiAgICAvKipcbiAgICAgKiAgVGhlIGJsb2NrIGhhc2ggb2YgdGhlIFtbQmxvY2tdXSB0aGlzIHRyYW5zYWN0aW9uIHdhcyBpbmNsdWRlZCBpbi5cbiAgICAgKi9cbiAgICBibG9ja0hhc2g7XG4gICAgLyoqXG4gICAgICogIFRoZSBibG9jayBudW1iZXIgb2YgdGhlIFtbQmxvY2tdXSB0aGlzIHRyYW5zYWN0aW9uIHdhcyBpbmNsdWRlZCBpbi5cbiAgICAgKi9cbiAgICBibG9ja051bWJlcjtcbiAgICAvKipcbiAgICAgKiAgVGhlIGJsb29tIGZpbHRlciBieXRlcyB0aGF0IHJlcHJlc2VudCBhbGwgbG9ncyB0aGF0IG9jY3VycmVkIHdpdGhpblxuICAgICAqICB0aGlzIHRyYW5zYWN0aW9uLiBUaGlzIGlzIGdlbmVyYWxseSBub3QgdXNlZnVsIGZvciBtb3N0IGRldmVsb3BlcnMsXG4gICAgICogIGJ1dCBjYW4gYmUgdXNlZCB0byB2YWxpZGF0ZSB0aGUgaW5jbHVkZWQgbG9ncy5cbiAgICAgKi9cbiAgICBsb2dzQmxvb207XG4gICAgLyoqXG4gICAgICogIFRoZSBhY3R1YWwgYW1vdW50IG9mIGdhcyB1c2VkIGJ5IHRoaXMgdHJhbnNhY3Rpb24uXG4gICAgICpcbiAgICAgKiAgV2hlbiBjcmVhdGluZyBhIHRyYW5zYWN0aW9uLCB0aGUgYW1vdW50IG9mIGdhcyB0aGF0IHdpbGwgYmUgdXNlZCBjYW5cbiAgICAgKiAgb25seSBiZSBhcHByb3hpbWF0ZWQsIGJ1dCB0aGUgc2VuZGVyIG11c3QgcGF5IHRoZSBnYXMgZmVlIGZvciB0aGVcbiAgICAgKiAgZW50aXJlIGdhcyBsaW1pdC4gQWZ0ZXIgdGhlIHRyYW5zYWN0aW9uLCB0aGUgZGlmZmVyZW5jZSBpcyByZWZ1bmRlZC5cbiAgICAgKi9cbiAgICBnYXNVc2VkO1xuICAgIC8qKlxuICAgICAqICBUaGUgZ2FzIHVzZWQgZm9yIEJMT2JzLiBTZWUgW1tsaW5rLWVpcC00ODQ0XV0uXG4gICAgICovXG4gICAgYmxvYkdhc1VzZWQ7XG4gICAgLyoqXG4gICAgICogIFRoZSBhbW91bnQgb2YgZ2FzIHVzZWQgYnkgYWxsIHRyYW5zYWN0aW9ucyB3aXRoaW4gdGhlIGJsb2NrIGZvciB0aGlzXG4gICAgICogIGFuZCBhbGwgdHJhbnNhY3Rpb25zIHdpdGggYSBsb3dlciBgYGluZGV4YGAuXG4gICAgICpcbiAgICAgKiAgVGhpcyBpcyBnZW5lcmFsbHkgbm90IHVzZWZ1bCBmb3IgZGV2ZWxvcGVycyBidXQgY2FuIGJlIHVzZWQgdG9cbiAgICAgKiAgdmFsaWRhdGUgY2VydGFpbiBhc3BlY3RzIG9mIGV4ZWN1dGlvbi5cbiAgICAgKi9cbiAgICBjdW11bGF0aXZlR2FzVXNlZDtcbiAgICAvKipcbiAgICAgKiAgVGhlIGFjdHVhbCBnYXMgcHJpY2UgdXNlZCBkdXJpbmcgZXhlY3V0aW9uLlxuICAgICAqXG4gICAgICogIER1ZSB0byB0aGUgY29tcGxleGl0eSBvZiBbW2xpbmstZWlwLTE1NTldXSB0aGlzIHZhbHVlIGNhbiBvbmx5XG4gICAgICogIGJlIGNhbHVjbGF0ZWQgYWZ0ZXIgdGhlIHRyYW5zYWN0aW9uIGhhcyBiZWVuIG1pbmVkLCBzbmNlIHRoZSBiYXNlXG4gICAgICogIGZlZSBpcyBwcm90b2NvbC1lbmZvcmNlZC5cbiAgICAgKi9cbiAgICBnYXNQcmljZTtcbiAgICAvKipcbiAgICAgKiAgVGhlIHByaWNlIHBhaWQgcGVyIEJMT0IgaW4gZ2FzLiBTZWUgW1tsaW5rLWVpcC00ODQ0XV0uXG4gICAgICovXG4gICAgYmxvYkdhc1ByaWNlO1xuICAgIC8qKlxuICAgICAqICBUaGUgW1tsaW5rLWVpcC0yNzE4XV0gdHJhbnNhY3Rpb24gdHlwZS5cbiAgICAgKi9cbiAgICB0eXBlO1xuICAgIC8vcmVhZG9ubHkgYnl6YW50aXVtITogYm9vbGVhbjtcbiAgICAvKipcbiAgICAgKiAgVGhlIHN0YXR1cyBvZiB0aGlzIHRyYW5zYWN0aW9uLCBpbmRpY2F0aW5nIHN1Y2Nlc3MgKGkuZS4gYGAxYGApIG9yXG4gICAgICogIGEgcmV2ZXJ0IChpLmUuIGBgMGBgKS5cbiAgICAgKlxuICAgICAqICBUaGlzIGlzIGF2YWlsYWJsZSBpbiBwb3N0LWJ5emFudGl1bSBibG9ja3MsIGJ1dCBzb21lIGJhY2tlbmRzIG1heVxuICAgICAqICBiYWNrZmlsbCB0aGlzIHZhbHVlLlxuICAgICAqL1xuICAgIHN0YXR1cztcbiAgICAvKipcbiAgICAgKiAgVGhlIHJvb3QgaGFzaCBvZiB0aGlzIHRyYW5zYWN0aW9uLlxuICAgICAqXG4gICAgICogIFRoaXMgaXMgbm8gcHJlc2VudCBhbmQgd2FzIG9ubHkgaW5jbHVkZWQgaW4gcHJlLWJ5emFudGl1bSBibG9ja3MsIGJ1dFxuICAgICAqICBjb3VsZCBiZSB1c2VkIHRvIHZhbGlkYXRlIGNlcnRhaW4gcGFydHMgb2YgdGhlIHJlY2VpcHQuXG4gICAgICovXG4gICAgcm9vdDtcbiAgICAjbG9ncztcbiAgICAvKipcbiAgICAgKiAgQF9pZ25vcmU6XG4gICAgICovXG4gICAgY29uc3RydWN0b3IodHgsIHByb3ZpZGVyKSB7XG4gICAgICAgIHRoaXMuI2xvZ3MgPSBPYmplY3QuZnJlZXplKHR4LmxvZ3MubWFwKChsb2cpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgTG9nKGxvZywgcHJvdmlkZXIpO1xuICAgICAgICB9KSk7XG4gICAgICAgIGxldCBnYXNQcmljZSA9IEJOXzA7XG4gICAgICAgIGlmICh0eC5lZmZlY3RpdmVHYXNQcmljZSAhPSBudWxsKSB7XG4gICAgICAgICAgICBnYXNQcmljZSA9IHR4LmVmZmVjdGl2ZUdhc1ByaWNlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR4Lmdhc1ByaWNlICE9IG51bGwpIHtcbiAgICAgICAgICAgIGdhc1ByaWNlID0gdHguZ2FzUHJpY2U7XG4gICAgICAgIH1cbiAgICAgICAgZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7XG4gICAgICAgICAgICBwcm92aWRlcixcbiAgICAgICAgICAgIHRvOiB0eC50byxcbiAgICAgICAgICAgIGZyb206IHR4LmZyb20sXG4gICAgICAgICAgICBjb250cmFjdEFkZHJlc3M6IHR4LmNvbnRyYWN0QWRkcmVzcyxcbiAgICAgICAgICAgIGhhc2g6IHR4Lmhhc2gsXG4gICAgICAgICAgICBpbmRleDogdHguaW5kZXgsXG4gICAgICAgICAgICBibG9ja0hhc2g6IHR4LmJsb2NrSGFzaCxcbiAgICAgICAgICAgIGJsb2NrTnVtYmVyOiB0eC5ibG9ja051bWJlcixcbiAgICAgICAgICAgIGxvZ3NCbG9vbTogdHgubG9nc0Jsb29tLFxuICAgICAgICAgICAgZ2FzVXNlZDogdHguZ2FzVXNlZCxcbiAgICAgICAgICAgIGN1bXVsYXRpdmVHYXNVc2VkOiB0eC5jdW11bGF0aXZlR2FzVXNlZCxcbiAgICAgICAgICAgIGJsb2JHYXNVc2VkOiB0eC5ibG9iR2FzVXNlZCxcbiAgICAgICAgICAgIGdhc1ByaWNlLFxuICAgICAgICAgICAgYmxvYkdhc1ByaWNlOiB0eC5ibG9iR2FzUHJpY2UsXG4gICAgICAgICAgICB0eXBlOiB0eC50eXBlLFxuICAgICAgICAgICAgLy9ieXphbnRpdW06IHR4LmJ5emFudGl1bSxcbiAgICAgICAgICAgIHN0YXR1czogdHguc3RhdHVzLFxuICAgICAgICAgICAgcm9vdDogdHgucm9vdFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRoZSBsb2dzIGZvciB0aGlzIHRyYW5zYWN0aW9uLlxuICAgICAqL1xuICAgIGdldCBsb2dzKCkgeyByZXR1cm4gdGhpcy4jbG9nczsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGEgSlNPTi1jb21wYXRpYmxlIHJlcHJlc2VudGF0aW9uLlxuICAgICAqL1xuICAgIHRvSlNPTigpIHtcbiAgICAgICAgY29uc3QgeyB0bywgZnJvbSwgY29udHJhY3RBZGRyZXNzLCBoYXNoLCBpbmRleCwgYmxvY2tIYXNoLCBibG9ja051bWJlciwgbG9nc0Jsb29tLCBsb2dzLCAvL2J5emFudGl1bSwgXG4gICAgICAgIHN0YXR1cywgcm9vdCB9ID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIF90eXBlOiBcIlRyYW5zYWN0aW9uUmVjZWlwdFwiLFxuICAgICAgICAgICAgYmxvY2tIYXNoLCBibG9ja051bWJlcixcbiAgICAgICAgICAgIC8vYnl6YW50aXVtLCBcbiAgICAgICAgICAgIGNvbnRyYWN0QWRkcmVzcyxcbiAgICAgICAgICAgIGN1bXVsYXRpdmVHYXNVc2VkOiB0b0pzb24odGhpcy5jdW11bGF0aXZlR2FzVXNlZCksXG4gICAgICAgICAgICBmcm9tLFxuICAgICAgICAgICAgZ2FzUHJpY2U6IHRvSnNvbih0aGlzLmdhc1ByaWNlKSxcbiAgICAgICAgICAgIGJsb2JHYXNVc2VkOiB0b0pzb24odGhpcy5ibG9iR2FzVXNlZCksXG4gICAgICAgICAgICBibG9iR2FzUHJpY2U6IHRvSnNvbih0aGlzLmJsb2JHYXNQcmljZSksXG4gICAgICAgICAgICBnYXNVc2VkOiB0b0pzb24odGhpcy5nYXNVc2VkKSxcbiAgICAgICAgICAgIGhhc2gsIGluZGV4LCBsb2dzLCBsb2dzQmxvb20sIHJvb3QsIHN0YXR1cywgdG9cbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIEBfaWdub3JlOlxuICAgICAqL1xuICAgIGdldCBsZW5ndGgoKSB7IHJldHVybiB0aGlzLmxvZ3MubGVuZ3RoOyB9XG4gICAgW1N5bWJvbC5pdGVyYXRvcl0oKSB7XG4gICAgICAgIGxldCBpbmRleCA9IDA7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBuZXh0OiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGluZGV4IDwgdGhpcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IHRoaXMubG9nc1tpbmRleCsrXSwgZG9uZTogZmFsc2UgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhlIHRvdGFsIGZlZSBmb3IgdGhpcyB0cmFuc2FjdGlvbiwgaW4gd2VpLlxuICAgICAqL1xuICAgIGdldCBmZWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdhc1VzZWQgKiB0aGlzLmdhc1ByaWNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmVzb2x2ZXMgdG8gdGhlIGJsb2NrIHRoaXMgdHJhbnNhY3Rpb24gb2NjdXJyZWQgaW4uXG4gICAgICovXG4gICAgYXN5bmMgZ2V0QmxvY2soKSB7XG4gICAgICAgIGNvbnN0IGJsb2NrID0gYXdhaXQgdGhpcy5wcm92aWRlci5nZXRCbG9jayh0aGlzLmJsb2NrSGFzaCk7XG4gICAgICAgIGlmIChibG9jayA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUT0RPXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBibG9jaztcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJlc29sdmVzIHRvIHRoZSB0cmFuc2FjdGlvbiB0aGlzIHRyYW5zYWN0aW9uIG9jY3VycmVkIGluLlxuICAgICAqL1xuICAgIGFzeW5jIGdldFRyYW5zYWN0aW9uKCkge1xuICAgICAgICBjb25zdCB0eCA9IGF3YWl0IHRoaXMucHJvdmlkZXIuZ2V0VHJhbnNhY3Rpb24odGhpcy5oYXNoKTtcbiAgICAgICAgaWYgKHR4ID09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRPRE9cIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHR4O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmVzb2x2ZXMgdG8gdGhlIHJldHVybiB2YWx1ZSBvZiB0aGUgZXhlY3V0aW9uIG9mIHRoaXMgdHJhbnNhY3Rpb24uXG4gICAgICpcbiAgICAgKiAgU3VwcG9ydCBmb3IgdGhpcyBmZWF0dXJlIGlzIGxpbWl0ZWQsIGFzIGl0IHJlcXVpcmVzIGFuIGFyY2hpdmUgbm9kZVxuICAgICAqICB3aXRoIHRoZSBgYGRlYnVnX2BgIG9yIGBgdHJhY2VfYGAgQVBJIGVuYWJsZWQuXG4gICAgICovXG4gICAgYXN5bmMgZ2V0UmVzdWx0KCkge1xuICAgICAgICByZXR1cm4gKGF3YWl0IHRoaXMucHJvdmlkZXIuZ2V0VHJhbnNhY3Rpb25SZXN1bHQodGhpcy5oYXNoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXNvbHZlcyB0byB0aGUgbnVtYmVyIG9mIGNvbmZpcm1hdGlvbnMgdGhpcyB0cmFuc2FjdGlvbiBoYXMuXG4gICAgICovXG4gICAgYXN5bmMgY29uZmlybWF0aW9ucygpIHtcbiAgICAgICAgcmV0dXJuIChhd2FpdCB0aGlzLnByb3ZpZGVyLmdldEJsb2NrTnVtYmVyKCkpIC0gdGhpcy5ibG9ja051bWJlciArIDE7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBAX2lnbm9yZTpcbiAgICAgKi9cbiAgICByZW1vdmVkRXZlbnQoKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVSZW1vdmVkVHJhbnNhY3Rpb25GaWx0ZXIodGhpcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBAX2lnbm9yZTpcbiAgICAgKi9cbiAgICByZW9yZGVyZWRFdmVudChvdGhlcikge1xuICAgICAgICBhc3NlcnQoIW90aGVyIHx8IG90aGVyLmlzTWluZWQoKSwgXCJ1bm1pbmVkICdvdGhlcicgdHJhbnNjdGlvbiBjYW5ub3QgYmUgb3JwaGFuZWRcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwgeyBvcGVyYXRpb246IFwicmVvcmRlcmVkRXZlbnQob3RoZXIpXCIgfSk7XG4gICAgICAgIHJldHVybiBjcmVhdGVSZW9yZGVyZWRUcmFuc2FjdGlvbkZpbHRlcih0aGlzLCBvdGhlcik7XG4gICAgfVxufVxuLyoqXG4gKiAgQSAqKlRyYW5zYWN0aW9uUmVzcG9uc2UqKiBpbmNsdWRlcyBhbGwgcHJvcGVydGllcyBhYm91dCBhIHRyYW5zYWN0aW9uXG4gKiAgdGhhdCB3YXMgc2VudCB0byB0aGUgbmV0d29yaywgd2hpY2ggbWF5IG9yIG1heSBub3QgYmUgaW5jbHVkZWQgaW4gYVxuICogIGJsb2NrLlxuICpcbiAqICBUaGUgW1tUcmFuc2FjdGlvblJlc3BvbnNlLWlzTWluZWRdXSBjYW4gYmUgdXNlZCB0byBjaGVjayBpZiB0aGVcbiAqICB0cmFuc2FjdGlvbiBoYXMgYmVlbiBtaW5lZCBhcyB3ZWxsIGFzIHR5cGUgZ3VhcmQgdGhhdCB0aGUgb3RoZXJ3aXNlXG4gKiAgcG9zc2libHkgYGBudWxsYGAgcHJvcGVydGllcyBhcmUgZGVmaW5lZC5cbiAqL1xuZXhwb3J0IGNsYXNzIFRyYW5zYWN0aW9uUmVzcG9uc2Uge1xuICAgIC8qKlxuICAgICAqICBUaGUgcHJvdmlkZXIgdGhpcyBpcyBjb25uZWN0ZWQgdG8sIHdoaWNoIHdpbGwgaW5mbHVlbmNlIGhvdyBpdHNcbiAgICAgKiAgbWV0aG9kcyB3aWxsIHJlc29sdmUgaXRzIGFzeW5jIGluc3BlY3Rpb24gbWV0aG9kcy5cbiAgICAgKi9cbiAgICBwcm92aWRlcjtcbiAgICAvKipcbiAgICAgKiAgVGhlIGJsb2NrIG51bWJlciBvZiB0aGUgYmxvY2sgdGhhdCB0aGlzIHRyYW5zYWN0aW9uIHdhcyBpbmNsdWRlZCBpbi5cbiAgICAgKlxuICAgICAqICBUaGlzIGlzIGBgbnVsbGBgIGZvciBwZW5kaW5nIHRyYW5zYWN0aW9ucy5cbiAgICAgKi9cbiAgICBibG9ja051bWJlcjtcbiAgICAvKipcbiAgICAgKiAgVGhlIGJsb2NrSGFzaCBvZiB0aGUgYmxvY2sgdGhhdCB0aGlzIHRyYW5zYWN0aW9uIHdhcyBpbmNsdWRlZCBpbi5cbiAgICAgKlxuICAgICAqICBUaGlzIGlzIGBgbnVsbGBgIGZvciBwZW5kaW5nIHRyYW5zYWN0aW9ucy5cbiAgICAgKi9cbiAgICBibG9ja0hhc2g7XG4gICAgLyoqXG4gICAgICogIFRoZSBpbmRleCB3aXRoaW4gdGhlIGJsb2NrIHRoYXQgdGhpcyB0cmFuc2FjdGlvbiByZXNpZGVzIGF0LlxuICAgICAqL1xuICAgIGluZGV4O1xuICAgIC8qKlxuICAgICAqICBUaGUgdHJhbnNhY3Rpb24gaGFzaC5cbiAgICAgKi9cbiAgICBoYXNoO1xuICAgIC8qKlxuICAgICAqICBUaGUgW1tsaW5rLWVpcC0yNzE4XV0gdHJhbnNhY3Rpb24gZW52ZWxvcGUgdHlwZS4gVGhpcyBpc1xuICAgICAqICBgYDBgYCBmb3IgbGVnYWN5IHRyYW5zYWN0aW9ucyB0eXBlcy5cbiAgICAgKi9cbiAgICB0eXBlO1xuICAgIC8qKlxuICAgICAqICBUaGUgcmVjZWl2ZXIgb2YgdGhpcyB0cmFuc2FjdGlvbi5cbiAgICAgKlxuICAgICAqICBJZiBgYG51bGxgYCwgdGhlbiB0aGUgdHJhbnNhY3Rpb24gaXMgYW4gaW5pdGNvZGUgdHJhbnNhY3Rpb24uXG4gICAgICogIFRoaXMgbWVhbnMgdGhlIHJlc3VsdCBvZiBleGVjdXRpbmcgdGhlIFtbZGF0YV1dIHdpbGwgYmUgZGVwbG95ZWRcbiAgICAgKiAgYXMgYSBuZXcgY29udHJhY3Qgb24gY2hhaW4gKGFzc3VtaW5nIGl0IGRvZXMgbm90IHJldmVydCkgYW5kIHRoZVxuICAgICAqICBhZGRyZXNzIG1heSBiZSBjb21wdXRlZCB1c2luZyBbW2dldENyZWF0ZUFkZHJlc3NdXS5cbiAgICAgKi9cbiAgICB0bztcbiAgICAvKipcbiAgICAgKiAgVGhlIHNlbmRlciBvZiB0aGlzIHRyYW5zYWN0aW9uLiBJdCBpcyBpbXBsaWNpdGx5IGNvbXB1dGVkXG4gICAgICogIGZyb20gdGhlIHRyYW5zYWN0aW9uIHByZS1pbWFnZSBoYXNoIChhcyB0aGUgZGlnZXN0KSBhbmQgdGhlXG4gICAgICogIFtbc2lnbmF0dXJlXV0gdXNpbmcgZWNyZWNvdmVyLlxuICAgICAqL1xuICAgIGZyb207XG4gICAgLyoqXG4gICAgICogIFRoZSBub25jZSwgd2hpY2ggaXMgdXNlZCB0byBwcmV2ZW50IHJlcGxheSBhdHRhY2tzIGFuZCBvZmZlclxuICAgICAqICBhIG1ldGhvZCB0byBlbnN1cmUgdHJhbnNhY3Rpb25zIGZyb20gYSBnaXZlbiBzZW5kZXIgYXJlIGV4cGxpY2l0bHlcbiAgICAgKiAgb3JkZXJlZC5cbiAgICAgKlxuICAgICAqICBXaGVuIHNlbmRpbmcgYSB0cmFuc2FjdGlvbiwgdGhpcyBtdXN0IGJlIGVxdWFsIHRvIHRoZSBudW1iZXIgb2ZcbiAgICAgKiAgdHJhbnNhY3Rpb25zIGV2ZXIgc2VudCBieSBbW2Zyb21dXS5cbiAgICAgKi9cbiAgICBub25jZTtcbiAgICAvKipcbiAgICAgKiAgVGhlIG1heGltdW0gdW5pdHMgb2YgZ2FzIHRoaXMgdHJhbnNhY3Rpb24gY2FuIGNvbnN1bWUuIElmIGV4ZWN1dGlvblxuICAgICAqICBleGNlZWRzIHRoaXMsIHRoZSBlbnRyaWVzIHRyYW5zYWN0aW9uIGlzIHJldmVydGVkIGFuZCB0aGUgc2VuZGVyXG4gICAgICogIGlzIGNoYXJnZWQgZm9yIHRoZSBmdWxsIGFtb3VudCwgZGVzcGl0ZSBub3Qgc3RhdGUgY2hhbmdlcyBiZWluZyBtYWRlLlxuICAgICAqL1xuICAgIGdhc0xpbWl0O1xuICAgIC8qKlxuICAgICAqICBUaGUgZ2FzIHByaWNlIGNhbiBoYXZlIHZhcmlvdXMgdmFsdWVzLCBkZXBlbmRpbmcgb24gdGhlIG5ldHdvcmsuXG4gICAgICpcbiAgICAgKiAgSW4gbW9kZXJuIG5ldHdvcmtzLCBmb3IgdHJhbnNhY3Rpb25zIHRoYXQgYXJlIGluY2x1ZGVkIHRoaXMgaXNcbiAgICAgKiAgdGhlIC8vZWZmZWN0aXZlIGdhcyBwcmljZS8vICh0aGUgZmVlIHBlciBnYXMgdGhhdCB3YXMgYWN0dWFsbHlcbiAgICAgKiAgY2hhcmdlZCksIHdoaWxlIGZvciB0cmFuc2FjdGlvbnMgdGhhdCBoYXZlIG5vdCBiZWVuIGluY2x1ZGVkIHlldFxuICAgICAqICBpcyB0aGUgW1ttYXhGZWVQZXJHYXNdXS5cbiAgICAgKlxuICAgICAqICBGb3IgbGVnYWN5IHRyYW5zYWN0aW9ucywgb3IgdHJhbnNhY3Rpb25zIG9uIGxlZ2FjeSBuZXR3b3JrcywgdGhpc1xuICAgICAqICBpcyB0aGUgZmVlIHRoYXQgd2lsbCBiZSBjaGFyZ2VkIHBlciB1bml0IG9mIGdhcyB0aGUgdHJhbnNhY3Rpb25cbiAgICAgKiAgY29uc3VtZXMuXG4gICAgICovXG4gICAgZ2FzUHJpY2U7XG4gICAgLyoqXG4gICAgICogIFRoZSBtYXhpbXVtIHByaW9yaXR5IGZlZSAocGVyIHVuaXQgb2YgZ2FzKSB0byBhbGxvdyBhXG4gICAgICogIHZhbGlkYXRvciB0byBjaGFyZ2UgdGhlIHNlbmRlci4gVGhpcyBpcyBpbmNsdXNpdmUgb2YgdGhlXG4gICAgICogIFtbbWF4RmVlRmVlUGVyR2FzXV0uXG4gICAgICovXG4gICAgbWF4UHJpb3JpdHlGZWVQZXJHYXM7XG4gICAgLyoqXG4gICAgICogIFRoZSBtYXhpbXVtIGZlZSAocGVyIHVuaXQgb2YgZ2FzKSB0byBhbGxvdyB0aGlzIHRyYW5zYWN0aW9uXG4gICAgICogIHRvIGNoYXJnZSB0aGUgc2VuZGVyLlxuICAgICAqL1xuICAgIG1heEZlZVBlckdhcztcbiAgICAvKipcbiAgICAgKiAgVGhlIFtbbGluay1laXAtNDg0NF1dIG1heCBmZWUgcGVyIEJMT2IgZ2FzLlxuICAgICAqL1xuICAgIG1heEZlZVBlckJsb2JHYXM7XG4gICAgLyoqXG4gICAgICogIFRoZSBkYXRhLlxuICAgICAqL1xuICAgIGRhdGE7XG4gICAgLyoqXG4gICAgICogIFRoZSB2YWx1ZSwgaW4gd2VpLiBVc2UgW1tmb3JtYXRFdGhlcl1dIHRvIGZvcm1hdCB0aGlzIHZhbHVlXG4gICAgICogIGFzIGV0aGVyLlxuICAgICAqL1xuICAgIHZhbHVlO1xuICAgIC8qKlxuICAgICAqICBUaGUgY2hhaW4gSUQuXG4gICAgICovXG4gICAgY2hhaW5JZDtcbiAgICAvKipcbiAgICAgKiAgVGhlIHNpZ25hdHVyZS5cbiAgICAgKi9cbiAgICBzaWduYXR1cmU7XG4gICAgLyoqXG4gICAgICogIFRoZSBbW2xpbmstZWlwLTI5MzBdXSBhY2Nlc3MgbGlzdCBmb3IgdHJhbnNhY3Rpb24gdHlwZXMgdGhhdFxuICAgICAqICBzdXBwb3J0IGl0LCBvdGhlcndpc2UgYGBudWxsYGAuXG4gICAgICovXG4gICAgYWNjZXNzTGlzdDtcbiAgICAvKipcbiAgICAgKiAgVGhlIFtbbGluay1laXAtNDg0NF1dIEJMT2IgdmVyc2lvbmVkIGhhc2hlcy5cbiAgICAgKi9cbiAgICBibG9iVmVyc2lvbmVkSGFzaGVzO1xuICAgIC8qKlxuICAgICAqICBUaGUgW1tsaW5rLWVpcC03NzAyXV0gYXV0aG9yaXphdGlvbnMgKGlmIGFueSkuXG4gICAgICovXG4gICAgYXV0aG9yaXphdGlvbkxpc3Q7XG4gICAgI3N0YXJ0QmxvY2s7XG4gICAgLyoqXG4gICAgICogIEBfaWdub3JlOlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHR4LCBwcm92aWRlcikge1xuICAgICAgICB0aGlzLnByb3ZpZGVyID0gcHJvdmlkZXI7XG4gICAgICAgIHRoaXMuYmxvY2tOdW1iZXIgPSAodHguYmxvY2tOdW1iZXIgIT0gbnVsbCkgPyB0eC5ibG9ja051bWJlciA6IG51bGw7XG4gICAgICAgIHRoaXMuYmxvY2tIYXNoID0gKHR4LmJsb2NrSGFzaCAhPSBudWxsKSA/IHR4LmJsb2NrSGFzaCA6IG51bGw7XG4gICAgICAgIHRoaXMuaGFzaCA9IHR4Lmhhc2g7XG4gICAgICAgIHRoaXMuaW5kZXggPSB0eC5pbmRleDtcbiAgICAgICAgdGhpcy50eXBlID0gdHgudHlwZTtcbiAgICAgICAgdGhpcy5mcm9tID0gdHguZnJvbTtcbiAgICAgICAgdGhpcy50byA9IHR4LnRvIHx8IG51bGw7XG4gICAgICAgIHRoaXMuZ2FzTGltaXQgPSB0eC5nYXNMaW1pdDtcbiAgICAgICAgdGhpcy5ub25jZSA9IHR4Lm5vbmNlO1xuICAgICAgICB0aGlzLmRhdGEgPSB0eC5kYXRhO1xuICAgICAgICB0aGlzLnZhbHVlID0gdHgudmFsdWU7XG4gICAgICAgIHRoaXMuZ2FzUHJpY2UgPSB0eC5nYXNQcmljZTtcbiAgICAgICAgdGhpcy5tYXhQcmlvcml0eUZlZVBlckdhcyA9ICh0eC5tYXhQcmlvcml0eUZlZVBlckdhcyAhPSBudWxsKSA/IHR4Lm1heFByaW9yaXR5RmVlUGVyR2FzIDogbnVsbDtcbiAgICAgICAgdGhpcy5tYXhGZWVQZXJHYXMgPSAodHgubWF4RmVlUGVyR2FzICE9IG51bGwpID8gdHgubWF4RmVlUGVyR2FzIDogbnVsbDtcbiAgICAgICAgdGhpcy5tYXhGZWVQZXJCbG9iR2FzID0gKHR4Lm1heEZlZVBlckJsb2JHYXMgIT0gbnVsbCkgPyB0eC5tYXhGZWVQZXJCbG9iR2FzIDogbnVsbDtcbiAgICAgICAgdGhpcy5jaGFpbklkID0gdHguY2hhaW5JZDtcbiAgICAgICAgdGhpcy5zaWduYXR1cmUgPSB0eC5zaWduYXR1cmU7XG4gICAgICAgIHRoaXMuYWNjZXNzTGlzdCA9ICh0eC5hY2Nlc3NMaXN0ICE9IG51bGwpID8gdHguYWNjZXNzTGlzdCA6IG51bGw7XG4gICAgICAgIHRoaXMuYmxvYlZlcnNpb25lZEhhc2hlcyA9ICh0eC5ibG9iVmVyc2lvbmVkSGFzaGVzICE9IG51bGwpID8gdHguYmxvYlZlcnNpb25lZEhhc2hlcyA6IG51bGw7XG4gICAgICAgIHRoaXMuYXV0aG9yaXphdGlvbkxpc3QgPSAodHguYXV0aG9yaXphdGlvbkxpc3QgIT0gbnVsbCkgPyB0eC5hdXRob3JpemF0aW9uTGlzdCA6IG51bGw7XG4gICAgICAgIHRoaXMuI3N0YXJ0QmxvY2sgPSAtMTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYSBKU09OLWNvbXBhdGlibGUgcmVwcmVzZW50YXRpb24gb2YgdGhpcyB0cmFuc2FjdGlvbi5cbiAgICAgKi9cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIGNvbnN0IHsgYmxvY2tOdW1iZXIsIGJsb2NrSGFzaCwgaW5kZXgsIGhhc2gsIHR5cGUsIHRvLCBmcm9tLCBub25jZSwgZGF0YSwgc2lnbmF0dXJlLCBhY2Nlc3NMaXN0LCBibG9iVmVyc2lvbmVkSGFzaGVzIH0gPSB0aGlzO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgX3R5cGU6IFwiVHJhbnNhY3Rpb25SZXNwb25zZVwiLFxuICAgICAgICAgICAgYWNjZXNzTGlzdCwgYmxvY2tOdW1iZXIsIGJsb2NrSGFzaCxcbiAgICAgICAgICAgIGJsb2JWZXJzaW9uZWRIYXNoZXMsXG4gICAgICAgICAgICBjaGFpbklkOiB0b0pzb24odGhpcy5jaGFpbklkKSxcbiAgICAgICAgICAgIGRhdGEsIGZyb20sXG4gICAgICAgICAgICBnYXNMaW1pdDogdG9Kc29uKHRoaXMuZ2FzTGltaXQpLFxuICAgICAgICAgICAgZ2FzUHJpY2U6IHRvSnNvbih0aGlzLmdhc1ByaWNlKSxcbiAgICAgICAgICAgIGhhc2gsXG4gICAgICAgICAgICBtYXhGZWVQZXJHYXM6IHRvSnNvbih0aGlzLm1heEZlZVBlckdhcyksXG4gICAgICAgICAgICBtYXhQcmlvcml0eUZlZVBlckdhczogdG9Kc29uKHRoaXMubWF4UHJpb3JpdHlGZWVQZXJHYXMpLFxuICAgICAgICAgICAgbWF4RmVlUGVyQmxvYkdhczogdG9Kc29uKHRoaXMubWF4RmVlUGVyQmxvYkdhcyksXG4gICAgICAgICAgICBub25jZSwgc2lnbmF0dXJlLCB0bywgaW5kZXgsIHR5cGUsXG4gICAgICAgICAgICB2YWx1ZTogdG9Kc29uKHRoaXMudmFsdWUpLFxuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmVzb2x2ZXMgdG8gdGhlIEJsb2NrIHRoYXQgdGhpcyB0cmFuc2FjdGlvbiB3YXMgaW5jbHVkZWQgaW4uXG4gICAgICpcbiAgICAgKiAgVGhpcyB3aWxsIHJldHVybiBudWxsIGlmIHRoZSB0cmFuc2FjdGlvbiBoYXMgbm90IGJlZW4gaW5jbHVkZWQgeWV0LlxuICAgICAqL1xuICAgIGFzeW5jIGdldEJsb2NrKCkge1xuICAgICAgICBsZXQgYmxvY2tOdW1iZXIgPSB0aGlzLmJsb2NrTnVtYmVyO1xuICAgICAgICBpZiAoYmxvY2tOdW1iZXIgPT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc3QgdHggPSBhd2FpdCB0aGlzLmdldFRyYW5zYWN0aW9uKCk7XG4gICAgICAgICAgICBpZiAodHgpIHtcbiAgICAgICAgICAgICAgICBibG9ja051bWJlciA9IHR4LmJsb2NrTnVtYmVyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChibG9ja051bWJlciA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBibG9jayA9IHRoaXMucHJvdmlkZXIuZ2V0QmxvY2soYmxvY2tOdW1iZXIpO1xuICAgICAgICBpZiAoYmxvY2sgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVE9ET1wiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYmxvY2s7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXNvbHZlcyB0byB0aGlzIHRyYW5zYWN0aW9uIGJlaW5nIHJlLXJlcXVlc3RlZCBmcm9tIHRoZVxuICAgICAqICBwcm92aWRlci4gVGhpcyBjYW4gYmUgdXNlZCBpZiB5b3UgaGF2ZSBhbiB1bm1pbmVkIHRyYW5zYWN0aW9uXG4gICAgICogIGFuZCB3aXNoIHRvIGdldCBhbiB1cC10by1kYXRlIHBvcHVsYXRlZCBpbnN0YW5jZS5cbiAgICAgKi9cbiAgICBhc3luYyBnZXRUcmFuc2FjdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJvdmlkZXIuZ2V0VHJhbnNhY3Rpb24odGhpcy5oYXNoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJlc29sdmUgdG8gdGhlIG51bWJlciBvZiBjb25maXJtYXRpb25zIHRoaXMgdHJhbnNhY3Rpb24gaGFzLlxuICAgICAqL1xuICAgIGFzeW5jIGNvbmZpcm1hdGlvbnMoKSB7XG4gICAgICAgIGlmICh0aGlzLmJsb2NrTnVtYmVyID09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgdHgsIGJsb2NrTnVtYmVyIH0gPSBhd2FpdCByZXNvbHZlUHJvcGVydGllcyh7XG4gICAgICAgICAgICAgICAgdHg6IHRoaXMuZ2V0VHJhbnNhY3Rpb24oKSxcbiAgICAgICAgICAgICAgICBibG9ja051bWJlcjogdGhpcy5wcm92aWRlci5nZXRCbG9ja051bWJlcigpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIE5vdCBtaW5lZCB5ZXQuLi5cbiAgICAgICAgICAgIGlmICh0eCA9PSBudWxsIHx8IHR4LmJsb2NrTnVtYmVyID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBibG9ja051bWJlciAtIHR4LmJsb2NrTnVtYmVyICsgMTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBibG9ja051bWJlciA9IGF3YWl0IHRoaXMucHJvdmlkZXIuZ2V0QmxvY2tOdW1iZXIoKTtcbiAgICAgICAgcmV0dXJuIGJsb2NrTnVtYmVyIC0gdGhpcy5ibG9ja051bWJlciArIDE7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXNvbHZlcyBvbmNlIHRoaXMgdHJhbnNhY3Rpb24gaGFzIGJlZW4gbWluZWQgYW5kIGhhc1xuICAgICAqICAlJWNvbmZpcm1zJSUgYmxvY2tzIGluY2x1ZGluZyBpdCAoZGVmYXVsdDogYGAxYGApIHdpdGggYW5cbiAgICAgKiAgb3B0aW9uYWwgJSV0aW1lb3V0JSUuXG4gICAgICpcbiAgICAgKiAgVGhpcyBjYW4gcmVzb2x2ZSB0byBgYG51bGxgYCBvbmx5IGlmICUlY29uZmlybXMlJSBpcyBgYDBgYFxuICAgICAqICBhbmQgdGhlIHRyYW5zYWN0aW9uIGhhcyBub3QgYmVlbiBtaW5lZCwgb3RoZXJ3aXNlIHRoaXMgd2lsbFxuICAgICAqICB3YWl0IHVudGlsIGVub3VnaCBjb25maXJtYXRpb25zIGhhdmUgY29tcGxldGVkLlxuICAgICAqL1xuICAgIGFzeW5jIHdhaXQoX2NvbmZpcm1zLCBfdGltZW91dCkge1xuICAgICAgICBjb25zdCBjb25maXJtcyA9IChfY29uZmlybXMgPT0gbnVsbCkgPyAxIDogX2NvbmZpcm1zO1xuICAgICAgICBjb25zdCB0aW1lb3V0ID0gKF90aW1lb3V0ID09IG51bGwpID8gMCA6IF90aW1lb3V0O1xuICAgICAgICBsZXQgc3RhcnRCbG9jayA9IHRoaXMuI3N0YXJ0QmxvY2s7XG4gICAgICAgIGxldCBuZXh0U2NhbiA9IC0xO1xuICAgICAgICBsZXQgc3RvcFNjYW5uaW5nID0gKHN0YXJ0QmxvY2sgPT09IC0xKSA/IHRydWUgOiBmYWxzZTtcbiAgICAgICAgY29uc3QgY2hlY2tSZXBsYWNlbWVudCA9IGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIC8vIEdldCB0aGUgY3VycmVudCB0cmFuc2FjdGlvbiBjb3VudCBmb3IgdGhpcyBzZW5kZXJcbiAgICAgICAgICAgIGlmIChzdG9wU2Nhbm5pbmcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHsgYmxvY2tOdW1iZXIsIG5vbmNlIH0gPSBhd2FpdCByZXNvbHZlUHJvcGVydGllcyh7XG4gICAgICAgICAgICAgICAgYmxvY2tOdW1iZXI6IHRoaXMucHJvdmlkZXIuZ2V0QmxvY2tOdW1iZXIoKSxcbiAgICAgICAgICAgICAgICBub25jZTogdGhpcy5wcm92aWRlci5nZXRUcmFuc2FjdGlvbkNvdW50KHRoaXMuZnJvbSlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gTm8gdHJhbnNhY3Rpb24gb3Igb3VyIG5vbmNlIGhhcyBub3QgYmVlbiBtaW5lZCB5ZXQ7IGJ1dCB3ZVxuICAgICAgICAgICAgLy8gY2FuIHN0YXJ0IHNjYW5uaW5nIGxhdGVyIHdoZW4gd2UgZG8gc3RhcnRcbiAgICAgICAgICAgIGlmIChub25jZSA8IHRoaXMubm9uY2UpIHtcbiAgICAgICAgICAgICAgICBzdGFydEJsb2NrID0gYmxvY2tOdW1iZXI7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gV2Ugd2VyZSBtaW5lZDsgbm8gcmVwbGFjZW1lbnRcbiAgICAgICAgICAgIGlmIChzdG9wU2Nhbm5pbmcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG1pbmVkID0gYXdhaXQgdGhpcy5nZXRUcmFuc2FjdGlvbigpO1xuICAgICAgICAgICAgaWYgKG1pbmVkICYmIG1pbmVkLmJsb2NrTnVtYmVyICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBXZSB3ZXJlIHJlcGxhY2VkOyBzdGFydCBzY2FubmluZyBmb3IgdGhhdCB0cmFuc2FjdGlvblxuICAgICAgICAgICAgLy8gU3RhcnRpbmcgdG8gc2NhbjsgbG9vayBiYWNrIGEgZmV3IGV4dHJhIGJsb2NrcyBmb3Igc2FmZXR5XG4gICAgICAgICAgICBpZiAobmV4dFNjYW4gPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgbmV4dFNjYW4gPSBzdGFydEJsb2NrIC0gMztcbiAgICAgICAgICAgICAgICBpZiAobmV4dFNjYW4gPCB0aGlzLiNzdGFydEJsb2NrKSB7XG4gICAgICAgICAgICAgICAgICAgIG5leHRTY2FuID0gdGhpcy4jc3RhcnRCbG9jaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3aGlsZSAobmV4dFNjYW4gPD0gYmxvY2tOdW1iZXIpIHtcbiAgICAgICAgICAgICAgICAvLyBHZXQgdGhlIG5leHQgYmxvY2sgdG8gc2NhblxuICAgICAgICAgICAgICAgIGlmIChzdG9wU2Nhbm5pbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGJsb2NrID0gYXdhaXQgdGhpcy5wcm92aWRlci5nZXRCbG9jayhuZXh0U2NhbiwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgLy8gVGhpcyBzaG91bGQgbm90IGhhcHBlbjsgYnV0IHdlJ2xsIHRyeSBhZ2FpbiBzaG9ydGx5XG4gICAgICAgICAgICAgICAgaWYgKGJsb2NrID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBXZSB3ZXJlIG1pbmVkOyBubyByZXBsYWNlbWVudFxuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgaGFzaCBvZiBibG9jaykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaGFzaCA9PT0gdGhpcy5oYXNoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gU2VhcmNoIGZvciB0aGUgdHJhbnNhY3Rpb24gdGhhdCByZXBsYWNlZCB1c1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYmxvY2subGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdHggPSBhd2FpdCBibG9jay5nZXRUcmFuc2FjdGlvbihpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR4LmZyb20gPT09IHRoaXMuZnJvbSAmJiB0eC5ub25jZSA9PT0gdGhpcy5ub25jZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gR2V0IHRoZSByZWNlaXB0XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3RvcFNjYW5uaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByZWNlaXB0ID0gYXdhaXQgdGhpcy5wcm92aWRlci5nZXRUcmFuc2FjdGlvblJlY2VpcHQodHguaGFzaCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIHNob3VsZCBub3QgaGFwcGVuOyBidXQgd2UnbGwgdHJ5IGFnYWluIHNob3J0bHlcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZWNlaXB0ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBXZSB3aWxsIHJldHJ5IHRoaXMgb24gdGhlIG5leHQgYmxvY2sgKHRoaXMgY2FzZSBjb3VsZCBiZSBvcHRpbWl6ZWQpXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKGJsb2NrTnVtYmVyIC0gcmVjZWlwdC5ibG9ja051bWJlciArIDEpIDwgY29uZmlybXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgcmVhc29uIHdlIHdlcmUgcmVwbGFjZWRcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCByZWFzb24gPSBcInJlcGxhY2VkXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHguZGF0YSA9PT0gdGhpcy5kYXRhICYmIHR4LnRvID09PSB0aGlzLnRvICYmIHR4LnZhbHVlID09PSB0aGlzLnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVhc29uID0gXCJyZXByaWNlZFwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodHguZGF0YSA9PT0gXCIweFwiICYmIHR4LmZyb20gPT09IHR4LnRvICYmIHR4LnZhbHVlID09PSBCTl8wKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVhc29uID0gXCJjYW5jZWxsZWRcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydChmYWxzZSwgXCJ0cmFuc2FjdGlvbiB3YXMgcmVwbGFjZWRcIiwgXCJUUkFOU0FDVElPTl9SRVBMQUNFRFwiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FuY2VsbGVkOiAocmVhc29uID09PSBcInJlcGxhY2VkXCIgfHwgcmVhc29uID09PSBcImNhbmNlbGxlZFwiKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWFzb24sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVwbGFjZW1lbnQ6IHR4LnJlcGxhY2VhYmxlVHJhbnNhY3Rpb24oc3RhcnRCbG9jayksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGFzaDogdHguaGFzaCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWNlaXB0XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBuZXh0U2NhbisrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBjaGVja1JlY2VpcHQgPSAocmVjZWlwdCkgPT4ge1xuICAgICAgICAgICAgaWYgKHJlY2VpcHQgPT0gbnVsbCB8fCByZWNlaXB0LnN0YXR1cyAhPT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZWNlaXB0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXNzZXJ0KGZhbHNlLCBcInRyYW5zYWN0aW9uIGV4ZWN1dGlvbiByZXZlcnRlZFwiLCBcIkNBTExfRVhDRVBUSU9OXCIsIHtcbiAgICAgICAgICAgICAgICBhY3Rpb246IFwic2VuZFRyYW5zYWN0aW9uXCIsXG4gICAgICAgICAgICAgICAgZGF0YTogbnVsbCwgcmVhc29uOiBudWxsLCBpbnZvY2F0aW9uOiBudWxsLCByZXZlcnQ6IG51bGwsXG4gICAgICAgICAgICAgICAgdHJhbnNhY3Rpb246IHtcbiAgICAgICAgICAgICAgICAgICAgdG86IHJlY2VpcHQudG8sXG4gICAgICAgICAgICAgICAgICAgIGZyb206IHJlY2VpcHQuZnJvbSxcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogXCJcIiAvLyBAVE9ETzogaW4gdjcsIHNwbGl0IG91dCBzZW5kVHJhbnNhY3Rpb24gcHJvcGVydGllc1xuICAgICAgICAgICAgICAgIH0sIHJlY2VpcHRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCByZWNlaXB0ID0gYXdhaXQgdGhpcy5wcm92aWRlci5nZXRUcmFuc2FjdGlvblJlY2VpcHQodGhpcy5oYXNoKTtcbiAgICAgICAgaWYgKGNvbmZpcm1zID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gY2hlY2tSZWNlaXB0KHJlY2VpcHQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZWNlaXB0KSB7XG4gICAgICAgICAgICBpZiAoY29uZmlybXMgPT09IDEgfHwgKGF3YWl0IHJlY2VpcHQuY29uZmlybWF0aW9ucygpKSA+PSBjb25maXJtcykge1xuICAgICAgICAgICAgICAgIHJldHVybiBjaGVja1JlY2VpcHQocmVjZWlwdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBDaGVjayBmb3IgYSByZXBsYWNlbWVudDsgdGhyb3dzIGlmIGEgcmVwbGFjZW1lbnQgd2FzIGZvdW5kXG4gICAgICAgICAgICBhd2FpdCBjaGVja1JlcGxhY2VtZW50KCk7XG4gICAgICAgICAgICAvLyBBbGxvdyBudWxsIG9ubHkgd2hlbiB0aGUgY29uZmlybXMgaXMgMFxuICAgICAgICAgICAgaWYgKGNvbmZpcm1zID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgd2FpdGVyID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgLy8gTGlzdCBvZiB0aGluZ3MgdG8gY2FuY2VsIHdoZW4gd2UgaGF2ZSBhIHJlc3VsdCAob25lIHdheSBvciB0aGUgb3RoZXIpXG4gICAgICAgICAgICBjb25zdCBjYW5jZWxsZXJzID0gW107XG4gICAgICAgICAgICBjb25zdCBjYW5jZWwgPSAoKSA9PiB7IGNhbmNlbGxlcnMuZm9yRWFjaCgoYykgPT4gYygpKTsgfTtcbiAgICAgICAgICAgIC8vIE9uIGNhbmNlbCwgc3RvcCBzY2FubmluZyBmb3IgcmVwbGFjZW1lbnRzXG4gICAgICAgICAgICBjYW5jZWxsZXJzLnB1c2goKCkgPT4geyBzdG9wU2Nhbm5pbmcgPSB0cnVlOyB9KTtcbiAgICAgICAgICAgIC8vIFNldCB1cCBhbnkgdGltZW91dCByZXF1ZXN0ZWRcbiAgICAgICAgICAgIGlmICh0aW1lb3V0ID4gMCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNhbmNlbCgpO1xuICAgICAgICAgICAgICAgICAgICByZWplY3QobWFrZUVycm9yKFwid2FpdCBmb3IgdHJhbnNhY3Rpb24gdGltZW91dFwiLCBcIlRJTUVPVVRcIikpO1xuICAgICAgICAgICAgICAgIH0sIHRpbWVvdXQpO1xuICAgICAgICAgICAgICAgIGNhbmNlbGxlcnMucHVzaCgoKSA9PiB7IGNsZWFyVGltZW91dCh0aW1lcik7IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgdHhMaXN0ZW5lciA9IGFzeW5jIChyZWNlaXB0KSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gRG9uZTsgcmV0dXJuIGl0IVxuICAgICAgICAgICAgICAgIGlmICgoYXdhaXQgcmVjZWlwdC5jb25maXJtYXRpb25zKCkpID49IGNvbmZpcm1zKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbmNlbCgpO1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShjaGVja1JlY2VpcHQocmVjZWlwdCkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjYW5jZWxsZXJzLnB1c2goKCkgPT4geyB0aGlzLnByb3ZpZGVyLm9mZih0aGlzLmhhc2gsIHR4TGlzdGVuZXIpOyB9KTtcbiAgICAgICAgICAgIHRoaXMucHJvdmlkZXIub24odGhpcy5oYXNoLCB0eExpc3RlbmVyKTtcbiAgICAgICAgICAgIC8vIFdlIHN1cHBvcnQgcmVwbGFjZW1lbnQgZGV0ZWN0aW9uOyBzdGFydCBjaGVja2luZ1xuICAgICAgICAgICAgaWYgKHN0YXJ0QmxvY2sgPj0gMCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlcGxhY2VMaXN0ZW5lciA9IGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIENoZWNrIGZvciBhIHJlcGxhY2VtZW50OyB0aGlzIHRocm93cyBvbmx5IGlmIG9uZSBpcyBmb3VuZFxuICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgY2hlY2tSZXBsYWNlbWVudCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2Ugd2VyZSByZXBsYWNlZCAod2l0aCBlbm91Z2ggY29uZmlybXMpOyByZS10aHJvdyB0aGUgZXJyb3JcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc0Vycm9yKGVycm9yLCBcIlRSQU5TQUNUSU9OX1JFUExBQ0VEXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FuY2VsKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gUmVzY2hldWRsZSBhIGNoZWNrIG9uIHRoZSBuZXh0IGJsb2NrXG4gICAgICAgICAgICAgICAgICAgIGlmICghc3RvcFNjYW5uaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnByb3ZpZGVyLm9uY2UoXCJibG9ja1wiLCByZXBsYWNlTGlzdGVuZXIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBjYW5jZWxsZXJzLnB1c2goKCkgPT4geyB0aGlzLnByb3ZpZGVyLm9mZihcImJsb2NrXCIsIHJlcGxhY2VMaXN0ZW5lcik7IH0pO1xuICAgICAgICAgICAgICAgIHRoaXMucHJvdmlkZXIub25jZShcImJsb2NrXCIsIHJlcGxhY2VMaXN0ZW5lcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gYXdhaXQgd2FpdGVyO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBgYHRydWVgYCBpZiB0aGlzIHRyYW5zYWN0aW9uIGhhcyBiZWVuIGluY2x1ZGVkLlxuICAgICAqXG4gICAgICogIFRoaXMgaXMgZWZmZWN0aXZlIG9ubHkgYXMgb2YgdGhlIHRpbWUgdGhlIFRyYW5zYWN0aW9uUmVzcG9uc2VcbiAgICAgKiAgd2FzIGluc3RhbnRpYXRlZC4gVG8gZ2V0IHVwLXRvLWRhdGUgaW5mb3JtYXRpb24sIHVzZVxuICAgICAqICBbW2dldFRyYW5zYWN0aW9uXV0uXG4gICAgICpcbiAgICAgKiAgVGhpcyBwcm92aWRlcyBhIFR5cGUgR3VhcmQgdGhhdCB0aGlzIHRyYW5zYWN0aW9uIHdpbGwgaGF2ZVxuICAgICAqICBub24tbnVsbCBwcm9wZXJ0eSB2YWx1ZXMgZm9yIHByb3BlcnRpZXMgdGhhdCBhcmUgbnVsbCBmb3JcbiAgICAgKiAgdW5taW5lZCB0cmFuc2FjdGlvbnMuXG4gICAgICovXG4gICAgaXNNaW5lZCgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLmJsb2NrSGFzaCAhPSBudWxsKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdHJ1ZSBpZiB0aGUgdHJhbnNhY3Rpb24gaXMgYSBsZWdhY3kgKGkuZS4gYGB0eXBlID09IDBgYClcbiAgICAgKiAgdHJhbnNhY3Rpb24uXG4gICAgICpcbiAgICAgKiAgVGhpcyBwcm92aWRlcyBhIFR5cGUgR3VhcmQgdGhhdCB0aGlzIHRyYW5zYWN0aW9uIHdpbGwgaGF2ZVxuICAgICAqICB0aGUgYGBudWxsYGAtbmVzcyBmb3IgaGFyZGZvcmstc3BlY2lmaWMgcHJvcGVydGllcyBzZXQgY29ycmVjdGx5LlxuICAgICAqL1xuICAgIGlzTGVnYWN5KCkge1xuICAgICAgICByZXR1cm4gKHRoaXMudHlwZSA9PT0gMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRydWUgaWYgdGhlIHRyYW5zYWN0aW9uIGlzIGEgQmVybGluIChpLmUuIGBgdHlwZSA9PSAxYGApXG4gICAgICogIHRyYW5zYWN0aW9uLiBTZWUgW1tsaW5rLWVpcC0yMDcwXV0uXG4gICAgICpcbiAgICAgKiAgVGhpcyBwcm92aWRlcyBhIFR5cGUgR3VhcmQgdGhhdCB0aGlzIHRyYW5zYWN0aW9uIHdpbGwgaGF2ZVxuICAgICAqICB0aGUgYGBudWxsYGAtbmVzcyBmb3IgaGFyZGZvcmstc3BlY2lmaWMgcHJvcGVydGllcyBzZXQgY29ycmVjdGx5LlxuICAgICAqL1xuICAgIGlzQmVybGluKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMudHlwZSA9PT0gMSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRydWUgaWYgdGhlIHRyYW5zYWN0aW9uIGlzIGEgTG9uZG9uIChpLmUuIGBgdHlwZSA9PSAyYGApXG4gICAgICogIHRyYW5zYWN0aW9uLiBTZWUgW1tsaW5rLWVpcC0xNTU5XV0uXG4gICAgICpcbiAgICAgKiAgVGhpcyBwcm92aWRlcyBhIFR5cGUgR3VhcmQgdGhhdCB0aGlzIHRyYW5zYWN0aW9uIHdpbGwgaGF2ZVxuICAgICAqICB0aGUgYGBudWxsYGAtbmVzcyBmb3IgaGFyZGZvcmstc3BlY2lmaWMgcHJvcGVydGllcyBzZXQgY29ycmVjdGx5LlxuICAgICAqL1xuICAgIGlzTG9uZG9uKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMudHlwZSA9PT0gMik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRydWUgaWYgaHRlIHRyYW5zYWN0aW9uIGlzIGEgQ2FuY3VuIChpLmUuIGBgdHlwZSA9PSAzYGApXG4gICAgICogIHRyYW5zYWN0aW9uLiBTZWUgW1tsaW5rLWVpcC00ODQ0XV0uXG4gICAgICovXG4gICAgaXNDYW5jdW4oKSB7XG4gICAgICAgIHJldHVybiAodGhpcy50eXBlID09PSAzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYSBmaWx0ZXIgd2hpY2ggY2FuIGJlIHVzZWQgdG8gbGlzdGVuIGZvciBvcnBoYW4gZXZlbnRzXG4gICAgICogIHRoYXQgZXZpY3QgdGhpcyB0cmFuc2FjdGlvbi5cbiAgICAgKi9cbiAgICByZW1vdmVkRXZlbnQoKSB7XG4gICAgICAgIGFzc2VydCh0aGlzLmlzTWluZWQoKSwgXCJ1bm1pbmVkIHRyYW5zYWN0aW9uIGNhbm90IGJlIG9ycGhhbmVkXCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHsgb3BlcmF0aW9uOiBcInJlbW92ZUV2ZW50KClcIiB9KTtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZVJlbW92ZWRUcmFuc2FjdGlvbkZpbHRlcih0aGlzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYSBmaWx0ZXIgd2hpY2ggY2FuIGJlIHVzZWQgdG8gbGlzdGVuIGZvciBvcnBoYW4gZXZlbnRzXG4gICAgICogIHRoYXQgcmUtb3JkZXIgdGhpcyBldmVudCBhZ2FpbnN0ICUlb3RoZXIlJS5cbiAgICAgKi9cbiAgICByZW9yZGVyZWRFdmVudChvdGhlcikge1xuICAgICAgICBhc3NlcnQodGhpcy5pc01pbmVkKCksIFwidW5taW5lZCB0cmFuc2FjdGlvbiBjYW5vdCBiZSBvcnBoYW5lZFwiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7IG9wZXJhdGlvbjogXCJyZW1vdmVFdmVudCgpXCIgfSk7XG4gICAgICAgIGFzc2VydCghb3RoZXIgfHwgb3RoZXIuaXNNaW5lZCgpLCBcInVubWluZWQgJ290aGVyJyB0cmFuc2FjdGlvbiBjYW5vdCBiZSBvcnBoYW5lZFwiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7IG9wZXJhdGlvbjogXCJyZW1vdmVFdmVudCgpXCIgfSk7XG4gICAgICAgIHJldHVybiBjcmVhdGVSZW9yZGVyZWRUcmFuc2FjdGlvbkZpbHRlcih0aGlzLCBvdGhlcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGEgbmV3IFRyYW5zYWN0aW9uUmVzcG9uc2UgaW5zdGFuY2Ugd2hpY2ggaGFzIHRoZSBhYmlsaXR5IHRvXG4gICAgICogIGRldGVjdCAoYW5kIHRocm93IGFuIGVycm9yKSBpZiB0aGUgdHJhbnNhY3Rpb24gaXMgcmVwbGFjZWQsIHdoaWNoXG4gICAgICogIHdpbGwgYmVnaW4gc2Nhbm5pbmcgYXQgJSVzdGFydEJsb2NrJSUuXG4gICAgICpcbiAgICAgKiAgVGhpcyBzaG91bGQgZ2VuZXJhbGx5IG5vdCBiZSB1c2VkIGJ5IGRldmVsb3BlcnMgYW5kIGlzIGludGVuZGVkXG4gICAgICogIHByaW1hcmlseSBmb3IgaW50ZXJuYWwgdXNlLiBTZXR0aW5nIGFuIGluY29ycmVjdCAlJXN0YXJ0QmxvY2slJSBjYW5cbiAgICAgKiAgaGF2ZSBkZXZhc3RhdGluZyBwZXJmb3JtYW5jZSBjb25zZXF1ZW5jZXMgaWYgdXNlZCBpbmNvcnJlY3RseS5cbiAgICAgKi9cbiAgICByZXBsYWNlYWJsZVRyYW5zYWN0aW9uKHN0YXJ0QmxvY2spIHtcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQoTnVtYmVyLmlzSW50ZWdlcihzdGFydEJsb2NrKSAmJiBzdGFydEJsb2NrID49IDAsIFwiaW52YWxpZCBzdGFydEJsb2NrXCIsIFwic3RhcnRCbG9ja1wiLCBzdGFydEJsb2NrKTtcbiAgICAgICAgY29uc3QgdHggPSBuZXcgVHJhbnNhY3Rpb25SZXNwb25zZSh0aGlzLCB0aGlzLnByb3ZpZGVyKTtcbiAgICAgICAgdHguI3N0YXJ0QmxvY2sgPSBzdGFydEJsb2NrO1xuICAgICAgICByZXR1cm4gdHg7XG4gICAgfVxufVxuZnVuY3Rpb24gY3JlYXRlT3JwaGFuZWRCbG9ja0ZpbHRlcihibG9jaykge1xuICAgIHJldHVybiB7IG9ycGhhbjogXCJkcm9wLWJsb2NrXCIsIGhhc2g6IGJsb2NrLmhhc2gsIG51bWJlcjogYmxvY2subnVtYmVyIH07XG59XG5mdW5jdGlvbiBjcmVhdGVSZW9yZGVyZWRUcmFuc2FjdGlvbkZpbHRlcih0eCwgb3RoZXIpIHtcbiAgICByZXR1cm4geyBvcnBoYW46IFwicmVvcmRlci10cmFuc2FjdGlvblwiLCB0eCwgb3RoZXIgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVJlbW92ZWRUcmFuc2FjdGlvbkZpbHRlcih0eCkge1xuICAgIHJldHVybiB7IG9ycGhhbjogXCJkcm9wLXRyYW5zYWN0aW9uXCIsIHR4IH07XG59XG5mdW5jdGlvbiBjcmVhdGVSZW1vdmVkTG9nRmlsdGVyKGxvZykge1xuICAgIHJldHVybiB7IG9ycGhhbjogXCJkcm9wLWxvZ1wiLCBsb2c6IHtcbiAgICAgICAgICAgIHRyYW5zYWN0aW9uSGFzaDogbG9nLnRyYW5zYWN0aW9uSGFzaCxcbiAgICAgICAgICAgIGJsb2NrSGFzaDogbG9nLmJsb2NrSGFzaCxcbiAgICAgICAgICAgIGJsb2NrTnVtYmVyOiBsb2cuYmxvY2tOdW1iZXIsXG4gICAgICAgICAgICBhZGRyZXNzOiBsb2cuYWRkcmVzcyxcbiAgICAgICAgICAgIGRhdGE6IGxvZy5kYXRhLFxuICAgICAgICAgICAgdG9waWNzOiBPYmplY3QuZnJlZXplKGxvZy50b3BpY3Muc2xpY2UoKSksXG4gICAgICAgICAgICBpbmRleDogbG9nLmluZGV4XG4gICAgICAgIH0gfTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXByb3ZpZGVyLmpzLm1hcCJdLCJuYW1lcyI6WyJkZWZpbmVQcm9wZXJ0aWVzIiwiZ2V0QmlnSW50IiwiZ2V0TnVtYmVyIiwiaGV4bGlmeSIsImlzQnl0ZXNMaWtlIiwicmVzb2x2ZVByb3BlcnRpZXMiLCJhc3NlcnQiLCJhc3NlcnRBcmd1bWVudCIsImlzRXJyb3IiLCJtYWtlRXJyb3IiLCJhY2Nlc3NMaXN0aWZ5IiwiQk5fMCIsIkJpZ0ludCIsImdldFZhbHVlIiwidmFsdWUiLCJ0b0pzb24iLCJ0b1N0cmluZyIsIkZlZURhdGEiLCJjb25zdHJ1Y3RvciIsImdhc1ByaWNlIiwibWF4RmVlUGVyR2FzIiwibWF4UHJpb3JpdHlGZWVQZXJHYXMiLCJ0b0pTT04iLCJfdHlwZSIsImNvcHlSZXF1ZXN0IiwicmVxIiwicmVzdWx0IiwidG8iLCJmcm9tIiwiZGF0YSIsImJpZ0ludEtleXMiLCJzcGxpdCIsImtleSIsIm51bWJlcktleXMiLCJhY2Nlc3NMaXN0IiwiYXV0aG9yaXphdGlvbkxpc3QiLCJzbGljZSIsImJsb2NrVGFnIiwiZW5hYmxlQ2NpcFJlYWQiLCJjdXN0b21EYXRhIiwiYmxvYlZlcnNpb25lZEhhc2hlcyIsImt6ZyIsImJsb2JzIiwibWFwIiwiYiIsIk9iamVjdCIsImFzc2lnbiIsIkJsb2NrIiwidHJhbnNhY3Rpb25zIiwiYmxvY2siLCJwcm92aWRlciIsInR4IiwiVHJhbnNhY3Rpb25SZXNwb25zZSIsImhhc2giLCJudW1iZXIiLCJ0aW1lc3RhbXAiLCJwYXJlbnRIYXNoIiwicGFyZW50QmVhY29uQmxvY2tSb290Iiwibm9uY2UiLCJkaWZmaWN1bHR5IiwiZ2FzTGltaXQiLCJnYXNVc2VkIiwiYmxvYkdhc1VzZWQiLCJleGNlc3NCbG9iR2FzIiwibWluZXIiLCJwcmV2UmFuZGFvIiwiZXh0cmFEYXRhIiwiYmFzZUZlZVBlckdhcyIsInN0YXRlUm9vdCIsInJlY2VpcHRzUm9vdCIsInByZWZldGNoZWRUcmFuc2FjdGlvbnMiLCJ0eHMiLCJsZW5ndGgiLCJvcGVyYXRpb24iLCJTeW1ib2wiLCJpdGVyYXRvciIsImluZGV4IiwibmV4dCIsImRvbmUiLCJ1bmRlZmluZWQiLCJkYXRlIiwiRGF0ZSIsImdldFRyYW5zYWN0aW9uIiwiaW5kZXhPckhhc2giLCJ0b0xvd2VyQ2FzZSIsInYiLCJFcnJvciIsImdldFByZWZldGNoZWRUcmFuc2FjdGlvbiIsImlzTWluZWQiLCJpc0xvbmRvbiIsIm9ycGhhbmVkRXZlbnQiLCJjcmVhdGVPcnBoYW5lZEJsb2NrRmlsdGVyIiwiTG9nIiwibG9nIiwidG9waWNzIiwiZnJlZXplIiwidHJhbnNhY3Rpb25IYXNoIiwiYmxvY2tIYXNoIiwiYmxvY2tOdW1iZXIiLCJyZW1vdmVkIiwiYWRkcmVzcyIsInRyYW5zYWN0aW9uSW5kZXgiLCJnZXRCbG9jayIsImdldFRyYW5zYWN0aW9uUmVjZWlwdCIsInJlY2VpcHQiLCJyZW1vdmVkRXZlbnQiLCJjcmVhdGVSZW1vdmVkTG9nRmlsdGVyIiwiVHJhbnNhY3Rpb25SZWNlaXB0IiwibG9ncyIsImVmZmVjdGl2ZUdhc1ByaWNlIiwiY29udHJhY3RBZGRyZXNzIiwibG9nc0Jsb29tIiwiY3VtdWxhdGl2ZUdhc1VzZWQiLCJibG9iR2FzUHJpY2UiLCJ0eXBlIiwic3RhdHVzIiwicm9vdCIsImZlZSIsImdldFJlc3VsdCIsImdldFRyYW5zYWN0aW9uUmVzdWx0IiwiY29uZmlybWF0aW9ucyIsImdldEJsb2NrTnVtYmVyIiwiY3JlYXRlUmVtb3ZlZFRyYW5zYWN0aW9uRmlsdGVyIiwicmVvcmRlcmVkRXZlbnQiLCJvdGhlciIsImNyZWF0ZVJlb3JkZXJlZFRyYW5zYWN0aW9uRmlsdGVyIiwic3RhcnRCbG9jayIsIm1heEZlZVBlckJsb2JHYXMiLCJjaGFpbklkIiwic2lnbmF0dXJlIiwid2FpdCIsIl9jb25maXJtcyIsIl90aW1lb3V0IiwiY29uZmlybXMiLCJ0aW1lb3V0IiwibmV4dFNjYW4iLCJzdG9wU2Nhbm5pbmciLCJjaGVja1JlcGxhY2VtZW50IiwiZ2V0VHJhbnNhY3Rpb25Db3VudCIsIm1pbmVkIiwiaSIsInJlYXNvbiIsImNhbmNlbGxlZCIsInJlcGxhY2VtZW50IiwicmVwbGFjZWFibGVUcmFuc2FjdGlvbiIsImNoZWNrUmVjZWlwdCIsImFjdGlvbiIsImludm9jYXRpb24iLCJyZXZlcnQiLCJ0cmFuc2FjdGlvbiIsIndhaXRlciIsIlByb21pc2UiLCJyZXNvbHZlIiwicmVqZWN0IiwiY2FuY2VsbGVycyIsImNhbmNlbCIsImZvckVhY2giLCJjIiwicHVzaCIsInRpbWVyIiwic2V0VGltZW91dCIsImNsZWFyVGltZW91dCIsInR4TGlzdGVuZXIiLCJlcnJvciIsIm9mZiIsIm9uIiwicmVwbGFjZUxpc3RlbmVyIiwib25jZSIsImlzTGVnYWN5IiwiaXNCZXJsaW4iLCJpc0NhbmN1biIsIk51bWJlciIsImlzSW50ZWdlciIsIm9ycGhhbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.esm/providers/provider.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.esm/providers/subscriber-filterid.js":
/*!**********************************************************************!*\
  !*** ./node_modules/ethers/lib.esm/providers/subscriber-filterid.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FilterIdEventSubscriber: () => (/* binding */ FilterIdEventSubscriber),\n/* harmony export */   FilterIdPendingSubscriber: () => (/* binding */ FilterIdPendingSubscriber),\n/* harmony export */   FilterIdSubscriber: () => (/* binding */ FilterIdSubscriber)\n/* harmony export */ });\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/errors.js\");\n/* harmony import */ var _subscriber_polling_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./subscriber-polling.js */ \"(ssr)/./node_modules/ethers/lib.esm/providers/subscriber-polling.js\");\n\n\nfunction copy(obj) {\n    return JSON.parse(JSON.stringify(obj));\n}\n/**\n *  Some backends support subscribing to events using a Filter ID.\n *\n *  When subscribing with this technique, the node issues a unique\n *  //Filter ID//. At this point the node dedicates resources to\n *  the filter, so that periodic calls to follow up on the //Filter ID//\n *  will receive any events since the last call.\n *\n *  @_docloc: api/providers/abstract-provider\n */ class FilterIdSubscriber {\n    #provider;\n    #filterIdPromise;\n    #poller;\n    #running;\n    #network;\n    #hault;\n    /**\n     *  Creates a new **FilterIdSubscriber** which will used [[_subscribe]]\n     *  and [[_emitResults]] to setup the subscription and provide the event\n     *  to the %%provider%%.\n     */ constructor(provider){\n        this.#provider = provider;\n        this.#filterIdPromise = null;\n        this.#poller = this.#poll.bind(this);\n        this.#running = false;\n        this.#network = null;\n        this.#hault = false;\n    }\n    /**\n     *  Sub-classes **must** override this to begin the subscription.\n     */ _subscribe(provider) {\n        throw new Error(\"subclasses must override this\");\n    }\n    /**\n     *  Sub-classes **must** override this handle the events.\n     */ _emitResults(provider, result) {\n        throw new Error(\"subclasses must override this\");\n    }\n    /**\n     *  Sub-classes **must** override this handle recovery on errors.\n     */ _recover(provider) {\n        throw new Error(\"subclasses must override this\");\n    }\n    async #poll(blockNumber) {\n        try {\n            // Subscribe if necessary\n            if (this.#filterIdPromise == null) {\n                this.#filterIdPromise = this._subscribe(this.#provider);\n            }\n            // Get the Filter ID\n            let filterId = null;\n            try {\n                filterId = await this.#filterIdPromise;\n            } catch (error) {\n                if (!(0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.isError)(error, \"UNSUPPORTED_OPERATION\") || error.operation !== \"eth_newFilter\") {\n                    throw error;\n                }\n            }\n            // The backend does not support Filter ID; downgrade to\n            // polling\n            if (filterId == null) {\n                this.#filterIdPromise = null;\n                this.#provider._recoverSubscriber(this, this._recover(this.#provider));\n                return;\n            }\n            const network = await this.#provider.getNetwork();\n            if (!this.#network) {\n                this.#network = network;\n            }\n            if (this.#network.chainId !== network.chainId) {\n                throw new Error(\"chaid changed\");\n            }\n            if (this.#hault) {\n                return;\n            }\n            const result = await this.#provider.send(\"eth_getFilterChanges\", [\n                filterId\n            ]);\n            await this._emitResults(this.#provider, result);\n        } catch (error) {\n            console.log(\"@TODO\", error);\n        }\n        this.#provider.once(\"block\", this.#poller);\n    }\n    #teardown() {\n        const filterIdPromise = this.#filterIdPromise;\n        if (filterIdPromise) {\n            this.#filterIdPromise = null;\n            filterIdPromise.then((filterId)=>{\n                if (this.#provider.destroyed) {\n                    return;\n                }\n                this.#provider.send(\"eth_uninstallFilter\", [\n                    filterId\n                ]);\n            });\n        }\n    }\n    start() {\n        if (this.#running) {\n            return;\n        }\n        this.#running = true;\n        this.#poll(-2);\n    }\n    stop() {\n        if (!this.#running) {\n            return;\n        }\n        this.#running = false;\n        this.#hault = true;\n        this.#teardown();\n        this.#provider.off(\"block\", this.#poller);\n    }\n    pause(dropWhilePaused) {\n        if (dropWhilePaused) {\n            this.#teardown();\n        }\n        this.#provider.off(\"block\", this.#poller);\n    }\n    resume() {\n        this.start();\n    }\n}\n/**\n *  A **FilterIdSubscriber** for receiving contract events.\n *\n *  @_docloc: api/providers/abstract-provider\n */ class FilterIdEventSubscriber extends FilterIdSubscriber {\n    #event;\n    /**\n     *  Creates a new **FilterIdEventSubscriber** attached to %%provider%%\n     *  listening for %%filter%%.\n     */ constructor(provider, filter){\n        super(provider);\n        this.#event = copy(filter);\n    }\n    _recover(provider) {\n        return new _subscriber_polling_js__WEBPACK_IMPORTED_MODULE_1__.PollingEventSubscriber(provider, this.#event);\n    }\n    async _subscribe(provider) {\n        const filterId = await provider.send(\"eth_newFilter\", [\n            this.#event\n        ]);\n        return filterId;\n    }\n    async _emitResults(provider, results) {\n        for (const result of results){\n            provider.emit(this.#event, provider._wrapLog(result, provider._network));\n        }\n    }\n}\n/**\n *  A **FilterIdSubscriber** for receiving pending transactions events.\n *\n *  @_docloc: api/providers/abstract-provider\n */ class FilterIdPendingSubscriber extends FilterIdSubscriber {\n    async _subscribe(provider) {\n        return await provider.send(\"eth_newPendingTransactionFilter\", []);\n    }\n    async _emitResults(provider, results) {\n        for (const result of results){\n            provider.emit(\"pending\", result);\n        }\n    }\n} //# sourceMappingURL=subscriber-filterid.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vcHJvdmlkZXJzL3N1YnNjcmliZXItZmlsdGVyaWQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBNEM7QUFDcUI7QUFDakUsU0FBU0UsS0FBS0MsR0FBRztJQUNiLE9BQU9DLEtBQUtDLEtBQUssQ0FBQ0QsS0FBS0UsU0FBUyxDQUFDSDtBQUNyQztBQUNBOzs7Ozs7Ozs7Q0FTQyxHQUNNLE1BQU1JO0lBQ1QsQ0FBQ0MsUUFBUSxDQUFDO0lBQ1YsQ0FBQ0MsZUFBZSxDQUFDO0lBQ2pCLENBQUNDLE1BQU0sQ0FBQztJQUNSLENBQUNDLE9BQU8sQ0FBQztJQUNULENBQUNDLE9BQU8sQ0FBQztJQUNULENBQUNDLEtBQUssQ0FBQztJQUNQOzs7O0tBSUMsR0FDREMsWUFBWU4sUUFBUSxDQUFFO1FBQ2xCLElBQUksQ0FBQyxDQUFDQSxRQUFRLEdBQUdBO1FBQ2pCLElBQUksQ0FBQyxDQUFDQyxlQUFlLEdBQUc7UUFDeEIsSUFBSSxDQUFDLENBQUNDLE1BQU0sR0FBRyxJQUFJLENBQUMsQ0FBQ0ssSUFBSSxDQUFDQyxJQUFJLENBQUMsSUFBSTtRQUNuQyxJQUFJLENBQUMsQ0FBQ0wsT0FBTyxHQUFHO1FBQ2hCLElBQUksQ0FBQyxDQUFDQyxPQUFPLEdBQUc7UUFDaEIsSUFBSSxDQUFDLENBQUNDLEtBQUssR0FBRztJQUNsQjtJQUNBOztLQUVDLEdBQ0RJLFdBQVdULFFBQVEsRUFBRTtRQUNqQixNQUFNLElBQUlVLE1BQU07SUFDcEI7SUFDQTs7S0FFQyxHQUNEQyxhQUFhWCxRQUFRLEVBQUVZLE1BQU0sRUFBRTtRQUMzQixNQUFNLElBQUlGLE1BQU07SUFDcEI7SUFDQTs7S0FFQyxHQUNERyxTQUFTYixRQUFRLEVBQUU7UUFDZixNQUFNLElBQUlVLE1BQU07SUFDcEI7SUFDQSxNQUFNLENBQUNILElBQUksQ0FBQ08sV0FBVztRQUNuQixJQUFJO1lBQ0EseUJBQXlCO1lBQ3pCLElBQUksSUFBSSxDQUFDLENB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cm9udGVuZC8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9wcm92aWRlcnMvc3Vic2NyaWJlci1maWx0ZXJpZC5qcz85YzIzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGlzRXJyb3IgfSBmcm9tIFwiLi4vdXRpbHMvaW5kZXguanNcIjtcbmltcG9ydCB7IFBvbGxpbmdFdmVudFN1YnNjcmliZXIgfSBmcm9tIFwiLi9zdWJzY3JpYmVyLXBvbGxpbmcuanNcIjtcbmZ1bmN0aW9uIGNvcHkob2JqKSB7XG4gICAgcmV0dXJuIEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkob2JqKSk7XG59XG4vKipcbiAqICBTb21lIGJhY2tlbmRzIHN1cHBvcnQgc3Vic2NyaWJpbmcgdG8gZXZlbnRzIHVzaW5nIGEgRmlsdGVyIElELlxuICpcbiAqICBXaGVuIHN1YnNjcmliaW5nIHdpdGggdGhpcyB0ZWNobmlxdWUsIHRoZSBub2RlIGlzc3VlcyBhIHVuaXF1ZVxuICogIC8vRmlsdGVyIElELy8uIEF0IHRoaXMgcG9pbnQgdGhlIG5vZGUgZGVkaWNhdGVzIHJlc291cmNlcyB0b1xuICogIHRoZSBmaWx0ZXIsIHNvIHRoYXQgcGVyaW9kaWMgY2FsbHMgdG8gZm9sbG93IHVwIG9uIHRoZSAvL0ZpbHRlciBJRC8vXG4gKiAgd2lsbCByZWNlaXZlIGFueSBldmVudHMgc2luY2UgdGhlIGxhc3QgY2FsbC5cbiAqXG4gKiAgQF9kb2Nsb2M6IGFwaS9wcm92aWRlcnMvYWJzdHJhY3QtcHJvdmlkZXJcbiAqL1xuZXhwb3J0IGNsYXNzIEZpbHRlcklkU3Vic2NyaWJlciB7XG4gICAgI3Byb3ZpZGVyO1xuICAgICNmaWx0ZXJJZFByb21pc2U7XG4gICAgI3BvbGxlcjtcbiAgICAjcnVubmluZztcbiAgICAjbmV0d29yaztcbiAgICAjaGF1bHQ7XG4gICAgLyoqXG4gICAgICogIENyZWF0ZXMgYSBuZXcgKipGaWx0ZXJJZFN1YnNjcmliZXIqKiB3aGljaCB3aWxsIHVzZWQgW1tfc3Vic2NyaWJlXV1cbiAgICAgKiAgYW5kIFtbX2VtaXRSZXN1bHRzXV0gdG8gc2V0dXAgdGhlIHN1YnNjcmlwdGlvbiBhbmQgcHJvdmlkZSB0aGUgZXZlbnRcbiAgICAgKiAgdG8gdGhlICUlcHJvdmlkZXIlJS5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihwcm92aWRlcikge1xuICAgICAgICB0aGlzLiNwcm92aWRlciA9IHByb3ZpZGVyO1xuICAgICAgICB0aGlzLiNmaWx0ZXJJZFByb21pc2UgPSBudWxsO1xuICAgICAgICB0aGlzLiNwb2xsZXIgPSB0aGlzLiNwb2xsLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuI3J1bm5pbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy4jbmV0d29yayA9IG51bGw7XG4gICAgICAgIHRoaXMuI2hhdWx0ID0gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBTdWItY2xhc3NlcyAqKm11c3QqKiBvdmVycmlkZSB0aGlzIHRvIGJlZ2luIHRoZSBzdWJzY3JpcHRpb24uXG4gICAgICovXG4gICAgX3N1YnNjcmliZShwcm92aWRlcikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJzdWJjbGFzc2VzIG11c3Qgb3ZlcnJpZGUgdGhpc1wiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFN1Yi1jbGFzc2VzICoqbXVzdCoqIG92ZXJyaWRlIHRoaXMgaGFuZGxlIHRoZSBldmVudHMuXG4gICAgICovXG4gICAgX2VtaXRSZXN1bHRzKHByb3ZpZGVyLCByZXN1bHQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwic3ViY2xhc3NlcyBtdXN0IG92ZXJyaWRlIHRoaXNcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBTdWItY2xhc3NlcyAqKm11c3QqKiBvdmVycmlkZSB0aGlzIGhhbmRsZSByZWNvdmVyeSBvbiBlcnJvcnMuXG4gICAgICovXG4gICAgX3JlY292ZXIocHJvdmlkZXIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwic3ViY2xhc3NlcyBtdXN0IG92ZXJyaWRlIHRoaXNcIik7XG4gICAgfVxuICAgIGFzeW5jICNwb2xsKGJsb2NrTnVtYmVyKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBTdWJzY3JpYmUgaWYgbmVjZXNzYXJ5XG4gICAgICAgICAgICBpZiAodGhpcy4jZmlsdGVySWRQcm9taXNlID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLiNmaWx0ZXJJZFByb21pc2UgPSB0aGlzLl9zdWJzY3JpYmUodGhpcy4jcHJvdmlkZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gR2V0IHRoZSBGaWx0ZXIgSURcbiAgICAgICAgICAgIGxldCBmaWx0ZXJJZCA9IG51bGw7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGZpbHRlcklkID0gYXdhaXQgdGhpcy4jZmlsdGVySWRQcm9taXNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFpc0Vycm9yKGVycm9yLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiKSB8fCBlcnJvci5vcGVyYXRpb24gIT09IFwiZXRoX25ld0ZpbHRlclwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFRoZSBiYWNrZW5kIGRvZXMgbm90IHN1cHBvcnQgRmlsdGVyIElEOyBkb3duZ3JhZGUgdG9cbiAgICAgICAgICAgIC8vIHBvbGxpbmdcbiAgICAgICAgICAgIGlmIChmaWx0ZXJJZCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy4jZmlsdGVySWRQcm9taXNlID0gbnVsbDtcbiAgICAgICAgICAgICAgICB0aGlzLiNwcm92aWRlci5fcmVjb3ZlclN1YnNjcmliZXIodGhpcywgdGhpcy5fcmVjb3Zlcih0aGlzLiNwcm92aWRlcikpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG5ldHdvcmsgPSBhd2FpdCB0aGlzLiNwcm92aWRlci5nZXROZXR3b3JrKCk7XG4gICAgICAgICAgICBpZiAoIXRoaXMuI25ldHdvcmspIHtcbiAgICAgICAgICAgICAgICB0aGlzLiNuZXR3b3JrID0gbmV0d29yaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLiNuZXR3b3JrLmNoYWluSWQgIT09IG5ldHdvcmsuY2hhaW5JZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImNoYWlkIGNoYW5nZWRcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy4jaGF1bHQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLiNwcm92aWRlci5zZW5kKFwiZXRoX2dldEZpbHRlckNoYW5nZXNcIiwgW2ZpbHRlcklkXSk7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9lbWl0UmVzdWx0cyh0aGlzLiNwcm92aWRlciwgcmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiQFRPRE9cIiwgZXJyb3IpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuI3Byb3ZpZGVyLm9uY2UoXCJibG9ja1wiLCB0aGlzLiNwb2xsZXIpO1xuICAgIH1cbiAgICAjdGVhcmRvd24oKSB7XG4gICAgICAgIGNvbnN0IGZpbHRlcklkUHJvbWlzZSA9IHRoaXMuI2ZpbHRlcklkUHJvbWlzZTtcbiAgICAgICAgaWYgKGZpbHRlcklkUHJvbWlzZSkge1xuICAgICAgICAgICAgdGhpcy4jZmlsdGVySWRQcm9taXNlID0gbnVsbDtcbiAgICAgICAgICAgIGZpbHRlcklkUHJvbWlzZS50aGVuKChmaWx0ZXJJZCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLiNwcm92aWRlci5kZXN0cm95ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLiNwcm92aWRlci5zZW5kKFwiZXRoX3VuaW5zdGFsbEZpbHRlclwiLCBbZmlsdGVySWRdKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN0YXJ0KCkge1xuICAgICAgICBpZiAodGhpcy4jcnVubmluZykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuI3J1bm5pbmcgPSB0cnVlO1xuICAgICAgICB0aGlzLiNwb2xsKC0yKTtcbiAgICB9XG4gICAgc3RvcCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLiNydW5uaW5nKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4jcnVubmluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLiNoYXVsdCA9IHRydWU7XG4gICAgICAgIHRoaXMuI3RlYXJkb3duKCk7XG4gICAgICAgIHRoaXMuI3Byb3ZpZGVyLm9mZihcImJsb2NrXCIsIHRoaXMuI3BvbGxlcik7XG4gICAgfVxuICAgIHBhdXNlKGRyb3BXaGlsZVBhdXNlZCkge1xuICAgICAgICBpZiAoZHJvcFdoaWxlUGF1c2VkKSB7XG4gICAgICAgICAgICB0aGlzLiN0ZWFyZG93bigpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuI3Byb3ZpZGVyLm9mZihcImJsb2NrXCIsIHRoaXMuI3BvbGxlcik7XG4gICAgfVxuICAgIHJlc3VtZSgpIHsgdGhpcy5zdGFydCgpOyB9XG59XG4vKipcbiAqICBBICoqRmlsdGVySWRTdWJzY3JpYmVyKiogZm9yIHJlY2VpdmluZyBjb250cmFjdCBldmVudHMuXG4gKlxuICogIEBfZG9jbG9jOiBhcGkvcHJvdmlkZXJzL2Fic3RyYWN0LXByb3ZpZGVyXG4gKi9cbmV4cG9ydCBjbGFzcyBGaWx0ZXJJZEV2ZW50U3Vic2NyaWJlciBleHRlbmRzIEZpbHRlcklkU3Vic2NyaWJlciB7XG4gICAgI2V2ZW50O1xuICAgIC8qKlxuICAgICAqICBDcmVhdGVzIGEgbmV3ICoqRmlsdGVySWRFdmVudFN1YnNjcmliZXIqKiBhdHRhY2hlZCB0byAlJXByb3ZpZGVyJSVcbiAgICAgKiAgbGlzdGVuaW5nIGZvciAlJWZpbHRlciUlLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHByb3ZpZGVyLCBmaWx0ZXIpIHtcbiAgICAgICAgc3VwZXIocHJvdmlkZXIpO1xuICAgICAgICB0aGlzLiNldmVudCA9IGNvcHkoZmlsdGVyKTtcbiAgICB9XG4gICAgX3JlY292ZXIocHJvdmlkZXIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQb2xsaW5nRXZlbnRTdWJzY3JpYmVyKHByb3ZpZGVyLCB0aGlzLiNldmVudCk7XG4gICAgfVxuICAgIGFzeW5jIF9zdWJzY3JpYmUocHJvdmlkZXIpIHtcbiAgICAgICAgY29uc3QgZmlsdGVySWQgPSBhd2FpdCBwcm92aWRlci5zZW5kKFwiZXRoX25ld0ZpbHRlclwiLCBbdGhpcy4jZXZlbnRdKTtcbiAgICAgICAgcmV0dXJuIGZpbHRlcklkO1xuICAgIH1cbiAgICBhc3luYyBfZW1pdFJlc3VsdHMocHJvdmlkZXIsIHJlc3VsdHMpIHtcbiAgICAgICAgZm9yIChjb25zdCByZXN1bHQgb2YgcmVzdWx0cykge1xuICAgICAgICAgICAgcHJvdmlkZXIuZW1pdCh0aGlzLiNldmVudCwgcHJvdmlkZXIuX3dyYXBMb2cocmVzdWx0LCBwcm92aWRlci5fbmV0d29yaykpO1xuICAgICAgICB9XG4gICAgfVxufVxuLyoqXG4gKiAgQSAqKkZpbHRlcklkU3Vic2NyaWJlcioqIGZvciByZWNlaXZpbmcgcGVuZGluZyB0cmFuc2FjdGlvbnMgZXZlbnRzLlxuICpcbiAqICBAX2RvY2xvYzogYXBpL3Byb3ZpZGVycy9hYnN0cmFjdC1wcm92aWRlclxuICovXG5leHBvcnQgY2xhc3MgRmlsdGVySWRQZW5kaW5nU3Vic2NyaWJlciBleHRlbmRzIEZpbHRlcklkU3Vic2NyaWJlciB7XG4gICAgYXN5bmMgX3N1YnNjcmliZShwcm92aWRlcikge1xuICAgICAgICByZXR1cm4gYXdhaXQgcHJvdmlkZXIuc2VuZChcImV0aF9uZXdQZW5kaW5nVHJhbnNhY3Rpb25GaWx0ZXJcIiwgW10pO1xuICAgIH1cbiAgICBhc3luYyBfZW1pdFJlc3VsdHMocHJvdmlkZXIsIHJlc3VsdHMpIHtcbiAgICAgICAgZm9yIChjb25zdCByZXN1bHQgb2YgcmVzdWx0cykge1xuICAgICAgICAgICAgcHJvdmlkZXIuZW1pdChcInBlbmRpbmdcIiwgcmVzdWx0KTtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXN1YnNjcmliZXItZmlsdGVyaWQuanMubWFwIl0sIm5hbWVzIjpbImlzRXJyb3IiLCJQb2xsaW5nRXZlbnRTdWJzY3JpYmVyIiwiY29weSIsIm9iaiIsIkpTT04iLCJwYXJzZSIsInN0cmluZ2lmeSIsIkZpbHRlcklkU3Vic2NyaWJlciIsInByb3ZpZGVyIiwiZmlsdGVySWRQcm9taXNlIiwicG9sbGVyIiwicnVubmluZyIsIm5ldHdvcmsiLCJoYXVsdCIsImNvbnN0cnVjdG9yIiwicG9sbCIsImJpbmQiLCJfc3Vic2NyaWJlIiwiRXJyb3IiLCJfZW1pdFJlc3VsdHMiLCJyZXN1bHQiLCJfcmVjb3ZlciIsImJsb2NrTnVtYmVyIiwiZmlsdGVySWQiLCJlcnJvciIsIm9wZXJhdGlvbiIsIl9yZWNvdmVyU3Vic2NyaWJlciIsImdldE5ldHdvcmsiLCJjaGFpbklkIiwic2VuZCIsImNvbnNvbGUiLCJsb2ciLCJvbmNlIiwidGVhcmRvd24iLCJ0aGVuIiwiZGVzdHJveWVkIiwic3RhcnQiLCJzdG9wIiwib2ZmIiwicGF1c2UiLCJkcm9wV2hpbGVQYXVzZWQiLCJyZXN1bWUiLCJGaWx0ZXJJZEV2ZW50U3Vic2NyaWJlciIsImV2ZW50IiwiZmlsdGVyIiwicmVzdWx0cyIsImVtaXQiLCJfd3JhcExvZyIsIl9uZXR3b3JrIiwiRmlsdGVySWRQZW5kaW5nU3Vic2NyaWJlciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.esm/providers/subscriber-filterid.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.esm/providers/subscriber-polling.js":
/*!*********************************************************************!*\
  !*** ./node_modules/ethers/lib.esm/providers/subscriber-polling.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   OnBlockSubscriber: () => (/* binding */ OnBlockSubscriber),\n/* harmony export */   PollingBlockSubscriber: () => (/* binding */ PollingBlockSubscriber),\n/* harmony export */   PollingBlockTagSubscriber: () => (/* binding */ PollingBlockTagSubscriber),\n/* harmony export */   PollingEventSubscriber: () => (/* binding */ PollingEventSubscriber),\n/* harmony export */   PollingOrphanSubscriber: () => (/* binding */ PollingOrphanSubscriber),\n/* harmony export */   PollingTransactionSubscriber: () => (/* binding */ PollingTransactionSubscriber),\n/* harmony export */   getPollingSubscriber: () => (/* binding */ getPollingSubscriber)\n/* harmony export */ });\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/data.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/errors.js\");\n\nfunction copy(obj) {\n    return JSON.parse(JSON.stringify(obj));\n}\n/**\n *  Return the polling subscriber for common events.\n *\n *  @_docloc: api/providers/abstract-provider\n */ function getPollingSubscriber(provider, event) {\n    if (event === \"block\") {\n        return new PollingBlockSubscriber(provider);\n    }\n    if ((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.isHexString)(event, 32)) {\n        return new PollingTransactionSubscriber(provider, event);\n    }\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assert)(false, \"unsupported polling event\", \"UNSUPPORTED_OPERATION\", {\n        operation: \"getPollingSubscriber\",\n        info: {\n            event\n        }\n    });\n}\n// @TODO: refactor this\n/**\n *  A **PollingBlockSubscriber** polls at a regular interval for a change\n *  in the block number.\n *\n *  @_docloc: api/providers/abstract-provider\n */ class PollingBlockSubscriber {\n    #provider;\n    #poller;\n    #interval;\n    // The most recent block we have scanned for events. The value -2\n    // indicates we still need to fetch an initial block number\n    #blockNumber;\n    /**\n     *  Create a new **PollingBlockSubscriber** attached to %%provider%%.\n     */ constructor(provider){\n        this.#provider = provider;\n        this.#poller = null;\n        this.#interval = 4000;\n        this.#blockNumber = -2;\n    }\n    /**\n     *  The polling interval.\n     */ get pollingInterval() {\n        return this.#interval;\n    }\n    set pollingInterval(value) {\n        this.#interval = value;\n    }\n    async #poll() {\n        try {\n            const blockNumber = await this.#provider.getBlockNumber();\n            // Bootstrap poll to setup our initial block number\n            if (this.#blockNumber === -2) {\n                this.#blockNumber = blockNumber;\n                return;\n            }\n            // @TODO: Put a cap on the maximum number of events per loop?\n            if (blockNumber !== this.#blockNumber) {\n                for(let b = this.#blockNumber + 1; b <= blockNumber; b++){\n                    // We have been stopped\n                    if (this.#poller == null) {\n                        return;\n                    }\n                    await this.#provider.emit(\"block\", b);\n                }\n                this.#blockNumber = blockNumber;\n            }\n        } catch (error) {\n        // @TODO: Minor bump, add an \"error\" event to let subscribers\n        //        know things went awry.\n        //console.log(error);\n        }\n        // We have been stopped\n        if (this.#poller == null) {\n            return;\n        }\n        this.#poller = this.#provider._setTimeout(this.#poll.bind(this), this.#interval);\n    }\n    start() {\n        if (this.#poller) {\n            return;\n        }\n        this.#poller = this.#provider._setTimeout(this.#poll.bind(this), this.#interval);\n        this.#poll();\n    }\n    stop() {\n        if (!this.#poller) {\n            return;\n        }\n        this.#provider._clearTimeout(this.#poller);\n        this.#poller = null;\n    }\n    pause(dropWhilePaused) {\n        this.stop();\n        if (dropWhilePaused) {\n            this.#blockNumber = -2;\n        }\n    }\n    resume() {\n        this.start();\n    }\n}\n/**\n *  An **OnBlockSubscriber** can be sub-classed, with a [[_poll]]\n *  implmentation which will be called on every new block.\n *\n *  @_docloc: api/providers/abstract-provider\n */ class OnBlockSubscriber {\n    #provider;\n    #poll;\n    #running;\n    /**\n     *  Create a new **OnBlockSubscriber** attached to %%provider%%.\n     */ constructor(provider){\n        this.#provider = provider;\n        this.#running = false;\n        this.#poll = (blockNumber)=>{\n            this._poll(blockNumber, this.#provider);\n        };\n    }\n    /**\n     *  Called on every new block.\n     */ async _poll(blockNumber, provider) {\n        throw new Error(\"sub-classes must override this\");\n    }\n    start() {\n        if (this.#running) {\n            return;\n        }\n        this.#running = true;\n        this.#poll(-2);\n        this.#provider.on(\"block\", this.#poll);\n    }\n    stop() {\n        if (!this.#running) {\n            return;\n        }\n        this.#running = false;\n        this.#provider.off(\"block\", this.#poll);\n    }\n    pause(dropWhilePaused) {\n        this.stop();\n    }\n    resume() {\n        this.start();\n    }\n}\nclass PollingBlockTagSubscriber extends OnBlockSubscriber {\n    #tag;\n    #lastBlock;\n    constructor(provider, tag){\n        super(provider);\n        this.#tag = tag;\n        this.#lastBlock = -2;\n    }\n    pause(dropWhilePaused) {\n        if (dropWhilePaused) {\n            this.#lastBlock = -2;\n        }\n        super.pause(dropWhilePaused);\n    }\n    async _poll(blockNumber, provider) {\n        const block = await provider.getBlock(this.#tag);\n        if (block == null) {\n            return;\n        }\n        if (this.#lastBlock === -2) {\n            this.#lastBlock = block.number;\n        } else if (block.number > this.#lastBlock) {\n            provider.emit(this.#tag, block.number);\n            this.#lastBlock = block.number;\n        }\n    }\n}\n/**\n *  @_ignore:\n *\n *  @_docloc: api/providers/abstract-provider\n */ class PollingOrphanSubscriber extends OnBlockSubscriber {\n    #filter;\n    constructor(provider, filter){\n        super(provider);\n        this.#filter = copy(filter);\n    }\n    async _poll(blockNumber, provider) {\n        throw new Error(\"@TODO\");\n        console.log(this.#filter);\n    }\n}\n/**\n *  A **PollingTransactionSubscriber** will poll for a given transaction\n *  hash for its receipt.\n *\n *  @_docloc: api/providers/abstract-provider\n */ class PollingTransactionSubscriber extends OnBlockSubscriber {\n    #hash;\n    /**\n     *  Create a new **PollingTransactionSubscriber** attached to\n     *  %%provider%%, listening for %%hash%%.\n     */ constructor(provider, hash){\n        super(provider);\n        this.#hash = hash;\n    }\n    async _poll(blockNumber, provider) {\n        const tx = await provider.getTransactionReceipt(this.#hash);\n        if (tx) {\n            provider.emit(this.#hash, tx);\n        }\n    }\n}\n/**\n *  A **PollingEventSubscriber** will poll for a given filter for its logs.\n *\n *  @_docloc: api/providers/abstract-provider\n */ class PollingEventSubscriber {\n    #provider;\n    #filter;\n    #poller;\n    #running;\n    // The most recent block we have scanned for events. The value -2\n    // indicates we still need to fetch an initial block number\n    #blockNumber;\n    /**\n     *  Create a new **PollingTransactionSubscriber** attached to\n     *  %%provider%%, listening for %%filter%%.\n     */ constructor(provider, filter){\n        this.#provider = provider;\n        this.#filter = copy(filter);\n        this.#poller = this.#poll.bind(this);\n        this.#running = false;\n        this.#blockNumber = -2;\n    }\n    async #poll(blockNumber) {\n        // The initial block hasn't been determined yet\n        if (this.#blockNumber === -2) {\n            return;\n        }\n        const filter = copy(this.#filter);\n        filter.fromBlock = this.#blockNumber + 1;\n        filter.toBlock = blockNumber;\n        const logs = await this.#provider.getLogs(filter);\n        // No logs could just mean the node has not indexed them yet,\n        // so we keep a sliding window of 60 blocks to keep scanning\n        if (logs.length === 0) {\n            if (this.#blockNumber < blockNumber - 60) {\n                this.#blockNumber = blockNumber - 60;\n            }\n            return;\n        }\n        for (const log of logs){\n            this.#provider.emit(this.#filter, log);\n            // Only advance the block number when logs were found to\n            // account for networks (like BNB and Polygon) which may\n            // sacrifice event consistency for block event speed\n            this.#blockNumber = log.blockNumber;\n        }\n    }\n    start() {\n        if (this.#running) {\n            return;\n        }\n        this.#running = true;\n        if (this.#blockNumber === -2) {\n            this.#provider.getBlockNumber().then((blockNumber)=>{\n                this.#blockNumber = blockNumber;\n            });\n        }\n        this.#provider.on(\"block\", this.#poller);\n    }\n    stop() {\n        if (!this.#running) {\n            return;\n        }\n        this.#running = false;\n        this.#provider.off(\"block\", this.#poller);\n    }\n    pause(dropWhilePaused) {\n        this.stop();\n        if (dropWhilePaused) {\n            this.#blockNumber = -2;\n        }\n    }\n    resume() {\n        this.start();\n    }\n} //# sourceMappingURL=subscriber-polling.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vcHJvdmlkZXJzL3N1YnNjcmliZXItcG9sbGluZy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFBd0Q7QUFDeEQsU0FBU0UsS0FBS0MsR0FBRztJQUNiLE9BQU9DLEtBQUtDLEtBQUssQ0FBQ0QsS0FBS0UsU0FBUyxDQUFDSDtBQUNyQztBQUNBOzs7O0NBSUMsR0FDTSxTQUFTSSxxQkFBcUJDLFFBQVEsRUFBRUMsS0FBSztJQUNoRCxJQUFJQSxVQUFVLFNBQVM7UUFDbkIsT0FBTyxJQUFJQyx1QkFBdUJGO0lBQ3RDO0lBQ0EsSUFBSVAsNERBQVdBLENBQUNRLE9BQU8sS0FBSztRQUN4QixPQUFPLElBQUlFLDZCQUE2QkgsVUFBVUM7SUFDdEQ7SUFDQVQsdURBQU1BLENBQUMsT0FBTyw2QkFBNkIseUJBQXlCO1FBQ2hFWSxXQUFXO1FBQXdCQyxNQUFNO1lBQUVKO1FBQU07SUFDckQ7QUFDSjtBQUNBLHVCQUF1QjtBQUN2Qjs7Ozs7Q0FLQyxHQUNNLE1BQU1DO0lBQ1QsQ0FBQ0YsUUFBUSxDQUFDO0lBQ1YsQ0FBQ00sTUFBTSxDQUFDO0lBQ1IsQ0FBQ0MsUUFBUSxDQUFDO0lBQ1YsaUVBQWlFO0lBQ2pFLDJEQUEyRDtJQUMzRCxDQUFDQyxXQUFXLENBQUM7SUFDYjs7S0FFQyxHQUNEQyxZQUFZVCxRQUFRLENBQUU7UUFDbEIsSUFBSSxDQUFDLENBQUNBLFFBQVEsR0FBR0E7UUFDakIsSUFBSSxDQUFDLENBQUNNLE1BQU0sR0FBRztRQUNmLElBQUksQ0FBQyxDQUFDQyxRQUFRLEdBQUc7UUFDakIsSUFBSSxDQUFDLENBQUNDLFdBQVcsR0FBRyxDQUFDO0lBQ3pCO0lBQ0E7O0tBRUMsR0FDRCxJQUFJRSxrQkFBa0I7UUFBRSxPQUFPLElBQUksQ0FBQyxDQUFDSCxRQUFRO0lBQUU7SUFDL0MsSUFBSUcsZ0JBQWdCQyxLQUFLLEVBQUU7UUFBRSxJQUFJLENBQUMsQ0FBQ0osUUFBUSxHQUFHSTtJQUFPO0lBQ3JELE1BQU0sQ0FBQ0MsSUFBSTtRQUNQLElBQUk7WUFDQSxNQUFNSixjQUFjLE1BQU0sSUFBSSxDQUFDLENBQUNSLFFBQVEsQ0FBQ2EsY0FBYztZQUN2RCxtREFBbUQ7WUFDbkQsSUFBSSxJQUFJLENBQUMsQ0FBQ0wsV0FBVyxLQUFLLENBQUMsR0FBRztnQkFDMUIsSUFBSSxDQUFDLENBQUNBLFdBQVcsR0FBR0E7Z0JBQ3BCO1lBQ0o7WUFDQSw2REFBNkQ7WUFDN0QsSUFBSUEsZ0JBQWdCLElBQUksQ0FBQyxDQUFDQSxXQUFXLEVBQUU7Z0JBQ25DLElBQUssSUFBSU0sSUFBSSxJQUFJLENBQUMsQ0FBQ04sV0FBVyxHQUFHLEdBQUdNLEtBQUtOLGFBQWFNLElBQUs7b0JBQ3ZELHVCQUF1QjtvQkFDdkIsSUFBSSxJQUFJLENBQUMsQ0FBQ1IsTUFBTSxJQUFJLE1BQU07d0JBQ3RCO29CQUNKO29CQUNBLE1BQU0sSUFBSSxDQUFDLENBQUNOLFFBQVEsQ0FBQ2UsSUFBSSxDQUFDLFNBQVNEO2dCQUN2QztnQkFDQSxJQUFJLENBQUMsQ0FBQ04sV0FBVyxHQUFHQTtZQUN4QjtRQUNKLEVBQ0EsT0FBT1EsT0FBTztRQUNWLDZEQUE2RDtRQUM3RCxnQ0FBZ0M7UUFDaEMscUJBQXFCO1FBQ3pCO1FBQ0EsdUJBQXVCO1FBQ3ZCLElBQUksSUFBSSxDQUFDLENBQUNWLE1BQU0sSUFBSSxNQUFNO1lBQ3RCO1FBQ0o7UUFDQSxJQUFJLENBQUMsQ0FBQ0EsTUFBTSxHQUFHLElBQUksQ0FBQyxDQUFDTixRQUFRLENBQUNpQixXQUFXLENBQUMsSUFBSSxDQUFDLENBQUNMLElBQUksQ0FBQ00sSUFBSSxDQUFDLElBQUksR0FBRyxJQUFJLENBQUMsQ0FBQ1gsUUFBUTtJQUNuRjtJQUNBWSxRQUFRO1FBQ0osSUFBSSxJQUFJLENBQUMsQ0FBQ2IsTUFBTSxFQUFFO1lBQ2Q7UUFDSjtRQUNBLElBQUksQ0FBQyxDQUFDQSxNQUFNLEdBQUcsSUFBSSxDQUFDLENBQUNOLFFBQVEsQ0FBQ2lCLFdBQVcsQ0FBQyxJQUFJLENBQUMsQ0FBQ0wsSUFBSSxDQUFDTSxJQUFJLENBQUMsSUFBSSxHQUFHLElBQUksQ0FBQyxDQUFDWCxRQUFRO1FBQy9FLElBQUksQ0FBQyxDQUFDSyxJQUFJO0lBQ2Q7SUFDQVEsT0FBTztRQUNILElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQ2QsTUFBTSxFQUFFO1lBQ2Y7UUFDSjtRQUNBLElBQUksQ0FBQyxDQUFDTixRQUFRLENBQUNxQixhQUFhLENBQUMsSUFBSSxDQUFDLENBQUNmLE1BQU07UUFDekMsSUFBSSxDQUFDLENBQUNBLE1BQU0sR0FBRztJQUNuQjtJQUNBZ0IsTUFBTUMsZUFBZSxFQUFFO1FBQ25CLElBQUksQ0FBQ0gsSUFBSTtRQUNULElBQUlHLGlCQUFpQjtZQUNqQixJQUFJLENBQUMsQ0FBQ2YsV0FBVyxHQUFHLENBQUM7UUFDekI7SUFDSjtJQUNBZ0IsU0FBUztRQUNMLElBQUksQ0FBQ0wsS0FBSztJQUNkO0FBQ0o7QUFDQTs7Ozs7Q0FLQyxHQUNNLE1BQU1NO0lBQ1QsQ0FBQ3pCLFFBQVEsQ0FBQztJQUNWLENBQUNZLElBQUksQ0FBQztJQUNOLENBQUNjLE9BQU8sQ0FBQztJQUNUOztLQUVDLEdBQ0RqQixZQUFZVCxRQUFRLENBQUU7UUFDbEIsSUFBSSxDQUFDLENBQUNBLFFBQVEsR0FBR0E7UUFDakIsSUFBSSxDQUFDLENBQUMwQixPQUFPLEdBQUc7UUFDaEIsSUFBSSxDQUFDLENBQUNkLElBQUksR0FBRyxDQUFDSjtZQUNWLElBQUksQ0FBQ21CLEtBQUssQ0FBQ25CLGFBQWEsSUFBSSxDQUFDLENBQUNSLFFBQVE7UUFDMUM7SUFDSjtJQUNBOztLQUVDLEdBQ0QsTUFBTTJCLE1BQU1uQixXQUFXLEVBQUVSLFFBQVEsRUFBRTtRQUMvQixNQUFNLElBQUk0QixNQUFNO0lBQ3BCO0lBQ0FULFFBQVE7UUFDSixJQUFJLElBQUksQ0FBQyxDQUFDTyxPQUFPLEVBQUU7WUFDZjtRQUNKO1FBQ0EsSUFBSSxDQUFDLENBQUNBLE9BQU8sR0FBRztRQUNoQixJQUFJLENBQUMsQ0FBQ2QsSUFBSSxDQUFDLENBQUM7UUFDWixJQUFJLENBQUMsQ0FBQ1osUUFBUSxDQUFDNkIsRUFBRSxDQUFDLFNBQVMsSUFBSSxDQUFDLENBQUNqQixJQUFJO0lBQ3pDO0lBQ0FRLE9BQU87UUFDSCxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUNNLE9BQU8sRUFBRTtZQUNoQjtRQUNKO1FBQ0EsSUFBSSxDQUFDLENBQUNBLE9BQU8sR0FBRztRQUNoQixJQUFJLENBQUMsQ0FBQzFCLFFBQVEsQ0FBQzhCLEdBQUcsQ0FBQyxTQUFTLElBQUksQ0FBQyxDQUFDbEIsSUFBSTtJQUMxQztJQUNBVSxNQUFNQyxlQUFlLEVBQUU7UUFBRSxJQUFJLENBQUNILElBQUk7SUFBSTtJQUN0Q0ksU0FBUztRQUFFLElBQUksQ0FBQ0wsS0FBSztJQUFJO0FBQzdCO0FBQ08sTUFBTVksa0NBQWtDTjtJQUMzQyxDQUFDTyxHQUFHLENBQUM7SUFDTCxDQUFDQyxTQUFTLENBQUM7SUFDWHhCLFlBQVlULFFBQVEsRUFBRWdDLEdBQUcsQ0FBRTtRQUN2QixLQUFLLENBQUNoQztRQUNOLElBQUksQ0FBQyxDQUFDZ0MsR0FBRyxHQUFHQTtRQUNaLElBQUksQ0FBQyxDQUFDQyxTQUFTLEdBQUcsQ0FBQztJQUN2QjtJQUNBWCxNQUFNQyxlQUFlLEVBQUU7UUFDbkIsSUFBSUEsaUJBQWlCO1lBQ2pCLElBQUksQ0FBQyxDQUFDVSxTQUFTLEdBQUcsQ0FBQztRQUN2QjtRQUNBLEtBQUssQ0FBQ1gsTUFBTUM7SUFDaEI7SUFDQSxNQUFNSSxNQUFNbkIsV0FBVyxFQUFFUixRQUFRLEVBQUU7UUFDL0IsTUFBTWtDLFFBQVEsTUFBTWxDLFNBQVNtQyxRQUFRLENBQUMsSUFBSSxDQUFDLENBQUNILEdBQUc7UUFDL0MsSUFBSUUsU0FBUyxNQUFNO1lBQ2Y7UUFDSjtRQUNBLElBQUksSUFBSSxDQUFDLENBQUNELFNBQVMsS0FBSyxDQUFDLEdBQUc7WUFDeEIsSUFBSSxDQUFDLENBQUNBLFNBQVMsR0FBR0MsTUFBTUUsTUFBTTtRQUNsQyxPQUNLLElBQUlGLE1BQU1FLE1BQU0sR0FBRyxJQUFJLENBQUMsQ0FBQ0gsU0FBUyxFQUFFO1lBQ3JDakMsU0FBU2UsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDaUIsR0FBRyxFQUFFRSxNQUFNRSxNQUFNO1lBQ3JDLElBQUksQ0FBQyxDQUFDSCxTQUFTLEdBQUdDLE1BQU1FLE1BQU07UUFDbEM7SUFDSjtBQUNKO0FBQ0E7Ozs7Q0FJQyxHQUNNLE1BQU1DLGdDQUFnQ1o7SUFDekMsQ0FBQ2EsTUFBTSxDQUFDO0lBQ1I3QixZQUFZVCxRQUFRLEVBQUVzQyxNQUFNLENBQUU7UUFDMUIsS0FBSyxDQUFDdEM7UUFDTixJQUFJLENBQUMsQ0FBQ3NDLE1BQU0sR0FBRzVDLEtBQUs0QztJQUN4QjtJQUNBLE1BQU1YLE1BQU1uQixXQUFXLEVBQUVSLFFBQVEsRUFBRTtRQUMvQixNQUFNLElBQUk0QixNQUFNO1FBQ2hCVyxRQUFRQyxHQUFHLENBQUMsSUFBSSxDQUFDLENBQUNGLE1BQU07SUFDNUI7QUFDSjtBQUNBOzs7OztDQUtDLEdBQ00sTUFBTW5DLHFDQUFxQ3NCO0lBQzlDLENBQUNnQixJQUFJLENBQUM7SUFDTjs7O0tBR0MsR0FDRGhDLFlBQVlULFFBQVEsRUFBRXlDLElBQUksQ0FBRTtRQUN4QixLQUFLLENBQUN6QztRQUNOLElBQUksQ0FBQyxDQUFDeUMsSUFBSSxHQUFHQTtJQUNqQjtJQUNBLE1BQU1kLE1BQU1uQixXQUFXLEVBQUVSLFFBQVEsRUFBRTtRQUMvQixNQUFNMEMsS0FBSyxNQUFNMUMsU0FBUzJDLHFCQUFxQixDQUFDLElBQUksQ0FBQyxDQUFDRixJQUFJO1FBQzFELElBQUlDLElBQUk7WUFDSjFDLFNBQVNlLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQzBCLElBQUksRUFBRUM7UUFDOUI7SUFDSjtBQUNKO0FBQ0E7Ozs7Q0FJQyxHQUNNLE1BQU1FO0lBQ1QsQ0FBQzVDLFFBQVEsQ0FBQztJQUNWLENBQUNzQyxNQUFNLENBQUM7SUFDUixDQUFDaEMsTUFBTSxDQUFDO0lBQ1IsQ0FBQ29CLE9BQU8sQ0FBQztJQUNULGlFQUFpRTtJQUNqRSwyREFBMkQ7SUFDM0QsQ0FBQ2xCLFdBQVcsQ0FBQztJQUNiOzs7S0FHQyxHQUNEQyxZQUFZVCxRQUFRLEVBQUVzQyxNQUFNLENBQUU7UUFDMUIsSUFBSSxDQUFDLENBQUN0QyxRQUFRLEdBQUdBO1FBQ2pCLElBQUksQ0FBQyxDQUFDc0MsTUFBTSxHQUFHNUMsS0FBSzRDO1FBQ3BCLElBQUksQ0FBQyxDQUFDaEMsTUFBTSxHQUFHLElBQUksQ0FBQyxDQUFDTSxJQUFJLENBQUNNLElBQUksQ0FBQyxJQUFJO1FBQ25DLElBQUksQ0FBQyxDQUFDUSxPQUFPLEdBQUc7UUFDaEIsSUFBSSxDQUFDLENBQUNsQixXQUFXLEdBQUcsQ0FBQztJQUN6QjtJQUNBLE1BQU0sQ0FBQ0ksSUFBSSxDQUFDSixXQUFXO1FBQ25CLCtDQUErQztRQUMvQyxJQUFJLElBQUksQ0FBQyxDQUFDQSxXQUFXLEtBQUssQ0FBQyxHQUFHO1lBQzFCO1FBQ0o7UUFDQSxNQUFNOEIsU0FBUzVDLEtBQUssSUFBSSxDQUFDLENBQUM0QyxNQUFNO1FBQ2hDQSxPQUFPTyxTQUFTLEdBQUcsSUFBSSxDQUFDLENBQUNyQyxXQUFXLEdBQUc7UUFDdkM4QixPQUFPUSxPQUFPLEdBQUd0QztRQUNqQixNQUFNdUMsT0FBTyxNQUFNLElBQUksQ0FBQyxDQUFDL0MsUUFBUSxDQUFDZ0QsT0FBTyxDQUFDVjtRQUMxQyw2REFBNkQ7UUFDN0QsNERBQTREO1FBQzVELElBQUlTLEtBQUtFLE1BQU0sS0FBSyxHQUFHO1lBQ25CLElBQUksSUFBSSxDQUFDLENBQUN6QyxXQUFXLEdBQUdBLGNBQWMsSUFBSTtnQkFDdEMsSUFBSSxDQUFDLENBQUNBLFdBQVcsR0FBR0EsY0FBYztZQUN0QztZQUNBO1FBQ0o7UUFDQSxLQUFLLE1BQU1nQyxPQUFPTyxLQUFNO1lBQ3BCLElBQUksQ0FBQyxDQUFDL0MsUUFBUSxDQUFDZSxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUN1QixNQUFNLEVBQUVFO1lBQ2xDLHdEQUF3RDtZQUN4RCx3REFBd0Q7WUFDeEQsb0RBQW9EO1lBQ3BELElBQUksQ0FBQyxDQUFDaEMsV0FBVyxHQUFHZ0MsSUFBSWhDLFdBQVc7UUFDdkM7SUFDSjtJQUNBVyxRQUFRO1FBQ0osSUFBSSxJQUFJLENBQUMsQ0FBQ08sT0FBTyxFQUFFO1lBQ2Y7UUFDSjtRQUNBLElBQUksQ0FBQyxDQUFDQSxPQUFPLEdBQUc7UUFDaEIsSUFBSSxJQUFJLENBQUMsQ0FBQ2xCLFdBQVcsS0FBSyxDQUFDLEdBQUc7WUFDMUIsSUFBSSxDQUFDLENBQUNSLFFBQVEsQ0FBQ2EsY0FBYyxHQUFHcUMsSUFBSSxDQUFDLENBQUMxQztnQkFDbEMsSUFBSSxDQUFDLENBQUNBLFdBQVcsR0FBR0E7WUFDeEI7UUFDSjtRQUNBLElBQUksQ0FBQyxDQUFDUixRQUFRLENBQUM2QixFQUFFLENBQUMsU0FBUyxJQUFJLENBQUMsQ0FBQ3ZCLE1BQU07SUFDM0M7SUFDQWMsT0FBTztRQUNILElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQ00sT0FBTyxFQUFFO1lBQ2hCO1FBQ0o7UUFDQSxJQUFJLENBQUMsQ0FBQ0EsT0FBTyxHQUFHO1FBQ2hCLElBQUksQ0FBQyxDQUFDMUIsUUFBUSxDQUFDOEIsR0FBRyxDQUFDLFNBQVMsSUFBSSxDQUFDLENBQUN4QixNQUFNO0lBQzVDO0lBQ0FnQixNQUFNQyxlQUFlLEVBQUU7UUFDbkIsSUFBSSxDQUFDSCxJQUFJO1FBQ1QsSUFBSUcsaUJBQWlCO1lBQ2pCLElBQUksQ0FBQyxDQUFDZixXQUFXLEdBQUcsQ0FBQztRQUN6QjtJQUNKO0lBQ0FnQixTQUFTO1FBQ0wsSUFBSSxDQUFDTCxLQUFLO0lBQ2Q7QUFDSixFQUNBLDhDQUE4QyIsInNvdXJjZXMiOlsid2VicGFjazovL21lZ2F2aWJlLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL3Byb3ZpZGVycy9zdWJzY3JpYmVyLXBvbGxpbmcuanM/YjZjNiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBhc3NlcnQsIGlzSGV4U3RyaW5nIH0gZnJvbSBcIi4uL3V0aWxzL2luZGV4LmpzXCI7XG5mdW5jdGlvbiBjb3B5KG9iaikge1xuICAgIHJldHVybiBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KG9iaikpO1xufVxuLyoqXG4gKiAgUmV0dXJuIHRoZSBwb2xsaW5nIHN1YnNjcmliZXIgZm9yIGNvbW1vbiBldmVudHMuXG4gKlxuICogIEBfZG9jbG9jOiBhcGkvcHJvdmlkZXJzL2Fic3RyYWN0LXByb3ZpZGVyXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRQb2xsaW5nU3Vic2NyaWJlcihwcm92aWRlciwgZXZlbnQpIHtcbiAgICBpZiAoZXZlbnQgPT09IFwiYmxvY2tcIikge1xuICAgICAgICByZXR1cm4gbmV3IFBvbGxpbmdCbG9ja1N1YnNjcmliZXIocHJvdmlkZXIpO1xuICAgIH1cbiAgICBpZiAoaXNIZXhTdHJpbmcoZXZlbnQsIDMyKSkge1xuICAgICAgICByZXR1cm4gbmV3IFBvbGxpbmdUcmFuc2FjdGlvblN1YnNjcmliZXIocHJvdmlkZXIsIGV2ZW50KTtcbiAgICB9XG4gICAgYXNzZXJ0KGZhbHNlLCBcInVuc3VwcG9ydGVkIHBvbGxpbmcgZXZlbnRcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwge1xuICAgICAgICBvcGVyYXRpb246IFwiZ2V0UG9sbGluZ1N1YnNjcmliZXJcIiwgaW5mbzogeyBldmVudCB9XG4gICAgfSk7XG59XG4vLyBAVE9ETzogcmVmYWN0b3IgdGhpc1xuLyoqXG4gKiAgQSAqKlBvbGxpbmdCbG9ja1N1YnNjcmliZXIqKiBwb2xscyBhdCBhIHJlZ3VsYXIgaW50ZXJ2YWwgZm9yIGEgY2hhbmdlXG4gKiAgaW4gdGhlIGJsb2NrIG51bWJlci5cbiAqXG4gKiAgQF9kb2Nsb2M6IGFwaS9wcm92aWRlcnMvYWJzdHJhY3QtcHJvdmlkZXJcbiAqL1xuZXhwb3J0IGNsYXNzIFBvbGxpbmdCbG9ja1N1YnNjcmliZXIge1xuICAgICNwcm92aWRlcjtcbiAgICAjcG9sbGVyO1xuICAgICNpbnRlcnZhbDtcbiAgICAvLyBUaGUgbW9zdCByZWNlbnQgYmxvY2sgd2UgaGF2ZSBzY2FubmVkIGZvciBldmVudHMuIFRoZSB2YWx1ZSAtMlxuICAgIC8vIGluZGljYXRlcyB3ZSBzdGlsbCBuZWVkIHRvIGZldGNoIGFuIGluaXRpYWwgYmxvY2sgbnVtYmVyXG4gICAgI2Jsb2NrTnVtYmVyO1xuICAgIC8qKlxuICAgICAqICBDcmVhdGUgYSBuZXcgKipQb2xsaW5nQmxvY2tTdWJzY3JpYmVyKiogYXR0YWNoZWQgdG8gJSVwcm92aWRlciUlLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHByb3ZpZGVyKSB7XG4gICAgICAgIHRoaXMuI3Byb3ZpZGVyID0gcHJvdmlkZXI7XG4gICAgICAgIHRoaXMuI3BvbGxlciA9IG51bGw7XG4gICAgICAgIHRoaXMuI2ludGVydmFsID0gNDAwMDtcbiAgICAgICAgdGhpcy4jYmxvY2tOdW1iZXIgPSAtMjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRoZSBwb2xsaW5nIGludGVydmFsLlxuICAgICAqL1xuICAgIGdldCBwb2xsaW5nSW50ZXJ2YWwoKSB7IHJldHVybiB0aGlzLiNpbnRlcnZhbDsgfVxuICAgIHNldCBwb2xsaW5nSW50ZXJ2YWwodmFsdWUpIHsgdGhpcy4jaW50ZXJ2YWwgPSB2YWx1ZTsgfVxuICAgIGFzeW5jICNwb2xsKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgYmxvY2tOdW1iZXIgPSBhd2FpdCB0aGlzLiNwcm92aWRlci5nZXRCbG9ja051bWJlcigpO1xuICAgICAgICAgICAgLy8gQm9vdHN0cmFwIHBvbGwgdG8gc2V0dXAgb3VyIGluaXRpYWwgYmxvY2sgbnVtYmVyXG4gICAgICAgICAgICBpZiAodGhpcy4jYmxvY2tOdW1iZXIgPT09IC0yKSB7XG4gICAgICAgICAgICAgICAgdGhpcy4jYmxvY2tOdW1iZXIgPSBibG9ja051bWJlcjtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBAVE9ETzogUHV0IGEgY2FwIG9uIHRoZSBtYXhpbXVtIG51bWJlciBvZiBldmVudHMgcGVyIGxvb3A/XG4gICAgICAgICAgICBpZiAoYmxvY2tOdW1iZXIgIT09IHRoaXMuI2Jsb2NrTnVtYmVyKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgYiA9IHRoaXMuI2Jsb2NrTnVtYmVyICsgMTsgYiA8PSBibG9ja051bWJlcjsgYisrKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIGhhdmUgYmVlbiBzdG9wcGVkXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLiNwb2xsZXIgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuI3Byb3ZpZGVyLmVtaXQoXCJibG9ja1wiLCBiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy4jYmxvY2tOdW1iZXIgPSBibG9ja051bWJlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIC8vIEBUT0RPOiBNaW5vciBidW1wLCBhZGQgYW4gXCJlcnJvclwiIGV2ZW50IHRvIGxldCBzdWJzY3JpYmVyc1xuICAgICAgICAgICAgLy8gICAgICAgIGtub3cgdGhpbmdzIHdlbnQgYXdyeS5cbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coZXJyb3IpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFdlIGhhdmUgYmVlbiBzdG9wcGVkXG4gICAgICAgIGlmICh0aGlzLiNwb2xsZXIgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuI3BvbGxlciA9IHRoaXMuI3Byb3ZpZGVyLl9zZXRUaW1lb3V0KHRoaXMuI3BvbGwuYmluZCh0aGlzKSwgdGhpcy4jaW50ZXJ2YWwpO1xuICAgIH1cbiAgICBzdGFydCgpIHtcbiAgICAgICAgaWYgKHRoaXMuI3BvbGxlcikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuI3BvbGxlciA9IHRoaXMuI3Byb3ZpZGVyLl9zZXRUaW1lb3V0KHRoaXMuI3BvbGwuYmluZCh0aGlzKSwgdGhpcy4jaW50ZXJ2YWwpO1xuICAgICAgICB0aGlzLiNwb2xsKCk7XG4gICAgfVxuICAgIHN0b3AoKSB7XG4gICAgICAgIGlmICghdGhpcy4jcG9sbGVyKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4jcHJvdmlkZXIuX2NsZWFyVGltZW91dCh0aGlzLiNwb2xsZXIpO1xuICAgICAgICB0aGlzLiNwb2xsZXIgPSBudWxsO1xuICAgIH1cbiAgICBwYXVzZShkcm9wV2hpbGVQYXVzZWQpIHtcbiAgICAgICAgdGhpcy5zdG9wKCk7XG4gICAgICAgIGlmIChkcm9wV2hpbGVQYXVzZWQpIHtcbiAgICAgICAgICAgIHRoaXMuI2Jsb2NrTnVtYmVyID0gLTI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVzdW1lKCkge1xuICAgICAgICB0aGlzLnN0YXJ0KCk7XG4gICAgfVxufVxuLyoqXG4gKiAgQW4gKipPbkJsb2NrU3Vic2NyaWJlcioqIGNhbiBiZSBzdWItY2xhc3NlZCwgd2l0aCBhIFtbX3BvbGxdXVxuICogIGltcGxtZW50YXRpb24gd2hpY2ggd2lsbCBiZSBjYWxsZWQgb24gZXZlcnkgbmV3IGJsb2NrLlxuICpcbiAqICBAX2RvY2xvYzogYXBpL3Byb3ZpZGVycy9hYnN0cmFjdC1wcm92aWRlclxuICovXG5leHBvcnQgY2xhc3MgT25CbG9ja1N1YnNjcmliZXIge1xuICAgICNwcm92aWRlcjtcbiAgICAjcG9sbDtcbiAgICAjcnVubmluZztcbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlIGEgbmV3ICoqT25CbG9ja1N1YnNjcmliZXIqKiBhdHRhY2hlZCB0byAlJXByb3ZpZGVyJSUuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IocHJvdmlkZXIpIHtcbiAgICAgICAgdGhpcy4jcHJvdmlkZXIgPSBwcm92aWRlcjtcbiAgICAgICAgdGhpcy4jcnVubmluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLiNwb2xsID0gKGJsb2NrTnVtYmVyKSA9PiB7XG4gICAgICAgICAgICB0aGlzLl9wb2xsKGJsb2NrTnVtYmVyLCB0aGlzLiNwcm92aWRlcik7XG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBDYWxsZWQgb24gZXZlcnkgbmV3IGJsb2NrLlxuICAgICAqL1xuICAgIGFzeW5jIF9wb2xsKGJsb2NrTnVtYmVyLCBwcm92aWRlcikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJzdWItY2xhc3NlcyBtdXN0IG92ZXJyaWRlIHRoaXNcIik7XG4gICAgfVxuICAgIHN0YXJ0KCkge1xuICAgICAgICBpZiAodGhpcy4jcnVubmluZykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuI3J1bm5pbmcgPSB0cnVlO1xuICAgICAgICB0aGlzLiNwb2xsKC0yKTtcbiAgICAgICAgdGhpcy4jcHJvdmlkZXIub24oXCJibG9ja1wiLCB0aGlzLiNwb2xsKTtcbiAgICB9XG4gICAgc3RvcCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLiNydW5uaW5nKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4jcnVubmluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLiNwcm92aWRlci5vZmYoXCJibG9ja1wiLCB0aGlzLiNwb2xsKTtcbiAgICB9XG4gICAgcGF1c2UoZHJvcFdoaWxlUGF1c2VkKSB7IHRoaXMuc3RvcCgpOyB9XG4gICAgcmVzdW1lKCkgeyB0aGlzLnN0YXJ0KCk7IH1cbn1cbmV4cG9ydCBjbGFzcyBQb2xsaW5nQmxvY2tUYWdTdWJzY3JpYmVyIGV4dGVuZHMgT25CbG9ja1N1YnNjcmliZXIge1xuICAgICN0YWc7XG4gICAgI2xhc3RCbG9jaztcbiAgICBjb25zdHJ1Y3Rvcihwcm92aWRlciwgdGFnKSB7XG4gICAgICAgIHN1cGVyKHByb3ZpZGVyKTtcbiAgICAgICAgdGhpcy4jdGFnID0gdGFnO1xuICAgICAgICB0aGlzLiNsYXN0QmxvY2sgPSAtMjtcbiAgICB9XG4gICAgcGF1c2UoZHJvcFdoaWxlUGF1c2VkKSB7XG4gICAgICAgIGlmIChkcm9wV2hpbGVQYXVzZWQpIHtcbiAgICAgICAgICAgIHRoaXMuI2xhc3RCbG9jayA9IC0yO1xuICAgICAgICB9XG4gICAgICAgIHN1cGVyLnBhdXNlKGRyb3BXaGlsZVBhdXNlZCk7XG4gICAgfVxuICAgIGFzeW5jIF9wb2xsKGJsb2NrTnVtYmVyLCBwcm92aWRlcikge1xuICAgICAgICBjb25zdCBibG9jayA9IGF3YWl0IHByb3ZpZGVyLmdldEJsb2NrKHRoaXMuI3RhZyk7XG4gICAgICAgIGlmIChibG9jayA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuI2xhc3RCbG9jayA9PT0gLTIpIHtcbiAgICAgICAgICAgIHRoaXMuI2xhc3RCbG9jayA9IGJsb2NrLm51bWJlcjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChibG9jay5udW1iZXIgPiB0aGlzLiNsYXN0QmxvY2spIHtcbiAgICAgICAgICAgIHByb3ZpZGVyLmVtaXQodGhpcy4jdGFnLCBibG9jay5udW1iZXIpO1xuICAgICAgICAgICAgdGhpcy4jbGFzdEJsb2NrID0gYmxvY2subnVtYmVyO1xuICAgICAgICB9XG4gICAgfVxufVxuLyoqXG4gKiAgQF9pZ25vcmU6XG4gKlxuICogIEBfZG9jbG9jOiBhcGkvcHJvdmlkZXJzL2Fic3RyYWN0LXByb3ZpZGVyXG4gKi9cbmV4cG9ydCBjbGFzcyBQb2xsaW5nT3JwaGFuU3Vic2NyaWJlciBleHRlbmRzIE9uQmxvY2tTdWJzY3JpYmVyIHtcbiAgICAjZmlsdGVyO1xuICAgIGNvbnN0cnVjdG9yKHByb3ZpZGVyLCBmaWx0ZXIpIHtcbiAgICAgICAgc3VwZXIocHJvdmlkZXIpO1xuICAgICAgICB0aGlzLiNmaWx0ZXIgPSBjb3B5KGZpbHRlcik7XG4gICAgfVxuICAgIGFzeW5jIF9wb2xsKGJsb2NrTnVtYmVyLCBwcm92aWRlcikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJAVE9ET1wiKTtcbiAgICAgICAgY29uc29sZS5sb2codGhpcy4jZmlsdGVyKTtcbiAgICB9XG59XG4vKipcbiAqICBBICoqUG9sbGluZ1RyYW5zYWN0aW9uU3Vic2NyaWJlcioqIHdpbGwgcG9sbCBmb3IgYSBnaXZlbiB0cmFuc2FjdGlvblxuICogIGhhc2ggZm9yIGl0cyByZWNlaXB0LlxuICpcbiAqICBAX2RvY2xvYzogYXBpL3Byb3ZpZGVycy9hYnN0cmFjdC1wcm92aWRlclxuICovXG5leHBvcnQgY2xhc3MgUG9sbGluZ1RyYW5zYWN0aW9uU3Vic2NyaWJlciBleHRlbmRzIE9uQmxvY2tTdWJzY3JpYmVyIHtcbiAgICAjaGFzaDtcbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlIGEgbmV3ICoqUG9sbGluZ1RyYW5zYWN0aW9uU3Vic2NyaWJlcioqIGF0dGFjaGVkIHRvXG4gICAgICogICUlcHJvdmlkZXIlJSwgbGlzdGVuaW5nIGZvciAlJWhhc2glJS5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihwcm92aWRlciwgaGFzaCkge1xuICAgICAgICBzdXBlcihwcm92aWRlcik7XG4gICAgICAgIHRoaXMuI2hhc2ggPSBoYXNoO1xuICAgIH1cbiAgICBhc3luYyBfcG9sbChibG9ja051bWJlciwgcHJvdmlkZXIpIHtcbiAgICAgICAgY29uc3QgdHggPSBhd2FpdCBwcm92aWRlci5nZXRUcmFuc2FjdGlvblJlY2VpcHQodGhpcy4jaGFzaCk7XG4gICAgICAgIGlmICh0eCkge1xuICAgICAgICAgICAgcHJvdmlkZXIuZW1pdCh0aGlzLiNoYXNoLCB0eCk7XG4gICAgICAgIH1cbiAgICB9XG59XG4vKipcbiAqICBBICoqUG9sbGluZ0V2ZW50U3Vic2NyaWJlcioqIHdpbGwgcG9sbCBmb3IgYSBnaXZlbiBmaWx0ZXIgZm9yIGl0cyBsb2dzLlxuICpcbiAqICBAX2RvY2xvYzogYXBpL3Byb3ZpZGVycy9hYnN0cmFjdC1wcm92aWRlclxuICovXG5leHBvcnQgY2xhc3MgUG9sbGluZ0V2ZW50U3Vic2NyaWJlciB7XG4gICAgI3Byb3ZpZGVyO1xuICAgICNmaWx0ZXI7XG4gICAgI3BvbGxlcjtcbiAgICAjcnVubmluZztcbiAgICAvLyBUaGUgbW9zdCByZWNlbnQgYmxvY2sgd2UgaGF2ZSBzY2FubmVkIGZvciBldmVudHMuIFRoZSB2YWx1ZSAtMlxuICAgIC8vIGluZGljYXRlcyB3ZSBzdGlsbCBuZWVkIHRvIGZldGNoIGFuIGluaXRpYWwgYmxvY2sgbnVtYmVyXG4gICAgI2Jsb2NrTnVtYmVyO1xuICAgIC8qKlxuICAgICAqICBDcmVhdGUgYSBuZXcgKipQb2xsaW5nVHJhbnNhY3Rpb25TdWJzY3JpYmVyKiogYXR0YWNoZWQgdG9cbiAgICAgKiAgJSVwcm92aWRlciUlLCBsaXN0ZW5pbmcgZm9yICUlZmlsdGVyJSUuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IocHJvdmlkZXIsIGZpbHRlcikge1xuICAgICAgICB0aGlzLiNwcm92aWRlciA9IHByb3ZpZGVyO1xuICAgICAgICB0aGlzLiNmaWx0ZXIgPSBjb3B5KGZpbHRlcik7XG4gICAgICAgIHRoaXMuI3BvbGxlciA9IHRoaXMuI3BvbGwuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy4jcnVubmluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLiNibG9ja051bWJlciA9IC0yO1xuICAgIH1cbiAgICBhc3luYyAjcG9sbChibG9ja051bWJlcikge1xuICAgICAgICAvLyBUaGUgaW5pdGlhbCBibG9jayBoYXNuJ3QgYmVlbiBkZXRlcm1pbmVkIHlldFxuICAgICAgICBpZiAodGhpcy4jYmxvY2tOdW1iZXIgPT09IC0yKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZmlsdGVyID0gY29weSh0aGlzLiNmaWx0ZXIpO1xuICAgICAgICBmaWx0ZXIuZnJvbUJsb2NrID0gdGhpcy4jYmxvY2tOdW1iZXIgKyAxO1xuICAgICAgICBmaWx0ZXIudG9CbG9jayA9IGJsb2NrTnVtYmVyO1xuICAgICAgICBjb25zdCBsb2dzID0gYXdhaXQgdGhpcy4jcHJvdmlkZXIuZ2V0TG9ncyhmaWx0ZXIpO1xuICAgICAgICAvLyBObyBsb2dzIGNvdWxkIGp1c3QgbWVhbiB0aGUgbm9kZSBoYXMgbm90IGluZGV4ZWQgdGhlbSB5ZXQsXG4gICAgICAgIC8vIHNvIHdlIGtlZXAgYSBzbGlkaW5nIHdpbmRvdyBvZiA2MCBibG9ja3MgdG8ga2VlcCBzY2FubmluZ1xuICAgICAgICBpZiAobG9ncy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGlmICh0aGlzLiNibG9ja051bWJlciA8IGJsb2NrTnVtYmVyIC0gNjApIHtcbiAgICAgICAgICAgICAgICB0aGlzLiNibG9ja051bWJlciA9IGJsb2NrTnVtYmVyIC0gNjA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBsb2cgb2YgbG9ncykge1xuICAgICAgICAgICAgdGhpcy4jcHJvdmlkZXIuZW1pdCh0aGlzLiNmaWx0ZXIsIGxvZyk7XG4gICAgICAgICAgICAvLyBPbmx5IGFkdmFuY2UgdGhlIGJsb2NrIG51bWJlciB3aGVuIGxvZ3Mgd2VyZSBmb3VuZCB0b1xuICAgICAgICAgICAgLy8gYWNjb3VudCBmb3IgbmV0d29ya3MgKGxpa2UgQk5CIGFuZCBQb2x5Z29uKSB3aGljaCBtYXlcbiAgICAgICAgICAgIC8vIHNhY3JpZmljZSBldmVudCBjb25zaXN0ZW5jeSBmb3IgYmxvY2sgZXZlbnQgc3BlZWRcbiAgICAgICAgICAgIHRoaXMuI2Jsb2NrTnVtYmVyID0gbG9nLmJsb2NrTnVtYmVyO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN0YXJ0KCkge1xuICAgICAgICBpZiAodGhpcy4jcnVubmluZykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuI3J1bm5pbmcgPSB0cnVlO1xuICAgICAgICBpZiAodGhpcy4jYmxvY2tOdW1iZXIgPT09IC0yKSB7XG4gICAgICAgICAgICB0aGlzLiNwcm92aWRlci5nZXRCbG9ja051bWJlcigpLnRoZW4oKGJsb2NrTnVtYmVyKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy4jYmxvY2tOdW1iZXIgPSBibG9ja051bWJlcjtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuI3Byb3ZpZGVyLm9uKFwiYmxvY2tcIiwgdGhpcy4jcG9sbGVyKTtcbiAgICB9XG4gICAgc3RvcCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLiNydW5uaW5nKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4jcnVubmluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLiNwcm92aWRlci5vZmYoXCJibG9ja1wiLCB0aGlzLiNwb2xsZXIpO1xuICAgIH1cbiAgICBwYXVzZShkcm9wV2hpbGVQYXVzZWQpIHtcbiAgICAgICAgdGhpcy5zdG9wKCk7XG4gICAgICAgIGlmIChkcm9wV2hpbGVQYXVzZWQpIHtcbiAgICAgICAgICAgIHRoaXMuI2Jsb2NrTnVtYmVyID0gLTI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVzdW1lKCkge1xuICAgICAgICB0aGlzLnN0YXJ0KCk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3Vic2NyaWJlci1wb2xsaW5nLmpzLm1hcCJdLCJuYW1lcyI6WyJhc3NlcnQiLCJpc0hleFN0cmluZyIsImNvcHkiLCJvYmoiLCJKU09OIiwicGFyc2UiLCJzdHJpbmdpZnkiLCJnZXRQb2xsaW5nU3Vic2NyaWJlciIsInByb3ZpZGVyIiwiZXZlbnQiLCJQb2xsaW5nQmxvY2tTdWJzY3JpYmVyIiwiUG9sbGluZ1RyYW5zYWN0aW9uU3Vic2NyaWJlciIsIm9wZXJhdGlvbiIsImluZm8iLCJwb2xsZXIiLCJpbnRlcnZhbCIsImJsb2NrTnVtYmVyIiwiY29uc3RydWN0b3IiLCJwb2xsaW5nSW50ZXJ2YWwiLCJ2YWx1ZSIsInBvbGwiLCJnZXRCbG9ja051bWJlciIsImIiLCJlbWl0IiwiZXJyb3IiLCJfc2V0VGltZW91dCIsImJpbmQiLCJzdGFydCIsInN0b3AiLCJfY2xlYXJUaW1lb3V0IiwicGF1c2UiLCJkcm9wV2hpbGVQYXVzZWQiLCJyZXN1bWUiLCJPbkJsb2NrU3Vic2NyaWJlciIsInJ1bm5pbmciLCJfcG9sbCIsIkVycm9yIiwib24iLCJvZmYiLCJQb2xsaW5nQmxvY2tUYWdTdWJzY3JpYmVyIiwidGFnIiwibGFzdEJsb2NrIiwiYmxvY2siLCJnZXRCbG9jayIsIm51bWJlciIsIlBvbGxpbmdPcnBoYW5TdWJzY3JpYmVyIiwiZmlsdGVyIiwiY29uc29sZSIsImxvZyIsImhhc2giLCJ0eCIsImdldFRyYW5zYWN0aW9uUmVjZWlwdCIsIlBvbGxpbmdFdmVudFN1YnNjcmliZXIiLCJmcm9tQmxvY2siLCJ0b0Jsb2NrIiwibG9ncyIsImdldExvZ3MiLCJsZW5ndGgiLCJ0aGVuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.esm/providers/subscriber-polling.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.esm/transaction/accesslist.js":
/*!***************************************************************!*\
  !*** ./node_modules/ethers/lib.esm/transaction/accesslist.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   accessListify: () => (/* binding */ accessListify)\n/* harmony export */ });\n/* harmony import */ var _address_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../address/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/address/address.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/errors.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/data.js\");\n\n\nfunction accessSetify(addr, storageKeys) {\n    return {\n        address: (0,_address_index_js__WEBPACK_IMPORTED_MODULE_0__.getAddress)(addr),\n        storageKeys: storageKeys.map((storageKey, index)=>{\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.isHexString)(storageKey, 32), \"invalid slot\", `storageKeys[${index}]`, storageKey);\n            return storageKey.toLowerCase();\n        })\n    };\n}\n/**\n *  Returns a [[AccessList]] from any ethers-supported access-list structure.\n */ function accessListify(value) {\n    if (Array.isArray(value)) {\n        return value.map((set, index)=>{\n            if (Array.isArray(set)) {\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(set.length === 2, \"invalid slot set\", `value[${index}]`, set);\n                return accessSetify(set[0], set[1]);\n            }\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(set != null && typeof set === \"object\", \"invalid address-slot set\", \"value\", value);\n            return accessSetify(set.address, set.storageKeys);\n        });\n    }\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(value != null && typeof value === \"object\", \"invalid access list\", \"value\", value);\n    const result = Object.keys(value).map((addr)=>{\n        const storageKeys = value[addr].reduce((accum, storageKey)=>{\n            accum[storageKey] = true;\n            return accum;\n        }, {});\n        return accessSetify(addr, Object.keys(storageKeys).sort());\n    });\n    result.sort((a, b)=>a.address.localeCompare(b.address));\n    return result;\n} //# sourceMappingURL=accesslist.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vdHJhbnNhY3Rpb24vYWNjZXNzbGlzdC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQWlEO0FBQ2U7QUFDaEUsU0FBU0csYUFBYUMsSUFBSSxFQUFFQyxXQUFXO0lBQ25DLE9BQU87UUFDSEMsU0FBU04sNkRBQVVBLENBQUNJO1FBQ3BCQyxhQUFhQSxZQUFZRSxHQUFHLENBQUMsQ0FBQ0MsWUFBWUM7WUFDdENSLCtEQUFjQSxDQUFDQyw0REFBV0EsQ0FBQ00sWUFBWSxLQUFLLGdCQUFnQixDQUFDLFlBQVksRUFBRUMsTUFBTSxDQUFDLENBQUMsRUFBRUQ7WUFDckYsT0FBT0EsV0FBV0UsV0FBVztRQUNqQztJQUNKO0FBQ0o7QUFDQTs7Q0FFQyxHQUNNLFNBQVNDLGNBQWNDLEtBQUs7SUFDL0IsSUFBSUMsTUFBTUMsT0FBTyxDQUFDRixRQUFRO1FBQ3RCLE9BQU9BLE1BQU1MLEdBQUcsQ0FBQyxDQUFDUSxLQUFLTjtZQUNuQixJQUFJSSxNQUFNQyxPQUFPLENBQUNDLE1BQU07Z0JBQ3BCZCwrREFBY0EsQ0FBQ2MsSUFBSUMsTUFBTSxLQUFLLEdBQUcsb0JBQW9CLENBQUMsTUFBTSxFQUFFUCxNQUFNLENBQUMsQ0FBQyxFQUFFTTtnQkFDeEUsT0FBT1osYUFBYVksR0FBRyxDQUFDLEVBQUUsRUFBRUEsR0FBRyxDQUFDLEVBQUU7WUFDdEM7WUFDQWQsK0RBQWNBLENBQUNjLE9BQU8sUUFBUSxPQUFRQSxRQUFTLFVBQVUsNEJBQTRCLFNBQVNIO1lBQzlGLE9BQU9ULGFBQWFZLElBQUlULE9BQU8sRUFBRVMsSUFBSVYsV0FBVztRQUNwRDtJQUNKO0lBQ0FKLCtEQUFjQSxDQUFDVyxTQUFTLFFBQVEsT0FBUUEsVUFBVyxVQUFVLHVCQUF1QixTQUFTQTtJQUM3RixNQUFNSyxTQUFTQyxPQUFPQyxJQUFJLENBQUNQLE9BQU9MLEdBQUcsQ0FBQyxDQUFDSDtRQUNuQyxNQUFNQyxjQUFjTyxLQUFLLENBQUNSLEtBQUssQ0FBQ2dCLE1BQU0sQ0FBQyxDQUFDQyxPQUFPYjtZQUMzQ2EsS0FBSyxDQUFDYixXQUFXLEdBQUc7WUFDcEIsT0FBT2E7UUFDWCxHQUFHLENBQUM7UUFDSixPQUFPbEIsYUFBYUMsTUFBTWMsT0FBT0MsSUFBSSxDQUFDZCxhQUFhaUIsSUFBSTtJQUMzRDtJQUNBTCxPQUFPSyxJQUFJLENBQUMsQ0FBQ0MsR0FBR0MsSUFBT0QsRUFBRWpCLE9BQU8sQ0FBQ21CLGFBQWEsQ0FBQ0QsRUFBRWxCLE9BQU87SUFDeEQsT0FBT1c7QUFDWCxFQUNBLHNDQUFzQyIsInNvdXJjZXMiOlsid2VicGFjazovL21lZ2F2aWJlLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL3RyYW5zYWN0aW9uL2FjY2Vzc2xpc3QuanM/ZWU1MSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBnZXRBZGRyZXNzIH0gZnJvbSBcIi4uL2FkZHJlc3MvaW5kZXguanNcIjtcbmltcG9ydCB7IGFzc2VydEFyZ3VtZW50LCBpc0hleFN0cmluZyB9IGZyb20gXCIuLi91dGlscy9pbmRleC5qc1wiO1xuZnVuY3Rpb24gYWNjZXNzU2V0aWZ5KGFkZHIsIHN0b3JhZ2VLZXlzKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgYWRkcmVzczogZ2V0QWRkcmVzcyhhZGRyKSxcbiAgICAgICAgc3RvcmFnZUtleXM6IHN0b3JhZ2VLZXlzLm1hcCgoc3RvcmFnZUtleSwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KGlzSGV4U3RyaW5nKHN0b3JhZ2VLZXksIDMyKSwgXCJpbnZhbGlkIHNsb3RcIiwgYHN0b3JhZ2VLZXlzWyR7aW5kZXh9XWAsIHN0b3JhZ2VLZXkpO1xuICAgICAgICAgICAgcmV0dXJuIHN0b3JhZ2VLZXkudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgfSlcbiAgICB9O1xufVxuLyoqXG4gKiAgUmV0dXJucyBhIFtbQWNjZXNzTGlzdF1dIGZyb20gYW55IGV0aGVycy1zdXBwb3J0ZWQgYWNjZXNzLWxpc3Qgc3RydWN0dXJlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gYWNjZXNzTGlzdGlmeSh2YWx1ZSkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gdmFsdWUubWFwKChzZXQsIGluZGV4KSA9PiB7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShzZXQpKSB7XG4gICAgICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoc2V0Lmxlbmd0aCA9PT0gMiwgXCJpbnZhbGlkIHNsb3Qgc2V0XCIsIGB2YWx1ZVske2luZGV4fV1gLCBzZXQpO1xuICAgICAgICAgICAgICAgIHJldHVybiBhY2Nlc3NTZXRpZnkoc2V0WzBdLCBzZXRbMV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoc2V0ICE9IG51bGwgJiYgdHlwZW9mIChzZXQpID09PSBcIm9iamVjdFwiLCBcImludmFsaWQgYWRkcmVzcy1zbG90IHNldFwiLCBcInZhbHVlXCIsIHZhbHVlKTtcbiAgICAgICAgICAgIHJldHVybiBhY2Nlc3NTZXRpZnkoc2V0LmFkZHJlc3MsIHNldC5zdG9yYWdlS2V5cyk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhc3NlcnRBcmd1bWVudCh2YWx1ZSAhPSBudWxsICYmIHR5cGVvZiAodmFsdWUpID09PSBcIm9iamVjdFwiLCBcImludmFsaWQgYWNjZXNzIGxpc3RcIiwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG4gICAgY29uc3QgcmVzdWx0ID0gT2JqZWN0LmtleXModmFsdWUpLm1hcCgoYWRkcikgPT4ge1xuICAgICAgICBjb25zdCBzdG9yYWdlS2V5cyA9IHZhbHVlW2FkZHJdLnJlZHVjZSgoYWNjdW0sIHN0b3JhZ2VLZXkpID0+IHtcbiAgICAgICAgICAgIGFjY3VtW3N0b3JhZ2VLZXldID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybiBhY2N1bTtcbiAgICAgICAgfSwge30pO1xuICAgICAgICByZXR1cm4gYWNjZXNzU2V0aWZ5KGFkZHIsIE9iamVjdC5rZXlzKHN0b3JhZ2VLZXlzKS5zb3J0KCkpO1xuICAgIH0pO1xuICAgIHJlc3VsdC5zb3J0KChhLCBiKSA9PiAoYS5hZGRyZXNzLmxvY2FsZUNvbXBhcmUoYi5hZGRyZXNzKSkpO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hY2Nlc3NsaXN0LmpzLm1hcCJdLCJuYW1lcyI6WyJnZXRBZGRyZXNzIiwiYXNzZXJ0QXJndW1lbnQiLCJpc0hleFN0cmluZyIsImFjY2Vzc1NldGlmeSIsImFkZHIiLCJzdG9yYWdlS2V5cyIsImFkZHJlc3MiLCJtYXAiLCJzdG9yYWdlS2V5IiwiaW5kZXgiLCJ0b0xvd2VyQ2FzZSIsImFjY2Vzc0xpc3RpZnkiLCJ2YWx1ZSIsIkFycmF5IiwiaXNBcnJheSIsInNldCIsImxlbmd0aCIsInJlc3VsdCIsIk9iamVjdCIsImtleXMiLCJyZWR1Y2UiLCJhY2N1bSIsInNvcnQiLCJhIiwiYiIsImxvY2FsZUNvbXBhcmUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.esm/transaction/accesslist.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.esm/transaction/address.js":
/*!************************************************************!*\
  !*** ./node_modules/ethers/lib.esm/transaction/address.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   computeAddress: () => (/* binding */ computeAddress),\n/* harmony export */   recoverAddress: () => (/* binding */ recoverAddress)\n/* harmony export */ });\n/* harmony import */ var _address_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../address/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/address/address.js\");\n/* harmony import */ var _crypto_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../crypto/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/crypto/signing-key.js\");\n/* harmony import */ var _crypto_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../crypto/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/crypto/keccak.js\");\n\n\n/**\n *  Returns the address for the %%key%%.\n *\n *  The key may be any standard form of public key or a private key.\n */ function computeAddress(key) {\n    let pubkey;\n    if (typeof key === \"string\") {\n        pubkey = _crypto_index_js__WEBPACK_IMPORTED_MODULE_0__.SigningKey.computePublicKey(key, false);\n    } else {\n        pubkey = key.publicKey;\n    }\n    return (0,_address_index_js__WEBPACK_IMPORTED_MODULE_1__.getAddress)((0,_crypto_index_js__WEBPACK_IMPORTED_MODULE_2__.keccak256)(\"0x\" + pubkey.substring(4)).substring(26));\n}\n/**\n *  Returns the recovered address for the private key that was\n *  used to sign %%digest%% that resulted in %%signature%%.\n */ function recoverAddress(digest, signature) {\n    return computeAddress(_crypto_index_js__WEBPACK_IMPORTED_MODULE_0__.SigningKey.recoverPublicKey(digest, signature));\n} //# sourceMappingURL=address.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vdHJhbnNhY3Rpb24vYWRkcmVzcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFpRDtBQUNVO0FBQzNEOzs7O0NBSUMsR0FDTSxTQUFTRyxlQUFlQyxHQUFHO0lBQzlCLElBQUlDO0lBQ0osSUFBSSxPQUFRRCxRQUFTLFVBQVU7UUFDM0JDLFNBQVNILHdEQUFVQSxDQUFDSSxnQkFBZ0IsQ0FBQ0YsS0FBSztJQUM5QyxPQUNLO1FBQ0RDLFNBQVNELElBQUlHLFNBQVM7SUFDMUI7SUFDQSxPQUFPUCw2REFBVUEsQ0FBQ0MsMkRBQVNBLENBQUMsT0FBT0ksT0FBT0csU0FBUyxDQUFDLElBQUlBLFNBQVMsQ0FBQztBQUN0RTtBQUNBOzs7Q0FHQyxHQUNNLFNBQVNDLGVBQWVDLE1BQU0sRUFBRUMsU0FBUztJQUM1QyxPQUFPUixlQUFlRCx3REFBVUEsQ0FBQ1UsZ0JBQWdCLENBQUNGLFFBQVFDO0FBQzlELEVBQ0EsbUNBQW1DIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbWVnYXZpYmUtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vdHJhbnNhY3Rpb24vYWRkcmVzcy5qcz8wZDBiIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGdldEFkZHJlc3MgfSBmcm9tIFwiLi4vYWRkcmVzcy9pbmRleC5qc1wiO1xuaW1wb3J0IHsga2VjY2FrMjU2LCBTaWduaW5nS2V5IH0gZnJvbSBcIi4uL2NyeXB0by9pbmRleC5qc1wiO1xuLyoqXG4gKiAgUmV0dXJucyB0aGUgYWRkcmVzcyBmb3IgdGhlICUla2V5JSUuXG4gKlxuICogIFRoZSBrZXkgbWF5IGJlIGFueSBzdGFuZGFyZCBmb3JtIG9mIHB1YmxpYyBrZXkgb3IgYSBwcml2YXRlIGtleS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbXB1dGVBZGRyZXNzKGtleSkge1xuICAgIGxldCBwdWJrZXk7XG4gICAgaWYgKHR5cGVvZiAoa2V5KSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBwdWJrZXkgPSBTaWduaW5nS2V5LmNvbXB1dGVQdWJsaWNLZXkoa2V5LCBmYWxzZSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBwdWJrZXkgPSBrZXkucHVibGljS2V5O1xuICAgIH1cbiAgICByZXR1cm4gZ2V0QWRkcmVzcyhrZWNjYWsyNTYoXCIweFwiICsgcHVia2V5LnN1YnN0cmluZyg0KSkuc3Vic3RyaW5nKDI2KSk7XG59XG4vKipcbiAqICBSZXR1cm5zIHRoZSByZWNvdmVyZWQgYWRkcmVzcyBmb3IgdGhlIHByaXZhdGUga2V5IHRoYXQgd2FzXG4gKiAgdXNlZCB0byBzaWduICUlZGlnZXN0JSUgdGhhdCByZXN1bHRlZCBpbiAlJXNpZ25hdHVyZSUlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVjb3ZlckFkZHJlc3MoZGlnZXN0LCBzaWduYXR1cmUpIHtcbiAgICByZXR1cm4gY29tcHV0ZUFkZHJlc3MoU2lnbmluZ0tleS5yZWNvdmVyUHVibGljS2V5KGRpZ2VzdCwgc2lnbmF0dXJlKSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hZGRyZXNzLmpzLm1hcCJdLCJuYW1lcyI6WyJnZXRBZGRyZXNzIiwia2VjY2FrMjU2IiwiU2lnbmluZ0tleSIsImNvbXB1dGVBZGRyZXNzIiwia2V5IiwicHVia2V5IiwiY29tcHV0ZVB1YmxpY0tleSIsInB1YmxpY0tleSIsInN1YnN0cmluZyIsInJlY292ZXJBZGRyZXNzIiwiZGlnZXN0Iiwic2lnbmF0dXJlIiwicmVjb3ZlclB1YmxpY0tleSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.esm/transaction/address.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.esm/transaction/authorization.js":
/*!******************************************************************!*\
  !*** ./node_modules/ethers/lib.esm/transaction/authorization.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   authorizationify: () => (/* binding */ authorizationify)\n/* harmony export */ });\n/* harmony import */ var _address_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../address/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/address/address.js\");\n/* harmony import */ var _crypto_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../crypto/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/crypto/signature.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/maths.js\");\n\n\n\nfunction authorizationify(auth) {\n    return {\n        address: (0,_address_index_js__WEBPACK_IMPORTED_MODULE_0__.getAddress)(auth.address),\n        nonce: (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.getBigInt)(auth.nonce != null ? auth.nonce : 0),\n        chainId: (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.getBigInt)(auth.chainId != null ? auth.chainId : 0),\n        signature: _crypto_index_js__WEBPACK_IMPORTED_MODULE_2__.Signature.from(auth.signature)\n    };\n} //# sourceMappingURL=authorization.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vdHJhbnNhY3Rpb24vYXV0aG9yaXphdGlvbi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQWlEO0FBQ0Y7QUFDRDtBQUN2QyxTQUFTRyxpQkFBaUJDLElBQUk7SUFDakMsT0FBTztRQUNIQyxTQUFTTCw2REFBVUEsQ0FBQ0ksS0FBS0MsT0FBTztRQUNoQ0MsT0FBT0osMERBQVNBLENBQUMsS0FBTUksS0FBSyxJQUFJLE9BQVFGLEtBQUtFLEtBQUssR0FBRztRQUNyREMsU0FBU0wsMERBQVNBLENBQUMsS0FBTUssT0FBTyxJQUFJLE9BQVFILEtBQUtHLE9BQU8sR0FBRztRQUMzREMsV0FBV1AsdURBQVNBLENBQUNRLElBQUksQ0FBQ0wsS0FBS0ksU0FBUztJQUM1QztBQUNKLEVBQ0EseUNBQXlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbWVnYXZpYmUtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vdHJhbnNhY3Rpb24vYXV0aG9yaXphdGlvbi5qcz9jNDE1Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGdldEFkZHJlc3MgfSBmcm9tIFwiLi4vYWRkcmVzcy9pbmRleC5qc1wiO1xuaW1wb3J0IHsgU2lnbmF0dXJlIH0gZnJvbSBcIi4uL2NyeXB0by9pbmRleC5qc1wiO1xuaW1wb3J0IHsgZ2V0QmlnSW50IH0gZnJvbSBcIi4uL3V0aWxzL2luZGV4LmpzXCI7XG5leHBvcnQgZnVuY3Rpb24gYXV0aG9yaXphdGlvbmlmeShhdXRoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgYWRkcmVzczogZ2V0QWRkcmVzcyhhdXRoLmFkZHJlc3MpLFxuICAgICAgICBub25jZTogZ2V0QmlnSW50KChhdXRoLm5vbmNlICE9IG51bGwpID8gYXV0aC5ub25jZSA6IDApLFxuICAgICAgICBjaGFpbklkOiBnZXRCaWdJbnQoKGF1dGguY2hhaW5JZCAhPSBudWxsKSA/IGF1dGguY2hhaW5JZCA6IDApLFxuICAgICAgICBzaWduYXR1cmU6IFNpZ25hdHVyZS5mcm9tKGF1dGguc2lnbmF0dXJlKVxuICAgIH07XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hdXRob3JpemF0aW9uLmpzLm1hcCJdLCJuYW1lcyI6WyJnZXRBZGRyZXNzIiwiU2lnbmF0dXJlIiwiZ2V0QmlnSW50IiwiYXV0aG9yaXphdGlvbmlmeSIsImF1dGgiLCJhZGRyZXNzIiwibm9uY2UiLCJjaGFpbklkIiwic2lnbmF0dXJlIiwiZnJvbSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.esm/transaction/authorization.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.esm/transaction/transaction.js":
/*!****************************************************************!*\
  !*** ./node_modules/ethers/lib.esm/transaction/transaction.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Transaction: () => (/* binding */ Transaction)\n/* harmony export */ });\n/* harmony import */ var _address_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../address/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/address/address.js\");\n/* harmony import */ var _constants_addresses_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../constants/addresses.js */ \"(ssr)/./node_modules/ethers/lib.esm/constants/addresses.js\");\n/* harmony import */ var _crypto_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../crypto/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/crypto/sha2.js\");\n/* harmony import */ var _crypto_index_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../crypto/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/crypto/signature.js\");\n/* harmony import */ var _crypto_index_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../crypto/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/crypto/keccak.js\");\n/* harmony import */ var _crypto_index_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../crypto/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/crypto/signing-key.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/data.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/errors.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/maths.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/rlp-decode.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/rlp-encode.js\");\n/* harmony import */ var _accesslist_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./accesslist.js */ \"(ssr)/./node_modules/ethers/lib.esm/transaction/accesslist.js\");\n/* harmony import */ var _authorization_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./authorization.js */ \"(ssr)/./node_modules/ethers/lib.esm/transaction/authorization.js\");\n/* harmony import */ var _address_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./address.js */ \"(ssr)/./node_modules/ethers/lib.esm/transaction/address.js\");\n\n\n\n\n\n\n\nconst BN_0 = BigInt(0);\nconst BN_2 = BigInt(2);\nconst BN_27 = BigInt(27);\nconst BN_28 = BigInt(28);\nconst BN_35 = BigInt(35);\nconst BN_MAX_UINT = BigInt(\"0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\");\nconst BLOB_SIZE = 4096 * 32;\nfunction getKzgLibrary(kzg) {\n    const blobToKzgCommitment = (blob)=>{\n        if (\"computeBlobProof\" in kzg) {\n            // micro-ecc-signer; check for computeBlobProof since this API\n            // expects a string while the kzg-wasm below expects a Unit8Array\n            if (\"blobToKzgCommitment\" in kzg && typeof kzg.blobToKzgCommitment === \"function\") {\n                return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBytes)(kzg.blobToKzgCommitment((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(blob)));\n            }\n        } else if (\"blobToKzgCommitment\" in kzg && typeof kzg.blobToKzgCommitment === \"function\") {\n            // kzg-wasm <0.5.0; blobToKzgCommitment(Uint8Array) => Uint8Array\n            return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBytes)(kzg.blobToKzgCommitment(blob));\n        }\n        // kzg-wasm >= 0.5.0; blobToKZGCommitment(string) => string\n        if (\"blobToKZGCommitment\" in kzg && typeof kzg.blobToKZGCommitment === \"function\") {\n            return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBytes)(kzg.blobToKZGCommitment((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(blob)));\n        }\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(false, \"unsupported KZG library\", \"kzg\", kzg);\n    };\n    const computeBlobKzgProof = (blob, commitment)=>{\n        // micro-ecc-signer\n        if (\"computeBlobProof\" in kzg && typeof kzg.computeBlobProof === \"function\") {\n            return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBytes)(kzg.computeBlobProof((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(blob), (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(commitment)));\n        }\n        // kzg-wasm <0.5.0; computeBlobKzgProof(Uint8Array, Uint8Array) => Uint8Array\n        if (\"computeBlobKzgProof\" in kzg && typeof kzg.computeBlobKzgProof === \"function\") {\n            return kzg.computeBlobKzgProof(blob, commitment);\n        }\n        // kzg-wasm >= 0.5.0; computeBlobKZGProof(string, string) => string\n        if (\"computeBlobKZGProof\" in kzg && typeof kzg.computeBlobKZGProof === \"function\") {\n            return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBytes)(kzg.computeBlobKZGProof((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(blob), (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(commitment)));\n        }\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(false, \"unsupported KZG library\", \"kzg\", kzg);\n    };\n    return {\n        blobToKzgCommitment,\n        computeBlobKzgProof\n    };\n}\nfunction getVersionedHash(version, hash) {\n    let versioned = version.toString(16);\n    while(versioned.length < 2){\n        versioned = \"0\" + versioned;\n    }\n    versioned += (0,_crypto_index_js__WEBPACK_IMPORTED_MODULE_2__.sha256)(hash).substring(4);\n    return \"0x\" + versioned;\n}\nfunction handleAddress(value) {\n    if (value === \"0x\") {\n        return null;\n    }\n    return (0,_address_index_js__WEBPACK_IMPORTED_MODULE_3__.getAddress)(value);\n}\nfunction handleAccessList(value, param) {\n    try {\n        return (0,_accesslist_js__WEBPACK_IMPORTED_MODULE_4__.accessListify)(value);\n    } catch (error) {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(false, error.message, param, value);\n    }\n}\nfunction handleAuthorizationList(value, param) {\n    try {\n        if (!Array.isArray(value)) {\n            throw new Error(\"authorizationList: invalid array\");\n        }\n        const result = [];\n        for(let i = 0; i < value.length; i++){\n            const auth = value[i];\n            if (!Array.isArray(auth)) {\n                throw new Error(`authorization[${i}]: invalid array`);\n            }\n            if (auth.length !== 6) {\n                throw new Error(`authorization[${i}]: wrong length`);\n            }\n            if (!auth[1]) {\n                throw new Error(`authorization[${i}]: null address`);\n            }\n            result.push({\n                address: handleAddress(auth[1]),\n                nonce: handleUint(auth[2], \"nonce\"),\n                chainId: handleUint(auth[0], \"chainId\"),\n                signature: _crypto_index_js__WEBPACK_IMPORTED_MODULE_5__.Signature.from({\n                    yParity: handleNumber(auth[3], \"yParity\"),\n                    r: (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.zeroPadValue)(auth[4], 32),\n                    s: (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.zeroPadValue)(auth[5], 32)\n                })\n            });\n        }\n        return result;\n    } catch (error) {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(false, error.message, param, value);\n    }\n}\nfunction handleNumber(_value, param) {\n    if (_value === \"0x\") {\n        return 0;\n    }\n    return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_6__.getNumber)(_value, param);\n}\nfunction handleUint(_value, param) {\n    if (_value === \"0x\") {\n        return BN_0;\n    }\n    const value = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_6__.getBigInt)(_value, param);\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(value <= BN_MAX_UINT, \"value exceeds uint size\", param, value);\n    return value;\n}\nfunction formatNumber(_value, name) {\n    const value = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_6__.getBigInt)(_value, \"value\");\n    const result = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_6__.toBeArray)(value);\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(result.length <= 32, `value too large`, `tx.${name}`, value);\n    return result;\n}\nfunction formatAccessList(value) {\n    return (0,_accesslist_js__WEBPACK_IMPORTED_MODULE_4__.accessListify)(value).map((set)=>[\n            set.address,\n            set.storageKeys\n        ]);\n}\nfunction formatAuthorizationList(value) {\n    return value.map((a)=>{\n        return [\n            formatNumber(a.chainId, \"chainId\"),\n            a.address,\n            formatNumber(a.nonce, \"nonce\"),\n            formatNumber(a.signature.yParity, \"yParity\"),\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_6__.toBeArray)(a.signature.r),\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_6__.toBeArray)(a.signature.s)\n        ];\n    });\n}\nfunction formatHashes(value, param) {\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(Array.isArray(value), `invalid ${param}`, \"value\", value);\n    for(let i = 0; i < value.length; i++){\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.isHexString)(value[i], 32), \"invalid ${ param } hash\", `value[${i}]`, value[i]);\n    }\n    return value;\n}\nfunction _parseLegacy(data) {\n    const fields = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_7__.decodeRlp)(data);\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(Array.isArray(fields) && (fields.length === 9 || fields.length === 6), \"invalid field count for legacy transaction\", \"data\", data);\n    const tx = {\n        type: 0,\n        nonce: handleNumber(fields[0], \"nonce\"),\n        gasPrice: handleUint(fields[1], \"gasPrice\"),\n        gasLimit: handleUint(fields[2], \"gasLimit\"),\n        to: handleAddress(fields[3]),\n        value: handleUint(fields[4], \"value\"),\n        data: (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(fields[5]),\n        chainId: BN_0\n    };\n    // Legacy unsigned transaction\n    if (fields.length === 6) {\n        return tx;\n    }\n    const v = handleUint(fields[6], \"v\");\n    const r = handleUint(fields[7], \"r\");\n    const s = handleUint(fields[8], \"s\");\n    if (r === BN_0 && s === BN_0) {\n        // EIP-155 unsigned transaction\n        tx.chainId = v;\n    } else {\n        // Compute the EIP-155 chain ID (or 0 for legacy)\n        let chainId = (v - BN_35) / BN_2;\n        if (chainId < BN_0) {\n            chainId = BN_0;\n        }\n        tx.chainId = chainId;\n        // Signed Legacy Transaction\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(chainId !== BN_0 || v === BN_27 || v === BN_28, \"non-canonical legacy v\", \"v\", fields[6]);\n        tx.signature = _crypto_index_js__WEBPACK_IMPORTED_MODULE_5__.Signature.from({\n            r: (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.zeroPadValue)(fields[7], 32),\n            s: (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.zeroPadValue)(fields[8], 32),\n            v\n        });\n    //tx.hash = keccak256(data);\n    }\n    return tx;\n}\nfunction _serializeLegacy(tx, sig) {\n    const fields = [\n        formatNumber(tx.nonce, \"nonce\"),\n        formatNumber(tx.gasPrice || 0, \"gasPrice\"),\n        formatNumber(tx.gasLimit, \"gasLimit\"),\n        tx.to || \"0x\",\n        formatNumber(tx.value, \"value\"),\n        tx.data\n    ];\n    let chainId = BN_0;\n    if (tx.chainId != BN_0) {\n        // A chainId was provided; if non-zero we'll use EIP-155\n        chainId = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_6__.getBigInt)(tx.chainId, \"tx.chainId\");\n        // We have a chainId in the tx and an EIP-155 v in the signature,\n        // make sure they agree with each other\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(!sig || sig.networkV == null || sig.legacyChainId === chainId, \"tx.chainId/sig.v mismatch\", \"sig\", sig);\n    } else if (tx.signature) {\n        // No explicit chainId, but EIP-155 have a derived implicit chainId\n        const legacy = tx.signature.legacyChainId;\n        if (legacy != null) {\n            chainId = legacy;\n        }\n    }\n    // Requesting an unsigned transaction\n    if (!sig) {\n        // We have an EIP-155 transaction (chainId was specified and non-zero)\n        if (chainId !== BN_0) {\n            fields.push((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_6__.toBeArray)(chainId));\n            fields.push(\"0x\");\n            fields.push(\"0x\");\n        }\n        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_8__.encodeRlp)(fields);\n    }\n    // @TODO: We should probably check that tx.signature, chainId, and sig\n    //        match but that logic could break existing code, so schedule\n    //        this for the next major bump.\n    // Compute the EIP-155 v\n    let v = BigInt(27 + sig.yParity);\n    if (chainId !== BN_0) {\n        v = _crypto_index_js__WEBPACK_IMPORTED_MODULE_5__.Signature.getChainIdV(chainId, sig.v);\n    } else if (BigInt(sig.v) !== v) {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(false, \"tx.chainId/sig.v mismatch\", \"sig\", sig);\n    }\n    // Add the signature\n    fields.push((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_6__.toBeArray)(v));\n    fields.push((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_6__.toBeArray)(sig.r));\n    fields.push((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_6__.toBeArray)(sig.s));\n    return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_8__.encodeRlp)(fields);\n}\nfunction _parseEipSignature(tx, fields) {\n    let yParity;\n    try {\n        yParity = handleNumber(fields[0], \"yParity\");\n        if (yParity !== 0 && yParity !== 1) {\n            throw new Error(\"bad yParity\");\n        }\n    } catch (error) {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(false, \"invalid yParity\", \"yParity\", fields[0]);\n    }\n    const r = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.zeroPadValue)(fields[1], 32);\n    const s = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.zeroPadValue)(fields[2], 32);\n    const signature = _crypto_index_js__WEBPACK_IMPORTED_MODULE_5__.Signature.from({\n        r,\n        s,\n        yParity\n    });\n    tx.signature = signature;\n}\nfunction _parseEip1559(data) {\n    const fields = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_7__.decodeRlp)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBytes)(data).slice(1));\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(Array.isArray(fields) && (fields.length === 9 || fields.length === 12), \"invalid field count for transaction type: 2\", \"data\", (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(data));\n    const tx = {\n        type: 2,\n        chainId: handleUint(fields[0], \"chainId\"),\n        nonce: handleNumber(fields[1], \"nonce\"),\n        maxPriorityFeePerGas: handleUint(fields[2], \"maxPriorityFeePerGas\"),\n        maxFeePerGas: handleUint(fields[3], \"maxFeePerGas\"),\n        gasPrice: null,\n        gasLimit: handleUint(fields[4], \"gasLimit\"),\n        to: handleAddress(fields[5]),\n        value: handleUint(fields[6], \"value\"),\n        data: (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(fields[7]),\n        accessList: handleAccessList(fields[8], \"accessList\")\n    };\n    // Unsigned EIP-1559 Transaction\n    if (fields.length === 9) {\n        return tx;\n    }\n    //tx.hash = keccak256(data);\n    _parseEipSignature(tx, fields.slice(9));\n    return tx;\n}\nfunction _serializeEip1559(tx, sig) {\n    const fields = [\n        formatNumber(tx.chainId, \"chainId\"),\n        formatNumber(tx.nonce, \"nonce\"),\n        formatNumber(tx.maxPriorityFeePerGas || 0, \"maxPriorityFeePerGas\"),\n        formatNumber(tx.maxFeePerGas || 0, \"maxFeePerGas\"),\n        formatNumber(tx.gasLimit, \"gasLimit\"),\n        tx.to || \"0x\",\n        formatNumber(tx.value, \"value\"),\n        tx.data,\n        formatAccessList(tx.accessList || [])\n    ];\n    if (sig) {\n        fields.push(formatNumber(sig.yParity, \"yParity\"));\n        fields.push((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_6__.toBeArray)(sig.r));\n        fields.push((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_6__.toBeArray)(sig.s));\n    }\n    return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.concat)([\n        \"0x02\",\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_8__.encodeRlp)(fields)\n    ]);\n}\nfunction _parseEip2930(data) {\n    const fields = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_7__.decodeRlp)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBytes)(data).slice(1));\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(Array.isArray(fields) && (fields.length === 8 || fields.length === 11), \"invalid field count for transaction type: 1\", \"data\", (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(data));\n    const tx = {\n        type: 1,\n        chainId: handleUint(fields[0], \"chainId\"),\n        nonce: handleNumber(fields[1], \"nonce\"),\n        gasPrice: handleUint(fields[2], \"gasPrice\"),\n        gasLimit: handleUint(fields[3], \"gasLimit\"),\n        to: handleAddress(fields[4]),\n        value: handleUint(fields[5], \"value\"),\n        data: (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(fields[6]),\n        accessList: handleAccessList(fields[7], \"accessList\")\n    };\n    // Unsigned EIP-2930 Transaction\n    if (fields.length === 8) {\n        return tx;\n    }\n    //tx.hash = keccak256(data);\n    _parseEipSignature(tx, fields.slice(8));\n    return tx;\n}\nfunction _serializeEip2930(tx, sig) {\n    const fields = [\n        formatNumber(tx.chainId, \"chainId\"),\n        formatNumber(tx.nonce, \"nonce\"),\n        formatNumber(tx.gasPrice || 0, \"gasPrice\"),\n        formatNumber(tx.gasLimit, \"gasLimit\"),\n        tx.to || \"0x\",\n        formatNumber(tx.value, \"value\"),\n        tx.data,\n        formatAccessList(tx.accessList || [])\n    ];\n    if (sig) {\n        fields.push(formatNumber(sig.yParity, \"recoveryParam\"));\n        fields.push((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_6__.toBeArray)(sig.r));\n        fields.push((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_6__.toBeArray)(sig.s));\n    }\n    return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.concat)([\n        \"0x01\",\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_8__.encodeRlp)(fields)\n    ]);\n}\nfunction _parseEip4844(data) {\n    let fields = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_7__.decodeRlp)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBytes)(data).slice(1));\n    let typeName = \"3\";\n    let blobs = null;\n    // Parse the network format\n    if (fields.length === 4 && Array.isArray(fields[0])) {\n        typeName = \"3 (network format)\";\n        const fBlobs = fields[1], fCommits = fields[2], fProofs = fields[3];\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(Array.isArray(fBlobs), \"invalid network format: blobs not an array\", \"fields[1]\", fBlobs);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(Array.isArray(fCommits), \"invalid network format: commitments not an array\", \"fields[2]\", fCommits);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(Array.isArray(fProofs), \"invalid network format: proofs not an array\", \"fields[3]\", fProofs);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(fBlobs.length === fCommits.length, \"invalid network format: blobs/commitments length mismatch\", \"fields\", fields);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(fBlobs.length === fProofs.length, \"invalid network format: blobs/proofs length mismatch\", \"fields\", fields);\n        blobs = [];\n        for(let i = 0; i < fields[1].length; i++){\n            blobs.push({\n                data: fBlobs[i],\n                commitment: fCommits[i],\n                proof: fProofs[i]\n            });\n        }\n        fields = fields[0];\n    }\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(Array.isArray(fields) && (fields.length === 11 || fields.length === 14), `invalid field count for transaction type: ${typeName}`, \"data\", (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(data));\n    const tx = {\n        type: 3,\n        chainId: handleUint(fields[0], \"chainId\"),\n        nonce: handleNumber(fields[1], \"nonce\"),\n        maxPriorityFeePerGas: handleUint(fields[2], \"maxPriorityFeePerGas\"),\n        maxFeePerGas: handleUint(fields[3], \"maxFeePerGas\"),\n        gasPrice: null,\n        gasLimit: handleUint(fields[4], \"gasLimit\"),\n        to: handleAddress(fields[5]),\n        value: handleUint(fields[6], \"value\"),\n        data: (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(fields[7]),\n        accessList: handleAccessList(fields[8], \"accessList\"),\n        maxFeePerBlobGas: handleUint(fields[9], \"maxFeePerBlobGas\"),\n        blobVersionedHashes: fields[10]\n    };\n    if (blobs) {\n        tx.blobs = blobs;\n    }\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(tx.to != null, `invalid address for transaction type: ${typeName}`, \"data\", data);\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(Array.isArray(tx.blobVersionedHashes), \"invalid blobVersionedHashes: must be an array\", \"data\", data);\n    for(let i = 0; i < tx.blobVersionedHashes.length; i++){\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.isHexString)(tx.blobVersionedHashes[i], 32), `invalid blobVersionedHash at index ${i}: must be length 32`, \"data\", data);\n    }\n    // Unsigned EIP-4844 Transaction\n    if (fields.length === 11) {\n        return tx;\n    }\n    // @TODO: Do we need to do this? This is only called internally\n    // and used to verify hashes; it might save time to not do this\n    //tx.hash = keccak256(concat([ \"0x03\", encodeRlp(fields) ]));\n    _parseEipSignature(tx, fields.slice(11));\n    return tx;\n}\nfunction _serializeEip4844(tx, sig, blobs) {\n    const fields = [\n        formatNumber(tx.chainId, \"chainId\"),\n        formatNumber(tx.nonce, \"nonce\"),\n        formatNumber(tx.maxPriorityFeePerGas || 0, \"maxPriorityFeePerGas\"),\n        formatNumber(tx.maxFeePerGas || 0, \"maxFeePerGas\"),\n        formatNumber(tx.gasLimit, \"gasLimit\"),\n        tx.to || _constants_addresses_js__WEBPACK_IMPORTED_MODULE_9__.ZeroAddress,\n        formatNumber(tx.value, \"value\"),\n        tx.data,\n        formatAccessList(tx.accessList || []),\n        formatNumber(tx.maxFeePerBlobGas || 0, \"maxFeePerBlobGas\"),\n        formatHashes(tx.blobVersionedHashes || [], \"blobVersionedHashes\")\n    ];\n    if (sig) {\n        fields.push(formatNumber(sig.yParity, \"yParity\"));\n        fields.push((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_6__.toBeArray)(sig.r));\n        fields.push((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_6__.toBeArray)(sig.s));\n        // We have blobs; return the network wrapped format\n        if (blobs) {\n            return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.concat)([\n                \"0x03\",\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_8__.encodeRlp)([\n                    fields,\n                    blobs.map((b)=>b.data),\n                    blobs.map((b)=>b.commitment),\n                    blobs.map((b)=>b.proof)\n                ])\n            ]);\n        }\n    }\n    return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.concat)([\n        \"0x03\",\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_8__.encodeRlp)(fields)\n    ]);\n}\nfunction _parseEip7702(data) {\n    const fields = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_7__.decodeRlp)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBytes)(data).slice(1));\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(Array.isArray(fields) && (fields.length === 10 || fields.length === 13), \"invalid field count for transaction type: 4\", \"data\", (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(data));\n    const tx = {\n        type: 4,\n        chainId: handleUint(fields[0], \"chainId\"),\n        nonce: handleNumber(fields[1], \"nonce\"),\n        maxPriorityFeePerGas: handleUint(fields[2], \"maxPriorityFeePerGas\"),\n        maxFeePerGas: handleUint(fields[3], \"maxFeePerGas\"),\n        gasPrice: null,\n        gasLimit: handleUint(fields[4], \"gasLimit\"),\n        to: handleAddress(fields[5]),\n        value: handleUint(fields[6], \"value\"),\n        data: (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(fields[7]),\n        accessList: handleAccessList(fields[8], \"accessList\"),\n        authorizationList: handleAuthorizationList(fields[9], \"authorizationList\")\n    };\n    // Unsigned EIP-7702 Transaction\n    if (fields.length === 10) {\n        return tx;\n    }\n    _parseEipSignature(tx, fields.slice(10));\n    return tx;\n}\nfunction _serializeEip7702(tx, sig) {\n    const fields = [\n        formatNumber(tx.chainId, \"chainId\"),\n        formatNumber(tx.nonce, \"nonce\"),\n        formatNumber(tx.maxPriorityFeePerGas || 0, \"maxPriorityFeePerGas\"),\n        formatNumber(tx.maxFeePerGas || 0, \"maxFeePerGas\"),\n        formatNumber(tx.gasLimit, \"gasLimit\"),\n        tx.to || \"0x\",\n        formatNumber(tx.value, \"value\"),\n        tx.data,\n        formatAccessList(tx.accessList || []),\n        formatAuthorizationList(tx.authorizationList || [])\n    ];\n    if (sig) {\n        fields.push(formatNumber(sig.yParity, \"yParity\"));\n        fields.push((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_6__.toBeArray)(sig.r));\n        fields.push((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_6__.toBeArray)(sig.s));\n    }\n    return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.concat)([\n        \"0x04\",\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_8__.encodeRlp)(fields)\n    ]);\n}\n/**\n *  A **Transaction** describes an operation to be executed on\n *  Ethereum by an Externally Owned Account (EOA). It includes\n *  who (the [[to]] address), what (the [[data]]) and how much (the\n *  [[value]] in ether) the operation should entail.\n *\n *  @example:\n *    tx = new Transaction()\n *    //_result:\n *\n *    tx.data = \"0x1234\";\n *    //_result:\n */ class Transaction {\n    #type;\n    #to;\n    #data;\n    #nonce;\n    #gasLimit;\n    #gasPrice;\n    #maxPriorityFeePerGas;\n    #maxFeePerGas;\n    #value;\n    #chainId;\n    #sig;\n    #accessList;\n    #maxFeePerBlobGas;\n    #blobVersionedHashes;\n    #kzg;\n    #blobs;\n    #auths;\n    /**\n     *  The transaction type.\n     *\n     *  If null, the type will be automatically inferred based on\n     *  explicit properties.\n     */ get type() {\n        return this.#type;\n    }\n    set type(value) {\n        switch(value){\n            case null:\n                this.#type = null;\n                break;\n            case 0:\n            case \"legacy\":\n                this.#type = 0;\n                break;\n            case 1:\n            case \"berlin\":\n            case \"eip-2930\":\n                this.#type = 1;\n                break;\n            case 2:\n            case \"london\":\n            case \"eip-1559\":\n                this.#type = 2;\n                break;\n            case 3:\n            case \"cancun\":\n            case \"eip-4844\":\n                this.#type = 3;\n                break;\n            case 4:\n            case \"pectra\":\n            case \"eip-7702\":\n                this.#type = 4;\n                break;\n            default:\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(false, \"unsupported transaction type\", \"type\", value);\n        }\n    }\n    /**\n     *  The name of the transaction type.\n     */ get typeName() {\n        switch(this.type){\n            case 0:\n                return \"legacy\";\n            case 1:\n                return \"eip-2930\";\n            case 2:\n                return \"eip-1559\";\n            case 3:\n                return \"eip-4844\";\n            case 4:\n                return \"eip-7702\";\n        }\n        return null;\n    }\n    /**\n     *  The ``to`` address for the transaction or ``null`` if the\n     *  transaction is an ``init`` transaction.\n     */ get to() {\n        const value = this.#to;\n        if (value == null && this.type === 3) {\n            return _constants_addresses_js__WEBPACK_IMPORTED_MODULE_9__.ZeroAddress;\n        }\n        return value;\n    }\n    set to(value) {\n        this.#to = value == null ? null : (0,_address_index_js__WEBPACK_IMPORTED_MODULE_3__.getAddress)(value);\n    }\n    /**\n     *  The transaction nonce.\n     */ get nonce() {\n        return this.#nonce;\n    }\n    set nonce(value) {\n        this.#nonce = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_6__.getNumber)(value, \"value\");\n    }\n    /**\n     *  The gas limit.\n     */ get gasLimit() {\n        return this.#gasLimit;\n    }\n    set gasLimit(value) {\n        this.#gasLimit = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_6__.getBigInt)(value);\n    }\n    /**\n     *  The gas price.\n     *\n     *  On legacy networks this defines the fee that will be paid. On\n     *  EIP-1559 networks, this should be ``null``.\n     */ get gasPrice() {\n        const value = this.#gasPrice;\n        if (value == null && (this.type === 0 || this.type === 1)) {\n            return BN_0;\n        }\n        return value;\n    }\n    set gasPrice(value) {\n        this.#gasPrice = value == null ? null : (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_6__.getBigInt)(value, \"gasPrice\");\n    }\n    /**\n     *  The maximum priority fee per unit of gas to pay. On legacy\n     *  networks this should be ``null``.\n     */ get maxPriorityFeePerGas() {\n        const value = this.#maxPriorityFeePerGas;\n        if (value == null) {\n            if (this.type === 2 || this.type === 3) {\n                return BN_0;\n            }\n            return null;\n        }\n        return value;\n    }\n    set maxPriorityFeePerGas(value) {\n        this.#maxPriorityFeePerGas = value == null ? null : (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_6__.getBigInt)(value, \"maxPriorityFeePerGas\");\n    }\n    /**\n     *  The maximum total fee per unit of gas to pay. On legacy\n     *  networks this should be ``null``.\n     */ get maxFeePerGas() {\n        const value = this.#maxFeePerGas;\n        if (value == null) {\n            if (this.type === 2 || this.type === 3) {\n                return BN_0;\n            }\n            return null;\n        }\n        return value;\n    }\n    set maxFeePerGas(value) {\n        this.#maxFeePerGas = value == null ? null : (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_6__.getBigInt)(value, \"maxFeePerGas\");\n    }\n    /**\n     *  The transaction data. For ``init`` transactions this is the\n     *  deployment code.\n     */ get data() {\n        return this.#data;\n    }\n    set data(value) {\n        this.#data = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(value);\n    }\n    /**\n     *  The amount of ether (in wei) to send in this transactions.\n     */ get value() {\n        return this.#value;\n    }\n    set value(value) {\n        this.#value = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_6__.getBigInt)(value, \"value\");\n    }\n    /**\n     *  The chain ID this transaction is valid on.\n     */ get chainId() {\n        return this.#chainId;\n    }\n    set chainId(value) {\n        this.#chainId = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_6__.getBigInt)(value);\n    }\n    /**\n     *  If signed, the signature for this transaction.\n     */ get signature() {\n        return this.#sig || null;\n    }\n    set signature(value) {\n        this.#sig = value == null ? null : _crypto_index_js__WEBPACK_IMPORTED_MODULE_5__.Signature.from(value);\n    }\n    /**\n     *  The access list.\n     *\n     *  An access list permits discounted (but pre-paid) access to\n     *  bytecode and state variable access within contract execution.\n     */ get accessList() {\n        const value = this.#accessList || null;\n        if (value == null) {\n            if (this.type === 1 || this.type === 2 || this.type === 3) {\n                // @TODO: in v7, this should assign the value or become\n                // a live object itself, otherwise mutation is inconsistent\n                return [];\n            }\n            return null;\n        }\n        return value;\n    }\n    set accessList(value) {\n        this.#accessList = value == null ? null : (0,_accesslist_js__WEBPACK_IMPORTED_MODULE_4__.accessListify)(value);\n    }\n    get authorizationList() {\n        const value = this.#auths || null;\n        if (value == null) {\n            if (this.type === 4) {\n                // @TODO: in v7, this should become a live object itself,\n                // otherwise mutation is inconsistent\n                return [];\n            }\n        }\n        return value;\n    }\n    set authorizationList(auths) {\n        this.#auths = auths == null ? null : auths.map((a)=>(0,_authorization_js__WEBPACK_IMPORTED_MODULE_10__.authorizationify)(a));\n    }\n    /**\n     *  The max fee per blob gas for Cancun transactions.\n     */ get maxFeePerBlobGas() {\n        const value = this.#maxFeePerBlobGas;\n        if (value == null && this.type === 3) {\n            return BN_0;\n        }\n        return value;\n    }\n    set maxFeePerBlobGas(value) {\n        this.#maxFeePerBlobGas = value == null ? null : (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_6__.getBigInt)(value, \"maxFeePerBlobGas\");\n    }\n    /**\n     *  The BLOb versioned hashes for Cancun transactions.\n     */ get blobVersionedHashes() {\n        // @TODO: Mutation is inconsistent; if unset, the returned value\n        // cannot mutate the object, if set it can\n        let value = this.#blobVersionedHashes;\n        if (value == null && this.type === 3) {\n            return [];\n        }\n        return value;\n    }\n    set blobVersionedHashes(value) {\n        if (value != null) {\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(Array.isArray(value), \"blobVersionedHashes must be an Array\", \"value\", value);\n            value = value.slice();\n            for(let i = 0; i < value.length; i++){\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.isHexString)(value[i], 32), \"invalid blobVersionedHash\", `value[${i}]`, value[i]);\n            }\n        }\n        this.#blobVersionedHashes = value;\n    }\n    /**\n     *  The BLObs for the Transaction, if any.\n     *\n     *  If ``blobs`` is non-``null``, then the [[seriailized]]\n     *  will return the network formatted sidecar, otherwise it\n     *  will return the standard [[link-eip-2718]] payload. The\n     *  [[unsignedSerialized]] is unaffected regardless.\n     *\n     *  When setting ``blobs``, either fully valid [[Blob]] objects\n     *  may be specified (i.e. correctly padded, with correct\n     *  committments and proofs) or a raw [[BytesLike]] may\n     *  be provided.\n     *\n     *  If raw [[BytesLike]] are provided, the [[kzg]] property **must**\n     *  be already set. The blob will be correctly padded and the\n     *  [[KzgLibrary]] will be used to compute the committment and\n     *  proof for the blob.\n     *\n     *  A BLOb is a sequence of field elements, each of which must\n     *  be within the BLS field modulo, so some additional processing\n     *  may be required to encode arbitrary data to ensure each 32 byte\n     *  field is within the valid range.\n     *\n     *  Setting this automatically populates [[blobVersionedHashes]],\n     *  overwriting any existing values. Setting this to ``null``\n     *  does **not** remove the [[blobVersionedHashes]], leaving them\n     *  present.\n     */ get blobs() {\n        if (this.#blobs == null) {\n            return null;\n        }\n        return this.#blobs.map((b)=>Object.assign({}, b));\n    }\n    set blobs(_blobs) {\n        if (_blobs == null) {\n            this.#blobs = null;\n            return;\n        }\n        const blobs = [];\n        const versionedHashes = [];\n        for(let i = 0; i < _blobs.length; i++){\n            const blob = _blobs[i];\n            if ((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.isBytesLike)(blob)) {\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assert)(this.#kzg, \"adding a raw blob requires a KZG library\", \"UNSUPPORTED_OPERATION\", {\n                    operation: \"set blobs()\"\n                });\n                let data = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBytes)(blob);\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(data.length <= BLOB_SIZE, \"blob is too large\", `blobs[${i}]`, blob);\n                // Pad blob if necessary\n                if (data.length !== BLOB_SIZE) {\n                    const padded = new Uint8Array(BLOB_SIZE);\n                    padded.set(data);\n                    data = padded;\n                }\n                const commit = this.#kzg.blobToKzgCommitment(data);\n                const proof = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(this.#kzg.computeBlobKzgProof(data, commit));\n                blobs.push({\n                    data: (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(data),\n                    commitment: (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(commit),\n                    proof\n                });\n                versionedHashes.push(getVersionedHash(1, commit));\n            } else {\n                const commit = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(blob.commitment);\n                blobs.push({\n                    data: (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(blob.data),\n                    commitment: commit,\n                    proof: (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(blob.proof)\n                });\n                versionedHashes.push(getVersionedHash(1, commit));\n            }\n        }\n        this.#blobs = blobs;\n        this.#blobVersionedHashes = versionedHashes;\n    }\n    get kzg() {\n        return this.#kzg;\n    }\n    set kzg(kzg) {\n        if (kzg == null) {\n            this.#kzg = null;\n        } else {\n            this.#kzg = getKzgLibrary(kzg);\n        }\n    }\n    /**\n     *  Creates a new Transaction with default values.\n     */ constructor(){\n        this.#type = null;\n        this.#to = null;\n        this.#nonce = 0;\n        this.#gasLimit = BN_0;\n        this.#gasPrice = null;\n        this.#maxPriorityFeePerGas = null;\n        this.#maxFeePerGas = null;\n        this.#data = \"0x\";\n        this.#value = BN_0;\n        this.#chainId = BN_0;\n        this.#sig = null;\n        this.#accessList = null;\n        this.#maxFeePerBlobGas = null;\n        this.#blobVersionedHashes = null;\n        this.#kzg = null;\n        this.#blobs = null;\n        this.#auths = null;\n    }\n    /**\n     *  The transaction hash, if signed. Otherwise, ``null``.\n     */ get hash() {\n        if (this.signature == null) {\n            return null;\n        }\n        return (0,_crypto_index_js__WEBPACK_IMPORTED_MODULE_11__.keccak256)(this.#getSerialized(true, false));\n    }\n    /**\n     *  The pre-image hash of this transaction.\n     *\n     *  This is the digest that a [[Signer]] must sign to authorize\n     *  this transaction.\n     */ get unsignedHash() {\n        return (0,_crypto_index_js__WEBPACK_IMPORTED_MODULE_11__.keccak256)(this.unsignedSerialized);\n    }\n    /**\n     *  The sending address, if signed. Otherwise, ``null``.\n     */ get from() {\n        if (this.signature == null) {\n            return null;\n        }\n        return (0,_address_js__WEBPACK_IMPORTED_MODULE_12__.recoverAddress)(this.unsignedHash, this.signature);\n    }\n    /**\n     *  The public key of the sender, if signed. Otherwise, ``null``.\n     */ get fromPublicKey() {\n        if (this.signature == null) {\n            return null;\n        }\n        return _crypto_index_js__WEBPACK_IMPORTED_MODULE_13__.SigningKey.recoverPublicKey(this.unsignedHash, this.signature);\n    }\n    /**\n     *  Returns true if signed.\n     *\n     *  This provides a Type Guard that properties requiring a signed\n     *  transaction are non-null.\n     */ isSigned() {\n        return this.signature != null;\n    }\n    #getSerialized(signed, sidecar) {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assert)(!signed || this.signature != null, \"cannot serialize unsigned transaction; maybe you meant .unsignedSerialized\", \"UNSUPPORTED_OPERATION\", {\n            operation: \".serialized\"\n        });\n        const sig = signed ? this.signature : null;\n        switch(this.inferType()){\n            case 0:\n                return _serializeLegacy(this, sig);\n            case 1:\n                return _serializeEip2930(this, sig);\n            case 2:\n                return _serializeEip1559(this, sig);\n            case 3:\n                return _serializeEip4844(this, sig, sidecar ? this.blobs : null);\n            case 4:\n                return _serializeEip7702(this, sig);\n        }\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assert)(false, \"unsupported transaction type\", \"UNSUPPORTED_OPERATION\", {\n            operation: \".serialized\"\n        });\n    }\n    /**\n     *  The serialized transaction.\n     *\n     *  This throws if the transaction is unsigned. For the pre-image,\n     *  use [[unsignedSerialized]].\n     */ get serialized() {\n        return this.#getSerialized(true, true);\n    }\n    /**\n     *  The transaction pre-image.\n     *\n     *  The hash of this is the digest which needs to be signed to\n     *  authorize this transaction.\n     */ get unsignedSerialized() {\n        return this.#getSerialized(false, false);\n    }\n    /**\n     *  Return the most \"likely\" type; currently the highest\n     *  supported transaction type.\n     */ inferType() {\n        const types = this.inferTypes();\n        // Prefer London (EIP-1559) over Cancun (BLOb)\n        if (types.indexOf(2) >= 0) {\n            return 2;\n        }\n        // Return the highest inferred type\n        return types.pop();\n    }\n    /**\n     *  Validates the explicit properties and returns a list of compatible\n     *  transaction types.\n     */ inferTypes() {\n        // Checks that there are no conflicting properties set\n        const hasGasPrice = this.gasPrice != null;\n        const hasFee = this.maxFeePerGas != null || this.maxPriorityFeePerGas != null;\n        const hasAccessList = this.accessList != null;\n        const hasBlob = this.#maxFeePerBlobGas != null || this.#blobVersionedHashes;\n        //if (hasGasPrice && hasFee) {\n        //    throw new Error(\"transaction cannot have gasPrice and maxFeePerGas\");\n        //}\n        if (this.maxFeePerGas != null && this.maxPriorityFeePerGas != null) {\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assert)(this.maxFeePerGas >= this.maxPriorityFeePerGas, \"priorityFee cannot be more than maxFee\", \"BAD_DATA\", {\n                value: this\n            });\n        }\n        //if (this.type === 2 && hasGasPrice) {\n        //    throw new Error(\"eip-1559 transaction cannot have gasPrice\");\n        //}\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assert)(!hasFee || this.type !== 0 && this.type !== 1, \"transaction type cannot have maxFeePerGas or maxPriorityFeePerGas\", \"BAD_DATA\", {\n            value: this\n        });\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assert)(this.type !== 0 || !hasAccessList, \"legacy transaction cannot have accessList\", \"BAD_DATA\", {\n            value: this\n        });\n        const types = [];\n        // Explicit type\n        if (this.type != null) {\n            types.push(this.type);\n        } else {\n            if (this.authorizationList && this.authorizationList.length) {\n                types.push(4);\n            } else if (hasFee) {\n                types.push(2);\n            } else if (hasGasPrice) {\n                types.push(1);\n                if (!hasAccessList) {\n                    types.push(0);\n                }\n            } else if (hasAccessList) {\n                types.push(1);\n                types.push(2);\n            } else if (hasBlob && this.to) {\n                types.push(3);\n            } else {\n                types.push(0);\n                types.push(1);\n                types.push(2);\n                types.push(3);\n            }\n        }\n        types.sort();\n        return types;\n    }\n    /**\n     *  Returns true if this transaction is a legacy transaction (i.e.\n     *  ``type === 0``).\n     *\n     *  This provides a Type Guard that the related properties are\n     *  non-null.\n     */ isLegacy() {\n        return this.type === 0;\n    }\n    /**\n     *  Returns true if this transaction is berlin hardform transaction (i.e.\n     *  ``type === 1``).\n     *\n     *  This provides a Type Guard that the related properties are\n     *  non-null.\n     */ isBerlin() {\n        return this.type === 1;\n    }\n    /**\n     *  Returns true if this transaction is london hardform transaction (i.e.\n     *  ``type === 2``).\n     *\n     *  This provides a Type Guard that the related properties are\n     *  non-null.\n     */ isLondon() {\n        return this.type === 2;\n    }\n    /**\n     *  Returns true if this transaction is an [[link-eip-4844]] BLOB\n     *  transaction.\n     *\n     *  This provides a Type Guard that the related properties are\n     *  non-null.\n     */ isCancun() {\n        return this.type === 3;\n    }\n    /**\n     *  Create a copy of this transaciton.\n     */ clone() {\n        return Transaction.from(this);\n    }\n    /**\n     *  Return a JSON-friendly object.\n     */ toJSON() {\n        const s = (v)=>{\n            if (v == null) {\n                return null;\n            }\n            return v.toString();\n        };\n        return {\n            type: this.type,\n            to: this.to,\n            //            from: this.from,\n            data: this.data,\n            nonce: this.nonce,\n            gasLimit: s(this.gasLimit),\n            gasPrice: s(this.gasPrice),\n            maxPriorityFeePerGas: s(this.maxPriorityFeePerGas),\n            maxFeePerGas: s(this.maxFeePerGas),\n            value: s(this.value),\n            chainId: s(this.chainId),\n            sig: this.signature ? this.signature.toJSON() : null,\n            accessList: this.accessList\n        };\n    }\n    /**\n     *  Create a **Transaction** from a serialized transaction or a\n     *  Transaction-like object.\n     */ static from(tx) {\n        if (tx == null) {\n            return new Transaction();\n        }\n        if (typeof tx === \"string\") {\n            const payload = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBytes)(tx);\n            if (payload[0] >= 0x7f) {\n                return Transaction.from(_parseLegacy(payload));\n            }\n            switch(payload[0]){\n                case 1:\n                    return Transaction.from(_parseEip2930(payload));\n                case 2:\n                    return Transaction.from(_parseEip1559(payload));\n                case 3:\n                    return Transaction.from(_parseEip4844(payload));\n                case 4:\n                    return Transaction.from(_parseEip7702(payload));\n            }\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assert)(false, \"unsupported transaction type\", \"UNSUPPORTED_OPERATION\", {\n                operation: \"from\"\n            });\n        }\n        const result = new Transaction();\n        if (tx.type != null) {\n            result.type = tx.type;\n        }\n        if (tx.to != null) {\n            result.to = tx.to;\n        }\n        if (tx.nonce != null) {\n            result.nonce = tx.nonce;\n        }\n        if (tx.gasLimit != null) {\n            result.gasLimit = tx.gasLimit;\n        }\n        if (tx.gasPrice != null) {\n            result.gasPrice = tx.gasPrice;\n        }\n        if (tx.maxPriorityFeePerGas != null) {\n            result.maxPriorityFeePerGas = tx.maxPriorityFeePerGas;\n        }\n        if (tx.maxFeePerGas != null) {\n            result.maxFeePerGas = tx.maxFeePerGas;\n        }\n        if (tx.maxFeePerBlobGas != null) {\n            result.maxFeePerBlobGas = tx.maxFeePerBlobGas;\n        }\n        if (tx.data != null) {\n            result.data = tx.data;\n        }\n        if (tx.value != null) {\n            result.value = tx.value;\n        }\n        if (tx.chainId != null) {\n            result.chainId = tx.chainId;\n        }\n        if (tx.signature != null) {\n            result.signature = _crypto_index_js__WEBPACK_IMPORTED_MODULE_5__.Signature.from(tx.signature);\n        }\n        if (tx.accessList != null) {\n            result.accessList = tx.accessList;\n        }\n        if (tx.authorizationList != null) {\n            result.authorizationList = tx.authorizationList;\n        }\n        // This will get overwritten by blobs, if present\n        if (tx.blobVersionedHashes != null) {\n            result.blobVersionedHashes = tx.blobVersionedHashes;\n        }\n        // Make sure we assign the kzg before assigning blobs, which\n        // require the library in the event raw blob data is provided.\n        if (tx.kzg != null) {\n            result.kzg = tx.kzg;\n        }\n        if (tx.blobs != null) {\n            result.blobs = tx.blobs;\n        }\n        if (tx.hash != null) {\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(result.isSigned(), \"unsigned transaction cannot define '.hash'\", \"tx\", tx);\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(result.hash === tx.hash, \"hash mismatch\", \"tx\", tx);\n        }\n        if (tx.from != null) {\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(result.isSigned(), \"unsigned transaction cannot define '.from'\", \"tx\", tx);\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(result.from.toLowerCase() === (tx.from || \"\").toLowerCase(), \"from mismatch\", \"tx\", tx);\n        }\n        return result;\n    }\n} //# sourceMappingURL=transaction.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vdHJhbnNhY3Rpb24vdHJhbnNhY3Rpb24uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQWlEO0FBQ087QUFDc0I7QUFDdUc7QUFDckk7QUFDTTtBQUNSO0FBQzlDLE1BQU1zQixPQUFPQyxPQUFPO0FBQ3BCLE1BQU1DLE9BQU9ELE9BQU87QUFDcEIsTUFBTUUsUUFBUUYsT0FBTztBQUNyQixNQUFNRyxRQUFRSCxPQUFPO0FBQ3JCLE1BQU1JLFFBQVFKLE9BQU87QUFDckIsTUFBTUssY0FBY0wsT0FBTztBQUMzQixNQUFNTSxZQUFZLE9BQU87QUFDekIsU0FBU0MsY0FBY0MsR0FBRztJQUN0QixNQUFNQyxzQkFBc0IsQ0FBQ0M7UUFDekIsSUFBSSxzQkFBc0JGLEtBQUs7WUFDM0IsOERBQThEO1lBQzlELGlFQUFpRTtZQUNqRSxJQUFJLHlCQUF5QkEsT0FBTyxPQUFRQSxJQUFJQyxtQkFBbUIsS0FBTSxZQUFZO2dCQUNqRixPQUFPdkIseURBQVFBLENBQUNzQixJQUFJQyxtQkFBbUIsQ0FBQ3BCLHdEQUFPQSxDQUFDcUI7WUFDcEQ7UUFDSixPQUNLLElBQUkseUJBQXlCRixPQUFPLE9BQVFBLElBQUlDLG1CQUFtQixLQUFNLFlBQVk7WUFDdEYsaUVBQWlFO1lBQ2pFLE9BQU92Qix5REFBUUEsQ0FBQ3NCLElBQUlDLG1CQUFtQixDQUFDQztRQUM1QztRQUNBLDJEQUEyRDtRQUMzRCxJQUFJLHlCQUF5QkYsT0FBTyxPQUFRQSxJQUFJRyxtQkFBbUIsS0FBTSxZQUFZO1lBQ2pGLE9BQU96Qix5REFBUUEsQ0FBQ3NCLElBQUlHLG1CQUFtQixDQUFDdEIsd0RBQU9BLENBQUNxQjtRQUNwRDtRQUNBbkIsK0RBQWNBLENBQUMsT0FBTywyQkFBMkIsT0FBT2lCO0lBQzVEO0lBQ0EsTUFBTUksc0JBQXNCLENBQUNGLE1BQU1HO1FBQy9CLG1CQUFtQjtRQUNuQixJQUFJLHNCQUFzQkwsT0FBTyxP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QWlEO1FBQ2pELElBQUlqQyxHQUFHNkIsbUJBQW1CLElBQUksTUFBTTtZQUNoQ3hELE9BQU93RCxtQkFBbUIsR0FBRzdCLEdBQUc2QixtQkFBbUI7UUFDdkQ7UUFDQSw0REFBNEQ7UUFDNUQsOERBQThEO1FBQzlELElBQUk3QixHQUFHcEQsR0FBRyxJQUFJLE1BQU07WUFDaEJ5QixPQUFPekIsR0FBRyxHQUFHb0QsR0FBR3BELEdBQUc7UUFDdkI7UUFDQSxJQUFJb0QsR0FBR3VCLEtBQUssSUFBSSxNQUFNO1lBQ2xCbEQsT0FBT2tELEtBQUssR0FBR3ZCLEdBQUd1QixLQUFLO1FBQzNCO1FBQ0EsSUFBSXZCLEdBQUcxQyxJQUFJLElBQUksTUFBTTtZQUNqQjNCLCtEQUFjQSxDQUFDMEMsT0FBTzhFLFFBQVEsSUFBSSw4Q0FBOEMsTUFBTW5EO1lBQ3RGckUsK0RBQWNBLENBQUMwQyxPQUFPZixJQUFJLEtBQUswQyxHQUFHMUMsSUFBSSxFQUFFLGlCQUFpQixNQUFNMEM7UUFDbkU7UUFDQSxJQUFJQSxHQUFHbEIsSUFBSSxJQUFJLE1BQU07WUFDakJuRCwrREFBY0EsQ0FBQzBDLE9BQU84RSxRQUFRLElBQUksOENBQThDLE1BQU1uRDtZQUN0RnJFLCtEQUFjQSxDQUFDMEMsT0FBT1MsSUFBSSxDQUFDMEYsV0FBVyxPQUFPLENBQUN4RSxHQUFHbEIsSUFBSSxJQUFJLEVBQUMsRUFBRzBGLFdBQVcsSUFBSSxpQkFBaUIsTUFBTXhFO1FBQ3ZHO1FBQ0EsT0FBTzNCO0lBQ1g7QUFDSixFQUNBLHVDQUF1QyIsInNvdXJjZXMiOlsid2VicGFjazovL21lZ2F2aWJlLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL3RyYW5zYWN0aW9uL3RyYW5zYWN0aW9uLmpzPzZlYmEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZ2V0QWRkcmVzcyB9IGZyb20gXCIuLi9hZGRyZXNzL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBaZXJvQWRkcmVzcyB9IGZyb20gXCIuLi9jb25zdGFudHMvYWRkcmVzc2VzLmpzXCI7XG5pbXBvcnQgeyBrZWNjYWsyNTYsIHNoYTI1NiwgU2lnbmF0dXJlLCBTaWduaW5nS2V5IH0gZnJvbSBcIi4uL2NyeXB0by9pbmRleC5qc1wiO1xuaW1wb3J0IHsgY29uY2F0LCBkZWNvZGVSbHAsIGVuY29kZVJscCwgZ2V0Qnl0ZXMsIGdldEJpZ0ludCwgZ2V0TnVtYmVyLCBoZXhsaWZ5LCBhc3NlcnQsIGFzc2VydEFyZ3VtZW50LCBpc0J5dGVzTGlrZSwgaXNIZXhTdHJpbmcsIHRvQmVBcnJheSwgemVyb1BhZFZhbHVlIH0gZnJvbSBcIi4uL3V0aWxzL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBhY2Nlc3NMaXN0aWZ5IH0gZnJvbSBcIi4vYWNjZXNzbGlzdC5qc1wiO1xuaW1wb3J0IHsgYXV0aG9yaXphdGlvbmlmeSB9IGZyb20gXCIuL2F1dGhvcml6YXRpb24uanNcIjtcbmltcG9ydCB7IHJlY292ZXJBZGRyZXNzIH0gZnJvbSBcIi4vYWRkcmVzcy5qc1wiO1xuY29uc3QgQk5fMCA9IEJpZ0ludCgwKTtcbmNvbnN0IEJOXzIgPSBCaWdJbnQoMik7XG5jb25zdCBCTl8yNyA9IEJpZ0ludCgyNyk7XG5jb25zdCBCTl8yOCA9IEJpZ0ludCgyOCk7XG5jb25zdCBCTl8zNSA9IEJpZ0ludCgzNSk7XG5jb25zdCBCTl9NQVhfVUlOVCA9IEJpZ0ludChcIjB4ZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZlwiKTtcbmNvbnN0IEJMT0JfU0laRSA9IDQwOTYgKiAzMjtcbmZ1bmN0aW9uIGdldEt6Z0xpYnJhcnkoa3pnKSB7XG4gICAgY29uc3QgYmxvYlRvS3pnQ29tbWl0bWVudCA9IChibG9iKSA9PiB7XG4gICAgICAgIGlmIChcImNvbXB1dGVCbG9iUHJvb2ZcIiBpbiBremcpIHtcbiAgICAgICAgICAgIC8vIG1pY3JvLWVjYy1zaWduZXI7IGNoZWNrIGZvciBjb21wdXRlQmxvYlByb29mIHNpbmNlIHRoaXMgQVBJXG4gICAgICAgICAgICAvLyBleHBlY3RzIGEgc3RyaW5nIHdoaWxlIHRoZSBremctd2FzbSBiZWxvdyBleHBlY3RzIGEgVW5pdDhBcnJheVxuICAgICAgICAgICAgaWYgKFwiYmxvYlRvS3pnQ29tbWl0bWVudFwiIGluIGt6ZyAmJiB0eXBlb2YgKGt6Zy5ibG9iVG9LemdDb21taXRtZW50KSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGdldEJ5dGVzKGt6Zy5ibG9iVG9LemdDb21taXRtZW50KGhleGxpZnkoYmxvYikpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChcImJsb2JUb0t6Z0NvbW1pdG1lbnRcIiBpbiBremcgJiYgdHlwZW9mIChremcuYmxvYlRvS3pnQ29tbWl0bWVudCkgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgLy8ga3pnLXdhc20gPDAuNS4wOyBibG9iVG9LemdDb21taXRtZW50KFVpbnQ4QXJyYXkpID0+IFVpbnQ4QXJyYXlcbiAgICAgICAgICAgIHJldHVybiBnZXRCeXRlcyhremcuYmxvYlRvS3pnQ29tbWl0bWVudChibG9iKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8ga3pnLXdhc20gPj0gMC41LjA7IGJsb2JUb0taR0NvbW1pdG1lbnQoc3RyaW5nKSA9PiBzdHJpbmdcbiAgICAgICAgaWYgKFwiYmxvYlRvS1pHQ29tbWl0bWVudFwiIGluIGt6ZyAmJiB0eXBlb2YgKGt6Zy5ibG9iVG9LWkdDb21taXRtZW50KSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0Qnl0ZXMoa3pnLmJsb2JUb0taR0NvbW1pdG1lbnQoaGV4bGlmeShibG9iKSkpO1xuICAgICAgICB9XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KGZhbHNlLCBcInVuc3VwcG9ydGVkIEtaRyBsaWJyYXJ5XCIsIFwia3pnXCIsIGt6Zyk7XG4gICAgfTtcbiAgICBjb25zdCBjb21wdXRlQmxvYkt6Z1Byb29mID0gKGJsb2IsIGNvbW1pdG1lbnQpID0+IHtcbiAgICAgICAgLy8gbWljcm8tZWNjLXNpZ25lclxuICAgICAgICBpZiAoXCJjb21wdXRlQmxvYlByb29mXCIgaW4ga3pnICYmIHR5cGVvZiAoa3pnLmNvbXB1dGVCbG9iUHJvb2YpID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBnZXRCeXRlcyhremcuY29tcHV0ZUJsb2JQcm9vZihoZXhsaWZ5KGJsb2IpLCBoZXhsaWZ5KGNvbW1pdG1lbnQpKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8ga3pnLXdhc20gPDAuNS4wOyBjb21wdXRlQmxvYkt6Z1Byb29mKFVpbnQ4QXJyYXksIFVpbnQ4QXJyYXkpID0+IFVpbnQ4QXJyYXlcbiAgICAgICAgaWYgKFwiY29tcHV0ZUJsb2JLemdQcm9vZlwiIGluIGt6ZyAmJiB0eXBlb2YgKGt6Zy5jb21wdXRlQmxvYkt6Z1Byb29mKSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICByZXR1cm4ga3pnLmNvbXB1dGVCbG9iS3pnUHJvb2YoYmxvYiwgY29tbWl0bWVudCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8ga3pnLXdhc20gPj0gMC41LjA7IGNvbXB1dGVCbG9iS1pHUHJvb2Yoc3RyaW5nLCBzdHJpbmcpID0+IHN0cmluZ1xuICAgICAgICBpZiAoXCJjb21wdXRlQmxvYktaR1Byb29mXCIgaW4ga3pnICYmIHR5cGVvZiAoa3pnLmNvbXB1dGVCbG9iS1pHUHJvb2YpID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBnZXRCeXRlcyhremcuY29tcHV0ZUJsb2JLWkdQcm9vZihoZXhsaWZ5KGJsb2IpLCBoZXhsaWZ5KGNvbW1pdG1lbnQpKSk7XG4gICAgICAgIH1cbiAgICAgICAgYXNzZXJ0QXJndW1lbnQoZmFsc2UsIFwidW5zdXBwb3J0ZWQgS1pHIGxpYnJhcnlcIiwgXCJremdcIiwga3pnKTtcbiAgICB9O1xuICAgIHJldHVybiB7IGJsb2JUb0t6Z0NvbW1pdG1lbnQsIGNvbXB1dGVCbG9iS3pnUHJvb2YgfTtcbn1cbmZ1bmN0aW9uIGdldFZlcnNpb25lZEhhc2godmVyc2lvbiwgaGFzaCkge1xuICAgIGxldCB2ZXJzaW9uZWQgPSB2ZXJzaW9uLnRvU3RyaW5nKDE2KTtcbiAgICB3aGlsZSAodmVyc2lvbmVkLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgdmVyc2lvbmVkID0gXCIwXCIgKyB2ZXJzaW9uZWQ7XG4gICAgfVxuICAgIHZlcnNpb25lZCArPSBzaGEyNTYoaGFzaCkuc3Vic3RyaW5nKDQpO1xuICAgIHJldHVybiBcIjB4XCIgKyB2ZXJzaW9uZWQ7XG59XG5mdW5jdGlvbiBoYW5kbGVBZGRyZXNzKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlID09PSBcIjB4XCIpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBnZXRBZGRyZXNzKHZhbHVlKTtcbn1cbmZ1bmN0aW9uIGhhbmRsZUFjY2Vzc0xpc3QodmFsdWUsIHBhcmFtKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGFjY2Vzc0xpc3RpZnkodmFsdWUpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQoZmFsc2UsIGVycm9yLm1lc3NhZ2UsIHBhcmFtLCB2YWx1ZSk7XG4gICAgfVxufVxuZnVuY3Rpb24gaGFuZGxlQXV0aG9yaXphdGlvbkxpc3QodmFsdWUsIHBhcmFtKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYXV0aG9yaXphdGlvbkxpc3Q6IGludmFsaWQgYXJyYXlcIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGF1dGggPSB2YWx1ZVtpXTtcbiAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShhdXRoKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgYXV0aG9yaXphdGlvblske2l9XTogaW52YWxpZCBhcnJheWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGF1dGgubGVuZ3RoICE9PSA2KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBhdXRob3JpemF0aW9uWyR7aX1dOiB3cm9uZyBsZW5ndGhgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghYXV0aFsxXSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgYXV0aG9yaXphdGlvblske2l9XTogbnVsbCBhZGRyZXNzYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQucHVzaCh7XG4gICAgICAgICAgICAgICAgYWRkcmVzczogaGFuZGxlQWRkcmVzcyhhdXRoWzFdKSxcbiAgICAgICAgICAgICAgICBub25jZTogaGFuZGxlVWludChhdXRoWzJdLCBcIm5vbmNlXCIpLFxuICAgICAgICAgICAgICAgIGNoYWluSWQ6IGhhbmRsZVVpbnQoYXV0aFswXSwgXCJjaGFpbklkXCIpLFxuICAgICAgICAgICAgICAgIHNpZ25hdHVyZTogU2lnbmF0dXJlLmZyb20oe1xuICAgICAgICAgICAgICAgICAgICB5UGFyaXR5OiBoYW5kbGVOdW1iZXIoYXV0aFszXSwgXCJ5UGFyaXR5XCIpLFxuICAgICAgICAgICAgICAgICAgICByOiB6ZXJvUGFkVmFsdWUoYXV0aFs0XSwgMzIpLFxuICAgICAgICAgICAgICAgICAgICBzOiB6ZXJvUGFkVmFsdWUoYXV0aFs1XSwgMzIpXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICBhc3NlcnRBcmd1bWVudChmYWxzZSwgZXJyb3IubWVzc2FnZSwgcGFyYW0sIHZhbHVlKTtcbiAgICB9XG59XG5mdW5jdGlvbiBoYW5kbGVOdW1iZXIoX3ZhbHVlLCBwYXJhbSkge1xuICAgIGlmIChfdmFsdWUgPT09IFwiMHhcIikge1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgcmV0dXJuIGdldE51bWJlcihfdmFsdWUsIHBhcmFtKTtcbn1cbmZ1bmN0aW9uIGhhbmRsZVVpbnQoX3ZhbHVlLCBwYXJhbSkge1xuICAgIGlmIChfdmFsdWUgPT09IFwiMHhcIikge1xuICAgICAgICByZXR1cm4gQk5fMDtcbiAgICB9XG4gICAgY29uc3QgdmFsdWUgPSBnZXRCaWdJbnQoX3ZhbHVlLCBwYXJhbSk7XG4gICAgYXNzZXJ0QXJndW1lbnQodmFsdWUgPD0gQk5fTUFYX1VJTlQsIFwidmFsdWUgZXhjZWVkcyB1aW50IHNpemVcIiwgcGFyYW0sIHZhbHVlKTtcbiAgICByZXR1cm4gdmFsdWU7XG59XG5mdW5jdGlvbiBmb3JtYXROdW1iZXIoX3ZhbHVlLCBuYW1lKSB7XG4gICAgY29uc3QgdmFsdWUgPSBnZXRCaWdJbnQoX3ZhbHVlLCBcInZhbHVlXCIpO1xuICAgIGNvbnN0IHJlc3VsdCA9IHRvQmVBcnJheSh2YWx1ZSk7XG4gICAgYXNzZXJ0QXJndW1lbnQocmVzdWx0Lmxlbmd0aCA8PSAzMiwgYHZhbHVlIHRvbyBsYXJnZWAsIGB0eC4ke25hbWV9YCwgdmFsdWUpO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBmb3JtYXRBY2Nlc3NMaXN0KHZhbHVlKSB7XG4gICAgcmV0dXJuIGFjY2Vzc0xpc3RpZnkodmFsdWUpLm1hcCgoc2V0KSA9PiBbc2V0LmFkZHJlc3MsIHNldC5zdG9yYWdlS2V5c10pO1xufVxuZnVuY3Rpb24gZm9ybWF0QXV0aG9yaXphdGlvbkxpc3QodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUubWFwKChhKSA9PiB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBmb3JtYXROdW1iZXIoYS5jaGFpbklkLCBcImNoYWluSWRcIiksXG4gICAgICAgICAgICBhLmFkZHJlc3MsXG4gICAgICAgICAgICBmb3JtYXROdW1iZXIoYS5ub25jZSwgXCJub25jZVwiKSxcbiAgICAgICAgICAgIGZvcm1hdE51bWJlcihhLnNpZ25hdHVyZS55UGFyaXR5LCBcInlQYXJpdHlcIiksXG4gICAgICAgICAgICB0b0JlQXJyYXkoYS5zaWduYXR1cmUuciksXG4gICAgICAgICAgICB0b0JlQXJyYXkoYS5zaWduYXR1cmUucylcbiAgICAgICAgXTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGZvcm1hdEhhc2hlcyh2YWx1ZSwgcGFyYW0pIHtcbiAgICBhc3NlcnRBcmd1bWVudChBcnJheS5pc0FycmF5KHZhbHVlKSwgYGludmFsaWQgJHtwYXJhbX1gLCBcInZhbHVlXCIsIHZhbHVlKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KGlzSGV4U3RyaW5nKHZhbHVlW2ldLCAzMiksIFwiaW52YWxpZCAkeyBwYXJhbSB9IGhhc2hcIiwgYHZhbHVlWyR7aX1dYCwgdmFsdWVbaV0pO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG59XG5mdW5jdGlvbiBfcGFyc2VMZWdhY3koZGF0YSkge1xuICAgIGNvbnN0IGZpZWxkcyA9IGRlY29kZVJscChkYXRhKTtcbiAgICBhc3NlcnRBcmd1bWVudChBcnJheS5pc0FycmF5KGZpZWxkcykgJiYgKGZpZWxkcy5sZW5ndGggPT09IDkgfHwgZmllbGRzLmxlbmd0aCA9PT0gNiksIFwiaW52YWxpZCBmaWVsZCBjb3VudCBmb3IgbGVnYWN5IHRyYW5zYWN0aW9uXCIsIFwiZGF0YVwiLCBkYXRhKTtcbiAgICBjb25zdCB0eCA9IHtcbiAgICAgICAgdHlwZTogMCxcbiAgICAgICAgbm9uY2U6IGhhbmRsZU51bWJlcihmaWVsZHNbMF0sIFwibm9uY2VcIiksXG4gICAgICAgIGdhc1ByaWNlOiBoYW5kbGVVaW50KGZpZWxkc1sxXSwgXCJnYXNQcmljZVwiKSxcbiAgICAgICAgZ2FzTGltaXQ6IGhhbmRsZVVpbnQoZmllbGRzWzJdLCBcImdhc0xpbWl0XCIpLFxuICAgICAgICB0bzogaGFuZGxlQWRkcmVzcyhmaWVsZHNbM10pLFxuICAgICAgICB2YWx1ZTogaGFuZGxlVWludChmaWVsZHNbNF0sIFwidmFsdWVcIiksXG4gICAgICAgIGRhdGE6IGhleGxpZnkoZmllbGRzWzVdKSxcbiAgICAgICAgY2hhaW5JZDogQk5fMFxuICAgIH07XG4gICAgLy8gTGVnYWN5IHVuc2lnbmVkIHRyYW5zYWN0aW9uXG4gICAgaWYgKGZpZWxkcy5sZW5ndGggPT09IDYpIHtcbiAgICAgICAgcmV0dXJuIHR4O1xuICAgIH1cbiAgICBjb25zdCB2ID0gaGFuZGxlVWludChmaWVsZHNbNl0sIFwidlwiKTtcbiAgICBjb25zdCByID0gaGFuZGxlVWludChmaWVsZHNbN10sIFwiclwiKTtcbiAgICBjb25zdCBzID0gaGFuZGxlVWludChmaWVsZHNbOF0sIFwic1wiKTtcbiAgICBpZiAociA9PT0gQk5fMCAmJiBzID09PSBCTl8wKSB7XG4gICAgICAgIC8vIEVJUC0xNTUgdW5zaWduZWQgdHJhbnNhY3Rpb25cbiAgICAgICAgdHguY2hhaW5JZCA9IHY7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBDb21wdXRlIHRoZSBFSVAtMTU1IGNoYWluIElEIChvciAwIGZvciBsZWdhY3kpXG4gICAgICAgIGxldCBjaGFpbklkID0gKHYgLSBCTl8zNSkgLyBCTl8yO1xuICAgICAgICBpZiAoY2hhaW5JZCA8IEJOXzApIHtcbiAgICAgICAgICAgIGNoYWluSWQgPSBCTl8wO1xuICAgICAgICB9XG4gICAgICAgIHR4LmNoYWluSWQgPSBjaGFpbklkO1xuICAgICAgICAvLyBTaWduZWQgTGVnYWN5IFRyYW5zYWN0aW9uXG4gICAgICAgIGFzc2VydEFyZ3VtZW50KGNoYWluSWQgIT09IEJOXzAgfHwgKHYgPT09IEJOXzI3IHx8IHYgPT09IEJOXzI4KSwgXCJub24tY2Fub25pY2FsIGxlZ2FjeSB2XCIsIFwidlwiLCBmaWVsZHNbNl0pO1xuICAgICAgICB0eC5zaWduYXR1cmUgPSBTaWduYXR1cmUuZnJvbSh7XG4gICAgICAgICAgICByOiB6ZXJvUGFkVmFsdWUoZmllbGRzWzddLCAzMiksXG4gICAgICAgICAgICBzOiB6ZXJvUGFkVmFsdWUoZmllbGRzWzhdLCAzMiksXG4gICAgICAgICAgICB2XG4gICAgICAgIH0pO1xuICAgICAgICAvL3R4Lmhhc2ggPSBrZWNjYWsyNTYoZGF0YSk7XG4gICAgfVxuICAgIHJldHVybiB0eDtcbn1cbmZ1bmN0aW9uIF9zZXJpYWxpemVMZWdhY3kodHgsIHNpZykge1xuICAgIGNvbnN0IGZpZWxkcyA9IFtcbiAgICAgICAgZm9ybWF0TnVtYmVyKHR4Lm5vbmNlLCBcIm5vbmNlXCIpLFxuICAgICAgICBmb3JtYXROdW1iZXIodHguZ2FzUHJpY2UgfHwgMCwgXCJnYXNQcmljZVwiKSxcbiAgICAgICAgZm9ybWF0TnVtYmVyKHR4Lmdhc0xpbWl0LCBcImdhc0xpbWl0XCIpLFxuICAgICAgICAodHgudG8gfHwgXCIweFwiKSxcbiAgICAgICAgZm9ybWF0TnVtYmVyKHR4LnZhbHVlLCBcInZhbHVlXCIpLFxuICAgICAgICB0eC5kYXRhLFxuICAgIF07XG4gICAgbGV0IGNoYWluSWQgPSBCTl8wO1xuICAgIGlmICh0eC5jaGFpbklkICE9IEJOXzApIHtcbiAgICAgICAgLy8gQSBjaGFpbklkIHdhcyBwcm92aWRlZDsgaWYgbm9uLXplcm8gd2UnbGwgdXNlIEVJUC0xNTVcbiAgICAgICAgY2hhaW5JZCA9IGdldEJpZ0ludCh0eC5jaGFpbklkLCBcInR4LmNoYWluSWRcIik7XG4gICAgICAgIC8vIFdlIGhhdmUgYSBjaGFpbklkIGluIHRoZSB0eCBhbmQgYW4gRUlQLTE1NSB2IGluIHRoZSBzaWduYXR1cmUsXG4gICAgICAgIC8vIG1ha2Ugc3VyZSB0aGV5IGFncmVlIHdpdGggZWFjaCBvdGhlclxuICAgICAgICBhc3NlcnRBcmd1bWVudCghc2lnIHx8IHNpZy5uZXR3b3JrViA9PSBudWxsIHx8IHNpZy5sZWdhY3lDaGFpbklkID09PSBjaGFpbklkLCBcInR4LmNoYWluSWQvc2lnLnYgbWlzbWF0Y2hcIiwgXCJzaWdcIiwgc2lnKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHguc2lnbmF0dXJlKSB7XG4gICAgICAgIC8vIE5vIGV4cGxpY2l0IGNoYWluSWQsIGJ1dCBFSVAtMTU1IGhhdmUgYSBkZXJpdmVkIGltcGxpY2l0IGNoYWluSWRcbiAgICAgICAgY29uc3QgbGVnYWN5ID0gdHguc2lnbmF0dXJlLmxlZ2FjeUNoYWluSWQ7XG4gICAgICAgIGlmIChsZWdhY3kgIT0gbnVsbCkge1xuICAgICAgICAgICAgY2hhaW5JZCA9IGxlZ2FjeTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBSZXF1ZXN0aW5nIGFuIHVuc2lnbmVkIHRyYW5zYWN0aW9uXG4gICAgaWYgKCFzaWcpIHtcbiAgICAgICAgLy8gV2UgaGF2ZSBhbiBFSVAtMTU1IHRyYW5zYWN0aW9uIChjaGFpbklkIHdhcyBzcGVjaWZpZWQgYW5kIG5vbi16ZXJvKVxuICAgICAgICBpZiAoY2hhaW5JZCAhPT0gQk5fMCkge1xuICAgICAgICAgICAgZmllbGRzLnB1c2godG9CZUFycmF5KGNoYWluSWQpKTtcbiAgICAgICAgICAgIGZpZWxkcy5wdXNoKFwiMHhcIik7XG4gICAgICAgICAgICBmaWVsZHMucHVzaChcIjB4XCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlbmNvZGVSbHAoZmllbGRzKTtcbiAgICB9XG4gICAgLy8gQFRPRE86IFdlIHNob3VsZCBwcm9iYWJseSBjaGVjayB0aGF0IHR4LnNpZ25hdHVyZSwgY2hhaW5JZCwgYW5kIHNpZ1xuICAgIC8vICAgICAgICBtYXRjaCBidXQgdGhhdCBsb2dpYyBjb3VsZCBicmVhayBleGlzdGluZyBjb2RlLCBzbyBzY2hlZHVsZVxuICAgIC8vICAgICAgICB0aGlzIGZvciB0aGUgbmV4dCBtYWpvciBidW1wLlxuICAgIC8vIENvbXB1dGUgdGhlIEVJUC0xNTUgdlxuICAgIGxldCB2ID0gQmlnSW50KDI3ICsgc2lnLnlQYXJpdHkpO1xuICAgIGlmIChjaGFpbklkICE9PSBCTl8wKSB7XG4gICAgICAgIHYgPSBTaWduYXR1cmUuZ2V0Q2hhaW5JZFYoY2hhaW5JZCwgc2lnLnYpO1xuICAgIH1cbiAgICBlbHNlIGlmIChCaWdJbnQoc2lnLnYpICE9PSB2KSB7XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KGZhbHNlLCBcInR4LmNoYWluSWQvc2lnLnYgbWlzbWF0Y2hcIiwgXCJzaWdcIiwgc2lnKTtcbiAgICB9XG4gICAgLy8gQWRkIHRoZSBzaWduYXR1cmVcbiAgICBmaWVsZHMucHVzaCh0b0JlQXJyYXkodikpO1xuICAgIGZpZWxkcy5wdXNoKHRvQmVBcnJheShzaWcucikpO1xuICAgIGZpZWxkcy5wdXNoKHRvQmVBcnJheShzaWcucykpO1xuICAgIHJldHVybiBlbmNvZGVSbHAoZmllbGRzKTtcbn1cbmZ1bmN0aW9uIF9wYXJzZUVpcFNpZ25hdHVyZSh0eCwgZmllbGRzKSB7XG4gICAgbGV0IHlQYXJpdHk7XG4gICAgdHJ5IHtcbiAgICAgICAgeVBhcml0eSA9IGhhbmRsZU51bWJlcihmaWVsZHNbMF0sIFwieVBhcml0eVwiKTtcbiAgICAgICAgaWYgKHlQYXJpdHkgIT09IDAgJiYgeVBhcml0eSAhPT0gMSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYmFkIHlQYXJpdHlcIik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KGZhbHNlLCBcImludmFsaWQgeVBhcml0eVwiLCBcInlQYXJpdHlcIiwgZmllbGRzWzBdKTtcbiAgICB9XG4gICAgY29uc3QgciA9IHplcm9QYWRWYWx1ZShmaWVsZHNbMV0sIDMyKTtcbiAgICBjb25zdCBzID0gemVyb1BhZFZhbHVlKGZpZWxkc1syXSwgMzIpO1xuICAgIGNvbnN0IHNpZ25hdHVyZSA9IFNpZ25hdHVyZS5mcm9tKHsgciwgcywgeVBhcml0eSB9KTtcbiAgICB0eC5zaWduYXR1cmUgPSBzaWduYXR1cmU7XG59XG5mdW5jdGlvbiBfcGFyc2VFaXAxNTU5KGRhdGEpIHtcbiAgICBjb25zdCBmaWVsZHMgPSBkZWNvZGVSbHAoZ2V0Qnl0ZXMoZGF0YSkuc2xpY2UoMSkpO1xuICAgIGFzc2VydEFyZ3VtZW50KEFycmF5LmlzQXJyYXkoZmllbGRzKSAmJiAoZmllbGRzLmxlbmd0aCA9PT0gOSB8fCBmaWVsZHMubGVuZ3RoID09PSAxMiksIFwiaW52YWxpZCBmaWVsZCBjb3VudCBmb3IgdHJhbnNhY3Rpb24gdHlwZTogMlwiLCBcImRhdGFcIiwgaGV4bGlmeShkYXRhKSk7XG4gICAgY29uc3QgdHggPSB7XG4gICAgICAgIHR5cGU6IDIsXG4gICAgICAgIGNoYWluSWQ6IGhhbmRsZVVpbnQoZmllbGRzWzBdLCBcImNoYWluSWRcIiksXG4gICAgICAgIG5vbmNlOiBoYW5kbGVOdW1iZXIoZmllbGRzWzFdLCBcIm5vbmNlXCIpLFxuICAgICAgICBtYXhQcmlvcml0eUZlZVBlckdhczogaGFuZGxlVWludChmaWVsZHNbMl0sIFwibWF4UHJpb3JpdHlGZWVQZXJHYXNcIiksXG4gICAgICAgIG1heEZlZVBlckdhczogaGFuZGxlVWludChmaWVsZHNbM10sIFwibWF4RmVlUGVyR2FzXCIpLFxuICAgICAgICBnYXNQcmljZTogbnVsbCxcbiAgICAgICAgZ2FzTGltaXQ6IGhhbmRsZVVpbnQoZmllbGRzWzRdLCBcImdhc0xpbWl0XCIpLFxuICAgICAgICB0bzogaGFuZGxlQWRkcmVzcyhmaWVsZHNbNV0pLFxuICAgICAgICB2YWx1ZTogaGFuZGxlVWludChmaWVsZHNbNl0sIFwidmFsdWVcIiksXG4gICAgICAgIGRhdGE6IGhleGxpZnkoZmllbGRzWzddKSxcbiAgICAgICAgYWNjZXNzTGlzdDogaGFuZGxlQWNjZXNzTGlzdChmaWVsZHNbOF0sIFwiYWNjZXNzTGlzdFwiKSxcbiAgICB9O1xuICAgIC8vIFVuc2lnbmVkIEVJUC0xNTU5IFRyYW5zYWN0aW9uXG4gICAgaWYgKGZpZWxkcy5sZW5ndGggPT09IDkpIHtcbiAgICAgICAgcmV0dXJuIHR4O1xuICAgIH1cbiAgICAvL3R4Lmhhc2ggPSBrZWNjYWsyNTYoZGF0YSk7XG4gICAgX3BhcnNlRWlwU2lnbmF0dXJlKHR4LCBmaWVsZHMuc2xpY2UoOSkpO1xuICAgIHJldHVybiB0eDtcbn1cbmZ1bmN0aW9uIF9zZXJpYWxpemVFaXAxNTU5KHR4LCBzaWcpIHtcbiAgICBjb25zdCBmaWVsZHMgPSBbXG4gICAgICAgIGZvcm1hdE51bWJlcih0eC5jaGFpbklkLCBcImNoYWluSWRcIiksXG4gICAgICAgIGZvcm1hdE51bWJlcih0eC5ub25jZSwgXCJub25jZVwiKSxcbiAgICAgICAgZm9ybWF0TnVtYmVyKHR4Lm1heFByaW9yaXR5RmVlUGVyR2FzIHx8IDAsIFwibWF4UHJpb3JpdHlGZWVQZXJHYXNcIiksXG4gICAgICAgIGZvcm1hdE51bWJlcih0eC5tYXhGZWVQZXJHYXMgfHwgMCwgXCJtYXhGZWVQZXJHYXNcIiksXG4gICAgICAgIGZvcm1hdE51bWJlcih0eC5nYXNMaW1pdCwgXCJnYXNMaW1pdFwiKSxcbiAgICAgICAgKHR4LnRvIHx8IFwiMHhcIiksXG4gICAgICAgIGZvcm1hdE51bWJlcih0eC52YWx1ZSwgXCJ2YWx1ZVwiKSxcbiAgICAgICAgdHguZGF0YSxcbiAgICAgICAgZm9ybWF0QWNjZXNzTGlzdCh0eC5hY2Nlc3NMaXN0IHx8IFtdKVxuICAgIF07XG4gICAgaWYgKHNpZykge1xuICAgICAgICBmaWVsZHMucHVzaChmb3JtYXROdW1iZXIoc2lnLnlQYXJpdHksIFwieVBhcml0eVwiKSk7XG4gICAgICAgIGZpZWxkcy5wdXNoKHRvQmVBcnJheShzaWcucikpO1xuICAgICAgICBmaWVsZHMucHVzaCh0b0JlQXJyYXkoc2lnLnMpKTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbmNhdChbXCIweDAyXCIsIGVuY29kZVJscChmaWVsZHMpXSk7XG59XG5mdW5jdGlvbiBfcGFyc2VFaXAyOTMwKGRhdGEpIHtcbiAgICBjb25zdCBmaWVsZHMgPSBkZWNvZGVSbHAoZ2V0Qnl0ZXMoZGF0YSkuc2xpY2UoMSkpO1xuICAgIGFzc2VydEFyZ3VtZW50KEFycmF5LmlzQXJyYXkoZmllbGRzKSAmJiAoZmllbGRzLmxlbmd0aCA9PT0gOCB8fCBmaWVsZHMubGVuZ3RoID09PSAxMSksIFwiaW52YWxpZCBmaWVsZCBjb3VudCBmb3IgdHJhbnNhY3Rpb24gdHlwZTogMVwiLCBcImRhdGFcIiwgaGV4bGlmeShkYXRhKSk7XG4gICAgY29uc3QgdHggPSB7XG4gICAgICAgIHR5cGU6IDEsXG4gICAgICAgIGNoYWluSWQ6IGhhbmRsZVVpbnQoZmllbGRzWzBdLCBcImNoYWluSWRcIiksXG4gICAgICAgIG5vbmNlOiBoYW5kbGVOdW1iZXIoZmllbGRzWzFdLCBcIm5vbmNlXCIpLFxuICAgICAgICBnYXNQcmljZTogaGFuZGxlVWludChmaWVsZHNbMl0sIFwiZ2FzUHJpY2VcIiksXG4gICAgICAgIGdhc0xpbWl0OiBoYW5kbGVVaW50KGZpZWxkc1szXSwgXCJnYXNMaW1pdFwiKSxcbiAgICAgICAgdG86IGhhbmRsZUFkZHJlc3MoZmllbGRzWzRdKSxcbiAgICAgICAgdmFsdWU6IGhhbmRsZVVpbnQoZmllbGRzWzVdLCBcInZhbHVlXCIpLFxuICAgICAgICBkYXRhOiBoZXhsaWZ5KGZpZWxkc1s2XSksXG4gICAgICAgIGFjY2Vzc0xpc3Q6IGhhbmRsZUFjY2Vzc0xpc3QoZmllbGRzWzddLCBcImFjY2Vzc0xpc3RcIilcbiAgICB9O1xuICAgIC8vIFVuc2lnbmVkIEVJUC0yOTMwIFRyYW5zYWN0aW9uXG4gICAgaWYgKGZpZWxkcy5sZW5ndGggPT09IDgpIHtcbiAgICAgICAgcmV0dXJuIHR4O1xuICAgIH1cbiAgICAvL3R4Lmhhc2ggPSBrZWNjYWsyNTYoZGF0YSk7XG4gICAgX3BhcnNlRWlwU2lnbmF0dXJlKHR4LCBmaWVsZHMuc2xpY2UoOCkpO1xuICAgIHJldHVybiB0eDtcbn1cbmZ1bmN0aW9uIF9zZXJpYWxpemVFaXAyOTMwKHR4LCBzaWcpIHtcbiAgICBjb25zdCBmaWVsZHMgPSBbXG4gICAgICAgIGZvcm1hdE51bWJlcih0eC5jaGFpbklkLCBcImNoYWluSWRcIiksXG4gICAgICAgIGZvcm1hdE51bWJlcih0eC5ub25jZSwgXCJub25jZVwiKSxcbiAgICAgICAgZm9ybWF0TnVtYmVyKHR4Lmdhc1ByaWNlIHx8IDAsIFwiZ2FzUHJpY2VcIiksXG4gICAgICAgIGZvcm1hdE51bWJlcih0eC5nYXNMaW1pdCwgXCJnYXNMaW1pdFwiKSxcbiAgICAgICAgKHR4LnRvIHx8IFwiMHhcIiksXG4gICAgICAgIGZvcm1hdE51bWJlcih0eC52YWx1ZSwgXCJ2YWx1ZVwiKSxcbiAgICAgICAgdHguZGF0YSxcbiAgICAgICAgZm9ybWF0QWNjZXNzTGlzdCh0eC5hY2Nlc3NMaXN0IHx8IFtdKVxuICAgIF07XG4gICAgaWYgKHNpZykge1xuICAgICAgICBmaWVsZHMucHVzaChmb3JtYXROdW1iZXIoc2lnLnlQYXJpdHksIFwicmVjb3ZlcnlQYXJhbVwiKSk7XG4gICAgICAgIGZpZWxkcy5wdXNoKHRvQmVBcnJheShzaWcucikpO1xuICAgICAgICBmaWVsZHMucHVzaCh0b0JlQXJyYXkoc2lnLnMpKTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbmNhdChbXCIweDAxXCIsIGVuY29kZVJscChmaWVsZHMpXSk7XG59XG5mdW5jdGlvbiBfcGFyc2VFaXA0ODQ0KGRhdGEpIHtcbiAgICBsZXQgZmllbGRzID0gZGVjb2RlUmxwKGdldEJ5dGVzKGRhdGEpLnNsaWNlKDEpKTtcbiAgICBsZXQgdHlwZU5hbWUgPSBcIjNcIjtcbiAgICBsZXQgYmxvYnMgPSBudWxsO1xuICAgIC8vIFBhcnNlIHRoZSBuZXR3b3JrIGZvcm1hdFxuICAgIGlmIChmaWVsZHMubGVuZ3RoID09PSA0ICYmIEFycmF5LmlzQXJyYXkoZmllbGRzWzBdKSkge1xuICAgICAgICB0eXBlTmFtZSA9IFwiMyAobmV0d29yayBmb3JtYXQpXCI7XG4gICAgICAgIGNvbnN0IGZCbG9icyA9IGZpZWxkc1sxXSwgZkNvbW1pdHMgPSBmaWVsZHNbMl0sIGZQcm9vZnMgPSBmaWVsZHNbM107XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KEFycmF5LmlzQXJyYXkoZkJsb2JzKSwgXCJpbnZhbGlkIG5ldHdvcmsgZm9ybWF0OiBibG9icyBub3QgYW4gYXJyYXlcIiwgXCJmaWVsZHNbMV1cIiwgZkJsb2JzKTtcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQoQXJyYXkuaXNBcnJheShmQ29tbWl0cyksIFwiaW52YWxpZCBuZXR3b3JrIGZvcm1hdDogY29tbWl0bWVudHMgbm90IGFuIGFycmF5XCIsIFwiZmllbGRzWzJdXCIsIGZDb21taXRzKTtcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQoQXJyYXkuaXNBcnJheShmUHJvb2ZzKSwgXCJpbnZhbGlkIG5ldHdvcmsgZm9ybWF0OiBwcm9vZnMgbm90IGFuIGFycmF5XCIsIFwiZmllbGRzWzNdXCIsIGZQcm9vZnMpO1xuICAgICAgICBhc3NlcnRBcmd1bWVudChmQmxvYnMubGVuZ3RoID09PSBmQ29tbWl0cy5sZW5ndGgsIFwiaW52YWxpZCBuZXR3b3JrIGZvcm1hdDogYmxvYnMvY29tbWl0bWVudHMgbGVuZ3RoIG1pc21hdGNoXCIsIFwiZmllbGRzXCIsIGZpZWxkcyk7XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KGZCbG9icy5sZW5ndGggPT09IGZQcm9vZnMubGVuZ3RoLCBcImludmFsaWQgbmV0d29yayBmb3JtYXQ6IGJsb2JzL3Byb29mcyBsZW5ndGggbWlzbWF0Y2hcIiwgXCJmaWVsZHNcIiwgZmllbGRzKTtcbiAgICAgICAgYmxvYnMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmaWVsZHNbMV0ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGJsb2JzLnB1c2goe1xuICAgICAgICAgICAgICAgIGRhdGE6IGZCbG9ic1tpXSxcbiAgICAgICAgICAgICAgICBjb21taXRtZW50OiBmQ29tbWl0c1tpXSxcbiAgICAgICAgICAgICAgICBwcm9vZjogZlByb29mc1tpXSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGZpZWxkcyA9IGZpZWxkc1swXTtcbiAgICB9XG4gICAgYXNzZXJ0QXJndW1lbnQoQXJyYXkuaXNBcnJheShmaWVsZHMpICYmIChmaWVsZHMubGVuZ3RoID09PSAxMSB8fCBmaWVsZHMubGVuZ3RoID09PSAxNCksIGBpbnZhbGlkIGZpZWxkIGNvdW50IGZvciB0cmFuc2FjdGlvbiB0eXBlOiAke3R5cGVOYW1lfWAsIFwiZGF0YVwiLCBoZXhsaWZ5KGRhdGEpKTtcbiAgICBjb25zdCB0eCA9IHtcbiAgICAgICAgdHlwZTogMyxcbiAgICAgICAgY2hhaW5JZDogaGFuZGxlVWludChmaWVsZHNbMF0sIFwiY2hhaW5JZFwiKSxcbiAgICAgICAgbm9uY2U6IGhhbmRsZU51bWJlcihmaWVsZHNbMV0sIFwibm9uY2VcIiksXG4gICAgICAgIG1heFByaW9yaXR5RmVlUGVyR2FzOiBoYW5kbGVVaW50KGZpZWxkc1syXSwgXCJtYXhQcmlvcml0eUZlZVBlckdhc1wiKSxcbiAgICAgICAgbWF4RmVlUGVyR2FzOiBoYW5kbGVVaW50KGZpZWxkc1szXSwgXCJtYXhGZWVQZXJHYXNcIiksXG4gICAgICAgIGdhc1ByaWNlOiBudWxsLFxuICAgICAgICBnYXNMaW1pdDogaGFuZGxlVWludChmaWVsZHNbNF0sIFwiZ2FzTGltaXRcIiksXG4gICAgICAgIHRvOiBoYW5kbGVBZGRyZXNzKGZpZWxkc1s1XSksXG4gICAgICAgIHZhbHVlOiBoYW5kbGVVaW50KGZpZWxkc1s2XSwgXCJ2YWx1ZVwiKSxcbiAgICAgICAgZGF0YTogaGV4bGlmeShmaWVsZHNbN10pLFxuICAgICAgICBhY2Nlc3NMaXN0OiBoYW5kbGVBY2Nlc3NMaXN0KGZpZWxkc1s4XSwgXCJhY2Nlc3NMaXN0XCIpLFxuICAgICAgICBtYXhGZWVQZXJCbG9iR2FzOiBoYW5kbGVVaW50KGZpZWxkc1s5XSwgXCJtYXhGZWVQZXJCbG9iR2FzXCIpLFxuICAgICAgICBibG9iVmVyc2lvbmVkSGFzaGVzOiBmaWVsZHNbMTBdXG4gICAgfTtcbiAgICBpZiAoYmxvYnMpIHtcbiAgICAgICAgdHguYmxvYnMgPSBibG9icztcbiAgICB9XG4gICAgYXNzZXJ0QXJndW1lbnQodHgudG8gIT0gbnVsbCwgYGludmFsaWQgYWRkcmVzcyBmb3IgdHJhbnNhY3Rpb24gdHlwZTogJHt0eXBlTmFtZX1gLCBcImRhdGFcIiwgZGF0YSk7XG4gICAgYXNzZXJ0QXJndW1lbnQoQXJyYXkuaXNBcnJheSh0eC5ibG9iVmVyc2lvbmVkSGFzaGVzKSwgXCJpbnZhbGlkIGJsb2JWZXJzaW9uZWRIYXNoZXM6IG11c3QgYmUgYW4gYXJyYXlcIiwgXCJkYXRhXCIsIGRhdGEpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdHguYmxvYlZlcnNpb25lZEhhc2hlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBhc3NlcnRBcmd1bWVudChpc0hleFN0cmluZyh0eC5ibG9iVmVyc2lvbmVkSGFzaGVzW2ldLCAzMiksIGBpbnZhbGlkIGJsb2JWZXJzaW9uZWRIYXNoIGF0IGluZGV4ICR7aX06IG11c3QgYmUgbGVuZ3RoIDMyYCwgXCJkYXRhXCIsIGRhdGEpO1xuICAgIH1cbiAgICAvLyBVbnNpZ25lZCBFSVAtNDg0NCBUcmFuc2FjdGlvblxuICAgIGlmIChmaWVsZHMubGVuZ3RoID09PSAxMSkge1xuICAgICAgICByZXR1cm4gdHg7XG4gICAgfVxuICAgIC8vIEBUT0RPOiBEbyB3ZSBuZWVkIHRvIGRvIHRoaXM/IFRoaXMgaXMgb25seSBjYWxsZWQgaW50ZXJuYWxseVxuICAgIC8vIGFuZCB1c2VkIHRvIHZlcmlmeSBoYXNoZXM7IGl0IG1pZ2h0IHNhdmUgdGltZSB0byBub3QgZG8gdGhpc1xuICAgIC8vdHguaGFzaCA9IGtlY2NhazI1Nihjb25jYXQoWyBcIjB4MDNcIiwgZW5jb2RlUmxwKGZpZWxkcykgXSkpO1xuICAgIF9wYXJzZUVpcFNpZ25hdHVyZSh0eCwgZmllbGRzLnNsaWNlKDExKSk7XG4gICAgcmV0dXJuIHR4O1xufVxuZnVuY3Rpb24gX3NlcmlhbGl6ZUVpcDQ4NDQodHgsIHNpZywgYmxvYnMpIHtcbiAgICBjb25zdCBmaWVsZHMgPSBbXG4gICAgICAgIGZvcm1hdE51bWJlcih0eC5jaGFpbklkLCBcImNoYWluSWRcIiksXG4gICAgICAgIGZvcm1hdE51bWJlcih0eC5ub25jZSwgXCJub25jZVwiKSxcbiAgICAgICAgZm9ybWF0TnVtYmVyKHR4Lm1heFByaW9yaXR5RmVlUGVyR2FzIHx8IDAsIFwibWF4UHJpb3JpdHlGZWVQZXJHYXNcIiksXG4gICAgICAgIGZvcm1hdE51bWJlcih0eC5tYXhGZWVQZXJHYXMgfHwgMCwgXCJtYXhGZWVQZXJHYXNcIiksXG4gICAgICAgIGZvcm1hdE51bWJlcih0eC5nYXNMaW1pdCwgXCJnYXNMaW1pdFwiKSxcbiAgICAgICAgKHR4LnRvIHx8IFplcm9BZGRyZXNzKSxcbiAgICAgICAgZm9ybWF0TnVtYmVyKHR4LnZhbHVlLCBcInZhbHVlXCIpLFxuICAgICAgICB0eC5kYXRhLFxuICAgICAgICBmb3JtYXRBY2Nlc3NMaXN0KHR4LmFjY2Vzc0xpc3QgfHwgW10pLFxuICAgICAgICBmb3JtYXROdW1iZXIodHgubWF4RmVlUGVyQmxvYkdhcyB8fCAwLCBcIm1heEZlZVBlckJsb2JHYXNcIiksXG4gICAgICAgIGZvcm1hdEhhc2hlcyh0eC5ibG9iVmVyc2lvbmVkSGFzaGVzIHx8IFtdLCBcImJsb2JWZXJzaW9uZWRIYXNoZXNcIilcbiAgICBdO1xuICAgIGlmIChzaWcpIHtcbiAgICAgICAgZmllbGRzLnB1c2goZm9ybWF0TnVtYmVyKHNpZy55UGFyaXR5LCBcInlQYXJpdHlcIikpO1xuICAgICAgICBmaWVsZHMucHVzaCh0b0JlQXJyYXkoc2lnLnIpKTtcbiAgICAgICAgZmllbGRzLnB1c2godG9CZUFycmF5KHNpZy5zKSk7XG4gICAgICAgIC8vIFdlIGhhdmUgYmxvYnM7IHJldHVybiB0aGUgbmV0d29yayB3cmFwcGVkIGZvcm1hdFxuICAgICAgICBpZiAoYmxvYnMpIHtcbiAgICAgICAgICAgIHJldHVybiBjb25jYXQoW1xuICAgICAgICAgICAgICAgIFwiMHgwM1wiLFxuICAgICAgICAgICAgICAgIGVuY29kZVJscChbXG4gICAgICAgICAgICAgICAgICAgIGZpZWxkcyxcbiAgICAgICAgICAgICAgICAgICAgYmxvYnMubWFwKChiKSA9PiBiLmRhdGEpLFxuICAgICAgICAgICAgICAgICAgICBibG9icy5tYXAoKGIpID0+IGIuY29tbWl0bWVudCksXG4gICAgICAgICAgICAgICAgICAgIGJsb2JzLm1hcCgoYikgPT4gYi5wcm9vZiksXG4gICAgICAgICAgICAgICAgXSlcbiAgICAgICAgICAgIF0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjb25jYXQoW1wiMHgwM1wiLCBlbmNvZGVSbHAoZmllbGRzKV0pO1xufVxuZnVuY3Rpb24gX3BhcnNlRWlwNzcwMihkYXRhKSB7XG4gICAgY29uc3QgZmllbGRzID0gZGVjb2RlUmxwKGdldEJ5dGVzKGRhdGEpLnNsaWNlKDEpKTtcbiAgICBhc3NlcnRBcmd1bWVudChBcnJheS5pc0FycmF5KGZpZWxkcykgJiYgKGZpZWxkcy5sZW5ndGggPT09IDEwIHx8IGZpZWxkcy5sZW5ndGggPT09IDEzKSwgXCJpbnZhbGlkIGZpZWxkIGNvdW50IGZvciB0cmFuc2FjdGlvbiB0eXBlOiA0XCIsIFwiZGF0YVwiLCBoZXhsaWZ5KGRhdGEpKTtcbiAgICBjb25zdCB0eCA9IHtcbiAgICAgICAgdHlwZTogNCxcbiAgICAgICAgY2hhaW5JZDogaGFuZGxlVWludChmaWVsZHNbMF0sIFwiY2hhaW5JZFwiKSxcbiAgICAgICAgbm9uY2U6IGhhbmRsZU51bWJlcihmaWVsZHNbMV0sIFwibm9uY2VcIiksXG4gICAgICAgIG1heFByaW9yaXR5RmVlUGVyR2FzOiBoYW5kbGVVaW50KGZpZWxkc1syXSwgXCJtYXhQcmlvcml0eUZlZVBlckdhc1wiKSxcbiAgICAgICAgbWF4RmVlUGVyR2FzOiBoYW5kbGVVaW50KGZpZWxkc1szXSwgXCJtYXhGZWVQZXJHYXNcIiksXG4gICAgICAgIGdhc1ByaWNlOiBudWxsLFxuICAgICAgICBnYXNMaW1pdDogaGFuZGxlVWludChmaWVsZHNbNF0sIFwiZ2FzTGltaXRcIiksXG4gICAgICAgIHRvOiBoYW5kbGVBZGRyZXNzKGZpZWxkc1s1XSksXG4gICAgICAgIHZhbHVlOiBoYW5kbGVVaW50KGZpZWxkc1s2XSwgXCJ2YWx1ZVwiKSxcbiAgICAgICAgZGF0YTogaGV4bGlmeShmaWVsZHNbN10pLFxuICAgICAgICBhY2Nlc3NMaXN0OiBoYW5kbGVBY2Nlc3NMaXN0KGZpZWxkc1s4XSwgXCJhY2Nlc3NMaXN0XCIpLFxuICAgICAgICBhdXRob3JpemF0aW9uTGlzdDogaGFuZGxlQXV0aG9yaXphdGlvbkxpc3QoZmllbGRzWzldLCBcImF1dGhvcml6YXRpb25MaXN0XCIpLFxuICAgIH07XG4gICAgLy8gVW5zaWduZWQgRUlQLTc3MDIgVHJhbnNhY3Rpb25cbiAgICBpZiAoZmllbGRzLmxlbmd0aCA9PT0gMTApIHtcbiAgICAgICAgcmV0dXJuIHR4O1xuICAgIH1cbiAgICBfcGFyc2VFaXBTaWduYXR1cmUodHgsIGZpZWxkcy5zbGljZSgxMCkpO1xuICAgIHJldHVybiB0eDtcbn1cbmZ1bmN0aW9uIF9zZXJpYWxpemVFaXA3NzAyKHR4LCBzaWcpIHtcbiAgICBjb25zdCBmaWVsZHMgPSBbXG4gICAgICAgIGZvcm1hdE51bWJlcih0eC5jaGFpbklkLCBcImNoYWluSWRcIiksXG4gICAgICAgIGZvcm1hdE51bWJlcih0eC5ub25jZSwgXCJub25jZVwiKSxcbiAgICAgICAgZm9ybWF0TnVtYmVyKHR4Lm1heFByaW9yaXR5RmVlUGVyR2FzIHx8IDAsIFwibWF4UHJpb3JpdHlGZWVQZXJHYXNcIiksXG4gICAgICAgIGZvcm1hdE51bWJlcih0eC5tYXhGZWVQZXJHYXMgfHwgMCwgXCJtYXhGZWVQZXJHYXNcIiksXG4gICAgICAgIGZvcm1hdE51bWJlcih0eC5nYXNMaW1pdCwgXCJnYXNMaW1pdFwiKSxcbiAgICAgICAgKHR4LnRvIHx8IFwiMHhcIiksXG4gICAgICAgIGZvcm1hdE51bWJlcih0eC52YWx1ZSwgXCJ2YWx1ZVwiKSxcbiAgICAgICAgdHguZGF0YSxcbiAgICAgICAgZm9ybWF0QWNjZXNzTGlzdCh0eC5hY2Nlc3NMaXN0IHx8IFtdKSxcbiAgICAgICAgZm9ybWF0QXV0aG9yaXphdGlvbkxpc3QodHguYXV0aG9yaXphdGlvbkxpc3QgfHwgW10pXG4gICAgXTtcbiAgICBpZiAoc2lnKSB7XG4gICAgICAgIGZpZWxkcy5wdXNoKGZvcm1hdE51bWJlcihzaWcueVBhcml0eSwgXCJ5UGFyaXR5XCIpKTtcbiAgICAgICAgZmllbGRzLnB1c2godG9CZUFycmF5KHNpZy5yKSk7XG4gICAgICAgIGZpZWxkcy5wdXNoKHRvQmVBcnJheShzaWcucykpO1xuICAgIH1cbiAgICByZXR1cm4gY29uY2F0KFtcIjB4MDRcIiwgZW5jb2RlUmxwKGZpZWxkcyldKTtcbn1cbi8qKlxuICogIEEgKipUcmFuc2FjdGlvbioqIGRlc2NyaWJlcyBhbiBvcGVyYXRpb24gdG8gYmUgZXhlY3V0ZWQgb25cbiAqICBFdGhlcmV1bSBieSBhbiBFeHRlcm5hbGx5IE93bmVkIEFjY291bnQgKEVPQSkuIEl0IGluY2x1ZGVzXG4gKiAgd2hvICh0aGUgW1t0b11dIGFkZHJlc3MpLCB3aGF0ICh0aGUgW1tkYXRhXV0pIGFuZCBob3cgbXVjaCAodGhlXG4gKiAgW1t2YWx1ZV1dIGluIGV0aGVyKSB0aGUgb3BlcmF0aW9uIHNob3VsZCBlbnRhaWwuXG4gKlxuICogIEBleGFtcGxlOlxuICogICAgdHggPSBuZXcgVHJhbnNhY3Rpb24oKVxuICogICAgLy9fcmVzdWx0OlxuICpcbiAqICAgIHR4LmRhdGEgPSBcIjB4MTIzNFwiO1xuICogICAgLy9fcmVzdWx0OlxuICovXG5leHBvcnQgY2xhc3MgVHJhbnNhY3Rpb24ge1xuICAgICN0eXBlO1xuICAgICN0bztcbiAgICAjZGF0YTtcbiAgICAjbm9uY2U7XG4gICAgI2dhc0xpbWl0O1xuICAgICNnYXNQcmljZTtcbiAgICAjbWF4UHJpb3JpdHlGZWVQZXJHYXM7XG4gICAgI21heEZlZVBlckdhcztcbiAgICAjdmFsdWU7XG4gICAgI2NoYWluSWQ7XG4gICAgI3NpZztcbiAgICAjYWNjZXNzTGlzdDtcbiAgICAjbWF4RmVlUGVyQmxvYkdhcztcbiAgICAjYmxvYlZlcnNpb25lZEhhc2hlcztcbiAgICAja3pnO1xuICAgICNibG9icztcbiAgICAjYXV0aHM7XG4gICAgLyoqXG4gICAgICogIFRoZSB0cmFuc2FjdGlvbiB0eXBlLlxuICAgICAqXG4gICAgICogIElmIG51bGwsIHRoZSB0eXBlIHdpbGwgYmUgYXV0b21hdGljYWxseSBpbmZlcnJlZCBiYXNlZCBvblxuICAgICAqICBleHBsaWNpdCBwcm9wZXJ0aWVzLlxuICAgICAqL1xuICAgIGdldCB0eXBlKCkgeyByZXR1cm4gdGhpcy4jdHlwZTsgfVxuICAgIHNldCB0eXBlKHZhbHVlKSB7XG4gICAgICAgIHN3aXRjaCAodmFsdWUpIHtcbiAgICAgICAgICAgIGNhc2UgbnVsbDpcbiAgICAgICAgICAgICAgICB0aGlzLiN0eXBlID0gbnVsbDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIGNhc2UgXCJsZWdhY3lcIjpcbiAgICAgICAgICAgICAgICB0aGlzLiN0eXBlID0gMDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIGNhc2UgXCJiZXJsaW5cIjpcbiAgICAgICAgICAgIGNhc2UgXCJlaXAtMjkzMFwiOlxuICAgICAgICAgICAgICAgIHRoaXMuI3R5cGUgPSAxO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgY2FzZSBcImxvbmRvblwiOlxuICAgICAgICAgICAgY2FzZSBcImVpcC0xNTU5XCI6XG4gICAgICAgICAgICAgICAgdGhpcy4jdHlwZSA9IDI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICBjYXNlIFwiY2FuY3VuXCI6XG4gICAgICAgICAgICBjYXNlIFwiZWlwLTQ4NDRcIjpcbiAgICAgICAgICAgICAgICB0aGlzLiN0eXBlID0gMztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgIGNhc2UgXCJwZWN0cmFcIjpcbiAgICAgICAgICAgIGNhc2UgXCJlaXAtNzcwMlwiOlxuICAgICAgICAgICAgICAgIHRoaXMuI3R5cGUgPSA0O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBhc3NlcnRBcmd1bWVudChmYWxzZSwgXCJ1bnN1cHBvcnRlZCB0cmFuc2FjdGlvbiB0eXBlXCIsIFwidHlwZVwiLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRoZSBuYW1lIG9mIHRoZSB0cmFuc2FjdGlvbiB0eXBlLlxuICAgICAqL1xuICAgIGdldCB0eXBlTmFtZSgpIHtcbiAgICAgICAgc3dpdGNoICh0aGlzLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFwibGVnYWN5XCI7XG4gICAgICAgICAgICBjYXNlIDE6IHJldHVybiBcImVpcC0yOTMwXCI7XG4gICAgICAgICAgICBjYXNlIDI6IHJldHVybiBcImVpcC0xNTU5XCI7XG4gICAgICAgICAgICBjYXNlIDM6IHJldHVybiBcImVpcC00ODQ0XCI7XG4gICAgICAgICAgICBjYXNlIDQ6IHJldHVybiBcImVpcC03NzAyXCI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgYGB0b2BgIGFkZHJlc3MgZm9yIHRoZSB0cmFuc2FjdGlvbiBvciBgYG51bGxgYCBpZiB0aGVcbiAgICAgKiAgdHJhbnNhY3Rpb24gaXMgYW4gYGBpbml0YGAgdHJhbnNhY3Rpb24uXG4gICAgICovXG4gICAgZ2V0IHRvKCkge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMuI3RvO1xuICAgICAgICBpZiAodmFsdWUgPT0gbnVsbCAmJiB0aGlzLnR5cGUgPT09IDMpIHtcbiAgICAgICAgICAgIHJldHVybiBaZXJvQWRkcmVzcztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIHNldCB0byh2YWx1ZSkge1xuICAgICAgICB0aGlzLiN0byA9ICh2YWx1ZSA9PSBudWxsKSA/IG51bGwgOiBnZXRBZGRyZXNzKHZhbHVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRoZSB0cmFuc2FjdGlvbiBub25jZS5cbiAgICAgKi9cbiAgICBnZXQgbm9uY2UoKSB7IHJldHVybiB0aGlzLiNub25jZTsgfVxuICAgIHNldCBub25jZSh2YWx1ZSkgeyB0aGlzLiNub25jZSA9IGdldE51bWJlcih2YWx1ZSwgXCJ2YWx1ZVwiKTsgfVxuICAgIC8qKlxuICAgICAqICBUaGUgZ2FzIGxpbWl0LlxuICAgICAqL1xuICAgIGdldCBnYXNMaW1pdCgpIHsgcmV0dXJuIHRoaXMuI2dhc0xpbWl0OyB9XG4gICAgc2V0IGdhc0xpbWl0KHZhbHVlKSB7IHRoaXMuI2dhc0xpbWl0ID0gZ2V0QmlnSW50KHZhbHVlKTsgfVxuICAgIC8qKlxuICAgICAqICBUaGUgZ2FzIHByaWNlLlxuICAgICAqXG4gICAgICogIE9uIGxlZ2FjeSBuZXR3b3JrcyB0aGlzIGRlZmluZXMgdGhlIGZlZSB0aGF0IHdpbGwgYmUgcGFpZC4gT25cbiAgICAgKiAgRUlQLTE1NTkgbmV0d29ya3MsIHRoaXMgc2hvdWxkIGJlIGBgbnVsbGBgLlxuICAgICAqL1xuICAgIGdldCBnYXNQcmljZSgpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLiNnYXNQcmljZTtcbiAgICAgICAgaWYgKHZhbHVlID09IG51bGwgJiYgKHRoaXMudHlwZSA9PT0gMCB8fCB0aGlzLnR5cGUgPT09IDEpKSB7XG4gICAgICAgICAgICByZXR1cm4gQk5fMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIHNldCBnYXNQcmljZSh2YWx1ZSkge1xuICAgICAgICB0aGlzLiNnYXNQcmljZSA9ICh2YWx1ZSA9PSBudWxsKSA/IG51bGwgOiBnZXRCaWdJbnQodmFsdWUsIFwiZ2FzUHJpY2VcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgbWF4aW11bSBwcmlvcml0eSBmZWUgcGVyIHVuaXQgb2YgZ2FzIHRvIHBheS4gT24gbGVnYWN5XG4gICAgICogIG5ldHdvcmtzIHRoaXMgc2hvdWxkIGJlIGBgbnVsbGBgLlxuICAgICAqL1xuICAgIGdldCBtYXhQcmlvcml0eUZlZVBlckdhcygpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLiNtYXhQcmlvcml0eUZlZVBlckdhcztcbiAgICAgICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnR5cGUgPT09IDIgfHwgdGhpcy50eXBlID09PSAzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEJOXzA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIHNldCBtYXhQcmlvcml0eUZlZVBlckdhcyh2YWx1ZSkge1xuICAgICAgICB0aGlzLiNtYXhQcmlvcml0eUZlZVBlckdhcyA9ICh2YWx1ZSA9PSBudWxsKSA/IG51bGwgOiBnZXRCaWdJbnQodmFsdWUsIFwibWF4UHJpb3JpdHlGZWVQZXJHYXNcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgbWF4aW11bSB0b3RhbCBmZWUgcGVyIHVuaXQgb2YgZ2FzIHRvIHBheS4gT24gbGVnYWN5XG4gICAgICogIG5ldHdvcmtzIHRoaXMgc2hvdWxkIGJlIGBgbnVsbGBgLlxuICAgICAqL1xuICAgIGdldCBtYXhGZWVQZXJHYXMoKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy4jbWF4RmVlUGVyR2FzO1xuICAgICAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHRoaXMudHlwZSA9PT0gMiB8fCB0aGlzLnR5cGUgPT09IDMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gQk5fMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgc2V0IG1heEZlZVBlckdhcyh2YWx1ZSkge1xuICAgICAgICB0aGlzLiNtYXhGZWVQZXJHYXMgPSAodmFsdWUgPT0gbnVsbCkgPyBudWxsIDogZ2V0QmlnSW50KHZhbHVlLCBcIm1heEZlZVBlckdhc1wiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRoZSB0cmFuc2FjdGlvbiBkYXRhLiBGb3IgYGBpbml0YGAgdHJhbnNhY3Rpb25zIHRoaXMgaXMgdGhlXG4gICAgICogIGRlcGxveW1lbnQgY29kZS5cbiAgICAgKi9cbiAgICBnZXQgZGF0YSgpIHsgcmV0dXJuIHRoaXMuI2RhdGE7IH1cbiAgICBzZXQgZGF0YSh2YWx1ZSkgeyB0aGlzLiNkYXRhID0gaGV4bGlmeSh2YWx1ZSk7IH1cbiAgICAvKipcbiAgICAgKiAgVGhlIGFtb3VudCBvZiBldGhlciAoaW4gd2VpKSB0byBzZW5kIGluIHRoaXMgdHJhbnNhY3Rpb25zLlxuICAgICAqL1xuICAgIGdldCB2YWx1ZSgpIHsgcmV0dXJuIHRoaXMuI3ZhbHVlOyB9XG4gICAgc2V0IHZhbHVlKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuI3ZhbHVlID0gZ2V0QmlnSW50KHZhbHVlLCBcInZhbHVlXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhlIGNoYWluIElEIHRoaXMgdHJhbnNhY3Rpb24gaXMgdmFsaWQgb24uXG4gICAgICovXG4gICAgZ2V0IGNoYWluSWQoKSB7IHJldHVybiB0aGlzLiNjaGFpbklkOyB9XG4gICAgc2V0IGNoYWluSWQodmFsdWUpIHsgdGhpcy4jY2hhaW5JZCA9IGdldEJpZ0ludCh2YWx1ZSk7IH1cbiAgICAvKipcbiAgICAgKiAgSWYgc2lnbmVkLCB0aGUgc2lnbmF0dXJlIGZvciB0aGlzIHRyYW5zYWN0aW9uLlxuICAgICAqL1xuICAgIGdldCBzaWduYXR1cmUoKSB7IHJldHVybiB0aGlzLiNzaWcgfHwgbnVsbDsgfVxuICAgIHNldCBzaWduYXR1cmUodmFsdWUpIHtcbiAgICAgICAgdGhpcy4jc2lnID0gKHZhbHVlID09IG51bGwpID8gbnVsbCA6IFNpZ25hdHVyZS5mcm9tKHZhbHVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRoZSBhY2Nlc3MgbGlzdC5cbiAgICAgKlxuICAgICAqICBBbiBhY2Nlc3MgbGlzdCBwZXJtaXRzIGRpc2NvdW50ZWQgKGJ1dCBwcmUtcGFpZCkgYWNjZXNzIHRvXG4gICAgICogIGJ5dGVjb2RlIGFuZCBzdGF0ZSB2YXJpYWJsZSBhY2Nlc3Mgd2l0aGluIGNvbnRyYWN0IGV4ZWN1dGlvbi5cbiAgICAgKi9cbiAgICBnZXQgYWNjZXNzTGlzdCgpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLiNhY2Nlc3NMaXN0IHx8IG51bGw7XG4gICAgICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAodGhpcy50eXBlID09PSAxIHx8IHRoaXMudHlwZSA9PT0gMiB8fCB0aGlzLnR5cGUgPT09IDMpIHtcbiAgICAgICAgICAgICAgICAvLyBAVE9ETzogaW4gdjcsIHRoaXMgc2hvdWxkIGFzc2lnbiB0aGUgdmFsdWUgb3IgYmVjb21lXG4gICAgICAgICAgICAgICAgLy8gYSBsaXZlIG9iamVjdCBpdHNlbGYsIG90aGVyd2lzZSBtdXRhdGlvbiBpcyBpbmNvbnNpc3RlbnRcbiAgICAgICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIHNldCBhY2Nlc3NMaXN0KHZhbHVlKSB7XG4gICAgICAgIHRoaXMuI2FjY2Vzc0xpc3QgPSAodmFsdWUgPT0gbnVsbCkgPyBudWxsIDogYWNjZXNzTGlzdGlmeSh2YWx1ZSk7XG4gICAgfVxuICAgIGdldCBhdXRob3JpemF0aW9uTGlzdCgpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLiNhdXRocyB8fCBudWxsO1xuICAgICAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHRoaXMudHlwZSA9PT0gNCkge1xuICAgICAgICAgICAgICAgIC8vIEBUT0RPOiBpbiB2NywgdGhpcyBzaG91bGQgYmVjb21lIGEgbGl2ZSBvYmplY3QgaXRzZWxmLFxuICAgICAgICAgICAgICAgIC8vIG90aGVyd2lzZSBtdXRhdGlvbiBpcyBpbmNvbnNpc3RlbnRcbiAgICAgICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBzZXQgYXV0aG9yaXphdGlvbkxpc3QoYXV0aHMpIHtcbiAgICAgICAgdGhpcy4jYXV0aHMgPSAoYXV0aHMgPT0gbnVsbCkgPyBudWxsIDogYXV0aHMubWFwKChhKSA9PiBhdXRob3JpemF0aW9uaWZ5KGEpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRoZSBtYXggZmVlIHBlciBibG9iIGdhcyBmb3IgQ2FuY3VuIHRyYW5zYWN0aW9ucy5cbiAgICAgKi9cbiAgICBnZXQgbWF4RmVlUGVyQmxvYkdhcygpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLiNtYXhGZWVQZXJCbG9iR2FzO1xuICAgICAgICBpZiAodmFsdWUgPT0gbnVsbCAmJiB0aGlzLnR5cGUgPT09IDMpIHtcbiAgICAgICAgICAgIHJldHVybiBCTl8wO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgc2V0IG1heEZlZVBlckJsb2JHYXModmFsdWUpIHtcbiAgICAgICAgdGhpcy4jbWF4RmVlUGVyQmxvYkdhcyA9ICh2YWx1ZSA9PSBudWxsKSA/IG51bGwgOiBnZXRCaWdJbnQodmFsdWUsIFwibWF4RmVlUGVyQmxvYkdhc1wiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRoZSBCTE9iIHZlcnNpb25lZCBoYXNoZXMgZm9yIENhbmN1biB0cmFuc2FjdGlvbnMuXG4gICAgICovXG4gICAgZ2V0IGJsb2JWZXJzaW9uZWRIYXNoZXMoKSB7XG4gICAgICAgIC8vIEBUT0RPOiBNdXRhdGlvbiBpcyBpbmNvbnNpc3RlbnQ7IGlmIHVuc2V0LCB0aGUgcmV0dXJuZWQgdmFsdWVcbiAgICAgICAgLy8gY2Fubm90IG11dGF0ZSB0aGUgb2JqZWN0LCBpZiBzZXQgaXQgY2FuXG4gICAgICAgIGxldCB2YWx1ZSA9IHRoaXMuI2Jsb2JWZXJzaW9uZWRIYXNoZXM7XG4gICAgICAgIGlmICh2YWx1ZSA9PSBudWxsICYmIHRoaXMudHlwZSA9PT0gMykge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgc2V0IGJsb2JWZXJzaW9uZWRIYXNoZXModmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KEFycmF5LmlzQXJyYXkodmFsdWUpLCBcImJsb2JWZXJzaW9uZWRIYXNoZXMgbXVzdCBiZSBhbiBBcnJheVwiLCBcInZhbHVlXCIsIHZhbHVlKTtcbiAgICAgICAgICAgIHZhbHVlID0gdmFsdWUuc2xpY2UoKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBhc3NlcnRBcmd1bWVudChpc0hleFN0cmluZyh2YWx1ZVtpXSwgMzIpLCBcImludmFsaWQgYmxvYlZlcnNpb25lZEhhc2hcIiwgYHZhbHVlWyR7aX1dYCwgdmFsdWVbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuI2Jsb2JWZXJzaW9uZWRIYXNoZXMgPSB2YWx1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRoZSBCTE9icyBmb3IgdGhlIFRyYW5zYWN0aW9uLCBpZiBhbnkuXG4gICAgICpcbiAgICAgKiAgSWYgYGBibG9ic2BgIGlzIG5vbi1gYG51bGxgYCwgdGhlbiB0aGUgW1tzZXJpYWlsaXplZF1dXG4gICAgICogIHdpbGwgcmV0dXJuIHRoZSBuZXR3b3JrIGZvcm1hdHRlZCBzaWRlY2FyLCBvdGhlcndpc2UgaXRcbiAgICAgKiAgd2lsbCByZXR1cm4gdGhlIHN0YW5kYXJkIFtbbGluay1laXAtMjcxOF1dIHBheWxvYWQuIFRoZVxuICAgICAqICBbW3Vuc2lnbmVkU2VyaWFsaXplZF1dIGlzIHVuYWZmZWN0ZWQgcmVnYXJkbGVzcy5cbiAgICAgKlxuICAgICAqICBXaGVuIHNldHRpbmcgYGBibG9ic2BgLCBlaXRoZXIgZnVsbHkgdmFsaWQgW1tCbG9iXV0gb2JqZWN0c1xuICAgICAqICBtYXkgYmUgc3BlY2lmaWVkIChpLmUuIGNvcnJlY3RseSBwYWRkZWQsIHdpdGggY29ycmVjdFxuICAgICAqICBjb21taXR0bWVudHMgYW5kIHByb29mcykgb3IgYSByYXcgW1tCeXRlc0xpa2VdXSBtYXlcbiAgICAgKiAgYmUgcHJvdmlkZWQuXG4gICAgICpcbiAgICAgKiAgSWYgcmF3IFtbQnl0ZXNMaWtlXV0gYXJlIHByb3ZpZGVkLCB0aGUgW1tremddXSBwcm9wZXJ0eSAqKm11c3QqKlxuICAgICAqICBiZSBhbHJlYWR5IHNldC4gVGhlIGJsb2Igd2lsbCBiZSBjb3JyZWN0bHkgcGFkZGVkIGFuZCB0aGVcbiAgICAgKiAgW1tLemdMaWJyYXJ5XV0gd2lsbCBiZSB1c2VkIHRvIGNvbXB1dGUgdGhlIGNvbW1pdHRtZW50IGFuZFxuICAgICAqICBwcm9vZiBmb3IgdGhlIGJsb2IuXG4gICAgICpcbiAgICAgKiAgQSBCTE9iIGlzIGEgc2VxdWVuY2Ugb2YgZmllbGQgZWxlbWVudHMsIGVhY2ggb2Ygd2hpY2ggbXVzdFxuICAgICAqICBiZSB3aXRoaW4gdGhlIEJMUyBmaWVsZCBtb2R1bG8sIHNvIHNvbWUgYWRkaXRpb25hbCBwcm9jZXNzaW5nXG4gICAgICogIG1heSBiZSByZXF1aXJlZCB0byBlbmNvZGUgYXJiaXRyYXJ5IGRhdGEgdG8gZW5zdXJlIGVhY2ggMzIgYnl0ZVxuICAgICAqICBmaWVsZCBpcyB3aXRoaW4gdGhlIHZhbGlkIHJhbmdlLlxuICAgICAqXG4gICAgICogIFNldHRpbmcgdGhpcyBhdXRvbWF0aWNhbGx5IHBvcHVsYXRlcyBbW2Jsb2JWZXJzaW9uZWRIYXNoZXNdXSxcbiAgICAgKiAgb3ZlcndyaXRpbmcgYW55IGV4aXN0aW5nIHZhbHVlcy4gU2V0dGluZyB0aGlzIHRvIGBgbnVsbGBgXG4gICAgICogIGRvZXMgKipub3QqKiByZW1vdmUgdGhlIFtbYmxvYlZlcnNpb25lZEhhc2hlc11dLCBsZWF2aW5nIHRoZW1cbiAgICAgKiAgcHJlc2VudC5cbiAgICAgKi9cbiAgICBnZXQgYmxvYnMoKSB7XG4gICAgICAgIGlmICh0aGlzLiNibG9icyA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy4jYmxvYnMubWFwKChiKSA9PiBPYmplY3QuYXNzaWduKHt9LCBiKSk7XG4gICAgfVxuICAgIHNldCBibG9icyhfYmxvYnMpIHtcbiAgICAgICAgaWYgKF9ibG9icyA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLiNibG9icyA9IG51bGw7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYmxvYnMgPSBbXTtcbiAgICAgICAgY29uc3QgdmVyc2lvbmVkSGFzaGVzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgX2Jsb2JzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBibG9iID0gX2Jsb2JzW2ldO1xuICAgICAgICAgICAgaWYgKGlzQnl0ZXNMaWtlKGJsb2IpKSB7XG4gICAgICAgICAgICAgICAgYXNzZXJ0KHRoaXMuI2t6ZywgXCJhZGRpbmcgYSByYXcgYmxvYiByZXF1aXJlcyBhIEtaRyBsaWJyYXJ5XCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBcInNldCBibG9icygpXCJcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBsZXQgZGF0YSA9IGdldEJ5dGVzKGJsb2IpO1xuICAgICAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KGRhdGEubGVuZ3RoIDw9IEJMT0JfU0laRSwgXCJibG9iIGlzIHRvbyBsYXJnZVwiLCBgYmxvYnNbJHtpfV1gLCBibG9iKTtcbiAgICAgICAgICAgICAgICAvLyBQYWQgYmxvYiBpZiBuZWNlc3NhcnlcbiAgICAgICAgICAgICAgICBpZiAoZGF0YS5sZW5ndGggIT09IEJMT0JfU0laRSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwYWRkZWQgPSBuZXcgVWludDhBcnJheShCTE9CX1NJWkUpO1xuICAgICAgICAgICAgICAgICAgICBwYWRkZWQuc2V0KGRhdGEpO1xuICAgICAgICAgICAgICAgICAgICBkYXRhID0gcGFkZGVkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBjb21taXQgPSB0aGlzLiNremcuYmxvYlRvS3pnQ29tbWl0bWVudChkYXRhKTtcbiAgICAgICAgICAgICAgICBjb25zdCBwcm9vZiA9IGhleGxpZnkodGhpcy4ja3pnLmNvbXB1dGVCbG9iS3pnUHJvb2YoZGF0YSwgY29tbWl0KSk7XG4gICAgICAgICAgICAgICAgYmxvYnMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IGhleGxpZnkoZGF0YSksXG4gICAgICAgICAgICAgICAgICAgIGNvbW1pdG1lbnQ6IGhleGxpZnkoY29tbWl0KSxcbiAgICAgICAgICAgICAgICAgICAgcHJvb2ZcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB2ZXJzaW9uZWRIYXNoZXMucHVzaChnZXRWZXJzaW9uZWRIYXNoKDEsIGNvbW1pdCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY29tbWl0ID0gaGV4bGlmeShibG9iLmNvbW1pdG1lbnQpO1xuICAgICAgICAgICAgICAgIGJsb2JzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBkYXRhOiBoZXhsaWZ5KGJsb2IuZGF0YSksXG4gICAgICAgICAgICAgICAgICAgIGNvbW1pdG1lbnQ6IGNvbW1pdCxcbiAgICAgICAgICAgICAgICAgICAgcHJvb2Y6IGhleGxpZnkoYmxvYi5wcm9vZilcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB2ZXJzaW9uZWRIYXNoZXMucHVzaChnZXRWZXJzaW9uZWRIYXNoKDEsIGNvbW1pdCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuI2Jsb2JzID0gYmxvYnM7XG4gICAgICAgIHRoaXMuI2Jsb2JWZXJzaW9uZWRIYXNoZXMgPSB2ZXJzaW9uZWRIYXNoZXM7XG4gICAgfVxuICAgIGdldCBremcoKSB7IHJldHVybiB0aGlzLiNremc7IH1cbiAgICBzZXQga3pnKGt6Zykge1xuICAgICAgICBpZiAoa3pnID09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuI2t6ZyA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLiNremcgPSBnZXRLemdMaWJyYXJ5KGt6Zyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogIENyZWF0ZXMgYSBuZXcgVHJhbnNhY3Rpb24gd2l0aCBkZWZhdWx0IHZhbHVlcy5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy4jdHlwZSA9IG51bGw7XG4gICAgICAgIHRoaXMuI3RvID0gbnVsbDtcbiAgICAgICAgdGhpcy4jbm9uY2UgPSAwO1xuICAgICAgICB0aGlzLiNnYXNMaW1pdCA9IEJOXzA7XG4gICAgICAgIHRoaXMuI2dhc1ByaWNlID0gbnVsbDtcbiAgICAgICAgdGhpcy4jbWF4UHJpb3JpdHlGZWVQZXJHYXMgPSBudWxsO1xuICAgICAgICB0aGlzLiNtYXhGZWVQZXJHYXMgPSBudWxsO1xuICAgICAgICB0aGlzLiNkYXRhID0gXCIweFwiO1xuICAgICAgICB0aGlzLiN2YWx1ZSA9IEJOXzA7XG4gICAgICAgIHRoaXMuI2NoYWluSWQgPSBCTl8wO1xuICAgICAgICB0aGlzLiNzaWcgPSBudWxsO1xuICAgICAgICB0aGlzLiNhY2Nlc3NMaXN0ID0gbnVsbDtcbiAgICAgICAgdGhpcy4jbWF4RmVlUGVyQmxvYkdhcyA9IG51bGw7XG4gICAgICAgIHRoaXMuI2Jsb2JWZXJzaW9uZWRIYXNoZXMgPSBudWxsO1xuICAgICAgICB0aGlzLiNremcgPSBudWxsO1xuICAgICAgICB0aGlzLiNibG9icyA9IG51bGw7XG4gICAgICAgIHRoaXMuI2F1dGhzID0gbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRoZSB0cmFuc2FjdGlvbiBoYXNoLCBpZiBzaWduZWQuIE90aGVyd2lzZSwgYGBudWxsYGAuXG4gICAgICovXG4gICAgZ2V0IGhhc2goKSB7XG4gICAgICAgIGlmICh0aGlzLnNpZ25hdHVyZSA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ga2VjY2FrMjU2KHRoaXMuI2dldFNlcmlhbGl6ZWQodHJ1ZSwgZmFsc2UpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRoZSBwcmUtaW1hZ2UgaGFzaCBvZiB0aGlzIHRyYW5zYWN0aW9uLlxuICAgICAqXG4gICAgICogIFRoaXMgaXMgdGhlIGRpZ2VzdCB0aGF0IGEgW1tTaWduZXJdXSBtdXN0IHNpZ24gdG8gYXV0aG9yaXplXG4gICAgICogIHRoaXMgdHJhbnNhY3Rpb24uXG4gICAgICovXG4gICAgZ2V0IHVuc2lnbmVkSGFzaCgpIHtcbiAgICAgICAgcmV0dXJuIGtlY2NhazI1Nih0aGlzLnVuc2lnbmVkU2VyaWFsaXplZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgc2VuZGluZyBhZGRyZXNzLCBpZiBzaWduZWQuIE90aGVyd2lzZSwgYGBudWxsYGAuXG4gICAgICovXG4gICAgZ2V0IGZyb20oKSB7XG4gICAgICAgIGlmICh0aGlzLnNpZ25hdHVyZSA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVjb3ZlckFkZHJlc3ModGhpcy51bnNpZ25lZEhhc2gsIHRoaXMuc2lnbmF0dXJlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRoZSBwdWJsaWMga2V5IG9mIHRoZSBzZW5kZXIsIGlmIHNpZ25lZC4gT3RoZXJ3aXNlLCBgYG51bGxgYC5cbiAgICAgKi9cbiAgICBnZXQgZnJvbVB1YmxpY0tleSgpIHtcbiAgICAgICAgaWYgKHRoaXMuc2lnbmF0dXJlID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBTaWduaW5nS2V5LnJlY292ZXJQdWJsaWNLZXkodGhpcy51bnNpZ25lZEhhc2gsIHRoaXMuc2lnbmF0dXJlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdHJ1ZSBpZiBzaWduZWQuXG4gICAgICpcbiAgICAgKiAgVGhpcyBwcm92aWRlcyBhIFR5cGUgR3VhcmQgdGhhdCBwcm9wZXJ0aWVzIHJlcXVpcmluZyBhIHNpZ25lZFxuICAgICAqICB0cmFuc2FjdGlvbiBhcmUgbm9uLW51bGwuXG4gICAgICovXG4gICAgaXNTaWduZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNpZ25hdHVyZSAhPSBudWxsO1xuICAgIH1cbiAgICAjZ2V0U2VyaWFsaXplZChzaWduZWQsIHNpZGVjYXIpIHtcbiAgICAgICAgYXNzZXJ0KCFzaWduZWQgfHwgdGhpcy5zaWduYXR1cmUgIT0gbnVsbCwgXCJjYW5ub3Qgc2VyaWFsaXplIHVuc2lnbmVkIHRyYW5zYWN0aW9uOyBtYXliZSB5b3UgbWVhbnQgLnVuc2lnbmVkU2VyaWFsaXplZFwiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7IG9wZXJhdGlvbjogXCIuc2VyaWFsaXplZFwiIH0pO1xuICAgICAgICBjb25zdCBzaWcgPSBzaWduZWQgPyB0aGlzLnNpZ25hdHVyZSA6IG51bGw7XG4gICAgICAgIHN3aXRjaCAodGhpcy5pbmZlclR5cGUoKSkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIHJldHVybiBfc2VyaWFsaXplTGVnYWN5KHRoaXMsIHNpZyk7XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9zZXJpYWxpemVFaXAyOTMwKHRoaXMsIHNpZyk7XG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9zZXJpYWxpemVFaXAxNTU5KHRoaXMsIHNpZyk7XG4gICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9zZXJpYWxpemVFaXA0ODQ0KHRoaXMsIHNpZywgc2lkZWNhciA/IHRoaXMuYmxvYnMgOiBudWxsKTtcbiAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICByZXR1cm4gX3NlcmlhbGl6ZUVpcDc3MDIodGhpcywgc2lnKTtcbiAgICAgICAgfVxuICAgICAgICBhc3NlcnQoZmFsc2UsIFwidW5zdXBwb3J0ZWQgdHJhbnNhY3Rpb24gdHlwZVwiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7IG9wZXJhdGlvbjogXCIuc2VyaWFsaXplZFwiIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhlIHNlcmlhbGl6ZWQgdHJhbnNhY3Rpb24uXG4gICAgICpcbiAgICAgKiAgVGhpcyB0aHJvd3MgaWYgdGhlIHRyYW5zYWN0aW9uIGlzIHVuc2lnbmVkLiBGb3IgdGhlIHByZS1pbWFnZSxcbiAgICAgKiAgdXNlIFtbdW5zaWduZWRTZXJpYWxpemVkXV0uXG4gICAgICovXG4gICAgZ2V0IHNlcmlhbGl6ZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiNnZXRTZXJpYWxpemVkKHRydWUsIHRydWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhlIHRyYW5zYWN0aW9uIHByZS1pbWFnZS5cbiAgICAgKlxuICAgICAqICBUaGUgaGFzaCBvZiB0aGlzIGlzIHRoZSBkaWdlc3Qgd2hpY2ggbmVlZHMgdG8gYmUgc2lnbmVkIHRvXG4gICAgICogIGF1dGhvcml6ZSB0aGlzIHRyYW5zYWN0aW9uLlxuICAgICAqL1xuICAgIGdldCB1bnNpZ25lZFNlcmlhbGl6ZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiNnZXRTZXJpYWxpemVkKGZhbHNlLCBmYWxzZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gdGhlIG1vc3QgXCJsaWtlbHlcIiB0eXBlOyBjdXJyZW50bHkgdGhlIGhpZ2hlc3RcbiAgICAgKiAgc3VwcG9ydGVkIHRyYW5zYWN0aW9uIHR5cGUuXG4gICAgICovXG4gICAgaW5mZXJUeXBlKCkge1xuICAgICAgICBjb25zdCB0eXBlcyA9IHRoaXMuaW5mZXJUeXBlcygpO1xuICAgICAgICAvLyBQcmVmZXIgTG9uZG9uIChFSVAtMTU1OSkgb3ZlciBDYW5jdW4gKEJMT2IpXG4gICAgICAgIGlmICh0eXBlcy5pbmRleE9mKDIpID49IDApIHtcbiAgICAgICAgICAgIHJldHVybiAyO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJldHVybiB0aGUgaGlnaGVzdCBpbmZlcnJlZCB0eXBlXG4gICAgICAgIHJldHVybiAodHlwZXMucG9wKCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVmFsaWRhdGVzIHRoZSBleHBsaWNpdCBwcm9wZXJ0aWVzIGFuZCByZXR1cm5zIGEgbGlzdCBvZiBjb21wYXRpYmxlXG4gICAgICogIHRyYW5zYWN0aW9uIHR5cGVzLlxuICAgICAqL1xuICAgIGluZmVyVHlwZXMoKSB7XG4gICAgICAgIC8vIENoZWNrcyB0aGF0IHRoZXJlIGFyZSBubyBjb25mbGljdGluZyBwcm9wZXJ0aWVzIHNldFxuICAgICAgICBjb25zdCBoYXNHYXNQcmljZSA9IHRoaXMuZ2FzUHJpY2UgIT0gbnVsbDtcbiAgICAgICAgY29uc3QgaGFzRmVlID0gKHRoaXMubWF4RmVlUGVyR2FzICE9IG51bGwgfHwgdGhpcy5tYXhQcmlvcml0eUZlZVBlckdhcyAhPSBudWxsKTtcbiAgICAgICAgY29uc3QgaGFzQWNjZXNzTGlzdCA9ICh0aGlzLmFjY2Vzc0xpc3QgIT0gbnVsbCk7XG4gICAgICAgIGNvbnN0IGhhc0Jsb2IgPSAodGhpcy4jbWF4RmVlUGVyQmxvYkdhcyAhPSBudWxsIHx8IHRoaXMuI2Jsb2JWZXJzaW9uZWRIYXNoZXMpO1xuICAgICAgICAvL2lmIChoYXNHYXNQcmljZSAmJiBoYXNGZWUpIHtcbiAgICAgICAgLy8gICAgdGhyb3cgbmV3IEVycm9yKFwidHJhbnNhY3Rpb24gY2Fubm90IGhhdmUgZ2FzUHJpY2UgYW5kIG1heEZlZVBlckdhc1wiKTtcbiAgICAgICAgLy99XG4gICAgICAgIGlmICh0aGlzLm1heEZlZVBlckdhcyAhPSBudWxsICYmIHRoaXMubWF4UHJpb3JpdHlGZWVQZXJHYXMgIT0gbnVsbCkge1xuICAgICAgICAgICAgYXNzZXJ0KHRoaXMubWF4RmVlUGVyR2FzID49IHRoaXMubWF4UHJpb3JpdHlGZWVQZXJHYXMsIFwicHJpb3JpdHlGZWUgY2Fubm90IGJlIG1vcmUgdGhhbiBtYXhGZWVcIiwgXCJCQURfREFUQVwiLCB7IHZhbHVlOiB0aGlzIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vaWYgKHRoaXMudHlwZSA9PT0gMiAmJiBoYXNHYXNQcmljZSkge1xuICAgICAgICAvLyAgICB0aHJvdyBuZXcgRXJyb3IoXCJlaXAtMTU1OSB0cmFuc2FjdGlvbiBjYW5ub3QgaGF2ZSBnYXNQcmljZVwiKTtcbiAgICAgICAgLy99XG4gICAgICAgIGFzc2VydCghaGFzRmVlIHx8ICh0aGlzLnR5cGUgIT09IDAgJiYgdGhpcy50eXBlICE9PSAxKSwgXCJ0cmFuc2FjdGlvbiB0eXBlIGNhbm5vdCBoYXZlIG1heEZlZVBlckdhcyBvciBtYXhQcmlvcml0eUZlZVBlckdhc1wiLCBcIkJBRF9EQVRBXCIsIHsgdmFsdWU6IHRoaXMgfSk7XG4gICAgICAgIGFzc2VydCh0aGlzLnR5cGUgIT09IDAgfHwgIWhhc0FjY2Vzc0xpc3QsIFwibGVnYWN5IHRyYW5zYWN0aW9uIGNhbm5vdCBoYXZlIGFjY2Vzc0xpc3RcIiwgXCJCQURfREFUQVwiLCB7IHZhbHVlOiB0aGlzIH0pO1xuICAgICAgICBjb25zdCB0eXBlcyA9IFtdO1xuICAgICAgICAvLyBFeHBsaWNpdCB0eXBlXG4gICAgICAgIGlmICh0aGlzLnR5cGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgdHlwZXMucHVzaCh0aGlzLnR5cGUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHRoaXMuYXV0aG9yaXphdGlvbkxpc3QgJiYgdGhpcy5hdXRob3JpemF0aW9uTGlzdC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0eXBlcy5wdXNoKDQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaGFzRmVlKSB7XG4gICAgICAgICAgICAgICAgdHlwZXMucHVzaCgyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGhhc0dhc1ByaWNlKSB7XG4gICAgICAgICAgICAgICAgdHlwZXMucHVzaCgxKTtcbiAgICAgICAgICAgICAgICBpZiAoIWhhc0FjY2Vzc0xpc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZXMucHVzaCgwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChoYXNBY2Nlc3NMaXN0KSB7XG4gICAgICAgICAgICAgICAgdHlwZXMucHVzaCgxKTtcbiAgICAgICAgICAgICAgICB0eXBlcy5wdXNoKDIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaGFzQmxvYiAmJiB0aGlzLnRvKSB7XG4gICAgICAgICAgICAgICAgdHlwZXMucHVzaCgzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHR5cGVzLnB1c2goMCk7XG4gICAgICAgICAgICAgICAgdHlwZXMucHVzaCgxKTtcbiAgICAgICAgICAgICAgICB0eXBlcy5wdXNoKDIpO1xuICAgICAgICAgICAgICAgIHR5cGVzLnB1c2goMyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdHlwZXMuc29ydCgpO1xuICAgICAgICByZXR1cm4gdHlwZXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRydWUgaWYgdGhpcyB0cmFuc2FjdGlvbiBpcyBhIGxlZ2FjeSB0cmFuc2FjdGlvbiAoaS5lLlxuICAgICAqICBgYHR5cGUgPT09IDBgYCkuXG4gICAgICpcbiAgICAgKiAgVGhpcyBwcm92aWRlcyBhIFR5cGUgR3VhcmQgdGhhdCB0aGUgcmVsYXRlZCBwcm9wZXJ0aWVzIGFyZVxuICAgICAqICBub24tbnVsbC5cbiAgICAgKi9cbiAgICBpc0xlZ2FjeSgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLnR5cGUgPT09IDApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0cnVlIGlmIHRoaXMgdHJhbnNhY3Rpb24gaXMgYmVybGluIGhhcmRmb3JtIHRyYW5zYWN0aW9uIChpLmUuXG4gICAgICogIGBgdHlwZSA9PT0gMWBgKS5cbiAgICAgKlxuICAgICAqICBUaGlzIHByb3ZpZGVzIGEgVHlwZSBHdWFyZCB0aGF0IHRoZSByZWxhdGVkIHByb3BlcnRpZXMgYXJlXG4gICAgICogIG5vbi1udWxsLlxuICAgICAqL1xuICAgIGlzQmVybGluKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMudHlwZSA9PT0gMSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRydWUgaWYgdGhpcyB0cmFuc2FjdGlvbiBpcyBsb25kb24gaGFyZGZvcm0gdHJhbnNhY3Rpb24gKGkuZS5cbiAgICAgKiAgYGB0eXBlID09PSAyYGApLlxuICAgICAqXG4gICAgICogIFRoaXMgcHJvdmlkZXMgYSBUeXBlIEd1YXJkIHRoYXQgdGhlIHJlbGF0ZWQgcHJvcGVydGllcyBhcmVcbiAgICAgKiAgbm9uLW51bGwuXG4gICAgICovXG4gICAgaXNMb25kb24oKSB7XG4gICAgICAgIHJldHVybiAodGhpcy50eXBlID09PSAyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdHJ1ZSBpZiB0aGlzIHRyYW5zYWN0aW9uIGlzIGFuIFtbbGluay1laXAtNDg0NF1dIEJMT0JcbiAgICAgKiAgdHJhbnNhY3Rpb24uXG4gICAgICpcbiAgICAgKiAgVGhpcyBwcm92aWRlcyBhIFR5cGUgR3VhcmQgdGhhdCB0aGUgcmVsYXRlZCBwcm9wZXJ0aWVzIGFyZVxuICAgICAqICBub24tbnVsbC5cbiAgICAgKi9cbiAgICBpc0NhbmN1bigpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLnR5cGUgPT09IDMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlIGEgY29weSBvZiB0aGlzIHRyYW5zYWNpdG9uLlxuICAgICAqL1xuICAgIGNsb25lKCkge1xuICAgICAgICByZXR1cm4gVHJhbnNhY3Rpb24uZnJvbSh0aGlzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIEpTT04tZnJpZW5kbHkgb2JqZWN0LlxuICAgICAqL1xuICAgIHRvSlNPTigpIHtcbiAgICAgICAgY29uc3QgcyA9ICh2KSA9PiB7XG4gICAgICAgICAgICBpZiAodiA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdi50b1N0cmluZygpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogdGhpcy50eXBlLFxuICAgICAgICAgICAgdG86IHRoaXMudG8sXG4gICAgICAgICAgICAvLyAgICAgICAgICAgIGZyb206IHRoaXMuZnJvbSxcbiAgICAgICAgICAgIGRhdGE6IHRoaXMuZGF0YSxcbiAgICAgICAgICAgIG5vbmNlOiB0aGlzLm5vbmNlLFxuICAgICAgICAgICAgZ2FzTGltaXQ6IHModGhpcy5nYXNMaW1pdCksXG4gICAgICAgICAgICBnYXNQcmljZTogcyh0aGlzLmdhc1ByaWNlKSxcbiAgICAgICAgICAgIG1heFByaW9yaXR5RmVlUGVyR2FzOiBzKHRoaXMubWF4UHJpb3JpdHlGZWVQZXJHYXMpLFxuICAgICAgICAgICAgbWF4RmVlUGVyR2FzOiBzKHRoaXMubWF4RmVlUGVyR2FzKSxcbiAgICAgICAgICAgIHZhbHVlOiBzKHRoaXMudmFsdWUpLFxuICAgICAgICAgICAgY2hhaW5JZDogcyh0aGlzLmNoYWluSWQpLFxuICAgICAgICAgICAgc2lnOiB0aGlzLnNpZ25hdHVyZSA/IHRoaXMuc2lnbmF0dXJlLnRvSlNPTigpIDogbnVsbCxcbiAgICAgICAgICAgIGFjY2Vzc0xpc3Q6IHRoaXMuYWNjZXNzTGlzdFxuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlIGEgKipUcmFuc2FjdGlvbioqIGZyb20gYSBzZXJpYWxpemVkIHRyYW5zYWN0aW9uIG9yIGFcbiAgICAgKiAgVHJhbnNhY3Rpb24tbGlrZSBvYmplY3QuXG4gICAgICovXG4gICAgc3RhdGljIGZyb20odHgpIHtcbiAgICAgICAgaWYgKHR4ID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgVHJhbnNhY3Rpb24oKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mICh0eCkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IHBheWxvYWQgPSBnZXRCeXRlcyh0eCk7XG4gICAgICAgICAgICBpZiAocGF5bG9hZFswXSA+PSAweDdmKSB7IC8vIEBUT0RPOiA+IHZzID49ID8/XG4gICAgICAgICAgICAgICAgcmV0dXJuIFRyYW5zYWN0aW9uLmZyb20oX3BhcnNlTGVnYWN5KHBheWxvYWQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN3aXRjaCAocGF5bG9hZFswXSkge1xuICAgICAgICAgICAgICAgIGNhc2UgMTogcmV0dXJuIFRyYW5zYWN0aW9uLmZyb20oX3BhcnNlRWlwMjkzMChwYXlsb2FkKSk7XG4gICAgICAgICAgICAgICAgY2FzZSAyOiByZXR1cm4gVHJhbnNhY3Rpb24uZnJvbShfcGFyc2VFaXAxNTU5KHBheWxvYWQpKTtcbiAgICAgICAgICAgICAgICBjYXNlIDM6IHJldHVybiBUcmFuc2FjdGlvbi5mcm9tKF9wYXJzZUVpcDQ4NDQocGF5bG9hZCkpO1xuICAgICAgICAgICAgICAgIGNhc2UgNDogcmV0dXJuIFRyYW5zYWN0aW9uLmZyb20oX3BhcnNlRWlwNzcwMihwYXlsb2FkKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhc3NlcnQoZmFsc2UsIFwidW5zdXBwb3J0ZWQgdHJhbnNhY3Rpb24gdHlwZVwiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7IG9wZXJhdGlvbjogXCJmcm9tXCIgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gbmV3IFRyYW5zYWN0aW9uKCk7XG4gICAgICAgIGlmICh0eC50eXBlICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJlc3VsdC50eXBlID0gdHgudHlwZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHgudG8gIT0gbnVsbCkge1xuICAgICAgICAgICAgcmVzdWx0LnRvID0gdHgudG87XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR4Lm5vbmNlICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJlc3VsdC5ub25jZSA9IHR4Lm5vbmNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eC5nYXNMaW1pdCAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXN1bHQuZ2FzTGltaXQgPSB0eC5nYXNMaW1pdDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHguZ2FzUHJpY2UgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmVzdWx0Lmdhc1ByaWNlID0gdHguZ2FzUHJpY2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR4Lm1heFByaW9yaXR5RmVlUGVyR2FzICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJlc3VsdC5tYXhQcmlvcml0eUZlZVBlckdhcyA9IHR4Lm1heFByaW9yaXR5RmVlUGVyR2FzO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eC5tYXhGZWVQZXJHYXMgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmVzdWx0Lm1heEZlZVBlckdhcyA9IHR4Lm1heEZlZVBlckdhcztcbiAgICAgICAgfVxuICAgICAgICBpZiAodHgubWF4RmVlUGVyQmxvYkdhcyAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXN1bHQubWF4RmVlUGVyQmxvYkdhcyA9IHR4Lm1heEZlZVBlckJsb2JHYXM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR4LmRhdGEgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmVzdWx0LmRhdGEgPSB0eC5kYXRhO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eC52YWx1ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXN1bHQudmFsdWUgPSB0eC52YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHguY2hhaW5JZCAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXN1bHQuY2hhaW5JZCA9IHR4LmNoYWluSWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR4LnNpZ25hdHVyZSAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXN1bHQuc2lnbmF0dXJlID0gU2lnbmF0dXJlLmZyb20odHguc2lnbmF0dXJlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHguYWNjZXNzTGlzdCAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXN1bHQuYWNjZXNzTGlzdCA9IHR4LmFjY2Vzc0xpc3Q7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR4LmF1dGhvcml6YXRpb25MaXN0ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJlc3VsdC5hdXRob3JpemF0aW9uTGlzdCA9IHR4LmF1dGhvcml6YXRpb25MaXN0O1xuICAgICAgICB9XG4gICAgICAgIC8vIFRoaXMgd2lsbCBnZXQgb3ZlcndyaXR0ZW4gYnkgYmxvYnMsIGlmIHByZXNlbnRcbiAgICAgICAgaWYgKHR4LmJsb2JWZXJzaW9uZWRIYXNoZXMgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmVzdWx0LmJsb2JWZXJzaW9uZWRIYXNoZXMgPSB0eC5ibG9iVmVyc2lvbmVkSGFzaGVzO1xuICAgICAgICB9XG4gICAgICAgIC8vIE1ha2Ugc3VyZSB3ZSBhc3NpZ24gdGhlIGt6ZyBiZWZvcmUgYXNzaWduaW5nIGJsb2JzLCB3aGljaFxuICAgICAgICAvLyByZXF1aXJlIHRoZSBsaWJyYXJ5IGluIHRoZSBldmVudCByYXcgYmxvYiBkYXRhIGlzIHByb3ZpZGVkLlxuICAgICAgICBpZiAodHgua3pnICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJlc3VsdC5remcgPSB0eC5remc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR4LmJsb2JzICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJlc3VsdC5ibG9icyA9IHR4LmJsb2JzO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eC5oYXNoICE9IG51bGwpIHtcbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KHJlc3VsdC5pc1NpZ25lZCgpLCBcInVuc2lnbmVkIHRyYW5zYWN0aW9uIGNhbm5vdCBkZWZpbmUgJy5oYXNoJ1wiLCBcInR4XCIsIHR4KTtcbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KHJlc3VsdC5oYXNoID09PSB0eC5oYXNoLCBcImhhc2ggbWlzbWF0Y2hcIiwgXCJ0eFwiLCB0eCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR4LmZyb20gIT0gbnVsbCkge1xuICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQocmVzdWx0LmlzU2lnbmVkKCksIFwidW5zaWduZWQgdHJhbnNhY3Rpb24gY2Fubm90IGRlZmluZSAnLmZyb20nXCIsIFwidHhcIiwgdHgpO1xuICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQocmVzdWx0LmZyb20udG9Mb3dlckNhc2UoKSA9PT0gKHR4LmZyb20gfHwgXCJcIikudG9Mb3dlckNhc2UoKSwgXCJmcm9tIG1pc21hdGNoXCIsIFwidHhcIiwgdHgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dHJhbnNhY3Rpb24uanMubWFwIl0sIm5hbWVzIjpbImdldEFkZHJlc3MiLCJaZXJvQWRkcmVzcyIsImtlY2NhazI1NiIsInNoYTI1NiIsIlNpZ25hdHVyZSIsIlNpZ25pbmdLZXkiLCJjb25jYXQiLCJkZWNvZGVSbHAiLCJlbmNvZGVSbHAiLCJnZXRCeXRlcyIsImdldEJpZ0ludCIsImdldE51bWJlciIsImhleGxpZnkiLCJhc3NlcnQiLCJhc3NlcnRBcmd1bWVudCIsImlzQnl0ZXNMaWtlIiwiaXNIZXhTdHJpbmciLCJ0b0JlQXJyYXkiLCJ6ZXJvUGFkVmFsdWUiLCJhY2Nlc3NMaXN0aWZ5IiwiYXV0aG9yaXphdGlvbmlmeSIsInJlY292ZXJBZGRyZXNzIiwiQk5fMCIsIkJpZ0ludCIsIkJOXzIiLCJCTl8yNyIsIkJOXzI4IiwiQk5fMzUiLCJCTl9NQVhfVUlOVCIsIkJMT0JfU0laRSIsImdldEt6Z0xpYnJhcnkiLCJremciLCJibG9iVG9LemdDb21taXRtZW50IiwiYmxvYiIsImJsb2JUb0taR0NvbW1pdG1lbnQiLCJjb21wdXRlQmxvYkt6Z1Byb29mIiwiY29tbWl0bWVudCIsImNvbXB1dGVCbG9iUHJvb2YiLCJjb21wdXRlQmxvYktaR1Byb29mIiwiZ2V0VmVyc2lvbmVkSGFzaCIsInZlcnNpb24iLCJoYXNoIiwidmVyc2lvbmVkIiwidG9TdHJpbmciLCJsZW5ndGgiLCJzdWJzdHJpbmciLCJoYW5kbGVBZGRyZXNzIiwidmFsdWUiLCJoYW5kbGVBY2Nlc3NMaXN0IiwicGFyYW0iLCJlcnJvciIsIm1lc3NhZ2UiLCJoYW5kbGVBdXRob3JpemF0aW9uTGlzdCIsIkFycmF5IiwiaXNBcnJheSIsIkVycm9yIiwicmVzdWx0IiwiaSIsImF1dGgiLCJwdXNoIiwiYWRkcmVzcyIsIm5vbmNlIiwiaGFuZGxlVWludCIsImNoYWluSWQiLCJzaWduYXR1cmUiLCJmcm9tIiwieVBhcml0eSIsImhhbmRsZU51bWJlciIsInIiLCJzIiwiX3ZhbHVlIiwiZm9ybWF0TnVtYmVyIiwibmFtZSIsImZvcm1hdEFjY2Vzc0xpc3QiLCJtYXAiLCJzZXQiLCJzdG9yYWdlS2V5cyIsImZvcm1hdEF1dGhvcml6YXRpb25MaXN0IiwiYSIsImZvcm1hdEhhc2hlcyIsIl9wYXJzZUxlZ2FjeSIsImRhdGEiLCJmaWVsZHMiLCJ0eCIsInR5cGUiLCJnYXNQcmljZSIsImdhc0xpbWl0IiwidG8iLCJ2IiwiX3NlcmlhbGl6ZUxlZ2FjeSIsInNpZyIsIm5ldHdvcmtWIiwibGVnYWN5Q2hhaW5JZCIsImxlZ2FjeSIsImdldENoYWluSWRWIiwiX3BhcnNlRWlwU2lnbmF0dXJlIiwiX3BhcnNlRWlwMTU1OSIsInNsaWNlIiwibWF4UHJpb3JpdHlGZWVQZXJHYXMiLCJtYXhGZWVQZXJHYXMiLCJhY2Nlc3NMaXN0IiwiX3NlcmlhbGl6ZUVpcDE1NTkiLCJfcGFyc2VFaXAyOTMwIiwiX3NlcmlhbGl6ZUVpcDI5MzAiLCJfcGFyc2VFaXA0ODQ0IiwidHlwZU5hbWUiLCJibG9icyIsImZCbG9icyIsImZDb21taXRzIiwiZlByb29mcyIsInByb29mIiwibWF4RmVlUGVyQmxvYkdhcyIsImJsb2JWZXJzaW9uZWRIYXNoZXMiLCJfc2VyaWFsaXplRWlwNDg0NCIsImIiLCJfcGFyc2VFaXA3NzAyIiwiYXV0aG9yaXphdGlvbkxpc3QiLCJfc2VyaWFsaXplRWlwNzcwMiIsIlRyYW5zYWN0aW9uIiwiYXV0aHMiLCJPYmplY3QiLCJhc3NpZ24iLCJfYmxvYnMiLCJ2ZXJzaW9uZWRIYXNoZXMiLCJvcGVyYXRpb24iLCJwYWRkZWQiLCJVaW50OEFycmF5IiwiY29tbWl0IiwiY29uc3RydWN0b3IiLCJnZXRTZXJpYWxpemVkIiwidW5zaWduZWRIYXNoIiwidW5zaWduZWRTZXJpYWxpemVkIiwiZnJvbVB1YmxpY0tleSIsInJlY292ZXJQdWJsaWNLZXkiLCJpc1NpZ25lZCIsInNpZ25lZCIsInNpZGVjYXIiLCJpbmZlclR5cGUiLCJzZXJpYWxpemVkIiwidHlwZXMiLCJpbmZlclR5cGVzIiwiaW5kZXhPZiIsInBvcCIsImhhc0dhc1ByaWNlIiwiaGFzRmVlIiwiaGFzQWNjZXNzTGlzdCIsImhhc0Jsb2IiLCJzb3J0IiwiaXNMZWdhY3kiLCJpc0JlcmxpbiIsImlzTG9uZG9uIiwiaXNDYW5jdW4iLCJjbG9uZSIsInRvSlNPTiIsInBheWxvYWQiLCJ0b0xvd2VyQ2FzZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.esm/transaction/transaction.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.esm/utils/base58.js":
/*!*****************************************************!*\
  !*** ./node_modules/ethers/lib.esm/utils/base58.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   decodeBase58: () => (/* binding */ decodeBase58),\n/* harmony export */   encodeBase58: () => (/* binding */ encodeBase58)\n/* harmony export */ });\n/* harmony import */ var _data_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./data.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/data.js\");\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./errors.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/errors.js\");\n/* harmony import */ var _maths_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./maths.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/maths.js\");\n/**\n *  The [Base58 Encoding](link-base58) scheme allows a **numeric** value\n *  to be encoded as a compact string using a radix of 58 using only\n *  alpha-numeric characters. Confusingly similar characters are omitted\n *  (i.e. ``\"l0O\"``).\n *\n *  Note that Base58 encodes a **numeric** value, not arbitrary bytes,\n *  since any zero-bytes on the left would get removed. To mitigate this\n *  issue most schemes that use Base58 choose specific high-order values\n *  to ensure non-zero prefixes.\n *\n *  @_subsection: api/utils:Base58 Encoding [about-base58]\n */ \n\n\nconst Alphabet = \"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\";\nlet Lookup = null;\nfunction getAlpha(letter) {\n    if (Lookup == null) {\n        Lookup = {};\n        for(let i = 0; i < Alphabet.length; i++){\n            Lookup[Alphabet[i]] = BigInt(i);\n        }\n    }\n    const result = Lookup[letter];\n    (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(result != null, `invalid base58 value`, \"letter\", letter);\n    return result;\n}\nconst BN_0 = BigInt(0);\nconst BN_58 = BigInt(58);\n/**\n *  Encode %%value%% as a Base58-encoded string.\n */ function encodeBase58(_value) {\n    const bytes = (0,_data_js__WEBPACK_IMPORTED_MODULE_1__.getBytes)(_value);\n    let value = (0,_maths_js__WEBPACK_IMPORTED_MODULE_2__.toBigInt)(bytes);\n    let result = \"\";\n    while(value){\n        result = Alphabet[Number(value % BN_58)] + result;\n        value /= BN_58;\n    }\n    // Account for leading padding zeros\n    for(let i = 0; i < bytes.length; i++){\n        if (bytes[i]) {\n            break;\n        }\n        result = Alphabet[0] + result;\n    }\n    return result;\n}\n/**\n *  Decode the Base58-encoded %%value%%.\n */ function decodeBase58(value) {\n    let result = BN_0;\n    for(let i = 0; i < value.length; i++){\n        result *= BN_58;\n        result += getAlpha(value[i]);\n    }\n    return result;\n} //# sourceMappingURL=base58.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vdXRpbHMvYmFzZTU4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUE7Ozs7Ozs7Ozs7OztDQVlDLEdBQ29DO0FBQ1E7QUFDUDtBQUN0QyxNQUFNRyxXQUFXO0FBQ2pCLElBQUlDLFNBQVM7QUFDYixTQUFTQyxTQUFTQyxNQUFNO0lBQ3BCLElBQUlGLFVBQVUsTUFBTTtRQUNoQkEsU0FBUyxDQUFDO1FBQ1YsSUFBSyxJQUFJRyxJQUFJLEdBQUdBLElBQUlKLFNBQVNLLE1BQU0sRUFBRUQsSUFBSztZQUN0Q0gsTUFBTSxDQUFDRCxRQUFRLENBQUNJLEVBQUUsQ0FBQyxHQUFHRSxPQUFPRjtRQUNqQztJQUNKO0lBQ0EsTUFBTUcsU0FBU04sTUFBTSxDQUFDRSxPQUFPO0lBQzdCTCwwREFBY0EsQ0FBQ1MsVUFBVSxNQUFNLENBQUMsb0JBQW9CLENBQUMsRUFBRSxVQUFVSjtJQUNqRSxPQUFPSTtBQUNYO0FBQ0EsTUFBTUMsT0FBT0YsT0FBTztBQUNwQixNQUFNRyxRQUFRSCxPQUFPO0FBQ3JCOztDQUVDLEdBQ00sU0FBU0ksYUFBYUMsTUFBTTtJQUMvQixNQUFNQyxRQUFRZixrREFBUUEsQ0FBQ2M7SUFDdkIsSUFBSUUsUUFBUWQsbURBQVFBLENBQUNhO0lBQ3JCLElBQUlMLFNBQVM7SUFDYixNQUFPTSxNQUFPO1FBQ1ZOLFNBQVNQLFFBQVEsQ0FBQ2MsT0FBT0QsUUFBUUosT0FBTyxHQUFHRjtRQUMzQ00sU0FBU0o7SUFDYjtJQUNBLG9DQUFvQztJQUNwQyxJQUFLLElBQUlMLElBQUksR0FBR0EsSUFBSVEsTUFBTVAsTUFBTSxFQUFFRCxJQUFLO1FBQ25DLElBQUlRLEtBQUssQ0FBQ1IsRUFBRSxFQUFFO1lBQ1Y7UUFDSjtRQUNBRyxTQUFTUCxRQUFRLENBQUMsRUFBRSxHQUFHTztJQUMzQjtJQUNBLE9BQU9BO0FBQ1g7QUFDQTs7Q0FFQyxHQUNNLFNBQVNRLGFBQWFGLEtBQUs7SUFDOUIsSUFBSU4sU0FBU0M7SUFDYixJQUFLLElBQUlKLElBQUksR0FBR0EsSUFBSVMsTUFBTVIsTUFBTSxFQUFFRCxJQUFLO1FBQ25DRyxVQUFVRTtRQUNWRixVQUFVTCxTQUFTVyxLQUFLLENBQUNULEVBQUU7SUFDL0I7SUFDQSxPQUFPRztBQUNYLEVBQ0Esa0NBQWtDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbWVnYXZpYmUtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vdXRpbHMvYmFzZTU4LmpzP2M0ZDIiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiAgVGhlIFtCYXNlNTggRW5jb2RpbmddKGxpbmstYmFzZTU4KSBzY2hlbWUgYWxsb3dzIGEgKipudW1lcmljKiogdmFsdWVcbiAqICB0byBiZSBlbmNvZGVkIGFzIGEgY29tcGFjdCBzdHJpbmcgdXNpbmcgYSByYWRpeCBvZiA1OCB1c2luZyBvbmx5XG4gKiAgYWxwaGEtbnVtZXJpYyBjaGFyYWN0ZXJzLiBDb25mdXNpbmdseSBzaW1pbGFyIGNoYXJhY3RlcnMgYXJlIG9taXR0ZWRcbiAqICAoaS5lLiBgYFwibDBPXCJgYCkuXG4gKlxuICogIE5vdGUgdGhhdCBCYXNlNTggZW5jb2RlcyBhICoqbnVtZXJpYyoqIHZhbHVlLCBub3QgYXJiaXRyYXJ5IGJ5dGVzLFxuICogIHNpbmNlIGFueSB6ZXJvLWJ5dGVzIG9uIHRoZSBsZWZ0IHdvdWxkIGdldCByZW1vdmVkLiBUbyBtaXRpZ2F0ZSB0aGlzXG4gKiAgaXNzdWUgbW9zdCBzY2hlbWVzIHRoYXQgdXNlIEJhc2U1OCBjaG9vc2Ugc3BlY2lmaWMgaGlnaC1vcmRlciB2YWx1ZXNcbiAqICB0byBlbnN1cmUgbm9uLXplcm8gcHJlZml4ZXMuXG4gKlxuICogIEBfc3Vic2VjdGlvbjogYXBpL3V0aWxzOkJhc2U1OCBFbmNvZGluZyBbYWJvdXQtYmFzZTU4XVxuICovXG5pbXBvcnQgeyBnZXRCeXRlcyB9IGZyb20gXCIuL2RhdGEuanNcIjtcbmltcG9ydCB7IGFzc2VydEFyZ3VtZW50IH0gZnJvbSBcIi4vZXJyb3JzLmpzXCI7XG5pbXBvcnQgeyB0b0JpZ0ludCB9IGZyb20gXCIuL21hdGhzLmpzXCI7XG5jb25zdCBBbHBoYWJldCA9IFwiMTIzNDU2Nzg5QUJDREVGR0hKS0xNTlBRUlNUVVZXWFlaYWJjZGVmZ2hpamttbm9wcXJzdHV2d3h5elwiO1xubGV0IExvb2t1cCA9IG51bGw7XG5mdW5jdGlvbiBnZXRBbHBoYShsZXR0ZXIpIHtcbiAgICBpZiAoTG9va3VwID09IG51bGwpIHtcbiAgICAgICAgTG9va3VwID0ge307XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgQWxwaGFiZXQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIExvb2t1cFtBbHBoYWJldFtpXV0gPSBCaWdJbnQoaSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgcmVzdWx0ID0gTG9va3VwW2xldHRlcl07XG4gICAgYXNzZXJ0QXJndW1lbnQocmVzdWx0ICE9IG51bGwsIGBpbnZhbGlkIGJhc2U1OCB2YWx1ZWAsIFwibGV0dGVyXCIsIGxldHRlcik7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmNvbnN0IEJOXzAgPSBCaWdJbnQoMCk7XG5jb25zdCBCTl81OCA9IEJpZ0ludCg1OCk7XG4vKipcbiAqICBFbmNvZGUgJSV2YWx1ZSUlIGFzIGEgQmFzZTU4LWVuY29kZWQgc3RyaW5nLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZW5jb2RlQmFzZTU4KF92YWx1ZSkge1xuICAgIGNvbnN0IGJ5dGVzID0gZ2V0Qnl0ZXMoX3ZhbHVlKTtcbiAgICBsZXQgdmFsdWUgPSB0b0JpZ0ludChieXRlcyk7XG4gICAgbGV0IHJlc3VsdCA9IFwiXCI7XG4gICAgd2hpbGUgKHZhbHVlKSB7XG4gICAgICAgIHJlc3VsdCA9IEFscGhhYmV0W051bWJlcih2YWx1ZSAlIEJOXzU4KV0gKyByZXN1bHQ7XG4gICAgICAgIHZhbHVlIC89IEJOXzU4O1xuICAgIH1cbiAgICAvLyBBY2NvdW50IGZvciBsZWFkaW5nIHBhZGRpbmcgemVyb3NcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChieXRlc1tpXSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0ID0gQWxwaGFiZXRbMF0gKyByZXN1bHQ7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG4vKipcbiAqICBEZWNvZGUgdGhlIEJhc2U1OC1lbmNvZGVkICUldmFsdWUlJS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlY29kZUJhc2U1OCh2YWx1ZSkge1xuICAgIGxldCByZXN1bHQgPSBCTl8wO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcmVzdWx0ICo9IEJOXzU4O1xuICAgICAgICByZXN1bHQgKz0gZ2V0QWxwaGEodmFsdWVbaV0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YmFzZTU4LmpzLm1hcCJdLCJuYW1lcyI6WyJnZXRCeXRlcyIsImFzc2VydEFyZ3VtZW50IiwidG9CaWdJbnQiLCJBbHBoYWJldCIsIkxvb2t1cCIsImdldEFscGhhIiwibGV0dGVyIiwiaSIsImxlbmd0aCIsIkJpZ0ludCIsInJlc3VsdCIsIkJOXzAiLCJCTl81OCIsImVuY29kZUJhc2U1OCIsIl92YWx1ZSIsImJ5dGVzIiwidmFsdWUiLCJOdW1iZXIiLCJkZWNvZGVCYXNlNTgiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.esm/utils/base58.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.esm/utils/base64.js":
/*!*****************************************************!*\
  !*** ./node_modules/ethers/lib.esm/utils/base64.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   decodeBase64: () => (/* binding */ decodeBase64),\n/* harmony export */   encodeBase64: () => (/* binding */ encodeBase64)\n/* harmony export */ });\n/* harmony import */ var _data_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./data.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/data.js\");\n/**\n *  [Base64 encoding](link-wiki-base64) using 6-bit words to encode\n *  arbitrary bytes into a string using 65 printable symbols, the\n *  upper-case and lower-case alphabet, the digits ``0`` through ``9``,\n *  ``\"+\"`` and ``\"/\"`` with the ``\"=\"`` used for padding.\n *\n *  @_subsection: api/utils:Base64 Encoding  [about-base64]\n */ \n/**\n *  Decodes the base-64 encoded %%value%%.\n *\n *  @example:\n *    // The decoded value is always binary data...\n *    result = decodeBase64(\"SGVsbG8gV29ybGQhIQ==\")\n *    //_result:\n *\n *    // ...use toUtf8String to convert it to a string.\n *    toUtf8String(result)\n *    //_result:\n *\n *    // Decoding binary data\n *    decodeBase64(\"EjQ=\")\n *    //_result:\n */ function decodeBase64(value) {\n    return (0,_data_js__WEBPACK_IMPORTED_MODULE_0__.getBytesCopy)(Buffer.from(value, \"base64\"));\n}\n;\n/**\n *  Encodes %%data%% as a base-64 encoded string.\n *\n *  @example:\n *    // Encoding binary data as a hexstring\n *    encodeBase64(\"0x1234\")\n *    //_result:\n *\n *    // Encoding binary data as a Uint8Array\n *    encodeBase64(new Uint8Array([ 0x12, 0x34 ]))\n *    //_result:\n *\n *    // The input MUST be data...\n *    encodeBase64(\"Hello World!!\")\n *    //_error:\n *\n *    // ...use toUtf8Bytes for this.\n *    encodeBase64(toUtf8Bytes(\"Hello World!!\"))\n *    //_result:\n */ function encodeBase64(data) {\n    return Buffer.from((0,_data_js__WEBPACK_IMPORTED_MODULE_0__.getBytes)(data)).toString(\"base64\");\n} //# sourceMappingURL=base64.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vdXRpbHMvYmFzZTY0LmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBOzs7Ozs7O0NBT0MsR0FDa0Q7QUFDbkQ7Ozs7Ozs7Ozs7Ozs7OztDQWVDLEdBQ00sU0FBU0UsYUFBYUMsS0FBSztJQUM5QixPQUFPRixzREFBWUEsQ0FBQ0csT0FBT0MsSUFBSSxDQUFDRixPQUFPO0FBQzNDOztBQUVBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBbUJDLEdBQ00sU0FBU0csYUFBYUMsSUFBSTtJQUM3QixPQUFPSCxPQUFPQyxJQUFJLENBQUNMLGtEQUFRQSxDQUFDTyxPQUFPQyxRQUFRLENBQUM7QUFDaEQsRUFDQSxrQ0FBa0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tZWdhdmliZS1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS91dGlscy9iYXNlNjQuanM/MDAwYSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqICBbQmFzZTY0IGVuY29kaW5nXShsaW5rLXdpa2ktYmFzZTY0KSB1c2luZyA2LWJpdCB3b3JkcyB0byBlbmNvZGVcbiAqICBhcmJpdHJhcnkgYnl0ZXMgaW50byBhIHN0cmluZyB1c2luZyA2NSBwcmludGFibGUgc3ltYm9scywgdGhlXG4gKiAgdXBwZXItY2FzZSBhbmQgbG93ZXItY2FzZSBhbHBoYWJldCwgdGhlIGRpZ2l0cyBgYDBgYCB0aHJvdWdoIGBgOWBgLFxuICogIGBgXCIrXCJgYCBhbmQgYGBcIi9cImBgIHdpdGggdGhlIGBgXCI9XCJgYCB1c2VkIGZvciBwYWRkaW5nLlxuICpcbiAqICBAX3N1YnNlY3Rpb246IGFwaS91dGlsczpCYXNlNjQgRW5jb2RpbmcgIFthYm91dC1iYXNlNjRdXG4gKi9cbmltcG9ydCB7IGdldEJ5dGVzLCBnZXRCeXRlc0NvcHkgfSBmcm9tIFwiLi9kYXRhLmpzXCI7XG4vKipcbiAqICBEZWNvZGVzIHRoZSBiYXNlLTY0IGVuY29kZWQgJSV2YWx1ZSUlLlxuICpcbiAqICBAZXhhbXBsZTpcbiAqICAgIC8vIFRoZSBkZWNvZGVkIHZhbHVlIGlzIGFsd2F5cyBiaW5hcnkgZGF0YS4uLlxuICogICAgcmVzdWx0ID0gZGVjb2RlQmFzZTY0KFwiU0dWc2JHOGdWMjl5YkdRaElRPT1cIilcbiAqICAgIC8vX3Jlc3VsdDpcbiAqXG4gKiAgICAvLyAuLi51c2UgdG9VdGY4U3RyaW5nIHRvIGNvbnZlcnQgaXQgdG8gYSBzdHJpbmcuXG4gKiAgICB0b1V0ZjhTdHJpbmcocmVzdWx0KVxuICogICAgLy9fcmVzdWx0OlxuICpcbiAqICAgIC8vIERlY29kaW5nIGJpbmFyeSBkYXRhXG4gKiAgICBkZWNvZGVCYXNlNjQoXCJFalE9XCIpXG4gKiAgICAvL19yZXN1bHQ6XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZWNvZGVCYXNlNjQodmFsdWUpIHtcbiAgICByZXR1cm4gZ2V0Qnl0ZXNDb3B5KEJ1ZmZlci5mcm9tKHZhbHVlLCBcImJhc2U2NFwiKSk7XG59XG47XG4vKipcbiAqICBFbmNvZGVzICUlZGF0YSUlIGFzIGEgYmFzZS02NCBlbmNvZGVkIHN0cmluZy5cbiAqXG4gKiAgQGV4YW1wbGU6XG4gKiAgICAvLyBFbmNvZGluZyBiaW5hcnkgZGF0YSBhcyBhIGhleHN0cmluZ1xuICogICAgZW5jb2RlQmFzZTY0KFwiMHgxMjM0XCIpXG4gKiAgICAvL19yZXN1bHQ6XG4gKlxuICogICAgLy8gRW5jb2RpbmcgYmluYXJ5IGRhdGEgYXMgYSBVaW50OEFycmF5XG4gKiAgICBlbmNvZGVCYXNlNjQobmV3IFVpbnQ4QXJyYXkoWyAweDEyLCAweDM0IF0pKVxuICogICAgLy9fcmVzdWx0OlxuICpcbiAqICAgIC8vIFRoZSBpbnB1dCBNVVNUIGJlIGRhdGEuLi5cbiAqICAgIGVuY29kZUJhc2U2NChcIkhlbGxvIFdvcmxkISFcIilcbiAqICAgIC8vX2Vycm9yOlxuICpcbiAqICAgIC8vIC4uLnVzZSB0b1V0ZjhCeXRlcyBmb3IgdGhpcy5cbiAqICAgIGVuY29kZUJhc2U2NCh0b1V0ZjhCeXRlcyhcIkhlbGxvIFdvcmxkISFcIikpXG4gKiAgICAvL19yZXN1bHQ6XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlbmNvZGVCYXNlNjQoZGF0YSkge1xuICAgIHJldHVybiBCdWZmZXIuZnJvbShnZXRCeXRlcyhkYXRhKSkudG9TdHJpbmcoXCJiYXNlNjRcIik7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1iYXNlNjQuanMubWFwIl0sIm5hbWVzIjpbImdldEJ5dGVzIiwiZ2V0Qnl0ZXNDb3B5IiwiZGVjb2RlQmFzZTY0IiwidmFsdWUiLCJCdWZmZXIiLCJmcm9tIiwiZW5jb2RlQmFzZTY0IiwiZGF0YSIsInRvU3RyaW5nIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.esm/utils/base64.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.esm/utils/data.js":
/*!***************************************************!*\
  !*** ./node_modules/ethers/lib.esm/utils/data.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   concat: () => (/* binding */ concat),\n/* harmony export */   dataLength: () => (/* binding */ dataLength),\n/* harmony export */   dataSlice: () => (/* binding */ dataSlice),\n/* harmony export */   getBytes: () => (/* binding */ getBytes),\n/* harmony export */   getBytesCopy: () => (/* binding */ getBytesCopy),\n/* harmony export */   hexlify: () => (/* binding */ hexlify),\n/* harmony export */   isBytesLike: () => (/* binding */ isBytesLike),\n/* harmony export */   isHexString: () => (/* binding */ isHexString),\n/* harmony export */   stripZerosLeft: () => (/* binding */ stripZerosLeft),\n/* harmony export */   zeroPadBytes: () => (/* binding */ zeroPadBytes),\n/* harmony export */   zeroPadValue: () => (/* binding */ zeroPadValue)\n/* harmony export */ });\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./errors.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/errors.js\");\n/**\n *  Some data helpers.\n *\n *\n *  @_subsection api/utils:Data Helpers  [about-data]\n */ \nfunction _getBytes(value, name, copy) {\n    if (value instanceof Uint8Array) {\n        if (copy) {\n            return new Uint8Array(value);\n        }\n        return value;\n    }\n    if (typeof value === \"string\" && value.match(/^0x(?:[0-9a-f][0-9a-f])*$/i)) {\n        const result = new Uint8Array((value.length - 2) / 2);\n        let offset = 2;\n        for(let i = 0; i < result.length; i++){\n            result[i] = parseInt(value.substring(offset, offset + 2), 16);\n            offset += 2;\n        }\n        return result;\n    }\n    (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(false, \"invalid BytesLike value\", name || \"value\", value);\n}\n/**\n *  Get a typed Uint8Array for %%value%%. If already a Uint8Array\n *  the original %%value%% is returned; if a copy is required use\n *  [[getBytesCopy]].\n *\n *  @see: getBytesCopy\n */ function getBytes(value, name) {\n    return _getBytes(value, name, false);\n}\n/**\n *  Get a typed Uint8Array for %%value%%, creating a copy if necessary\n *  to prevent any modifications of the returned value from being\n *  reflected elsewhere.\n *\n *  @see: getBytes\n */ function getBytesCopy(value, name) {\n    return _getBytes(value, name, true);\n}\n/**\n *  Returns true if %%value%% is a valid [[HexString]].\n *\n *  If %%length%% is ``true`` or a //number//, it also checks that\n *  %%value%% is a valid [[DataHexString]] of %%length%% (if a //number//)\n *  bytes of data (e.g. ``0x1234`` is 2 bytes).\n */ function isHexString(value, length) {\n    if (typeof value !== \"string\" || !value.match(/^0x[0-9A-Fa-f]*$/)) {\n        return false;\n    }\n    if (typeof length === \"number\" && value.length !== 2 + 2 * length) {\n        return false;\n    }\n    if (length === true && value.length % 2 !== 0) {\n        return false;\n    }\n    return true;\n}\n/**\n *  Returns true if %%value%% is a valid representation of arbitrary\n *  data (i.e. a valid [[DataHexString]] or a Uint8Array).\n */ function isBytesLike(value) {\n    return isHexString(value, true) || value instanceof Uint8Array;\n}\nconst HexCharacters = \"0123456789abcdef\";\n/**\n *  Returns a [[DataHexString]] representation of %%data%%.\n */ function hexlify(data) {\n    const bytes = getBytes(data);\n    let result = \"0x\";\n    for(let i = 0; i < bytes.length; i++){\n        const v = bytes[i];\n        result += HexCharacters[(v & 0xf0) >> 4] + HexCharacters[v & 0x0f];\n    }\n    return result;\n}\n/**\n *  Returns a [[DataHexString]] by concatenating all values\n *  within %%data%%.\n */ function concat(datas) {\n    return \"0x\" + datas.map((d)=>hexlify(d).substring(2)).join(\"\");\n}\n/**\n *  Returns the length of %%data%%, in bytes.\n */ function dataLength(data) {\n    if (isHexString(data, true)) {\n        return (data.length - 2) / 2;\n    }\n    return getBytes(data).length;\n}\n/**\n *  Returns a [[DataHexString]] by slicing %%data%% from the %%start%%\n *  offset to the %%end%% offset.\n *\n *  By default %%start%% is 0 and %%end%% is the length of %%data%%.\n */ function dataSlice(data, start, end) {\n    const bytes = getBytes(data);\n    if (end != null && end > bytes.length) {\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assert)(false, \"cannot slice beyond data bounds\", \"BUFFER_OVERRUN\", {\n            buffer: bytes,\n            length: bytes.length,\n            offset: end\n        });\n    }\n    return hexlify(bytes.slice(start == null ? 0 : start, end == null ? bytes.length : end));\n}\n/**\n *  Return the [[DataHexString]] result by stripping all **leading**\n ** zero bytes from %%data%%.\n */ function stripZerosLeft(data) {\n    let bytes = hexlify(data).substring(2);\n    while(bytes.startsWith(\"00\")){\n        bytes = bytes.substring(2);\n    }\n    return \"0x\" + bytes;\n}\nfunction zeroPad(data, length, left) {\n    const bytes = getBytes(data);\n    (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assert)(length >= bytes.length, \"padding exceeds data length\", \"BUFFER_OVERRUN\", {\n        buffer: new Uint8Array(bytes),\n        length: length,\n        offset: length + 1\n    });\n    const result = new Uint8Array(length);\n    result.fill(0);\n    if (left) {\n        result.set(bytes, length - bytes.length);\n    } else {\n        result.set(bytes, 0);\n    }\n    return hexlify(result);\n}\n/**\n *  Return the [[DataHexString]] of %%data%% padded on the **left**\n *  to %%length%% bytes.\n *\n *  If %%data%% already exceeds %%length%%, a [[BufferOverrunError]] is\n *  thrown.\n *\n *  This pads data the same as **values** are in Solidity\n *  (e.g. ``uint128``).\n */ function zeroPadValue(data, length) {\n    return zeroPad(data, length, true);\n}\n/**\n *  Return the [[DataHexString]] of %%data%% padded on the **right**\n *  to %%length%% bytes.\n *\n *  If %%data%% already exceeds %%length%%, a [[BufferOverrunError]] is\n *  thrown.\n *\n *  This pads data the same as **bytes** are in Solidity\n *  (e.g. ``bytes16``).\n */ function zeroPadBytes(data, length) {\n    return zeroPad(data, length, false);\n} //# sourceMappingURL=data.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vdXRpbHMvZGF0YS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7Ozs7Q0FLQyxHQUNvRDtBQUNyRCxTQUFTRSxVQUFVQyxLQUFLLEVBQUVDLElBQUksRUFBRUMsSUFBSTtJQUNoQyxJQUFJRixpQkFBaUJHLFlBQVk7UUFDN0IsSUFBSUQsTUFBTTtZQUNOLE9BQU8sSUFBSUMsV0FBV0g7UUFDMUI7UUFDQSxPQUFPQTtJQUNYO0lBQ0EsSUFBSSxPQUFRQSxVQUFXLFlBQVlBLE1BQU1JLEtBQUssQ0FBQywrQkFBK0I7UUFDMUUsTUFBTUMsU0FBUyxJQUFJRixXQUFXLENBQUNILE1BQU1NLE1BQU0sR0FBRyxLQUFLO1FBQ25ELElBQUlDLFNBQVM7UUFDYixJQUFLLElBQUlDLElBQUksR0FBR0EsSUFBSUgsT0FBT0MsTUFBTSxFQUFFRSxJQUFLO1lBQ3BDSCxNQUFNLENBQUNHLEVBQUUsR0FBR0MsU0FBU1QsTUFBTVUsU0FBUyxDQUFDSCxRQUFRQSxTQUFTLElBQUk7WUFDMURBLFVBQVU7UUFDZDtRQUNBLE9BQU9GO0lBQ1g7SUFDQVAsMERBQWNBLENBQUMsT0FBTywyQkFBMkJHLFFBQVEsU0FBU0Q7QUFDdEU7QUFDQTs7Ozs7O0NBTUMsR0FDTSxTQUFTVyxTQUFTWCxLQUFLLEVBQUVDLElBQUk7SUFDaEMsT0FBT0YsVUFBVUMsT0FBT0MsTUFBTTtBQUNsQztBQUNBOzs7Ozs7Q0FNQyxHQUNNLFNBQVNXLGFBQWFaLEtBQUssRUFBRUMsSUFBSTtJQUNwQyxPQUFPRixVQUFVQyxPQUFPQyxNQUFNO0FBQ2xDO0FBQ0E7Ozs7OztDQU1DLEdBQ00sU0FBU1ksWUFBWWIsS0FBSyxFQUFFTSxNQUFNO0lBQ3JDLElBQUksT0FBUU4sVUFBVyxZQUFZLENBQUNBLE1BQU1JLEtBQUssQ0FBQyxxQkFBcUI7UUFDakUsT0FBTztJQUNYO0lBQ0EsSUFBSSxPQUFRRSxXQUFZLFlBQVlOLE1BQU1NLE1BQU0s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YWNrOi8vbWVnYXZpYmUtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vdXRpbHMvZGF0YS5qcz9jNjhhIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogIFNvbWUgZGF0YSBoZWxwZXJzLlxuICpcbiAqXG4gKiAgQF9zdWJzZWN0aW9uIGFwaS91dGlsczpEYXRhIEhlbHBlcnMgIFthYm91dC1kYXRhXVxuICovXG5pbXBvcnQgeyBhc3NlcnQsIGFzc2VydEFyZ3VtZW50IH0gZnJvbSBcIi4vZXJyb3JzLmpzXCI7XG5mdW5jdGlvbiBfZ2V0Qnl0ZXModmFsdWUsIG5hbWUsIGNvcHkpIHtcbiAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgICAgIGlmIChjb3B5KSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiAodmFsdWUpID09PSBcInN0cmluZ1wiICYmIHZhbHVlLm1hdGNoKC9eMHgoPzpbMC05YS1mXVswLTlhLWZdKSokL2kpKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBVaW50OEFycmF5KCh2YWx1ZS5sZW5ndGggLSAyKSAvIDIpO1xuICAgICAgICBsZXQgb2Zmc2V0ID0gMjtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZXN1bHQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHJlc3VsdFtpXSA9IHBhcnNlSW50KHZhbHVlLnN1YnN0cmluZyhvZmZzZXQsIG9mZnNldCArIDIpLCAxNik7XG4gICAgICAgICAgICBvZmZzZXQgKz0gMjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBhc3NlcnRBcmd1bWVudChmYWxzZSwgXCJpbnZhbGlkIEJ5dGVzTGlrZSB2YWx1ZVwiLCBuYW1lIHx8IFwidmFsdWVcIiwgdmFsdWUpO1xufVxuLyoqXG4gKiAgR2V0IGEgdHlwZWQgVWludDhBcnJheSBmb3IgJSV2YWx1ZSUlLiBJZiBhbHJlYWR5IGEgVWludDhBcnJheVxuICogIHRoZSBvcmlnaW5hbCAlJXZhbHVlJSUgaXMgcmV0dXJuZWQ7IGlmIGEgY29weSBpcyByZXF1aXJlZCB1c2VcbiAqICBbW2dldEJ5dGVzQ29weV1dLlxuICpcbiAqICBAc2VlOiBnZXRCeXRlc0NvcHlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEJ5dGVzKHZhbHVlLCBuYW1lKSB7XG4gICAgcmV0dXJuIF9nZXRCeXRlcyh2YWx1ZSwgbmFtZSwgZmFsc2UpO1xufVxuLyoqXG4gKiAgR2V0IGEgdHlwZWQgVWludDhBcnJheSBmb3IgJSV2YWx1ZSUlLCBjcmVhdGluZyBhIGNvcHkgaWYgbmVjZXNzYXJ5XG4gKiAgdG8gcHJldmVudCBhbnkgbW9kaWZpY2F0aW9ucyBvZiB0aGUgcmV0dXJuZWQgdmFsdWUgZnJvbSBiZWluZ1xuICogIHJlZmxlY3RlZCBlbHNld2hlcmUuXG4gKlxuICogIEBzZWU6IGdldEJ5dGVzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRCeXRlc0NvcHkodmFsdWUsIG5hbWUpIHtcbiAgICByZXR1cm4gX2dldEJ5dGVzKHZhbHVlLCBuYW1lLCB0cnVlKTtcbn1cbi8qKlxuICogIFJldHVybnMgdHJ1ZSBpZiAlJXZhbHVlJSUgaXMgYSB2YWxpZCBbW0hleFN0cmluZ11dLlxuICpcbiAqICBJZiAlJWxlbmd0aCUlIGlzIGBgdHJ1ZWBgIG9yIGEgLy9udW1iZXIvLywgaXQgYWxzbyBjaGVja3MgdGhhdFxuICogICUldmFsdWUlJSBpcyBhIHZhbGlkIFtbRGF0YUhleFN0cmluZ11dIG9mICUlbGVuZ3RoJSUgKGlmIGEgLy9udW1iZXIvLylcbiAqICBieXRlcyBvZiBkYXRhIChlLmcuIGBgMHgxMjM0YGAgaXMgMiBieXRlcykuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0hleFN0cmluZyh2YWx1ZSwgbGVuZ3RoKSB7XG4gICAgaWYgKHR5cGVvZiAodmFsdWUpICE9PSBcInN0cmluZ1wiIHx8ICF2YWx1ZS5tYXRjaCgvXjB4WzAtOUEtRmEtZl0qJC8pKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiAobGVuZ3RoKSA9PT0gXCJudW1iZXJcIiAmJiB2YWx1ZS5sZW5ndGggIT09IDIgKyAyICogbGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKGxlbmd0aCA9PT0gdHJ1ZSAmJiAodmFsdWUubGVuZ3RoICUgMikgIT09IDApIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbi8qKlxuICogIFJldHVybnMgdHJ1ZSBpZiAlJXZhbHVlJSUgaXMgYSB2YWxpZCByZXByZXNlbnRhdGlvbiBvZiBhcmJpdHJhcnlcbiAqICBkYXRhIChpLmUuIGEgdmFsaWQgW1tEYXRhSGV4U3RyaW5nXV0gb3IgYSBVaW50OEFycmF5KS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzQnl0ZXNMaWtlKHZhbHVlKSB7XG4gICAgcmV0dXJuIChpc0hleFN0cmluZyh2YWx1ZSwgdHJ1ZSkgfHwgKHZhbHVlIGluc3RhbmNlb2YgVWludDhBcnJheSkpO1xufVxuY29uc3QgSGV4Q2hhcmFjdGVycyA9IFwiMDEyMzQ1Njc4OWFiY2RlZlwiO1xuLyoqXG4gKiAgUmV0dXJucyBhIFtbRGF0YUhleFN0cmluZ11dIHJlcHJlc2VudGF0aW9uIG9mICUlZGF0YSUlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gaGV4bGlmeShkYXRhKSB7XG4gICAgY29uc3QgYnl0ZXMgPSBnZXRCeXRlcyhkYXRhKTtcbiAgICBsZXQgcmVzdWx0ID0gXCIweFwiO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgdiA9IGJ5dGVzW2ldO1xuICAgICAgICByZXN1bHQgKz0gSGV4Q2hhcmFjdGVyc1sodiAmIDB4ZjApID4+IDRdICsgSGV4Q2hhcmFjdGVyc1t2ICYgMHgwZl07XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG4vKipcbiAqICBSZXR1cm5zIGEgW1tEYXRhSGV4U3RyaW5nXV0gYnkgY29uY2F0ZW5hdGluZyBhbGwgdmFsdWVzXG4gKiAgd2l0aGluICUlZGF0YSUlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY29uY2F0KGRhdGFzKSB7XG4gICAgcmV0dXJuIFwiMHhcIiArIGRhdGFzLm1hcCgoZCkgPT4gaGV4bGlmeShkKS5zdWJzdHJpbmcoMikpLmpvaW4oXCJcIik7XG59XG4vKipcbiAqICBSZXR1cm5zIHRoZSBsZW5ndGggb2YgJSVkYXRhJSUsIGluIGJ5dGVzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZGF0YUxlbmd0aChkYXRhKSB7XG4gICAgaWYgKGlzSGV4U3RyaW5nKGRhdGEsIHRydWUpKSB7XG4gICAgICAgIHJldHVybiAoZGF0YS5sZW5ndGggLSAyKSAvIDI7XG4gICAgfVxuICAgIHJldHVybiBnZXRCeXRlcyhkYXRhKS5sZW5ndGg7XG59XG4vKipcbiAqICBSZXR1cm5zIGEgW1tEYXRhSGV4U3RyaW5nXV0gYnkgc2xpY2luZyAlJWRhdGElJSBmcm9tIHRoZSAlJXN0YXJ0JSVcbiAqICBvZmZzZXQgdG8gdGhlICUlZW5kJSUgb2Zmc2V0LlxuICpcbiAqICBCeSBkZWZhdWx0ICUlc3RhcnQlJSBpcyAwIGFuZCAlJWVuZCUlIGlzIHRoZSBsZW5ndGggb2YgJSVkYXRhJSUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkYXRhU2xpY2UoZGF0YSwgc3RhcnQsIGVuZCkge1xuICAgIGNvbnN0IGJ5dGVzID0gZ2V0Qnl0ZXMoZGF0YSk7XG4gICAgaWYgKGVuZCAhPSBudWxsICYmIGVuZCA+IGJ5dGVzLmxlbmd0aCkge1xuICAgICAgICBhc3NlcnQoZmFsc2UsIFwiY2Fubm90IHNsaWNlIGJleW9uZCBkYXRhIGJvdW5kc1wiLCBcIkJVRkZFUl9PVkVSUlVOXCIsIHtcbiAgICAgICAgICAgIGJ1ZmZlcjogYnl0ZXMsIGxlbmd0aDogYnl0ZXMubGVuZ3RoLCBvZmZzZXQ6IGVuZFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGhleGxpZnkoYnl0ZXMuc2xpY2UoKHN0YXJ0ID09IG51bGwpID8gMCA6IHN0YXJ0LCAoZW5kID09IG51bGwpID8gYnl0ZXMubGVuZ3RoIDogZW5kKSk7XG59XG4vKipcbiAqICBSZXR1cm4gdGhlIFtbRGF0YUhleFN0cmluZ11dIHJlc3VsdCBieSBzdHJpcHBpbmcgYWxsICoqbGVhZGluZyoqXG4gKiogemVybyBieXRlcyBmcm9tICUlZGF0YSUlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gc3RyaXBaZXJvc0xlZnQoZGF0YSkge1xuICAgIGxldCBieXRlcyA9IGhleGxpZnkoZGF0YSkuc3Vic3RyaW5nKDIpO1xuICAgIHdoaWxlIChieXRlcy5zdGFydHNXaXRoKFwiMDBcIikpIHtcbiAgICAgICAgYnl0ZXMgPSBieXRlcy5zdWJzdHJpbmcoMik7XG4gICAgfVxuICAgIHJldHVybiBcIjB4XCIgKyBieXRlcztcbn1cbmZ1bmN0aW9uIHplcm9QYWQoZGF0YSwgbGVuZ3RoLCBsZWZ0KSB7XG4gICAgY29uc3QgYnl0ZXMgPSBnZXRCeXRlcyhkYXRhKTtcbiAgICBhc3NlcnQobGVuZ3RoID49IGJ5dGVzLmxlbmd0aCwgXCJwYWRkaW5nIGV4Y2VlZHMgZGF0YSBsZW5ndGhcIiwgXCJCVUZGRVJfT1ZFUlJVTlwiLCB7XG4gICAgICAgIGJ1ZmZlcjogbmV3IFVpbnQ4QXJyYXkoYnl0ZXMpLFxuICAgICAgICBsZW5ndGg6IGxlbmd0aCxcbiAgICAgICAgb2Zmc2V0OiBsZW5ndGggKyAxXG4gICAgfSk7XG4gICAgY29uc3QgcmVzdWx0ID0gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoKTtcbiAgICByZXN1bHQuZmlsbCgwKTtcbiAgICBpZiAobGVmdCkge1xuICAgICAgICByZXN1bHQuc2V0KGJ5dGVzLCBsZW5ndGggLSBieXRlcy5sZW5ndGgpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmVzdWx0LnNldChieXRlcywgMCk7XG4gICAgfVxuICAgIHJldHVybiBoZXhsaWZ5KHJlc3VsdCk7XG59XG4vKipcbiAqICBSZXR1cm4gdGhlIFtbRGF0YUhleFN0cmluZ11dIG9mICUlZGF0YSUlIHBhZGRlZCBvbiB0aGUgKipsZWZ0KipcbiAqICB0byAlJWxlbmd0aCUlIGJ5dGVzLlxuICpcbiAqICBJZiAlJWRhdGElJSBhbHJlYWR5IGV4Y2VlZHMgJSVsZW5ndGglJSwgYSBbW0J1ZmZlck92ZXJydW5FcnJvcl1dIGlzXG4gKiAgdGhyb3duLlxuICpcbiAqICBUaGlzIHBhZHMgZGF0YSB0aGUgc2FtZSBhcyAqKnZhbHVlcyoqIGFyZSBpbiBTb2xpZGl0eVxuICogIChlLmcuIGBgdWludDEyOGBgKS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHplcm9QYWRWYWx1ZShkYXRhLCBsZW5ndGgpIHtcbiAgICByZXR1cm4gemVyb1BhZChkYXRhLCBsZW5ndGgsIHRydWUpO1xufVxuLyoqXG4gKiAgUmV0dXJuIHRoZSBbW0RhdGFIZXhTdHJpbmddXSBvZiAlJWRhdGElJSBwYWRkZWQgb24gdGhlICoqcmlnaHQqKlxuICogIHRvICUlbGVuZ3RoJSUgYnl0ZXMuXG4gKlxuICogIElmICUlZGF0YSUlIGFscmVhZHkgZXhjZWVkcyAlJWxlbmd0aCUlLCBhIFtbQnVmZmVyT3ZlcnJ1bkVycm9yXV0gaXNcbiAqICB0aHJvd24uXG4gKlxuICogIFRoaXMgcGFkcyBkYXRhIHRoZSBzYW1lIGFzICoqYnl0ZXMqKiBhcmUgaW4gU29saWRpdHlcbiAqICAoZS5nLiBgYGJ5dGVzMTZgYCkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB6ZXJvUGFkQnl0ZXMoZGF0YSwgbGVuZ3RoKSB7XG4gICAgcmV0dXJuIHplcm9QYWQoZGF0YSwgbGVuZ3RoLCBmYWxzZSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhLmpzLm1hcCJdLCJuYW1lcyI6WyJhc3NlcnQiLCJhc3NlcnRBcmd1bWVudCIsIl9nZXRCeXRlcyIsInZhbHVlIiwibmFtZSIsImNvcHkiLCJVaW50OEFycmF5IiwibWF0Y2giLCJyZXN1bHQiLCJsZW5ndGgiLCJvZmZzZXQiLCJpIiwicGFyc2VJbnQiLCJzdWJzdHJpbmciLCJnZXRCeXRlcyIsImdldEJ5dGVzQ29weSIsImlzSGV4U3RyaW5nIiwiaXNCeXRlc0xpa2UiLCJIZXhDaGFyYWN0ZXJzIiwiaGV4bGlmeSIsImRhdGEiLCJieXRlcyIsInYiLCJjb25jYXQiLCJkYXRhcyIsIm1hcCIsImQiLCJqb2luIiwiZGF0YUxlbmd0aCIsImRhdGFTbGljZSIsInN0YXJ0IiwiZW5kIiwiYnVmZmVyIiwic2xpY2UiLCJzdHJpcFplcm9zTGVmdCIsInN0YXJ0c1dpdGgiLCJ6ZXJvUGFkIiwibGVmdCIsImZpbGwiLCJzZXQiLCJ6ZXJvUGFkVmFsdWUiLCJ6ZXJvUGFkQnl0ZXMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.esm/utils/data.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.esm/utils/errors.js":
/*!*****************************************************!*\
  !*** ./node_modules/ethers/lib.esm/utils/errors.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   assert: () => (/* binding */ assert),\n/* harmony export */   assertArgument: () => (/* binding */ assertArgument),\n/* harmony export */   assertArgumentCount: () => (/* binding */ assertArgumentCount),\n/* harmony export */   assertNormalize: () => (/* binding */ assertNormalize),\n/* harmony export */   assertPrivate: () => (/* binding */ assertPrivate),\n/* harmony export */   isCallException: () => (/* binding */ isCallException),\n/* harmony export */   isError: () => (/* binding */ isError),\n/* harmony export */   makeError: () => (/* binding */ makeError)\n/* harmony export */ });\n/* harmony import */ var _version_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../_version.js */ \"(ssr)/./node_modules/ethers/lib.esm/_version.js\");\n/* harmony import */ var _properties_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./properties.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/properties.js\");\n/**\n *  All errors in ethers include properties to ensure they are both\n *  human-readable (i.e. ``.message``) and machine-readable (i.e. ``.code``).\n *\n *  The [[isError]] function can be used to check the error ``code`` and\n *  provide a type guard for the properties present on that error interface.\n *\n *  @_section: api/utils/errors:Errors  [about-errors]\n */ \n\nfunction stringify(value, seen) {\n    if (value == null) {\n        return \"null\";\n    }\n    if (seen == null) {\n        seen = new Set();\n    }\n    if (typeof value === \"object\") {\n        if (seen.has(value)) {\n            return \"[Circular]\";\n        }\n        seen.add(value);\n    }\n    if (Array.isArray(value)) {\n        return \"[ \" + value.map((v)=>stringify(v, seen)).join(\", \") + \" ]\";\n    }\n    if (value instanceof Uint8Array) {\n        const HEX = \"0123456789abcdef\";\n        let result = \"0x\";\n        for(let i = 0; i < value.length; i++){\n            result += HEX[value[i] >> 4];\n            result += HEX[value[i] & 0xf];\n        }\n        return result;\n    }\n    if (typeof value === \"object\" && typeof value.toJSON === \"function\") {\n        return stringify(value.toJSON(), seen);\n    }\n    switch(typeof value){\n        case \"boolean\":\n        case \"number\":\n        case \"symbol\":\n            return value.toString();\n        case \"bigint\":\n            return BigInt(value).toString();\n        case \"string\":\n            return JSON.stringify(value);\n        case \"object\":\n            {\n                const keys = Object.keys(value);\n                keys.sort();\n                return \"{ \" + keys.map((k)=>`${stringify(k, seen)}: ${stringify(value[k], seen)}`).join(\", \") + \" }\";\n            }\n    }\n    return `[ COULD NOT SERIALIZE ]`;\n}\n/**\n *  Returns true if the %%error%% matches an error thrown by ethers\n *  that matches the error %%code%%.\n *\n *  In TypeScript environments, this can be used to check that %%error%%\n *  matches an EthersError type, which means the expected properties will\n *  be set.\n *\n *  @See [ErrorCodes](api:ErrorCode)\n *  @example\n *    try {\n *      // code....\n *    } catch (e) {\n *      if (isError(e, \"CALL_EXCEPTION\")) {\n *          // The Type Guard has validated this object\n *          console.log(e.data);\n *      }\n *    }\n */ function isError(error, code) {\n    return error && error.code === code;\n}\n/**\n *  Returns true if %%error%% is a [[CallExceptionError].\n */ function isCallException(error) {\n    return isError(error, \"CALL_EXCEPTION\");\n}\n/**\n *  Returns a new Error configured to the format ethers emits errors, with\n *  the %%message%%, [[api:ErrorCode]] %%code%% and additional properties\n *  for the corresponding EthersError.\n *\n *  Each error in ethers includes the version of ethers, a\n *  machine-readable [[ErrorCode]], and depending on %%code%%, additional\n *  required properties. The error message will also include the %%message%%,\n *  ethers version, %%code%% and all additional properties, serialized.\n */ function makeError(message, code, info) {\n    let shortMessage = message;\n    {\n        const details = [];\n        if (info) {\n            if (\"message\" in info || \"code\" in info || \"name\" in info) {\n                throw new Error(`value will overwrite populated values: ${stringify(info)}`);\n            }\n            for(const key in info){\n                if (key === \"shortMessage\") {\n                    continue;\n                }\n                const value = info[key];\n                //                try {\n                details.push(key + \"=\" + stringify(value));\n            //                } catch (error: any) {\n            //                console.log(\"MMM\", error.message);\n            //                    details.push(key + \"=[could not serialize object]\");\n            //                }\n            }\n        }\n        details.push(`code=${code}`);\n        details.push(`version=${_version_js__WEBPACK_IMPORTED_MODULE_0__.version}`);\n        if (details.length) {\n            message += \" (\" + details.join(\", \") + \")\";\n        }\n    }\n    let error;\n    switch(code){\n        case \"INVALID_ARGUMENT\":\n            error = new TypeError(message);\n            break;\n        case \"NUMERIC_FAULT\":\n        case \"BUFFER_OVERRUN\":\n            error = new RangeError(message);\n            break;\n        default:\n            error = new Error(message);\n    }\n    (0,_properties_js__WEBPACK_IMPORTED_MODULE_1__.defineProperties)(error, {\n        code\n    });\n    if (info) {\n        Object.assign(error, info);\n    }\n    if (error.shortMessage == null) {\n        (0,_properties_js__WEBPACK_IMPORTED_MODULE_1__.defineProperties)(error, {\n            shortMessage\n        });\n    }\n    return error;\n}\n/**\n *  Throws an EthersError with %%message%%, %%code%% and additional error\n *  %%info%% when %%check%% is falsish..\n *\n *  @see [[api:makeError]]\n */ function assert(check, message, code, info) {\n    if (!check) {\n        throw makeError(message, code, info);\n    }\n}\n/**\n *  A simple helper to simply ensuring provided arguments match expected\n *  constraints, throwing if not.\n *\n *  In TypeScript environments, the %%check%% has been asserted true, so\n *  any further code does not need additional compile-time checks.\n */ function assertArgument(check, message, name, value) {\n    assert(check, message, \"INVALID_ARGUMENT\", {\n        argument: name,\n        value: value\n    });\n}\nfunction assertArgumentCount(count, expectedCount, message) {\n    if (message == null) {\n        message = \"\";\n    }\n    if (message) {\n        message = \": \" + message;\n    }\n    assert(count >= expectedCount, \"missing argument\" + message, \"MISSING_ARGUMENT\", {\n        count: count,\n        expectedCount: expectedCount\n    });\n    assert(count <= expectedCount, \"too many arguments\" + message, \"UNEXPECTED_ARGUMENT\", {\n        count: count,\n        expectedCount: expectedCount\n    });\n}\nconst _normalizeForms = [\n    \"NFD\",\n    \"NFC\",\n    \"NFKD\",\n    \"NFKC\"\n].reduce((accum, form)=>{\n    try {\n        // General test for normalize\n        /* c8 ignore start */ if (\"test\".normalize(form) !== \"test\") {\n            throw new Error(\"bad\");\n        }\n        ;\n        /* c8 ignore stop */ if (form === \"NFD\") {\n            const check = String.fromCharCode(0xe9).normalize(\"NFD\");\n            const expected = String.fromCharCode(0x65, 0x0301);\n            /* c8 ignore start */ if (check !== expected) {\n                throw new Error(\"broken\");\n            }\n        /* c8 ignore stop */ }\n        accum.push(form);\n    } catch (error) {}\n    return accum;\n}, []);\n/**\n *  Throws if the normalization %%form%% is not supported.\n */ function assertNormalize(form) {\n    assert(_normalizeForms.indexOf(form) >= 0, \"platform missing String.prototype.normalize\", \"UNSUPPORTED_OPERATION\", {\n        operation: \"String.prototype.normalize\",\n        info: {\n            form\n        }\n    });\n}\n/**\n *  Many classes use file-scoped values to guard the constructor,\n *  making it effectively private. This facilitates that pattern\n *  by ensuring the %%givenGaurd%% matches the file-scoped %%guard%%,\n *  throwing if not, indicating the %%className%% if provided.\n */ function assertPrivate(givenGuard, guard, className) {\n    if (className == null) {\n        className = \"\";\n    }\n    if (givenGuard !== guard) {\n        let method = className, operation = \"new\";\n        if (className) {\n            method += \".\";\n            operation += \" \" + className;\n        }\n        assert(false, `private constructor; use ${method}from* methods`, \"UNSUPPORTED_OPERATION\", {\n            operation\n        });\n    }\n} //# sourceMappingURL=errors.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vdXRpbHMvZXJyb3JzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFBQTs7Ozs7Ozs7Q0FRQyxHQUN3QztBQUNVO0FBQ25ELFNBQVNFLFVBQVVDLEtBQUssRUFBRUMsSUFBSTtJQUMxQixJQUFJRCxTQUFTLE1BQU07UUFDZixPQUFPO0lBQ1g7SUFDQSxJQUFJQyxRQUFRLE1BQU07UUFDZEEsT0FBTyxJQUFJQztJQUNmO0lBQ0EsSUFBSSxPQUFRRixVQUFXLFVBQVU7UUFDN0IsSUFBSUMsS0FBS0UsR0FBRyxDQUFDSCxRQUFRO1lBQ2pCLE9BQU87UUFDWDtRQUNBQyxLQUFLRyxHQUFHLENBQUNKO0lBQ2I7SUFDQSxJQUFJSyxNQUFNQyxPQUFPLENBQUNOLFFBQVE7UUFDdEIsT0FBTyxPQUFPLE1BQU9PLEdBQUcsQ0FBQyxDQUFDQyxJQUFNVCxVQUFVUyxHQUFHUCxPQUFRUSxJQUFJLENBQUMsUUFBUTtJQUN0RTtJQUNBLElBQUlULGlCQUFpQlUsWUFBWTtRQUM3QixNQUFNQyxNQUFNO1FBQ1osSUFBSUMsU0FBUztRQUNiLElBQUssSUFBSUMsSUFBSSxHQUFHQSxJQUFJYixNQUFNYyxNQUFNLEVBQUVELElBQUs7WUFDbkNELFVBQVVELEdBQUcsQ0FBQ1gsS0FBSyxDQUFDYSxFQUFFLElBQUksRUFBRTtZQUM1QkQsVUFBVUQsR0FBRyxDQUFDWCxLQUFLLENBQUNhLEVBQUUsR0FBRyxJQUFJO1FBQ2pDO1FBQ0EsT0FBT0Q7SUFDWDtJQUNBLElBQUksT0FBUVosVUFBVyxZQUFZLE9BQVFBLE1BQU1lLE1BQU0sS0FBTSxZQUFZO1FBQ3JFLE9BQU9oQixVQUFVQyxNQUFNZSxNQUFNLElBQUlkO0lBQ3JDO0lBQ0EsT0FBUSxPQUFRRDtRQUNaLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztZQUNELE9BQU9BLE1BQU1nQixRQUFRO1FBQ3pCLEtBQUs7WUFDRCxPQUFPQyxPQUFPakIsT0FBT2dCLFFBQVE7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LGVBQWVDLE9BQU87UUFDdEIsSUFBSUUsU0FBU0QsV0FBV0osWUFBWTtRQUNwQyxJQUFJSSxXQUFXO1lBQ1hDLFVBQVU7WUFDVkwsYUFBYSxNQUFNSTtRQUN2QjtRQUNBdEIsT0FBTyxPQUFPLENBQUMseUJBQXlCLEVBQUV1QixPQUFPLGFBQWEsQ0FBQyxFQUFFLHlCQUF5QjtZQUN0Rkw7UUFDSjtJQUNKO0FBQ0osRUFDQSxrQ0FBa0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tZWdhdmliZS1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS91dGlscy9lcnJvcnMuanM/ODY2ZSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqICBBbGwgZXJyb3JzIGluIGV0aGVycyBpbmNsdWRlIHByb3BlcnRpZXMgdG8gZW5zdXJlIHRoZXkgYXJlIGJvdGhcbiAqICBodW1hbi1yZWFkYWJsZSAoaS5lLiBgYC5tZXNzYWdlYGApIGFuZCBtYWNoaW5lLXJlYWRhYmxlIChpLmUuIGBgLmNvZGVgYCkuXG4gKlxuICogIFRoZSBbW2lzRXJyb3JdXSBmdW5jdGlvbiBjYW4gYmUgdXNlZCB0byBjaGVjayB0aGUgZXJyb3IgYGBjb2RlYGAgYW5kXG4gKiAgcHJvdmlkZSBhIHR5cGUgZ3VhcmQgZm9yIHRoZSBwcm9wZXJ0aWVzIHByZXNlbnQgb24gdGhhdCBlcnJvciBpbnRlcmZhY2UuXG4gKlxuICogIEBfc2VjdGlvbjogYXBpL3V0aWxzL2Vycm9yczpFcnJvcnMgIFthYm91dC1lcnJvcnNdXG4gKi9cbmltcG9ydCB7IHZlcnNpb24gfSBmcm9tIFwiLi4vX3ZlcnNpb24uanNcIjtcbmltcG9ydCB7IGRlZmluZVByb3BlcnRpZXMgfSBmcm9tIFwiLi9wcm9wZXJ0aWVzLmpzXCI7XG5mdW5jdGlvbiBzdHJpbmdpZnkodmFsdWUsIHNlZW4pIHtcbiAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gXCJudWxsXCI7XG4gICAgfVxuICAgIGlmIChzZWVuID09IG51bGwpIHtcbiAgICAgICAgc2VlbiA9IG5ldyBTZXQoKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiAodmFsdWUpID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIGlmIChzZWVuLmhhcyh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBcIltDaXJjdWxhcl1cIjtcbiAgICAgICAgfVxuICAgICAgICBzZWVuLmFkZCh2YWx1ZSk7XG4gICAgfVxuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gXCJbIFwiICsgKHZhbHVlLm1hcCgodikgPT4gc3RyaW5naWZ5KHYsIHNlZW4pKSkuam9pbihcIiwgXCIpICsgXCIgXVwiO1xuICAgIH1cbiAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgICAgIGNvbnN0IEhFWCA9IFwiMDEyMzQ1Njc4OWFiY2RlZlwiO1xuICAgICAgICBsZXQgcmVzdWx0ID0gXCIweFwiO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gSEVYW3ZhbHVlW2ldID4+IDRdO1xuICAgICAgICAgICAgcmVzdWx0ICs9IEhFWFt2YWx1ZVtpXSAmIDB4Zl07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiAodmFsdWUpID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiAodmFsdWUudG9KU09OKSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHJldHVybiBzdHJpbmdpZnkodmFsdWUudG9KU09OKCksIHNlZW4pO1xuICAgIH1cbiAgICBzd2l0Y2ggKHR5cGVvZiAodmFsdWUpKSB7XG4gICAgICAgIGNhc2UgXCJib29sZWFuXCI6XG4gICAgICAgIGNhc2UgXCJudW1iZXJcIjpcbiAgICAgICAgY2FzZSBcInN5bWJvbFwiOlxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlLnRvU3RyaW5nKCk7XG4gICAgICAgIGNhc2UgXCJiaWdpbnRcIjpcbiAgICAgICAgICAgIHJldHVybiBCaWdJbnQodmFsdWUpLnRvU3RyaW5nKCk7XG4gICAgICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh2YWx1ZSk7XG4gICAgICAgIGNhc2UgXCJvYmplY3RcIjoge1xuICAgICAgICAgICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHZhbHVlKTtcbiAgICAgICAgICAgIGtleXMuc29ydCgpO1xuICAgICAgICAgICAgcmV0dXJuIFwieyBcIiArIGtleXMubWFwKChrKSA9PiBgJHtzdHJpbmdpZnkoaywgc2Vlbil9OiAke3N0cmluZ2lmeSh2YWx1ZVtrXSwgc2Vlbil9YCkuam9pbihcIiwgXCIpICsgXCIgfVwiO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBgWyBDT1VMRCBOT1QgU0VSSUFMSVpFIF1gO1xufVxuLyoqXG4gKiAgUmV0dXJucyB0cnVlIGlmIHRoZSAlJWVycm9yJSUgbWF0Y2hlcyBhbiBlcnJvciB0aHJvd24gYnkgZXRoZXJzXG4gKiAgdGhhdCBtYXRjaGVzIHRoZSBlcnJvciAlJWNvZGUlJS5cbiAqXG4gKiAgSW4gVHlwZVNjcmlwdCBlbnZpcm9ubWVudHMsIHRoaXMgY2FuIGJlIHVzZWQgdG8gY2hlY2sgdGhhdCAlJWVycm9yJSVcbiAqICBtYXRjaGVzIGFuIEV0aGVyc0Vycm9yIHR5cGUsIHdoaWNoIG1lYW5zIHRoZSBleHBlY3RlZCBwcm9wZXJ0aWVzIHdpbGxcbiAqICBiZSBzZXQuXG4gKlxuICogIEBTZWUgW0Vycm9yQ29kZXNdKGFwaTpFcnJvckNvZGUpXG4gKiAgQGV4YW1wbGVcbiAqICAgIHRyeSB7XG4gKiAgICAgIC8vIGNvZGUuLi4uXG4gKiAgICB9IGNhdGNoIChlKSB7XG4gKiAgICAgIGlmIChpc0Vycm9yKGUsIFwiQ0FMTF9FWENFUFRJT05cIikpIHtcbiAqICAgICAgICAgIC8vIFRoZSBUeXBlIEd1YXJkIGhhcyB2YWxpZGF0ZWQgdGhpcyBvYmplY3RcbiAqICAgICAgICAgIGNvbnNvbGUubG9nKGUuZGF0YSk7XG4gKiAgICAgIH1cbiAqICAgIH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzRXJyb3IoZXJyb3IsIGNvZGUpIHtcbiAgICByZXR1cm4gKGVycm9yICYmIGVycm9yLmNvZGUgPT09IGNvZGUpO1xufVxuLyoqXG4gKiAgUmV0dXJucyB0cnVlIGlmICUlZXJyb3IlJSBpcyBhIFtbQ2FsbEV4Y2VwdGlvbkVycm9yXS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzQ2FsbEV4Y2VwdGlvbihlcnJvcikge1xuICAgIHJldHVybiBpc0Vycm9yKGVycm9yLCBcIkNBTExfRVhDRVBUSU9OXCIpO1xufVxuLyoqXG4gKiAgUmV0dXJucyBhIG5ldyBFcnJvciBjb25maWd1cmVkIHRvIHRoZSBmb3JtYXQgZXRoZXJzIGVtaXRzIGVycm9ycywgd2l0aFxuICogIHRoZSAlJW1lc3NhZ2UlJSwgW1thcGk6RXJyb3JDb2RlXV0gJSVjb2RlJSUgYW5kIGFkZGl0aW9uYWwgcHJvcGVydGllc1xuICogIGZvciB0aGUgY29ycmVzcG9uZGluZyBFdGhlcnNFcnJvci5cbiAqXG4gKiAgRWFjaCBlcnJvciBpbiBldGhlcnMgaW5jbHVkZXMgdGhlIHZlcnNpb24gb2YgZXRoZXJzLCBhXG4gKiAgbWFjaGluZS1yZWFkYWJsZSBbW0Vycm9yQ29kZV1dLCBhbmQgZGVwZW5kaW5nIG9uICUlY29kZSUlLCBhZGRpdGlvbmFsXG4gKiAgcmVxdWlyZWQgcHJvcGVydGllcy4gVGhlIGVycm9yIG1lc3NhZ2Ugd2lsbCBhbHNvIGluY2x1ZGUgdGhlICUlbWVzc2FnZSUlLFxuICogIGV0aGVycyB2ZXJzaW9uLCAlJWNvZGUlJSBhbmQgYWxsIGFkZGl0aW9uYWwgcHJvcGVydGllcywgc2VyaWFsaXplZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1ha2VFcnJvcihtZXNzYWdlLCBjb2RlLCBpbmZvKSB7XG4gICAgbGV0IHNob3J0TWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAge1xuICAgICAgICBjb25zdCBkZXRhaWxzID0gW107XG4gICAgICAgIGlmIChpbmZvKSB7XG4gICAgICAgICAgICBpZiAoXCJtZXNzYWdlXCIgaW4gaW5mbyB8fCBcImNvZGVcIiBpbiBpbmZvIHx8IFwibmFtZVwiIGluIGluZm8pIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHZhbHVlIHdpbGwgb3ZlcndyaXRlIHBvcHVsYXRlZCB2YWx1ZXM6ICR7c3RyaW5naWZ5KGluZm8pfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gaW5mbykge1xuICAgICAgICAgICAgICAgIGlmIChrZXkgPT09IFwic2hvcnRNZXNzYWdlXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gKGluZm9ba2V5XSk7XG4gICAgICAgICAgICAgICAgLy8gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBkZXRhaWxzLnB1c2goa2V5ICsgXCI9XCIgKyBzdHJpbmdpZnkodmFsdWUpKTtcbiAgICAgICAgICAgICAgICAvLyAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgICAgICAgICAgICAgLy8gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJNTU1cIiwgZXJyb3IubWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgLy8gICAgICAgICAgICAgICAgICAgIGRldGFpbHMucHVzaChrZXkgKyBcIj1bY291bGQgbm90IHNlcmlhbGl6ZSBvYmplY3RdXCIpO1xuICAgICAgICAgICAgICAgIC8vICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBkZXRhaWxzLnB1c2goYGNvZGU9JHtjb2RlfWApO1xuICAgICAgICBkZXRhaWxzLnB1c2goYHZlcnNpb249JHt2ZXJzaW9ufWApO1xuICAgICAgICBpZiAoZGV0YWlscy5sZW5ndGgpIHtcbiAgICAgICAgICAgIG1lc3NhZ2UgKz0gXCIgKFwiICsgZGV0YWlscy5qb2luKFwiLCBcIikgKyBcIilcIjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBsZXQgZXJyb3I7XG4gICAgc3dpdGNoIChjb2RlKSB7XG4gICAgICAgIGNhc2UgXCJJTlZBTElEX0FSR1VNRU5UXCI6XG4gICAgICAgICAgICBlcnJvciA9IG5ldyBUeXBlRXJyb3IobWVzc2FnZSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIk5VTUVSSUNfRkFVTFRcIjpcbiAgICAgICAgY2FzZSBcIkJVRkZFUl9PVkVSUlVOXCI6XG4gICAgICAgICAgICBlcnJvciA9IG5ldyBSYW5nZUVycm9yKG1lc3NhZ2UpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBlcnJvciA9IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICB9XG4gICAgZGVmaW5lUHJvcGVydGllcyhlcnJvciwgeyBjb2RlIH0pO1xuICAgIGlmIChpbmZvKSB7XG4gICAgICAgIE9iamVjdC5hc3NpZ24oZXJyb3IsIGluZm8pO1xuICAgIH1cbiAgICBpZiAoZXJyb3Iuc2hvcnRNZXNzYWdlID09IG51bGwpIHtcbiAgICAgICAgZGVmaW5lUHJvcGVydGllcyhlcnJvciwgeyBzaG9ydE1lc3NhZ2UgfSk7XG4gICAgfVxuICAgIHJldHVybiBlcnJvcjtcbn1cbi8qKlxuICogIFRocm93cyBhbiBFdGhlcnNFcnJvciB3aXRoICUlbWVzc2FnZSUlLCAlJWNvZGUlJSBhbmQgYWRkaXRpb25hbCBlcnJvclxuICogICUlaW5mbyUlIHdoZW4gJSVjaGVjayUlIGlzIGZhbHNpc2guLlxuICpcbiAqICBAc2VlIFtbYXBpOm1ha2VFcnJvcl1dXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnQoY2hlY2ssIG1lc3NhZ2UsIGNvZGUsIGluZm8pIHtcbiAgICBpZiAoIWNoZWNrKSB7XG4gICAgICAgIHRocm93IG1ha2VFcnJvcihtZXNzYWdlLCBjb2RlLCBpbmZvKTtcbiAgICB9XG59XG4vKipcbiAqICBBIHNpbXBsZSBoZWxwZXIgdG8gc2ltcGx5IGVuc3VyaW5nIHByb3ZpZGVkIGFyZ3VtZW50cyBtYXRjaCBleHBlY3RlZFxuICogIGNvbnN0cmFpbnRzLCB0aHJvd2luZyBpZiBub3QuXG4gKlxuICogIEluIFR5cGVTY3JpcHQgZW52aXJvbm1lbnRzLCB0aGUgJSVjaGVjayUlIGhhcyBiZWVuIGFzc2VydGVkIHRydWUsIHNvXG4gKiAgYW55IGZ1cnRoZXIgY29kZSBkb2VzIG5vdCBuZWVkIGFkZGl0aW9uYWwgY29tcGlsZS10aW1lIGNoZWNrcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFzc2VydEFyZ3VtZW50KGNoZWNrLCBtZXNzYWdlLCBuYW1lLCB2YWx1ZSkge1xuICAgIGFzc2VydChjaGVjaywgbWVzc2FnZSwgXCJJTlZBTElEX0FSR1VNRU5UXCIsIHsgYXJndW1lbnQ6IG5hbWUsIHZhbHVlOiB2YWx1ZSB9KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnRBcmd1bWVudENvdW50KGNvdW50LCBleHBlY3RlZENvdW50LCBtZXNzYWdlKSB7XG4gICAgaWYgKG1lc3NhZ2UgPT0gbnVsbCkge1xuICAgICAgICBtZXNzYWdlID0gXCJcIjtcbiAgICB9XG4gICAgaWYgKG1lc3NhZ2UpIHtcbiAgICAgICAgbWVzc2FnZSA9IFwiOiBcIiArIG1lc3NhZ2U7XG4gICAgfVxuICAgIGFzc2VydChjb3VudCA+PSBleHBlY3RlZENvdW50LCBcIm1pc3NpbmcgYXJndW1lbnRcIiArIG1lc3NhZ2UsIFwiTUlTU0lOR19BUkdVTUVOVFwiLCB7XG4gICAgICAgIGNvdW50OiBjb3VudCxcbiAgICAgICAgZXhwZWN0ZWRDb3VudDogZXhwZWN0ZWRDb3VudFxuICAgIH0pO1xuICAgIGFzc2VydChjb3VudCA8PSBleHBlY3RlZENvdW50LCBcInRvbyBtYW55IGFyZ3VtZW50c1wiICsgbWVzc2FnZSwgXCJVTkVYUEVDVEVEX0FSR1VNRU5UXCIsIHtcbiAgICAgICAgY291bnQ6IGNvdW50LFxuICAgICAgICBleHBlY3RlZENvdW50OiBleHBlY3RlZENvdW50XG4gICAgfSk7XG59XG5jb25zdCBfbm9ybWFsaXplRm9ybXMgPSBbXCJORkRcIiwgXCJORkNcIiwgXCJORktEXCIsIFwiTkZLQ1wiXS5yZWR1Y2UoKGFjY3VtLCBmb3JtKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gR2VuZXJhbCB0ZXN0IGZvciBub3JtYWxpemVcbiAgICAgICAgLyogYzggaWdub3JlIHN0YXJ0ICovXG4gICAgICAgIGlmIChcInRlc3RcIi5ub3JtYWxpemUoZm9ybSkgIT09IFwidGVzdFwiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJiYWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgO1xuICAgICAgICAvKiBjOCBpZ25vcmUgc3RvcCAqL1xuICAgICAgICBpZiAoZm9ybSA9PT0gXCJORkRcIikge1xuICAgICAgICAgICAgY29uc3QgY2hlY2sgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4ZTkpLm5vcm1hbGl6ZShcIk5GRFwiKTtcbiAgICAgICAgICAgIGNvbnN0IGV4cGVjdGVkID0gU3RyaW5nLmZyb21DaGFyQ29kZSgweDY1LCAweDAzMDEpO1xuICAgICAgICAgICAgLyogYzggaWdub3JlIHN0YXJ0ICovXG4gICAgICAgICAgICBpZiAoY2hlY2sgIT09IGV4cGVjdGVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYnJva2VuXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLyogYzggaWdub3JlIHN0b3AgKi9cbiAgICAgICAgfVxuICAgICAgICBhY2N1bS5wdXNoKGZvcm0pO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHsgfVxuICAgIHJldHVybiBhY2N1bTtcbn0sIFtdKTtcbi8qKlxuICogIFRocm93cyBpZiB0aGUgbm9ybWFsaXphdGlvbiAlJWZvcm0lJSBpcyBub3Qgc3VwcG9ydGVkLlxuICovXG5leHBvcnQgZnVuY3Rpb24gYXNzZXJ0Tm9ybWFsaXplKGZvcm0pIHtcbiAgICBhc3NlcnQoX25vcm1hbGl6ZUZvcm1zLmluZGV4T2YoZm9ybSkgPj0gMCwgXCJwbGF0Zm9ybSBtaXNzaW5nIFN0cmluZy5wcm90b3R5cGUubm9ybWFsaXplXCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHtcbiAgICAgICAgb3BlcmF0aW9uOiBcIlN0cmluZy5wcm90b3R5cGUubm9ybWFsaXplXCIsIGluZm86IHsgZm9ybSB9XG4gICAgfSk7XG59XG4vKipcbiAqICBNYW55IGNsYXNzZXMgdXNlIGZpbGUtc2NvcGVkIHZhbHVlcyB0byBndWFyZCB0aGUgY29uc3RydWN0b3IsXG4gKiAgbWFraW5nIGl0IGVmZmVjdGl2ZWx5IHByaXZhdGUuIFRoaXMgZmFjaWxpdGF0ZXMgdGhhdCBwYXR0ZXJuXG4gKiAgYnkgZW5zdXJpbmcgdGhlICUlZ2l2ZW5HYXVyZCUlIG1hdGNoZXMgdGhlIGZpbGUtc2NvcGVkICUlZ3VhcmQlJSxcbiAqICB0aHJvd2luZyBpZiBub3QsIGluZGljYXRpbmcgdGhlICUlY2xhc3NOYW1lJSUgaWYgcHJvdmlkZWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnRQcml2YXRlKGdpdmVuR3VhcmQsIGd1YXJkLCBjbGFzc05hbWUpIHtcbiAgICBpZiAoY2xhc3NOYW1lID09IG51bGwpIHtcbiAgICAgICAgY2xhc3NOYW1lID0gXCJcIjtcbiAgICB9XG4gICAgaWYgKGdpdmVuR3VhcmQgIT09IGd1YXJkKSB7XG4gICAgICAgIGxldCBtZXRob2QgPSBjbGFzc05hbWUsIG9wZXJhdGlvbiA9IFwibmV3XCI7XG4gICAgICAgIGlmIChjbGFzc05hbWUpIHtcbiAgICAgICAgICAgIG1ldGhvZCArPSBcIi5cIjtcbiAgICAgICAgICAgIG9wZXJhdGlvbiArPSBcIiBcIiArIGNsYXNzTmFtZTtcbiAgICAgICAgfVxuICAgICAgICBhc3NlcnQoZmFsc2UsIGBwcml2YXRlIGNvbnN0cnVjdG9yOyB1c2UgJHttZXRob2R9ZnJvbSogbWV0aG9kc2AsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHtcbiAgICAgICAgICAgIG9wZXJhdGlvblxuICAgICAgICB9KTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1lcnJvcnMuanMubWFwIl0sIm5hbWVzIjpbInZlcnNpb24iLCJkZWZpbmVQcm9wZXJ0aWVzIiwic3RyaW5naWZ5IiwidmFsdWUiLCJzZWVuIiwiU2V0IiwiaGFzIiwiYWRkIiwiQXJyYXkiLCJpc0FycmF5IiwibWFwIiwidiIsImpvaW4iLCJVaW50OEFycmF5IiwiSEVYIiwicmVzdWx0IiwiaSIsImxlbmd0aCIsInRvSlNPTiIsInRvU3RyaW5nIiwiQmlnSW50IiwiSlNPTiIsImtleXMiLCJPYmplY3QiLCJzb3J0IiwiayIsImlzRXJyb3IiLCJlcnJvciIsImNvZGUiLCJpc0NhbGxFeGNlcHRpb24iLCJtYWtlRXJyb3IiLCJtZXNzYWdlIiwiaW5mbyIsInNob3J0TWVzc2FnZSIsImRldGFpbHMiLCJFcnJvciIsImtleSIsInB1c2giLCJUeXBlRXJyb3IiLCJSYW5nZUVycm9yIiwiYXNzaWduIiwiYXNzZXJ0IiwiY2hlY2siLCJhc3NlcnRBcmd1bWVudCIsIm5hbWUiLCJhcmd1bWVudCIsImFzc2VydEFyZ3VtZW50Q291bnQiLCJjb3VudCIsImV4cGVjdGVkQ291bnQiLCJfbm9ybWFsaXplRm9ybXMiLCJyZWR1Y2UiLCJhY2N1bSIsImZvcm0iLCJub3JtYWxpemUiLCJTdHJpbmciLCJmcm9tQ2hhckNvZGUiLCJleHBlY3RlZCIsImFzc2VydE5vcm1hbGl6ZSIsImluZGV4T2YiLCJvcGVyYXRpb24iLCJhc3NlcnRQcml2YXRlIiwiZ2l2ZW5HdWFyZCIsImd1YXJkIiwiY2xhc3NOYW1lIiwibWV0aG9kIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.esm/utils/errors.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.esm/utils/events.js":
/*!*****************************************************!*\
  !*** ./node_modules/ethers/lib.esm/utils/events.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   EventPayload: () => (/* binding */ EventPayload)\n/* harmony export */ });\n/* harmony import */ var _properties_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./properties.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/properties.js\");\n/**\n *  Events allow for applications to use the observer pattern, which\n *  allows subscribing and publishing events, outside the normal\n *  execution paths.\n *\n *  @_section api/utils/events:Events  [about-events]\n */ \n/**\n *  When an [[EventEmitterable]] triggers a [[Listener]], the\n *  callback always ahas one additional argument passed, which is\n *  an **EventPayload**.\n */ class EventPayload {\n    #listener;\n    /**\n     *  Create a new **EventPayload** for %%emitter%% with\n     *  the %%listener%% and for %%filter%%.\n     */ constructor(emitter, listener, filter){\n        this.#listener = listener;\n        (0,_properties_js__WEBPACK_IMPORTED_MODULE_0__.defineProperties)(this, {\n            emitter,\n            filter\n        });\n    }\n    /**\n     *  Unregister the triggered listener for future events.\n     */ async removeListener() {\n        if (this.#listener == null) {\n            return;\n        }\n        await this.emitter.off(this.filter, this.#listener);\n    }\n} //# sourceMappingURL=events.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vdXRpbHMvZXZlbnRzLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7Ozs7OztDQU1DLEdBQ2tEO0FBQ25EOzs7O0NBSUMsR0FDTSxNQUFNQztJQVNULENBQUNDLFFBQVEsQ0FBQztJQUNWOzs7S0FHQyxHQUNEQyxZQUFZQyxPQUFPLEVBQUVGLFFBQVEsRUFBRUcsTUFBTSxDQUFFO1FBQ25DLElBQUksQ0FBQyxDQUFDSCxRQUFRLEdBQUdBO1FBQ2pCRixnRUFBZ0JBLENBQUMsSUFBSSxFQUFFO1lBQUVJO1lBQVNDO1FBQU87SUFDN0M7SUFDQTs7S0FFQyxHQUNELE1BQU1DLGlCQUFpQjtRQUNuQixJQUFJLElBQUksQ0FBQyxDQUFDSixRQUFRLElBQUksTUFBTTtZQUN4QjtRQUNKO1FBQ0EsTUFBTSxJQUFJLENBQUNFLE9BQU8sQ0FBQ0csR0FBRyxDQUFDLElBQUksQ0FBQ0YsTUFBTSxFQUFFLElBQUksQ0FBQyxDQUFDSCxRQUFRO0lBQ3REO0FBQ0osRUFDQSxrQ0FBa0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tZWdhdmliZS1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS91dGlscy9ldmVudHMuanM/NzMzZiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqICBFdmVudHMgYWxsb3cgZm9yIGFwcGxpY2F0aW9ucyB0byB1c2UgdGhlIG9ic2VydmVyIHBhdHRlcm4sIHdoaWNoXG4gKiAgYWxsb3dzIHN1YnNjcmliaW5nIGFuZCBwdWJsaXNoaW5nIGV2ZW50cywgb3V0c2lkZSB0aGUgbm9ybWFsXG4gKiAgZXhlY3V0aW9uIHBhdGhzLlxuICpcbiAqICBAX3NlY3Rpb24gYXBpL3V0aWxzL2V2ZW50czpFdmVudHMgIFthYm91dC1ldmVudHNdXG4gKi9cbmltcG9ydCB7IGRlZmluZVByb3BlcnRpZXMgfSBmcm9tIFwiLi9wcm9wZXJ0aWVzLmpzXCI7XG4vKipcbiAqICBXaGVuIGFuIFtbRXZlbnRFbWl0dGVyYWJsZV1dIHRyaWdnZXJzIGEgW1tMaXN0ZW5lcl1dLCB0aGVcbiAqICBjYWxsYmFjayBhbHdheXMgYWhhcyBvbmUgYWRkaXRpb25hbCBhcmd1bWVudCBwYXNzZWQsIHdoaWNoIGlzXG4gKiAgYW4gKipFdmVudFBheWxvYWQqKi5cbiAqL1xuZXhwb3J0IGNsYXNzIEV2ZW50UGF5bG9hZCB7XG4gICAgLyoqXG4gICAgICogIFRoZSBldmVudCBmaWx0ZXIuXG4gICAgICovXG4gICAgZmlsdGVyO1xuICAgIC8qKlxuICAgICAqICBUaGUgKipFdmVudEVtaXR0ZXJhYmxlKiouXG4gICAgICovXG4gICAgZW1pdHRlcjtcbiAgICAjbGlzdGVuZXI7XG4gICAgLyoqXG4gICAgICogIENyZWF0ZSBhIG5ldyAqKkV2ZW50UGF5bG9hZCoqIGZvciAlJWVtaXR0ZXIlJSB3aXRoXG4gICAgICogIHRoZSAlJWxpc3RlbmVyJSUgYW5kIGZvciAlJWZpbHRlciUlLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGVtaXR0ZXIsIGxpc3RlbmVyLCBmaWx0ZXIpIHtcbiAgICAgICAgdGhpcy4jbGlzdGVuZXIgPSBsaXN0ZW5lcjtcbiAgICAgICAgZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7IGVtaXR0ZXIsIGZpbHRlciB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFVucmVnaXN0ZXIgdGhlIHRyaWdnZXJlZCBsaXN0ZW5lciBmb3IgZnV0dXJlIGV2ZW50cy5cbiAgICAgKi9cbiAgICBhc3luYyByZW1vdmVMaXN0ZW5lcigpIHtcbiAgICAgICAgaWYgKHRoaXMuI2xpc3RlbmVyID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCB0aGlzLmVtaXR0ZXIub2ZmKHRoaXMuZmlsdGVyLCB0aGlzLiNsaXN0ZW5lcik7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXZlbnRzLmpzLm1hcCJdLCJuYW1lcyI6WyJkZWZpbmVQcm9wZXJ0aWVzIiwiRXZlbnRQYXlsb2FkIiwibGlzdGVuZXIiLCJjb25zdHJ1Y3RvciIsImVtaXR0ZXIiLCJmaWx0ZXIiLCJyZW1vdmVMaXN0ZW5lciIsIm9mZiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.esm/utils/events.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.esm/utils/fetch.js":
/*!****************************************************!*\
  !*** ./node_modules/ethers/lib.esm/utils/fetch.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FetchCancelSignal: () => (/* binding */ FetchCancelSignal),\n/* harmony export */   FetchRequest: () => (/* binding */ FetchRequest),\n/* harmony export */   FetchResponse: () => (/* binding */ FetchResponse)\n/* harmony export */ });\n/* harmony import */ var _base64_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./base64.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/base64.js\");\n/* harmony import */ var _data_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./data.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/data.js\");\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./errors.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/errors.js\");\n/* harmony import */ var _properties_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./properties.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/properties.js\");\n/* harmony import */ var _utf8_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utf8.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/utf8.js\");\n/* harmony import */ var _geturl_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./geturl.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/geturl.js\");\n/**\n *  Fetching content from the web is environment-specific, so Ethers\n *  provides an abstraction that each environment can implement to provide\n *  this service.\n *\n *  On [Node.js](link-node), the ``http`` and ``https`` libs are used to\n *  create a request object, register event listeners and process data\n *  and populate the [[FetchResponse]].\n *\n *  In a browser, the [DOM fetch](link-js-fetch) is used, and the resulting\n *  ``Promise`` is waited on to retrieve the payload.\n *\n *  The [[FetchRequest]] is responsible for handling many common situations,\n *  such as redirects, server throttling, authentication, etc.\n *\n *  It also handles common gateways, such as IPFS and data URIs.\n *\n *  @_section api/utils/fetching:Fetching Web Content  [about-fetch]\n */ \n\n\n\n\n\nconst MAX_ATTEMPTS = 12;\nconst SLOT_INTERVAL = 250;\n// The global FetchGetUrlFunc implementation.\nlet defaultGetUrlFunc = (0,_geturl_js__WEBPACK_IMPORTED_MODULE_0__.createGetUrl)();\nconst reData = new RegExp(\"^data:([^;:]*)?(;base64)?,(.*)$\", \"i\");\nconst reIpfs = new RegExp(\"^ipfs://(ipfs/)?(.*)$\", \"i\");\n// If locked, new Gateways cannot be added\nlet locked = false;\n// https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/Data_URLs\nasync function dataGatewayFunc(url, signal) {\n    try {\n        const match = url.match(reData);\n        if (!match) {\n            throw new Error(\"invalid data\");\n        }\n        return new FetchResponse(200, \"OK\", {\n            \"content-type\": match[1] || \"text/plain\"\n        }, match[2] ? (0,_base64_js__WEBPACK_IMPORTED_MODULE_1__.decodeBase64)(match[3]) : unpercent(match[3]));\n    } catch (error) {\n        return new FetchResponse(599, \"BAD REQUEST (invalid data: URI)\", {}, null, new FetchRequest(url));\n    }\n}\n/**\n *  Returns a [[FetchGatewayFunc]] for fetching content from a standard\n *  IPFS gateway hosted at %%baseUrl%%.\n */ function getIpfsGatewayFunc(baseUrl) {\n    async function gatewayIpfs(url, signal) {\n        try {\n            const match = url.match(reIpfs);\n            if (!match) {\n                throw new Error(\"invalid link\");\n            }\n            return new FetchRequest(`${baseUrl}${match[2]}`);\n        } catch (error) {\n            return new FetchResponse(599, \"BAD REQUEST (invalid IPFS URI)\", {}, null, new FetchRequest(url));\n        }\n    }\n    return gatewayIpfs;\n}\nconst Gateways = {\n    \"data\": dataGatewayFunc,\n    \"ipfs\": getIpfsGatewayFunc(\"https://gateway.ipfs.io/ipfs/\")\n};\nconst fetchSignals = new WeakMap();\n/**\n *  @_ignore\n */ class FetchCancelSignal {\n    #listeners;\n    #cancelled;\n    constructor(request){\n        this.#listeners = [];\n        this.#cancelled = false;\n        fetchSignals.set(request, ()=>{\n            if (this.#cancelled) {\n                return;\n            }\n            this.#cancelled = true;\n            for (const listener of this.#listeners){\n                setTimeout(()=>{\n                    listener();\n                }, 0);\n            }\n            this.#listeners = [];\n        });\n    }\n    addListener(listener) {\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_2__.assert)(!this.#cancelled, \"singal already cancelled\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"fetchCancelSignal.addCancelListener\"\n        });\n        this.#listeners.push(listener);\n    }\n    get cancelled() {\n        return this.#cancelled;\n    }\n    checkSignal() {\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_2__.assert)(!this.cancelled, \"cancelled\", \"CANCELLED\", {});\n    }\n}\n// Check the signal, throwing if it is cancelled\nfunction checkSignal(signal) {\n    if (signal == null) {\n        throw new Error(\"missing signal; should not happen\");\n    }\n    signal.checkSignal();\n    return signal;\n}\n/**\n *  Represents a request for a resource using a URI.\n *\n *  By default, the supported schemes are ``HTTP``, ``HTTPS``, ``data:``,\n *  and ``IPFS:``.\n *\n *  Additional schemes can be added globally using [[registerGateway]].\n *\n *  @example:\n *    req = new FetchRequest(\"https://www.ricmoo.com\")\n *    resp = await req.send()\n *    resp.body.length\n *    //_result:\n */ class FetchRequest {\n    #allowInsecure;\n    #gzip;\n    #headers;\n    #method;\n    #timeout;\n    #url;\n    #body;\n    #bodyType;\n    #creds;\n    // Hooks\n    #preflight;\n    #process;\n    #retry;\n    #signal;\n    #throttle;\n    #getUrlFunc;\n    /**\n     *  The fetch URL to request.\n     */ get url() {\n        return this.#url;\n    }\n    set url(url) {\n        this.#url = String(url);\n    }\n    /**\n     *  The fetch body, if any, to send as the request body. //(default: null)//\n     *\n     *  When setting a body, the intrinsic ``Content-Type`` is automatically\n     *  set and will be used if **not overridden** by setting a custom\n     *  header.\n     *\n     *  If %%body%% is null, the body is cleared (along with the\n     *  intrinsic ``Content-Type``).\n     *\n     *  If %%body%% is a string, the intrinsic ``Content-Type`` is set to\n     *  ``text/plain``.\n     *\n     *  If %%body%% is a Uint8Array, the intrinsic ``Content-Type`` is set to\n     *  ``application/octet-stream``.\n     *\n     *  If %%body%% is any other object, the intrinsic ``Content-Type`` is\n     *  set to ``application/json``.\n     */ get body() {\n        if (this.#body == null) {\n            return null;\n        }\n        return new Uint8Array(this.#body);\n    }\n    set body(body) {\n        if (body == null) {\n            this.#body = undefined;\n            this.#bodyType = undefined;\n        } else if (typeof body === \"string\") {\n            this.#body = (0,_utf8_js__WEBPACK_IMPORTED_MODULE_3__.toUtf8Bytes)(body);\n            this.#bodyType = \"text/plain\";\n        } else if (body instanceof Uint8Array) {\n            this.#body = body;\n            this.#bodyType = \"application/octet-stream\";\n        } else if (typeof body === \"object\") {\n            this.#body = (0,_utf8_js__WEBPACK_IMPORTED_MODULE_3__.toUtf8Bytes)(JSON.stringify(body));\n            this.#bodyType = \"application/json\";\n        } else {\n            throw new Error(\"invalid body\");\n        }\n    }\n    /**\n     *  Returns true if the request has a body.\n     */ hasBody() {\n        return this.#body != null;\n    }\n    /**\n     *  The HTTP method to use when requesting the URI. If no method\n     *  has been explicitly set, then ``GET`` is used if the body is\n     *  null and ``POST`` otherwise.\n     */ get method() {\n        if (this.#method) {\n            return this.#method;\n        }\n        if (this.hasBody()) {\n            return \"POST\";\n        }\n        return \"GET\";\n    }\n    set method(method) {\n        if (method == null) {\n            method = \"\";\n        }\n        this.#method = String(method).toUpperCase();\n    }\n    /**\n     *  The headers that will be used when requesting the URI. All\n     *  keys are lower-case.\n     *\n     *  This object is a copy, so any changes will **NOT** be reflected\n     *  in the ``FetchRequest``.\n     *\n     *  To set a header entry, use the ``setHeader`` method.\n     */ get headers() {\n        const headers = Object.assign({}, this.#headers);\n        if (this.#creds) {\n            headers[\"authorization\"] = `Basic ${(0,_base64_js__WEBPACK_IMPORTED_MODULE_1__.encodeBase64)((0,_utf8_js__WEBPACK_IMPORTED_MODULE_3__.toUtf8Bytes)(this.#creds))}`;\n        }\n        ;\n        if (this.allowGzip) {\n            headers[\"accept-encoding\"] = \"gzip\";\n        }\n        if (headers[\"content-type\"] == null && this.#bodyType) {\n            headers[\"content-type\"] = this.#bodyType;\n        }\n        if (this.body) {\n            headers[\"content-length\"] = String(this.body.length);\n        }\n        return headers;\n    }\n    /**\n     *  Get the header for %%key%%, ignoring case.\n     */ getHeader(key) {\n        return this.headers[key.toLowerCase()];\n    }\n    /**\n     *  Set the header for %%key%% to %%value%%. All values are coerced\n     *  to a string.\n     */ setHeader(key, value) {\n        this.#headers[String(key).toLowerCase()] = String(value);\n    }\n    /**\n     *  Clear all headers, resetting all intrinsic headers.\n     */ clearHeaders() {\n        this.#headers = {};\n    }\n    [Symbol.iterator]() {\n        const headers = this.headers;\n        const keys = Object.keys(headers);\n        let index = 0;\n        return {\n            next: ()=>{\n                if (index < keys.length) {\n                    const key = keys[index++];\n                    return {\n                        value: [\n                            key,\n                            headers[key]\n                        ],\n                        done: false\n                    };\n                }\n                return {\n                    value: undefined,\n                    done: true\n                };\n            }\n        };\n    }\n    /**\n     *  The value that will be sent for the ``Authorization`` header.\n     *\n     *  To set the credentials, use the ``setCredentials`` method.\n     */ get credentials() {\n        return this.#creds || null;\n    }\n    /**\n     *  Sets an ``Authorization`` for %%username%% with %%password%%.\n     */ setCredentials(username, password) {\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(!username.match(/:/), \"invalid basic authentication username\", \"username\", \"[REDACTED]\");\n        this.#creds = `${username}:${password}`;\n    }\n    /**\n     *  Enable and request gzip-encoded responses. The response will\n     *  automatically be decompressed. //(default: true)//\n     */ get allowGzip() {\n        return this.#gzip;\n    }\n    set allowGzip(value) {\n        this.#gzip = !!value;\n    }\n    /**\n     *  Allow ``Authentication`` credentials to be sent over insecure\n     *  channels. //(default: false)//\n     */ get allowInsecureAuthentication() {\n        return !!this.#allowInsecure;\n    }\n    set allowInsecureAuthentication(value) {\n        this.#allowInsecure = !!value;\n    }\n    /**\n     *  The timeout (in milliseconds) to wait for a complete response.\n     *  //(default: 5 minutes)//\n     */ get timeout() {\n        return this.#timeout;\n    }\n    set timeout(timeout) {\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(timeout >= 0, \"timeout must be non-zero\", \"timeout\", timeout);\n        this.#timeout = timeout;\n    }\n    /**\n     *  This function is called prior to each request, for example\n     *  during a redirection or retry in case of server throttling.\n     *\n     *  This offers an opportunity to populate headers or update\n     *  content before sending a request.\n     */ get preflightFunc() {\n        return this.#preflight || null;\n    }\n    set preflightFunc(preflight) {\n        this.#preflight = preflight;\n    }\n    /**\n     *  This function is called after each response, offering an\n     *  opportunity to provide client-level throttling or updating\n     *  response data.\n     *\n     *  Any error thrown in this causes the ``send()`` to throw.\n     *\n     *  To schedule a retry attempt (assuming the maximum retry limit\n     *  has not been reached), use [[response.throwThrottleError]].\n     */ get processFunc() {\n        return this.#process || null;\n    }\n    set processFunc(process) {\n        this.#process = process;\n    }\n    /**\n     *  This function is called on each retry attempt.\n     */ get retryFunc() {\n        return this.#retry || null;\n    }\n    set retryFunc(retry) {\n        this.#retry = retry;\n    }\n    /**\n     *  This function is called to fetch content from HTTP and\n     *  HTTPS URLs and is platform specific (e.g. nodejs vs\n     *  browsers).\n     *\n     *  This is by default the currently registered global getUrl\n     *  function, which can be changed using [[registerGetUrl]].\n     *  If this has been set, setting is to ``null`` will cause\n     *  this FetchRequest (and any future clones) to revert back to\n     *  using the currently registered global getUrl function.\n     *\n     *  Setting this is generally not necessary, but may be useful\n     *  for developers that wish to intercept requests or to\n     *  configurege a proxy or other agent.\n     */ get getUrlFunc() {\n        return this.#getUrlFunc || defaultGetUrlFunc;\n    }\n    set getUrlFunc(value) {\n        this.#getUrlFunc = value;\n    }\n    /**\n     *  Create a new FetchRequest instance with default values.\n     *\n     *  Once created, each property may be set before issuing a\n     *  ``.send()`` to make the request.\n     */ constructor(url){\n        this.#url = String(url);\n        this.#allowInsecure = false;\n        this.#gzip = true;\n        this.#headers = {};\n        this.#method = \"\";\n        this.#timeout = 300000;\n        this.#throttle = {\n            slotInterval: SLOT_INTERVAL,\n            maxAttempts: MAX_ATTEMPTS\n        };\n        this.#getUrlFunc = null;\n    }\n    toString() {\n        return `<FetchRequest method=${JSON.stringify(this.method)} url=${JSON.stringify(this.url)} headers=${JSON.stringify(this.headers)} body=${this.#body ? (0,_data_js__WEBPACK_IMPORTED_MODULE_4__.hexlify)(this.#body) : \"null\"}>`;\n    }\n    /**\n     *  Update the throttle parameters used to determine maximum\n     *  attempts and exponential-backoff properties.\n     */ setThrottleParams(params) {\n        if (params.slotInterval != null) {\n            this.#throttle.slotInterval = params.slotInterval;\n        }\n        if (params.maxAttempts != null) {\n            this.#throttle.maxAttempts = params.maxAttempts;\n        }\n    }\n    async #send(attempt, expires, delay, _request, _response) {\n        if (attempt >= this.#throttle.maxAttempts) {\n            return _response.makeServerError(\"exceeded maximum retry limit\");\n        }\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_2__.assert)(getTime() <= expires, \"timeout\", \"TIMEOUT\", {\n            operation: \"request.send\",\n            reason: \"timeout\",\n            request: _request\n        });\n        if (delay > 0) {\n            await wait(delay);\n        }\n        let req = this.clone();\n        const scheme = (req.url.split(\":\")[0] || \"\").toLowerCase();\n        // Process any Gateways\n        if (scheme in Gateways) {\n            const result = await Gateways[scheme](req.url, checkSignal(_request.#signal));\n            if (result instanceof FetchResponse) {\n                let response = result;\n                if (this.processFunc) {\n                    checkSignal(_request.#signal);\n                    try {\n                        response = await this.processFunc(req, response);\n                    } catch (error) {\n                        // Something went wrong during processing; throw a 5xx server error\n                        if (error.throttle == null || typeof error.stall !== \"number\") {\n                            response.makeServerError(\"error in post-processing function\", error).assertOk();\n                        }\n                    // Ignore throttling\n                    }\n                }\n                return response;\n            }\n            req = result;\n        }\n        // We have a preflight function; update the request\n        if (this.preflightFunc) {\n            req = await this.preflightFunc(req);\n        }\n        const resp = await this.getUrlFunc(req, checkSignal(_request.#signal));\n        let response = new FetchResponse(resp.statusCode, resp.statusMessage, resp.headers, resp.body, _request);\n        if (response.statusCode === 301 || response.statusCode === 302) {\n            // Redirect\n            try {\n                const location = response.headers.location || \"\";\n                return req.redirect(location).#send(attempt + 1, expires, 0, _request, response);\n            } catch (error) {}\n            // Things won't get any better on another attempt; abort\n            return response;\n        } else if (response.statusCode === 429) {\n            // Throttle\n            if (this.retryFunc == null || await this.retryFunc(req, response, attempt)) {\n                const retryAfter = response.headers[\"retry-after\"];\n                let delay = this.#throttle.slotInterval * Math.trunc(Math.random() * Math.pow(2, attempt));\n                if (typeof retryAfter === \"string\" && retryAfter.match(/^[1-9][0-9]*$/)) {\n                    delay = parseInt(retryAfter);\n                }\n                return req.clone().#send(attempt + 1, expires, delay, _request, response);\n            }\n        }\n        if (this.processFunc) {\n            checkSignal(_request.#signal);\n            try {\n                response = await this.processFunc(req, response);\n            } catch (error) {\n                // Something went wrong during processing; throw a 5xx server error\n                if (error.throttle == null || typeof error.stall !== \"number\") {\n                    response.makeServerError(\"error in post-processing function\", error).assertOk();\n                }\n                // Throttle\n                let delay = this.#throttle.slotInterval * Math.trunc(Math.random() * Math.pow(2, attempt));\n                ;\n                if (error.stall >= 0) {\n                    delay = error.stall;\n                }\n                return req.clone().#send(attempt + 1, expires, delay, _request, response);\n            }\n        }\n        return response;\n    }\n    /**\n     *  Resolves to the response by sending the request.\n     */ send() {\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_2__.assert)(this.#signal == null, \"request already sent\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"fetchRequest.send\"\n        });\n        this.#signal = new FetchCancelSignal(this);\n        return this.#send(0, getTime() + this.timeout, 0, this, new FetchResponse(0, \"\", {}, null, this));\n    }\n    /**\n     *  Cancels the inflight response, causing a ``CANCELLED``\n     *  error to be rejected from the [[send]].\n     */ cancel() {\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_2__.assert)(this.#signal != null, \"request has not been sent\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"fetchRequest.cancel\"\n        });\n        const signal = fetchSignals.get(this);\n        if (!signal) {\n            throw new Error(\"missing signal; should not happen\");\n        }\n        signal();\n    }\n    /**\n     *  Returns a new [[FetchRequest]] that represents the redirection\n     *  to %%location%%.\n     */ redirect(location) {\n        // Redirection; for now we only support absolute locations\n        const current = this.url.split(\":\")[0].toLowerCase();\n        const target = location.split(\":\")[0].toLowerCase();\n        // Don't allow redirecting:\n        // - non-GET requests\n        // - downgrading the security (e.g. https => http)\n        // - to non-HTTP (or non-HTTPS) protocols [this could be relaxed?]\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_2__.assert)(this.method === \"GET\" && (current !== \"https\" || target !== \"http\") && location.match(/^https?:/), `unsupported redirect`, \"UNSUPPORTED_OPERATION\", {\n            operation: `redirect(${this.method} ${JSON.stringify(this.url)} => ${JSON.stringify(location)})`\n        });\n        // Create a copy of this request, with a new URL\n        const req = new FetchRequest(location);\n        req.method = \"GET\";\n        req.allowGzip = this.allowGzip;\n        req.timeout = this.timeout;\n        req.#headers = Object.assign({}, this.#headers);\n        if (this.#body) {\n            req.#body = new Uint8Array(this.#body);\n        }\n        req.#bodyType = this.#bodyType;\n        // Do not forward credentials unless on the same domain; only absolute\n        //req.allowInsecure = false;\n        // paths are currently supported; may want a way to specify to forward?\n        //setStore(req.#props, \"creds\", getStore(this.#pros, \"creds\"));\n        return req;\n    }\n    /**\n     *  Create a new copy of this request.\n     */ clone() {\n        const clone = new FetchRequest(this.url);\n        // Preserve \"default method\" (i.e. null)\n        clone.#method = this.#method;\n        // Preserve \"default body\" with type, copying the Uint8Array is present\n        if (this.#body) {\n            clone.#body = this.#body;\n        }\n        clone.#bodyType = this.#bodyType;\n        // Preserve \"default headers\"\n        clone.#headers = Object.assign({}, this.#headers);\n        // Credentials is readonly, so we copy internally\n        clone.#creds = this.#creds;\n        if (this.allowGzip) {\n            clone.allowGzip = true;\n        }\n        clone.timeout = this.timeout;\n        if (this.allowInsecureAuthentication) {\n            clone.allowInsecureAuthentication = true;\n        }\n        clone.#preflight = this.#preflight;\n        clone.#process = this.#process;\n        clone.#retry = this.#retry;\n        clone.#throttle = Object.assign({}, this.#throttle);\n        clone.#getUrlFunc = this.#getUrlFunc;\n        return clone;\n    }\n    /**\n     *  Locks all static configuration for gateways and FetchGetUrlFunc\n     *  registration.\n     */ static lockConfig() {\n        locked = true;\n    }\n    /**\n     *  Get the current Gateway function for %%scheme%%.\n     */ static getGateway(scheme) {\n        return Gateways[scheme.toLowerCase()] || null;\n    }\n    /**\n     *  Use the %%func%% when fetching URIs using %%scheme%%.\n     *\n     *  This method affects all requests globally.\n     *\n     *  If [[lockConfig]] has been called, no change is made and this\n     *  throws.\n     */ static registerGateway(scheme, func) {\n        scheme = scheme.toLowerCase();\n        if (scheme === \"http\" || scheme === \"https\") {\n            throw new Error(`cannot intercept ${scheme}; use registerGetUrl`);\n        }\n        if (locked) {\n            throw new Error(\"gateways locked\");\n        }\n        Gateways[scheme] = func;\n    }\n    /**\n     *  Use %%getUrl%% when fetching URIs over HTTP and HTTPS requests.\n     *\n     *  This method affects all requests globally.\n     *\n     *  If [[lockConfig]] has been called, no change is made and this\n     *  throws.\n     */ static registerGetUrl(getUrl) {\n        if (locked) {\n            throw new Error(\"gateways locked\");\n        }\n        defaultGetUrlFunc = getUrl;\n    }\n    /**\n     *  Creates a getUrl function that fetches content from HTTP and\n     *  HTTPS URLs.\n     *\n     *  The available %%options%% are dependent on the platform\n     *  implementation of the default getUrl function.\n     *\n     *  This is not generally something that is needed, but is useful\n     *  when trying to customize simple behaviour when fetching HTTP\n     *  content.\n     */ static createGetUrlFunc(options) {\n        return (0,_geturl_js__WEBPACK_IMPORTED_MODULE_0__.createGetUrl)(options);\n    }\n    /**\n     *  Creates a function that can \"fetch\" data URIs.\n     *\n     *  Note that this is automatically done internally to support\n     *  data URIs, so it is not necessary to register it.\n     *\n     *  This is not generally something that is needed, but may\n     *  be useful in a wrapper to perfom custom data URI functionality.\n     */ static createDataGateway() {\n        return dataGatewayFunc;\n    }\n    /**\n     *  Creates a function that will fetch IPFS (unvalidated) from\n     *  a custom gateway baseUrl.\n     *\n     *  The default IPFS gateway used internally is\n     *  ``\"https:/\\/gateway.ipfs.io/ipfs/\"``.\n     */ static createIpfsGatewayFunc(baseUrl) {\n        return getIpfsGatewayFunc(baseUrl);\n    }\n}\n;\n/**\n *  The response for a FetchRequest.\n */ class FetchResponse {\n    #statusCode;\n    #statusMessage;\n    #headers;\n    #body;\n    #request;\n    #error;\n    toString() {\n        return `<FetchResponse status=${this.statusCode} body=${this.#body ? (0,_data_js__WEBPACK_IMPORTED_MODULE_4__.hexlify)(this.#body) : \"null\"}>`;\n    }\n    /**\n     *  The response status code.\n     */ get statusCode() {\n        return this.#statusCode;\n    }\n    /**\n     *  The response status message.\n     */ get statusMessage() {\n        return this.#statusMessage;\n    }\n    /**\n     *  The response headers. All keys are lower-case.\n     */ get headers() {\n        return Object.assign({}, this.#headers);\n    }\n    /**\n     *  The response body, or ``null`` if there was no body.\n     */ get body() {\n        return this.#body == null ? null : new Uint8Array(this.#body);\n    }\n    /**\n     *  The response body as a UTF-8 encoded string, or the empty\n     *  string (i.e. ``\"\"``) if there was no body.\n     *\n     *  An error is thrown if the body is invalid UTF-8 data.\n     */ get bodyText() {\n        try {\n            return this.#body == null ? \"\" : (0,_utf8_js__WEBPACK_IMPORTED_MODULE_3__.toUtf8String)(this.#body);\n        } catch (error) {\n            (0,_errors_js__WEBPACK_IMPORTED_MODULE_2__.assert)(false, \"response body is not valid UTF-8 data\", \"UNSUPPORTED_OPERATION\", {\n                operation: \"bodyText\",\n                info: {\n                    response: this\n                }\n            });\n        }\n    }\n    /**\n     *  The response body, decoded as JSON.\n     *\n     *  An error is thrown if the body is invalid JSON-encoded data\n     *  or if there was no body.\n     */ get bodyJson() {\n        try {\n            return JSON.parse(this.bodyText);\n        } catch (error) {\n            (0,_errors_js__WEBPACK_IMPORTED_MODULE_2__.assert)(false, \"response body is not valid JSON\", \"UNSUPPORTED_OPERATION\", {\n                operation: \"bodyJson\",\n                info: {\n                    response: this\n                }\n            });\n        }\n    }\n    [Symbol.iterator]() {\n        const headers = this.headers;\n        const keys = Object.keys(headers);\n        let index = 0;\n        return {\n            next: ()=>{\n                if (index < keys.length) {\n                    const key = keys[index++];\n                    return {\n                        value: [\n                            key,\n                            headers[key]\n                        ],\n                        done: false\n                    };\n                }\n                return {\n                    value: undefined,\n                    done: true\n                };\n            }\n        };\n    }\n    constructor(statusCode, statusMessage, headers, body, request){\n        this.#statusCode = statusCode;\n        this.#statusMessage = statusMessage;\n        this.#headers = Object.keys(headers).reduce((accum, k)=>{\n            accum[k.toLowerCase()] = String(headers[k]);\n            return accum;\n        }, {});\n        this.#body = body == null ? null : new Uint8Array(body);\n        this.#request = request || null;\n        this.#error = {\n            message: \"\"\n        };\n    }\n    /**\n     *  Return a Response with matching headers and body, but with\n     *  an error status code (i.e. 599) and %%message%% with an\n     *  optional %%error%%.\n     */ makeServerError(message, error) {\n        let statusMessage;\n        if (!message) {\n            message = `${this.statusCode} ${this.statusMessage}`;\n            statusMessage = `CLIENT ESCALATED SERVER ERROR (${message})`;\n        } else {\n            statusMessage = `CLIENT ESCALATED SERVER ERROR (${this.statusCode} ${this.statusMessage}; ${message})`;\n        }\n        const response = new FetchResponse(599, statusMessage, this.headers, this.body, this.#request || undefined);\n        response.#error = {\n            message,\n            error\n        };\n        return response;\n    }\n    /**\n     *  If called within a [request.processFunc](FetchRequest-processFunc)\n     *  call, causes the request to retry as if throttled for %%stall%%\n     *  milliseconds.\n     */ throwThrottleError(message, stall) {\n        if (stall == null) {\n            stall = -1;\n        } else {\n            (0,_errors_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(Number.isInteger(stall) && stall >= 0, \"invalid stall timeout\", \"stall\", stall);\n        }\n        const error = new Error(message || \"throttling requests\");\n        (0,_properties_js__WEBPACK_IMPORTED_MODULE_5__.defineProperties)(error, {\n            stall,\n            throttle: true\n        });\n        throw error;\n    }\n    /**\n     *  Get the header value for %%key%%, ignoring case.\n     */ getHeader(key) {\n        return this.headers[key.toLowerCase()];\n    }\n    /**\n     *  Returns true if the response has a body.\n     */ hasBody() {\n        return this.#body != null;\n    }\n    /**\n     *  The request made for this response.\n     */ get request() {\n        return this.#request;\n    }\n    /**\n     *  Returns true if this response was a success statusCode.\n     */ ok() {\n        return this.#error.message === \"\" && this.statusCode >= 200 && this.statusCode < 300;\n    }\n    /**\n     *  Throws a ``SERVER_ERROR`` if this response is not ok.\n     */ assertOk() {\n        if (this.ok()) {\n            return;\n        }\n        let { message, error } = this.#error;\n        if (message === \"\") {\n            message = `server response ${this.statusCode} ${this.statusMessage}`;\n        }\n        let requestUrl = null;\n        if (this.request) {\n            requestUrl = this.request.url;\n        }\n        let responseBody = null;\n        try {\n            if (this.#body) {\n                responseBody = (0,_utf8_js__WEBPACK_IMPORTED_MODULE_3__.toUtf8String)(this.#body);\n            }\n        } catch (e) {}\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_2__.assert)(false, message, \"SERVER_ERROR\", {\n            request: this.request || \"unknown request\",\n            response: this,\n            error,\n            info: {\n                requestUrl,\n                responseBody,\n                responseStatus: `${this.statusCode} ${this.statusMessage}`\n            }\n        });\n    }\n}\nfunction getTime() {\n    return new Date().getTime();\n}\nfunction unpercent(value) {\n    return (0,_utf8_js__WEBPACK_IMPORTED_MODULE_3__.toUtf8Bytes)(value.replace(/%([0-9a-f][0-9a-f])/gi, (all, code)=>{\n        return String.fromCharCode(parseInt(code, 16));\n    }));\n}\nfunction wait(delay) {\n    return new Promise((resolve)=>setTimeout(resolve, delay));\n} //# sourceMappingURL=fetch.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vdXRpbHMvZmV0Y2guanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQWtCQyxHQUN3RDtBQUNyQjtBQUNpQjtBQUNGO0FBQ0c7QUFDWDtBQUMzQyxNQUFNUyxlQUFlO0FBQ3JCLE1BQU1DLGdCQUFnQjtBQUN0Qiw2Q0FBNkM7QUFDN0MsSUFBSUMsb0JBQW9CSCx3REFBWUE7QUFDcEMsTUFBTUksU0FBUyxJQUFJQyxPQUFPLG1DQUFtQztBQUM3RCxNQUFNQyxTQUFTLElBQUlELE9BQU8seUJBQTBCO0FBQ3BELDBDQUEwQztBQUMxQyxJQUFJRSxTQUFTO0FBQ2IsNkVBQTZFO0FBQzdFLGVBQWVDLGdCQUFnQkMsR0FBRyxFQUFFQyxNQUFNO0lBQ3RDLElBQUk7UUFDQSxNQUFNQyxRQUFRRixJQUFJRSxLQUFLLENBQUNQO1FBQ3hCLElBQUksQ0FBQ08sT0FBTztZQUNSLE1BQU0sSUFBSUMsTUFBTTtRQUNwQjtRQUNBLE9BQU8sSUFBSUMsY0FBYyxLQUFLLE1BQU07WUFDaEMsZ0JBQWlCRixLQUFLLENBQUMsRUFBRSxJQUFJO1FBQ2pDLEdBQUlBLEtBQUssQ0FBQyxFQUFFLEdBQUduQix3REFBWUEsQ0FBQ21CLEtBQUssQ0FBQyxFQUFFLElBQUlHLFVBQVVILEtBQUssQ0FBQyxFQUFFO0lBQzlELEVBQ0EsT0FBT0ksT0FBTztRQUNWLE9BQU8sSUFBSUYsY0FBYyxLQUFLLG1DQUFtQyxDQUFDLEdBQUcsTUFBTSxJQUFJRyxhQUFhUDtJQUNoRztBQUNKO0FBQ0E7OztDQUdDLEdBQ0QsU0FBU1EsbUJBQW1CQyxPQUFPO0lBQy9CLGVBQWVDLFlBQVlWLEdBQUcsRUFBRUMsTUFBTTtRQUNsQyxJQUFJO1lBQ0EsTUFBTUMsUUFBUUYsSUFBSUUsS0FBSyxDQUFDTDtZQUN4QixJQUFJLENBQUNLLE9BQU87Z0JBQ1IsTUFBTSxJQUFJQyxNQUFNO1lBQ3BCO1lBQ0EsT0FBTyxJ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WSxPQUFPLElBQUtvRCxPQUFRcEQsT0FBTztBQUFJO0FBQ3BELFNBQVM3RSxVQUFVaUQsS0FBSztJQUNwQixPQUFPakUscURBQVdBLENBQUNpRSxNQUFNaUYsT0FBTyxDQUFDLHlCQUF5QixDQUFDQyxLQUFLQztRQUM1RCxPQUFPbEcsT0FBT21HLFlBQVksQ0FBQ25DLFNBQVNrQyxNQUFNO0lBQzlDO0FBQ0o7QUFDQSxTQUFTckQsS0FBS04sS0FBSztJQUNmLE9BQU8sSUFBSTZELFFBQVEsQ0FBQ0MsVUFBWXZILFdBQVd1SCxTQUFTOUQ7QUFDeEQsRUFDQSxpQ0FBaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tZWdhdmliZS1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS91dGlscy9mZXRjaC5qcz9lMWU1Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogIEZldGNoaW5nIGNvbnRlbnQgZnJvbSB0aGUgd2ViIGlzIGVudmlyb25tZW50LXNwZWNpZmljLCBzbyBFdGhlcnNcbiAqICBwcm92aWRlcyBhbiBhYnN0cmFjdGlvbiB0aGF0IGVhY2ggZW52aXJvbm1lbnQgY2FuIGltcGxlbWVudCB0byBwcm92aWRlXG4gKiAgdGhpcyBzZXJ2aWNlLlxuICpcbiAqICBPbiBbTm9kZS5qc10obGluay1ub2RlKSwgdGhlIGBgaHR0cGBgIGFuZCBgYGh0dHBzYGAgbGlicyBhcmUgdXNlZCB0b1xuICogIGNyZWF0ZSBhIHJlcXVlc3Qgb2JqZWN0LCByZWdpc3RlciBldmVudCBsaXN0ZW5lcnMgYW5kIHByb2Nlc3MgZGF0YVxuICogIGFuZCBwb3B1bGF0ZSB0aGUgW1tGZXRjaFJlc3BvbnNlXV0uXG4gKlxuICogIEluIGEgYnJvd3NlciwgdGhlIFtET00gZmV0Y2hdKGxpbmstanMtZmV0Y2gpIGlzIHVzZWQsIGFuZCB0aGUgcmVzdWx0aW5nXG4gKiAgYGBQcm9taXNlYGAgaXMgd2FpdGVkIG9uIHRvIHJldHJpZXZlIHRoZSBwYXlsb2FkLlxuICpcbiAqICBUaGUgW1tGZXRjaFJlcXVlc3RdXSBpcyByZXNwb25zaWJsZSBmb3IgaGFuZGxpbmcgbWFueSBjb21tb24gc2l0dWF0aW9ucyxcbiAqICBzdWNoIGFzIHJlZGlyZWN0cywgc2VydmVyIHRocm90dGxpbmcsIGF1dGhlbnRpY2F0aW9uLCBldGMuXG4gKlxuICogIEl0IGFsc28gaGFuZGxlcyBjb21tb24gZ2F0ZXdheXMsIHN1Y2ggYXMgSVBGUyBhbmQgZGF0YSBVUklzLlxuICpcbiAqICBAX3NlY3Rpb24gYXBpL3V0aWxzL2ZldGNoaW5nOkZldGNoaW5nIFdlYiBDb250ZW50ICBbYWJvdXQtZmV0Y2hdXG4gKi9cbmltcG9ydCB7IGRlY29kZUJhc2U2NCwgZW5jb2RlQmFzZTY0IH0gZnJvbSBcIi4vYmFzZTY0LmpzXCI7XG5pbXBvcnQgeyBoZXhsaWZ5IH0gZnJvbSBcIi4vZGF0YS5qc1wiO1xuaW1wb3J0IHsgYXNzZXJ0LCBhc3NlcnRBcmd1bWVudCB9IGZyb20gXCIuL2Vycm9ycy5qc1wiO1xuaW1wb3J0IHsgZGVmaW5lUHJvcGVydGllcyB9IGZyb20gXCIuL3Byb3BlcnRpZXMuanNcIjtcbmltcG9ydCB7IHRvVXRmOEJ5dGVzLCB0b1V0ZjhTdHJpbmcgfSBmcm9tIFwiLi91dGY4LmpzXCI7XG5pbXBvcnQgeyBjcmVhdGVHZXRVcmwgfSBmcm9tIFwiLi9nZXR1cmwuanNcIjtcbmNvbnN0IE1BWF9BVFRFTVBUUyA9IDEyO1xuY29uc3QgU0xPVF9JTlRFUlZBTCA9IDI1MDtcbi8vIFRoZSBnbG9iYWwgRmV0Y2hHZXRVcmxGdW5jIGltcGxlbWVudGF0aW9uLlxubGV0IGRlZmF1bHRHZXRVcmxGdW5jID0gY3JlYXRlR2V0VXJsKCk7XG5jb25zdCByZURhdGEgPSBuZXcgUmVnRXhwKFwiXmRhdGE6KFteOzpdKik/KDtiYXNlNjQpPywoLiopJFwiLCBcImlcIik7XG5jb25zdCByZUlwZnMgPSBuZXcgUmVnRXhwKFwiXmlwZnM6L1xcLyhpcGZzLyk/KC4qKSRcIiwgXCJpXCIpO1xuLy8gSWYgbG9ja2VkLCBuZXcgR2F0ZXdheXMgY2Fubm90IGJlIGFkZGVkXG5sZXQgbG9ja2VkID0gZmFsc2U7XG4vLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9IVFRQL0Jhc2ljc19vZl9IVFRQL0RhdGFfVVJMc1xuYXN5bmMgZnVuY3Rpb24gZGF0YUdhdGV3YXlGdW5jKHVybCwgc2lnbmFsKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgbWF0Y2ggPSB1cmwubWF0Y2gocmVEYXRhKTtcbiAgICAgICAgaWYgKCFtYXRjaCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBkYXRhXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgRmV0Y2hSZXNwb25zZSgyMDAsIFwiT0tcIiwge1xuICAgICAgICAgICAgXCJjb250ZW50LXR5cGVcIjogKG1hdGNoWzFdIHx8IFwidGV4dC9wbGFpblwiKSxcbiAgICAgICAgfSwgKG1hdGNoWzJdID8gZGVjb2RlQmFzZTY0KG1hdGNoWzNdKSA6IHVucGVyY2VudChtYXRjaFszXSkpKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHJldHVybiBuZXcgRmV0Y2hSZXNwb25zZSg1OTksIFwiQkFEIFJFUVVFU1QgKGludmFsaWQgZGF0YTogVVJJKVwiLCB7fSwgbnVsbCwgbmV3IEZldGNoUmVxdWVzdCh1cmwpKTtcbiAgICB9XG59XG4vKipcbiAqICBSZXR1cm5zIGEgW1tGZXRjaEdhdGV3YXlGdW5jXV0gZm9yIGZldGNoaW5nIGNvbnRlbnQgZnJvbSBhIHN0YW5kYXJkXG4gKiAgSVBGUyBnYXRld2F5IGhvc3RlZCBhdCAlJWJhc2VVcmwlJS5cbiAqL1xuZnVuY3Rpb24gZ2V0SXBmc0dhdGV3YXlGdW5jKGJhc2VVcmwpIHtcbiAgICBhc3luYyBmdW5jdGlvbiBnYXRld2F5SXBmcyh1cmwsIHNpZ25hbCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgbWF0Y2ggPSB1cmwubWF0Y2gocmVJcGZzKTtcbiAgICAgICAgICAgIGlmICghbWF0Y2gpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGxpbmtcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IEZldGNoUmVxdWVzdChgJHtiYXNlVXJsfSR7bWF0Y2hbMl19YCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEZldGNoUmVzcG9uc2UoNTk5LCBcIkJBRCBSRVFVRVNUIChpbnZhbGlkIElQRlMgVVJJKVwiLCB7fSwgbnVsbCwgbmV3IEZldGNoUmVxdWVzdCh1cmwpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZ2F0ZXdheUlwZnM7XG59XG5jb25zdCBHYXRld2F5cyA9IHtcbiAgICBcImRhdGFcIjogZGF0YUdhdGV3YXlGdW5jLFxuICAgIFwiaXBmc1wiOiBnZXRJcGZzR2F0ZXdheUZ1bmMoXCJodHRwczovXFwvZ2F0ZXdheS5pcGZzLmlvL2lwZnMvXCIpXG59O1xuY29uc3QgZmV0Y2hTaWduYWxzID0gbmV3IFdlYWtNYXAoKTtcbi8qKlxuICogIEBfaWdub3JlXG4gKi9cbmV4cG9ydCBjbGFzcyBGZXRjaENhbmNlbFNpZ25hbCB7XG4gICAgI2xpc3RlbmVycztcbiAgICAjY2FuY2VsbGVkO1xuICAgIGNvbnN0cnVjdG9yKHJlcXVlc3QpIHtcbiAgICAgICAgdGhpcy4jbGlzdGVuZXJzID0gW107XG4gICAgICAgIHRoaXMuI2NhbmNlbGxlZCA9IGZhbHNlO1xuICAgICAgICBmZXRjaFNpZ25hbHMuc2V0KHJlcXVlc3QsICgpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLiNjYW5jZWxsZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLiNjYW5jZWxsZWQgPSB0cnVlO1xuICAgICAgICAgICAgZm9yIChjb25zdCBsaXN0ZW5lciBvZiB0aGlzLiNsaXN0ZW5lcnMpIHtcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHsgbGlzdGVuZXIoKTsgfSwgMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLiNsaXN0ZW5lcnMgPSBbXTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFkZExpc3RlbmVyKGxpc3RlbmVyKSB7XG4gICAgICAgIGFzc2VydCghdGhpcy4jY2FuY2VsbGVkLCBcInNpbmdhbCBhbHJlYWR5IGNhbmNlbGxlZFwiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7XG4gICAgICAgICAgICBvcGVyYXRpb246IFwiZmV0Y2hDYW5jZWxTaWduYWwuYWRkQ2FuY2VsTGlzdGVuZXJcIlxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy4jbGlzdGVuZXJzLnB1c2gobGlzdGVuZXIpO1xuICAgIH1cbiAgICBnZXQgY2FuY2VsbGVkKCkgeyByZXR1cm4gdGhpcy4jY2FuY2VsbGVkOyB9XG4gICAgY2hlY2tTaWduYWwoKSB7XG4gICAgICAgIGFzc2VydCghdGhpcy5jYW5jZWxsZWQsIFwiY2FuY2VsbGVkXCIsIFwiQ0FOQ0VMTEVEXCIsIHt9KTtcbiAgICB9XG59XG4vLyBDaGVjayB0aGUgc2lnbmFsLCB0aHJvd2luZyBpZiBpdCBpcyBjYW5jZWxsZWRcbmZ1bmN0aW9uIGNoZWNrU2lnbmFsKHNpZ25hbCkge1xuICAgIGlmIChzaWduYWwgPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJtaXNzaW5nIHNpZ25hbDsgc2hvdWxkIG5vdCBoYXBwZW5cIik7XG4gICAgfVxuICAgIHNpZ25hbC5jaGVja1NpZ25hbCgpO1xuICAgIHJldHVybiBzaWduYWw7XG59XG4vKipcbiAqICBSZXByZXNlbnRzIGEgcmVxdWVzdCBmb3IgYSByZXNvdXJjZSB1c2luZyBhIFVSSS5cbiAqXG4gKiAgQnkgZGVmYXVsdCwgdGhlIHN1cHBvcnRlZCBzY2hlbWVzIGFyZSBgYEhUVFBgYCwgYGBIVFRQU2BgLCBgYGRhdGE6YGAsXG4gKiAgYW5kIGBgSVBGUzpgYC5cbiAqXG4gKiAgQWRkaXRpb25hbCBzY2hlbWVzIGNhbiBiZSBhZGRlZCBnbG9iYWxseSB1c2luZyBbW3JlZ2lzdGVyR2F0ZXdheV1dLlxuICpcbiAqICBAZXhhbXBsZTpcbiAqICAgIHJlcSA9IG5ldyBGZXRjaFJlcXVlc3QoXCJodHRwczovL3d3dy5yaWNtb28uY29tXCIpXG4gKiAgICByZXNwID0gYXdhaXQgcmVxLnNlbmQoKVxuICogICAgcmVzcC5ib2R5Lmxlbmd0aFxuICogICAgLy9fcmVzdWx0OlxuICovXG5leHBvcnQgY2xhc3MgRmV0Y2hSZXF1ZXN0IHtcbiAgICAjYWxsb3dJbnNlY3VyZTtcbiAgICAjZ3ppcDtcbiAgICAjaGVhZGVycztcbiAgICAjbWV0aG9kO1xuICAgICN0aW1lb3V0O1xuICAgICN1cmw7XG4gICAgI2JvZHk7XG4gICAgI2JvZHlUeXBlO1xuICAgICNjcmVkcztcbiAgICAvLyBIb29rc1xuICAgICNwcmVmbGlnaHQ7XG4gICAgI3Byb2Nlc3M7XG4gICAgI3JldHJ5O1xuICAgICNzaWduYWw7XG4gICAgI3Rocm90dGxlO1xuICAgICNnZXRVcmxGdW5jO1xuICAgIC8qKlxuICAgICAqICBUaGUgZmV0Y2ggVVJMIHRvIHJlcXVlc3QuXG4gICAgICovXG4gICAgZ2V0IHVybCgpIHsgcmV0dXJuIHRoaXMuI3VybDsgfVxuICAgIHNldCB1cmwodXJsKSB7XG4gICAgICAgIHRoaXMuI3VybCA9IFN0cmluZyh1cmwpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhlIGZldGNoIGJvZHksIGlmIGFueSwgdG8gc2VuZCBhcyB0aGUgcmVxdWVzdCBib2R5LiAvLyhkZWZhdWx0OiBudWxsKS8vXG4gICAgICpcbiAgICAgKiAgV2hlbiBzZXR0aW5nIGEgYm9keSwgdGhlIGludHJpbnNpYyBgYENvbnRlbnQtVHlwZWBgIGlzIGF1dG9tYXRpY2FsbHlcbiAgICAgKiAgc2V0IGFuZCB3aWxsIGJlIHVzZWQgaWYgKipub3Qgb3ZlcnJpZGRlbioqIGJ5IHNldHRpbmcgYSBjdXN0b21cbiAgICAgKiAgaGVhZGVyLlxuICAgICAqXG4gICAgICogIElmICUlYm9keSUlIGlzIG51bGwsIHRoZSBib2R5IGlzIGNsZWFyZWQgKGFsb25nIHdpdGggdGhlXG4gICAgICogIGludHJpbnNpYyBgYENvbnRlbnQtVHlwZWBgKS5cbiAgICAgKlxuICAgICAqICBJZiAlJWJvZHklJSBpcyBhIHN0cmluZywgdGhlIGludHJpbnNpYyBgYENvbnRlbnQtVHlwZWBgIGlzIHNldCB0b1xuICAgICAqICBgYHRleHQvcGxhaW5gYC5cbiAgICAgKlxuICAgICAqICBJZiAlJWJvZHklJSBpcyBhIFVpbnQ4QXJyYXksIHRoZSBpbnRyaW5zaWMgYGBDb250ZW50LVR5cGVgYCBpcyBzZXQgdG9cbiAgICAgKiAgYGBhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW1gYC5cbiAgICAgKlxuICAgICAqICBJZiAlJWJvZHklJSBpcyBhbnkgb3RoZXIgb2JqZWN0LCB0aGUgaW50cmluc2ljIGBgQ29udGVudC1UeXBlYGAgaXNcbiAgICAgKiAgc2V0IHRvIGBgYXBwbGljYXRpb24vanNvbmBgLlxuICAgICAqL1xuICAgIGdldCBib2R5KCkge1xuICAgICAgICBpZiAodGhpcy4jYm9keSA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkodGhpcy4jYm9keSk7XG4gICAgfVxuICAgIHNldCBib2R5KGJvZHkpIHtcbiAgICAgICAgaWYgKGJvZHkgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy4jYm9keSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHRoaXMuI2JvZHlUeXBlID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiAoYm9keSkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHRoaXMuI2JvZHkgPSB0b1V0ZjhCeXRlcyhib2R5KTtcbiAgICAgICAgICAgIHRoaXMuI2JvZHlUeXBlID0gXCJ0ZXh0L3BsYWluXCI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYm9keSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICAgICAgICAgIHRoaXMuI2JvZHkgPSBib2R5O1xuICAgICAgICAgICAgdGhpcy4jYm9keVR5cGUgPSBcImFwcGxpY2F0aW9uL29jdGV0LXN0cmVhbVwiO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiAoYm9keSkgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgIHRoaXMuI2JvZHkgPSB0b1V0ZjhCeXRlcyhKU09OLnN0cmluZ2lmeShib2R5KSk7XG4gICAgICAgICAgICB0aGlzLiNib2R5VHlwZSA9IFwiYXBwbGljYXRpb24vanNvblwiO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBib2R5XCIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRydWUgaWYgdGhlIHJlcXVlc3QgaGFzIGEgYm9keS5cbiAgICAgKi9cbiAgICBoYXNCb2R5KCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuI2JvZHkgIT0gbnVsbCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgSFRUUCBtZXRob2QgdG8gdXNlIHdoZW4gcmVxdWVzdGluZyB0aGUgVVJJLiBJZiBubyBtZXRob2RcbiAgICAgKiAgaGFzIGJlZW4gZXhwbGljaXRseSBzZXQsIHRoZW4gYGBHRVRgYCBpcyB1c2VkIGlmIHRoZSBib2R5IGlzXG4gICAgICogIG51bGwgYW5kIGBgUE9TVGBgIG90aGVyd2lzZS5cbiAgICAgKi9cbiAgICBnZXQgbWV0aG9kKCkge1xuICAgICAgICBpZiAodGhpcy4jbWV0aG9kKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy4jbWV0aG9kO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmhhc0JvZHkoKSkge1xuICAgICAgICAgICAgcmV0dXJuIFwiUE9TVFwiO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBcIkdFVFwiO1xuICAgIH1cbiAgICBzZXQgbWV0aG9kKG1ldGhvZCkge1xuICAgICAgICBpZiAobWV0aG9kID09IG51bGwpIHtcbiAgICAgICAgICAgIG1ldGhvZCA9IFwiXCI7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4jbWV0aG9kID0gU3RyaW5nKG1ldGhvZCkudG9VcHBlckNhc2UoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRoZSBoZWFkZXJzIHRoYXQgd2lsbCBiZSB1c2VkIHdoZW4gcmVxdWVzdGluZyB0aGUgVVJJLiBBbGxcbiAgICAgKiAga2V5cyBhcmUgbG93ZXItY2FzZS5cbiAgICAgKlxuICAgICAqICBUaGlzIG9iamVjdCBpcyBhIGNvcHksIHNvIGFueSBjaGFuZ2VzIHdpbGwgKipOT1QqKiBiZSByZWZsZWN0ZWRcbiAgICAgKiAgaW4gdGhlIGBgRmV0Y2hSZXF1ZXN0YGAuXG4gICAgICpcbiAgICAgKiAgVG8gc2V0IGEgaGVhZGVyIGVudHJ5LCB1c2UgdGhlIGBgc2V0SGVhZGVyYGAgbWV0aG9kLlxuICAgICAqL1xuICAgIGdldCBoZWFkZXJzKCkge1xuICAgICAgICBjb25zdCBoZWFkZXJzID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy4jaGVhZGVycyk7XG4gICAgICAgIGlmICh0aGlzLiNjcmVkcykge1xuICAgICAgICAgICAgaGVhZGVyc1tcImF1dGhvcml6YXRpb25cIl0gPSBgQmFzaWMgJHtlbmNvZGVCYXNlNjQodG9VdGY4Qnl0ZXModGhpcy4jY3JlZHMpKX1gO1xuICAgICAgICB9XG4gICAgICAgIDtcbiAgICAgICAgaWYgKHRoaXMuYWxsb3dHemlwKSB7XG4gICAgICAgICAgICBoZWFkZXJzW1wiYWNjZXB0LWVuY29kaW5nXCJdID0gXCJnemlwXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhlYWRlcnNbXCJjb250ZW50LXR5cGVcIl0gPT0gbnVsbCAmJiB0aGlzLiNib2R5VHlwZSkge1xuICAgICAgICAgICAgaGVhZGVyc1tcImNvbnRlbnQtdHlwZVwiXSA9IHRoaXMuI2JvZHlUeXBlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmJvZHkpIHtcbiAgICAgICAgICAgIGhlYWRlcnNbXCJjb250ZW50LWxlbmd0aFwiXSA9IFN0cmluZyh0aGlzLmJvZHkubGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaGVhZGVycztcbiAgICB9XG4gICAgLyoqXG4gICAgICogIEdldCB0aGUgaGVhZGVyIGZvciAlJWtleSUlLCBpZ25vcmluZyBjYXNlLlxuICAgICAqL1xuICAgIGdldEhlYWRlcihrZXkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaGVhZGVyc1trZXkudG9Mb3dlckNhc2UoKV07XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBTZXQgdGhlIGhlYWRlciBmb3IgJSVrZXklJSB0byAlJXZhbHVlJSUuIEFsbCB2YWx1ZXMgYXJlIGNvZXJjZWRcbiAgICAgKiAgdG8gYSBzdHJpbmcuXG4gICAgICovXG4gICAgc2V0SGVhZGVyKGtleSwgdmFsdWUpIHtcbiAgICAgICAgdGhpcy4jaGVhZGVyc1tTdHJpbmcoa2V5KS50b0xvd2VyQ2FzZSgpXSA9IFN0cmluZyh2YWx1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBDbGVhciBhbGwgaGVhZGVycywgcmVzZXR0aW5nIGFsbCBpbnRyaW5zaWMgaGVhZGVycy5cbiAgICAgKi9cbiAgICBjbGVhckhlYWRlcnMoKSB7XG4gICAgICAgIHRoaXMuI2hlYWRlcnMgPSB7fTtcbiAgICB9XG4gICAgW1N5bWJvbC5pdGVyYXRvcl0oKSB7XG4gICAgICAgIGNvbnN0IGhlYWRlcnMgPSB0aGlzLmhlYWRlcnM7XG4gICAgICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhoZWFkZXJzKTtcbiAgICAgICAgbGV0IGluZGV4ID0gMDtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5leHQ6ICgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggPCBrZXlzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBrZXkgPSBrZXlzW2luZGV4KytdO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IFtrZXksIGhlYWRlcnNba2V5XV0sIGRvbmU6IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiB1bmRlZmluZWQsIGRvbmU6IHRydWUgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRoZSB2YWx1ZSB0aGF0IHdpbGwgYmUgc2VudCBmb3IgdGhlIGBgQXV0aG9yaXphdGlvbmBgIGhlYWRlci5cbiAgICAgKlxuICAgICAqICBUbyBzZXQgdGhlIGNyZWRlbnRpYWxzLCB1c2UgdGhlIGBgc2V0Q3JlZGVudGlhbHNgYCBtZXRob2QuXG4gICAgICovXG4gICAgZ2V0IGNyZWRlbnRpYWxzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4jY3JlZHMgfHwgbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFNldHMgYW4gYGBBdXRob3JpemF0aW9uYGAgZm9yICUldXNlcm5hbWUlJSB3aXRoICUlcGFzc3dvcmQlJS5cbiAgICAgKi9cbiAgICBzZXRDcmVkZW50aWFscyh1c2VybmFtZSwgcGFzc3dvcmQpIHtcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQoIXVzZXJuYW1lLm1hdGNoKC86LyksIFwiaW52YWxpZCBiYXNpYyBhdXRoZW50aWNhdGlvbiB1c2VybmFtZVwiLCBcInVzZXJuYW1lXCIsIFwiW1JFREFDVEVEXVwiKTtcbiAgICAgICAgdGhpcy4jY3JlZHMgPSBgJHt1c2VybmFtZX06JHtwYXNzd29yZH1gO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgRW5hYmxlIGFuZCByZXF1ZXN0IGd6aXAtZW5jb2RlZCByZXNwb25zZXMuIFRoZSByZXNwb25zZSB3aWxsXG4gICAgICogIGF1dG9tYXRpY2FsbHkgYmUgZGVjb21wcmVzc2VkLiAvLyhkZWZhdWx0OiB0cnVlKS8vXG4gICAgICovXG4gICAgZ2V0IGFsbG93R3ppcCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI2d6aXA7XG4gICAgfVxuICAgIHNldCBhbGxvd0d6aXAodmFsdWUpIHtcbiAgICAgICAgdGhpcy4jZ3ppcCA9ICEhdmFsdWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBBbGxvdyBgYEF1dGhlbnRpY2F0aW9uYGAgY3JlZGVudGlhbHMgdG8gYmUgc2VudCBvdmVyIGluc2VjdXJlXG4gICAgICogIGNoYW5uZWxzLiAvLyhkZWZhdWx0OiBmYWxzZSkvL1xuICAgICAqL1xuICAgIGdldCBhbGxvd0luc2VjdXJlQXV0aGVudGljYXRpb24oKSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMuI2FsbG93SW5zZWN1cmU7XG4gICAgfVxuICAgIHNldCBhbGxvd0luc2VjdXJlQXV0aGVudGljYXRpb24odmFsdWUpIHtcbiAgICAgICAgdGhpcy4jYWxsb3dJbnNlY3VyZSA9ICEhdmFsdWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgdGltZW91dCAoaW4gbWlsbGlzZWNvbmRzKSB0byB3YWl0IGZvciBhIGNvbXBsZXRlIHJlc3BvbnNlLlxuICAgICAqICAvLyhkZWZhdWx0OiA1IG1pbnV0ZXMpLy9cbiAgICAgKi9cbiAgICBnZXQgdGltZW91dCgpIHsgcmV0dXJuIHRoaXMuI3RpbWVvdXQ7IH1cbiAgICBzZXQgdGltZW91dCh0aW1lb3V0KSB7XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KHRpbWVvdXQgPj0gMCwgXCJ0aW1lb3V0IG11c3QgYmUgbm9uLXplcm9cIiwgXCJ0aW1lb3V0XCIsIHRpbWVvdXQpO1xuICAgICAgICB0aGlzLiN0aW1lb3V0ID0gdGltZW91dDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIHByaW9yIHRvIGVhY2ggcmVxdWVzdCwgZm9yIGV4YW1wbGVcbiAgICAgKiAgZHVyaW5nIGEgcmVkaXJlY3Rpb24gb3IgcmV0cnkgaW4gY2FzZSBvZiBzZXJ2ZXIgdGhyb3R0bGluZy5cbiAgICAgKlxuICAgICAqICBUaGlzIG9mZmVycyBhbiBvcHBvcnR1bml0eSB0byBwb3B1bGF0ZSBoZWFkZXJzIG9yIHVwZGF0ZVxuICAgICAqICBjb250ZW50IGJlZm9yZSBzZW5kaW5nIGEgcmVxdWVzdC5cbiAgICAgKi9cbiAgICBnZXQgcHJlZmxpZ2h0RnVuYygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI3ByZWZsaWdodCB8fCBudWxsO1xuICAgIH1cbiAgICBzZXQgcHJlZmxpZ2h0RnVuYyhwcmVmbGlnaHQpIHtcbiAgICAgICAgdGhpcy4jcHJlZmxpZ2h0ID0gcHJlZmxpZ2h0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgYWZ0ZXIgZWFjaCByZXNwb25zZSwgb2ZmZXJpbmcgYW5cbiAgICAgKiAgb3Bwb3J0dW5pdHkgdG8gcHJvdmlkZSBjbGllbnQtbGV2ZWwgdGhyb3R0bGluZyBvciB1cGRhdGluZ1xuICAgICAqICByZXNwb25zZSBkYXRhLlxuICAgICAqXG4gICAgICogIEFueSBlcnJvciB0aHJvd24gaW4gdGhpcyBjYXVzZXMgdGhlIGBgc2VuZCgpYGAgdG8gdGhyb3cuXG4gICAgICpcbiAgICAgKiAgVG8gc2NoZWR1bGUgYSByZXRyeSBhdHRlbXB0IChhc3N1bWluZyB0aGUgbWF4aW11bSByZXRyeSBsaW1pdFxuICAgICAqICBoYXMgbm90IGJlZW4gcmVhY2hlZCksIHVzZSBbW3Jlc3BvbnNlLnRocm93VGhyb3R0bGVFcnJvcl1dLlxuICAgICAqL1xuICAgIGdldCBwcm9jZXNzRnVuYygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI3Byb2Nlc3MgfHwgbnVsbDtcbiAgICB9XG4gICAgc2V0IHByb2Nlc3NGdW5jKHByb2Nlc3MpIHtcbiAgICAgICAgdGhpcy4jcHJvY2VzcyA9IHByb2Nlc3M7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCBvbiBlYWNoIHJldHJ5IGF0dGVtcHQuXG4gICAgICovXG4gICAgZ2V0IHJldHJ5RnVuYygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI3JldHJ5IHx8IG51bGw7XG4gICAgfVxuICAgIHNldCByZXRyeUZ1bmMocmV0cnkpIHtcbiAgICAgICAgdGhpcy4jcmV0cnkgPSByZXRyeTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIHRvIGZldGNoIGNvbnRlbnQgZnJvbSBIVFRQIGFuZFxuICAgICAqICBIVFRQUyBVUkxzIGFuZCBpcyBwbGF0Zm9ybSBzcGVjaWZpYyAoZS5nLiBub2RlanMgdnNcbiAgICAgKiAgYnJvd3NlcnMpLlxuICAgICAqXG4gICAgICogIFRoaXMgaXMgYnkgZGVmYXVsdCB0aGUgY3VycmVudGx5IHJlZ2lzdGVyZWQgZ2xvYmFsIGdldFVybFxuICAgICAqICBmdW5jdGlvbiwgd2hpY2ggY2FuIGJlIGNoYW5nZWQgdXNpbmcgW1tyZWdpc3RlckdldFVybF1dLlxuICAgICAqICBJZiB0aGlzIGhhcyBiZWVuIHNldCwgc2V0dGluZyBpcyB0byBgYG51bGxgYCB3aWxsIGNhdXNlXG4gICAgICogIHRoaXMgRmV0Y2hSZXF1ZXN0IChhbmQgYW55IGZ1dHVyZSBjbG9uZXMpIHRvIHJldmVydCBiYWNrIHRvXG4gICAgICogIHVzaW5nIHRoZSBjdXJyZW50bHkgcmVnaXN0ZXJlZCBnbG9iYWwgZ2V0VXJsIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogIFNldHRpbmcgdGhpcyBpcyBnZW5lcmFsbHkgbm90IG5lY2Vzc2FyeSwgYnV0IG1heSBiZSB1c2VmdWxcbiAgICAgKiAgZm9yIGRldmVsb3BlcnMgdGhhdCB3aXNoIHRvIGludGVyY2VwdCByZXF1ZXN0cyBvciB0b1xuICAgICAqICBjb25maWd1cmVnZSBhIHByb3h5IG9yIG90aGVyIGFnZW50LlxuICAgICAqL1xuICAgIGdldCBnZXRVcmxGdW5jKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4jZ2V0VXJsRnVuYyB8fCBkZWZhdWx0R2V0VXJsRnVuYztcbiAgICB9XG4gICAgc2V0IGdldFVybEZ1bmModmFsdWUpIHtcbiAgICAgICAgdGhpcy4jZ2V0VXJsRnVuYyA9IHZhbHVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlIGEgbmV3IEZldGNoUmVxdWVzdCBpbnN0YW5jZSB3aXRoIGRlZmF1bHQgdmFsdWVzLlxuICAgICAqXG4gICAgICogIE9uY2UgY3JlYXRlZCwgZWFjaCBwcm9wZXJ0eSBtYXkgYmUgc2V0IGJlZm9yZSBpc3N1aW5nIGFcbiAgICAgKiAgYGAuc2VuZCgpYGAgdG8gbWFrZSB0aGUgcmVxdWVzdC5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih1cmwpIHtcbiAgICAgICAgdGhpcy4jdXJsID0gU3RyaW5nKHVybCk7XG4gICAgICAgIHRoaXMuI2FsbG93SW5zZWN1cmUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy4jZ3ppcCA9IHRydWU7XG4gICAgICAgIHRoaXMuI2hlYWRlcnMgPSB7fTtcbiAgICAgICAgdGhpcy4jbWV0aG9kID0gXCJcIjtcbiAgICAgICAgdGhpcy4jdGltZW91dCA9IDMwMDAwMDtcbiAgICAgICAgdGhpcy4jdGhyb3R0bGUgPSB7XG4gICAgICAgICAgICBzbG90SW50ZXJ2YWw6IFNMT1RfSU5URVJWQUwsXG4gICAgICAgICAgICBtYXhBdHRlbXB0czogTUFYX0FUVEVNUFRTXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuI2dldFVybEZ1bmMgPSBudWxsO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIGA8RmV0Y2hSZXF1ZXN0IG1ldGhvZD0ke0pTT04uc3RyaW5naWZ5KHRoaXMubWV0aG9kKX0gdXJsPSR7SlNPTi5zdHJpbmdpZnkodGhpcy51cmwpfSBoZWFkZXJzPSR7SlNPTi5zdHJpbmdpZnkodGhpcy5oZWFkZXJzKX0gYm9keT0ke3RoaXMuI2JvZHkgPyBoZXhsaWZ5KHRoaXMuI2JvZHkpIDogXCJudWxsXCJ9PmA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBVcGRhdGUgdGhlIHRocm90dGxlIHBhcmFtZXRlcnMgdXNlZCB0byBkZXRlcm1pbmUgbWF4aW11bVxuICAgICAqICBhdHRlbXB0cyBhbmQgZXhwb25lbnRpYWwtYmFja29mZiBwcm9wZXJ0aWVzLlxuICAgICAqL1xuICAgIHNldFRocm90dGxlUGFyYW1zKHBhcmFtcykge1xuICAgICAgICBpZiAocGFyYW1zLnNsb3RJbnRlcnZhbCAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLiN0aHJvdHRsZS5zbG90SW50ZXJ2YWwgPSBwYXJhbXMuc2xvdEludGVydmFsO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJhbXMubWF4QXR0ZW1wdHMgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy4jdGhyb3R0bGUubWF4QXR0ZW1wdHMgPSBwYXJhbXMubWF4QXR0ZW1wdHM7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgI3NlbmQoYXR0ZW1wdCwgZXhwaXJlcywgZGVsYXksIF9yZXF1ZXN0LCBfcmVzcG9uc2UpIHtcbiAgICAgICAgaWYgKGF0dGVtcHQgPj0gdGhpcy4jdGhyb3R0bGUubWF4QXR0ZW1wdHMpIHtcbiAgICAgICAgICAgIHJldHVybiBfcmVzcG9uc2UubWFrZVNlcnZlckVycm9yKFwiZXhjZWVkZWQgbWF4aW11bSByZXRyeSBsaW1pdFwiKTtcbiAgICAgICAgfVxuICAgICAgICBhc3NlcnQoZ2V0VGltZSgpIDw9IGV4cGlyZXMsIFwidGltZW91dFwiLCBcIlRJTUVPVVRcIiwge1xuICAgICAgICAgICAgb3BlcmF0aW9uOiBcInJlcXVlc3Quc2VuZFwiLCByZWFzb246IFwidGltZW91dFwiLCByZXF1ZXN0OiBfcmVxdWVzdFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGRlbGF5ID4gMCkge1xuICAgICAgICAgICAgYXdhaXQgd2FpdChkZWxheSk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJlcSA9IHRoaXMuY2xvbmUoKTtcbiAgICAgICAgY29uc3Qgc2NoZW1lID0gKHJlcS51cmwuc3BsaXQoXCI6XCIpWzBdIHx8IFwiXCIpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIC8vIFByb2Nlc3MgYW55IEdhdGV3YXlzXG4gICAgICAgIGlmIChzY2hlbWUgaW4gR2F0ZXdheXMpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IEdhdGV3YXlzW3NjaGVtZV0ocmVxLnVybCwgY2hlY2tTaWduYWwoX3JlcXVlc3QuI3NpZ25hbCkpO1xuICAgICAgICAgICAgaWYgKHJlc3VsdCBpbnN0YW5jZW9mIEZldGNoUmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICBsZXQgcmVzcG9uc2UgPSByZXN1bHQ7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucHJvY2Vzc0Z1bmMpIHtcbiAgICAgICAgICAgICAgICAgICAgY2hlY2tTaWduYWwoX3JlcXVlc3QuI3NpZ25hbCk7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZSA9IGF3YWl0IHRoaXMucHJvY2Vzc0Z1bmMocmVxLCByZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBTb21ldGhpbmcgd2VudCB3cm9uZyBkdXJpbmcgcHJvY2Vzc2luZzsgdGhyb3cgYSA1eHggc2VydmVyIGVycm9yXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3IudGhyb3R0bGUgPT0gbnVsbCB8fCB0eXBlb2YgKGVycm9yLnN0YWxsKSAhPT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLm1ha2VTZXJ2ZXJFcnJvcihcImVycm9yIGluIHBvc3QtcHJvY2Vzc2luZyBmdW5jdGlvblwiLCBlcnJvcikuYXNzZXJ0T2soKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElnbm9yZSB0aHJvdHRsaW5nXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVxID0gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIC8vIFdlIGhhdmUgYSBwcmVmbGlnaHQgZnVuY3Rpb247IHVwZGF0ZSB0aGUgcmVxdWVzdFxuICAgICAgICBpZiAodGhpcy5wcmVmbGlnaHRGdW5jKSB7XG4gICAgICAgICAgICByZXEgPSBhd2FpdCB0aGlzLnByZWZsaWdodEZ1bmMocmVxKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXNwID0gYXdhaXQgdGhpcy5nZXRVcmxGdW5jKHJlcSwgY2hlY2tTaWduYWwoX3JlcXVlc3QuI3NpZ25hbCkpO1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBuZXcgRmV0Y2hSZXNwb25zZShyZXNwLnN0YXR1c0NvZGUsIHJlc3Auc3RhdHVzTWVzc2FnZSwgcmVzcC5oZWFkZXJzLCByZXNwLmJvZHksIF9yZXF1ZXN0KTtcbiAgICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1c0NvZGUgPT09IDMwMSB8fCByZXNwb25zZS5zdGF0dXNDb2RlID09PSAzMDIpIHtcbiAgICAgICAgICAgIC8vIFJlZGlyZWN0XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGxvY2F0aW9uID0gcmVzcG9uc2UuaGVhZGVycy5sb2NhdGlvbiB8fCBcIlwiO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXEucmVkaXJlY3QobG9jYXRpb24pLiNzZW5kKGF0dGVtcHQgKyAxLCBleHBpcmVzLCAwLCBfcmVxdWVzdCwgcmVzcG9uc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7IH1cbiAgICAgICAgICAgIC8vIFRoaW5ncyB3b24ndCBnZXQgYW55IGJldHRlciBvbiBhbm90aGVyIGF0dGVtcHQ7IGFib3J0XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocmVzcG9uc2Uuc3RhdHVzQ29kZSA9PT0gNDI5KSB7XG4gICAgICAgICAgICAvLyBUaHJvdHRsZVxuICAgICAgICAgICAgaWYgKHRoaXMucmV0cnlGdW5jID09IG51bGwgfHwgKGF3YWl0IHRoaXMucmV0cnlGdW5jKHJlcSwgcmVzcG9uc2UsIGF0dGVtcHQpKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJldHJ5QWZ0ZXIgPSByZXNwb25zZS5oZWFkZXJzW1wicmV0cnktYWZ0ZXJcIl07XG4gICAgICAgICAgICAgICAgbGV0IGRlbGF5ID0gdGhpcy4jdGhyb3R0bGUuc2xvdEludGVydmFsICogTWF0aC50cnVuYyhNYXRoLnJhbmRvbSgpICogTWF0aC5wb3coMiwgYXR0ZW1wdCkpO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgKHJldHJ5QWZ0ZXIpID09PSBcInN0cmluZ1wiICYmIHJldHJ5QWZ0ZXIubWF0Y2goL15bMS05XVswLTldKiQvKSkge1xuICAgICAgICAgICAgICAgICAgICBkZWxheSA9IHBhcnNlSW50KHJldHJ5QWZ0ZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVxLmNsb25lKCkuI3NlbmQoYXR0ZW1wdCArIDEsIGV4cGlyZXMsIGRlbGF5LCBfcmVxdWVzdCwgcmVzcG9uc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnByb2Nlc3NGdW5jKSB7XG4gICAgICAgICAgICBjaGVja1NpZ25hbChfcmVxdWVzdC4jc2lnbmFsKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnByb2Nlc3NGdW5jKHJlcSwgcmVzcG9uc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgLy8gU29tZXRoaW5nIHdlbnQgd3JvbmcgZHVyaW5nIHByb2Nlc3Npbmc7IHRocm93IGEgNXh4IHNlcnZlciBlcnJvclxuICAgICAgICAgICAgICAgIGlmIChlcnJvci50aHJvdHRsZSA9PSBudWxsIHx8IHR5cGVvZiAoZXJyb3Iuc3RhbGwpICE9PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLm1ha2VTZXJ2ZXJFcnJvcihcImVycm9yIGluIHBvc3QtcHJvY2Vzc2luZyBmdW5jdGlvblwiLCBlcnJvcikuYXNzZXJ0T2soKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gVGhyb3R0bGVcbiAgICAgICAgICAgICAgICBsZXQgZGVsYXkgPSB0aGlzLiN0aHJvdHRsZS5zbG90SW50ZXJ2YWwgKiBNYXRoLnRydW5jKE1hdGgucmFuZG9tKCkgKiBNYXRoLnBvdygyLCBhdHRlbXB0KSk7XG4gICAgICAgICAgICAgICAgO1xuICAgICAgICAgICAgICAgIGlmIChlcnJvci5zdGFsbCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGF5ID0gZXJyb3Iuc3RhbGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZXEuY2xvbmUoKS4jc2VuZChhdHRlbXB0ICsgMSwgZXhwaXJlcywgZGVsYXksIF9yZXF1ZXN0LCByZXNwb25zZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmVzb2x2ZXMgdG8gdGhlIHJlc3BvbnNlIGJ5IHNlbmRpbmcgdGhlIHJlcXVlc3QuXG4gICAgICovXG4gICAgc2VuZCgpIHtcbiAgICAgICAgYXNzZXJ0KHRoaXMuI3NpZ25hbCA9PSBudWxsLCBcInJlcXVlc3QgYWxyZWFkeSBzZW50XCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHsgb3BlcmF0aW9uOiBcImZldGNoUmVxdWVzdC5zZW5kXCIgfSk7XG4gICAgICAgIHRoaXMuI3NpZ25hbCA9IG5ldyBGZXRjaENhbmNlbFNpZ25hbCh0aGlzKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuI3NlbmQoMCwgZ2V0VGltZSgpICsgdGhpcy50aW1lb3V0LCAwLCB0aGlzLCBuZXcgRmV0Y2hSZXNwb25zZSgwLCBcIlwiLCB7fSwgbnVsbCwgdGhpcykpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQ2FuY2VscyB0aGUgaW5mbGlnaHQgcmVzcG9uc2UsIGNhdXNpbmcgYSBgYENBTkNFTExFRGBgXG4gICAgICogIGVycm9yIHRvIGJlIHJlamVjdGVkIGZyb20gdGhlIFtbc2VuZF1dLlxuICAgICAqL1xuICAgIGNhbmNlbCgpIHtcbiAgICAgICAgYXNzZXJ0KHRoaXMuI3NpZ25hbCAhPSBudWxsLCBcInJlcXVlc3QgaGFzIG5vdCBiZWVuIHNlbnRcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwgeyBvcGVyYXRpb246IFwiZmV0Y2hSZXF1ZXN0LmNhbmNlbFwiIH0pO1xuICAgICAgICBjb25zdCBzaWduYWwgPSBmZXRjaFNpZ25hbHMuZ2V0KHRoaXMpO1xuICAgICAgICBpZiAoIXNpZ25hbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibWlzc2luZyBzaWduYWw7IHNob3VsZCBub3QgaGFwcGVuXCIpO1xuICAgICAgICB9XG4gICAgICAgIHNpZ25hbCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBhIG5ldyBbW0ZldGNoUmVxdWVzdF1dIHRoYXQgcmVwcmVzZW50cyB0aGUgcmVkaXJlY3Rpb25cbiAgICAgKiAgdG8gJSVsb2NhdGlvbiUlLlxuICAgICAqL1xuICAgIHJlZGlyZWN0KGxvY2F0aW9uKSB7XG4gICAgICAgIC8vIFJlZGlyZWN0aW9uOyBmb3Igbm93IHdlIG9ubHkgc3VwcG9ydCBhYnNvbHV0ZSBsb2NhdGlvbnNcbiAgICAgICAgY29uc3QgY3VycmVudCA9IHRoaXMudXJsLnNwbGl0KFwiOlwiKVswXS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBjb25zdCB0YXJnZXQgPSBsb2NhdGlvbi5zcGxpdChcIjpcIilbMF0udG9Mb3dlckNhc2UoKTtcbiAgICAgICAgLy8gRG9uJ3QgYWxsb3cgcmVkaXJlY3Rpbmc6XG4gICAgICAgIC8vIC0gbm9uLUdFVCByZXF1ZXN0c1xuICAgICAgICAvLyAtIGRvd25ncmFkaW5nIHRoZSBzZWN1cml0eSAoZS5nLiBodHRwcyA9PiBodHRwKVxuICAgICAgICAvLyAtIHRvIG5vbi1IVFRQIChvciBub24tSFRUUFMpIHByb3RvY29scyBbdGhpcyBjb3VsZCBiZSByZWxheGVkP11cbiAgICAgICAgYXNzZXJ0KHRoaXMubWV0aG9kID09PSBcIkdFVFwiICYmIChjdXJyZW50ICE9PSBcImh0dHBzXCIgfHwgdGFyZ2V0ICE9PSBcImh0dHBcIikgJiYgbG9jYXRpb24ubWF0Y2goL15odHRwcz86LyksIGB1bnN1cHBvcnRlZCByZWRpcmVjdGAsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHtcbiAgICAgICAgICAgIG9wZXJhdGlvbjogYHJlZGlyZWN0KCR7dGhpcy5tZXRob2R9ICR7SlNPTi5zdHJpbmdpZnkodGhpcy51cmwpfSA9PiAke0pTT04uc3RyaW5naWZ5KGxvY2F0aW9uKX0pYFxuICAgICAgICB9KTtcbiAgICAgICAgLy8gQ3JlYXRlIGEgY29weSBvZiB0aGlzIHJlcXVlc3QsIHdpdGggYSBuZXcgVVJMXG4gICAgICAgIGNvbnN0IHJlcSA9IG5ldyBGZXRjaFJlcXVlc3QobG9jYXRpb24pO1xuICAgICAgICByZXEubWV0aG9kID0gXCJHRVRcIjtcbiAgICAgICAgcmVxLmFsbG93R3ppcCA9IHRoaXMuYWxsb3dHemlwO1xuICAgICAgICByZXEudGltZW91dCA9IHRoaXMudGltZW91dDtcbiAgICAgICAgcmVxLiNoZWFkZXJzID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy4jaGVhZGVycyk7XG4gICAgICAgIGlmICh0aGlzLiNib2R5KSB7XG4gICAgICAgICAgICByZXEuI2JvZHkgPSBuZXcgVWludDhBcnJheSh0aGlzLiNib2R5KTtcbiAgICAgICAgfVxuICAgICAgICByZXEuI2JvZHlUeXBlID0gdGhpcy4jYm9keVR5cGU7XG4gICAgICAgIC8vIERvIG5vdCBmb3J3YXJkIGNyZWRlbnRpYWxzIHVubGVzcyBvbiB0aGUgc2FtZSBkb21haW47IG9ubHkgYWJzb2x1dGVcbiAgICAgICAgLy9yZXEuYWxsb3dJbnNlY3VyZSA9IGZhbHNlO1xuICAgICAgICAvLyBwYXRocyBhcmUgY3VycmVudGx5IHN1cHBvcnRlZDsgbWF5IHdhbnQgYSB3YXkgdG8gc3BlY2lmeSB0byBmb3J3YXJkP1xuICAgICAgICAvL3NldFN0b3JlKHJlcS4jcHJvcHMsIFwiY3JlZHNcIiwgZ2V0U3RvcmUodGhpcy4jcHJvcywgXCJjcmVkc1wiKSk7XG4gICAgICAgIHJldHVybiByZXE7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBDcmVhdGUgYSBuZXcgY29weSBvZiB0aGlzIHJlcXVlc3QuXG4gICAgICovXG4gICAgY2xvbmUoKSB7XG4gICAgICAgIGNvbnN0IGNsb25lID0gbmV3IEZldGNoUmVxdWVzdCh0aGlzLnVybCk7XG4gICAgICAgIC8vIFByZXNlcnZlIFwiZGVmYXVsdCBtZXRob2RcIiAoaS5lLiBudWxsKVxuICAgICAgICBjbG9uZS4jbWV0aG9kID0gdGhpcy4jbWV0aG9kO1xuICAgICAgICAvLyBQcmVzZXJ2ZSBcImRlZmF1bHQgYm9keVwiIHdpdGggdHlwZSwgY29weWluZyB0aGUgVWludDhBcnJheSBpcyBwcmVzZW50XG4gICAgICAgIGlmICh0aGlzLiNib2R5KSB7XG4gICAgICAgICAgICBjbG9uZS4jYm9keSA9IHRoaXMuI2JvZHk7XG4gICAgICAgIH1cbiAgICAgICAgY2xvbmUuI2JvZHlUeXBlID0gdGhpcy4jYm9keVR5cGU7XG4gICAgICAgIC8vIFByZXNlcnZlIFwiZGVmYXVsdCBoZWFkZXJzXCJcbiAgICAgICAgY2xvbmUuI2hlYWRlcnMgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLiNoZWFkZXJzKTtcbiAgICAgICAgLy8gQ3JlZGVudGlhbHMgaXMgcmVhZG9ubHksIHNvIHdlIGNvcHkgaW50ZXJuYWxseVxuICAgICAgICBjbG9uZS4jY3JlZHMgPSB0aGlzLiNjcmVkcztcbiAgICAgICAgaWYgKHRoaXMuYWxsb3dHemlwKSB7XG4gICAgICAgICAgICBjbG9uZS5hbGxvd0d6aXAgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGNsb25lLnRpbWVvdXQgPSB0aGlzLnRpbWVvdXQ7XG4gICAgICAgIGlmICh0aGlzLmFsbG93SW5zZWN1cmVBdXRoZW50aWNhdGlvbikge1xuICAgICAgICAgICAgY2xvbmUuYWxsb3dJbnNlY3VyZUF1dGhlbnRpY2F0aW9uID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBjbG9uZS4jcHJlZmxpZ2h0ID0gdGhpcy4jcHJlZmxpZ2h0O1xuICAgICAgICBjbG9uZS4jcHJvY2VzcyA9IHRoaXMuI3Byb2Nlc3M7XG4gICAgICAgIGNsb25lLiNyZXRyeSA9IHRoaXMuI3JldHJ5O1xuICAgICAgICBjbG9uZS4jdGhyb3R0bGUgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLiN0aHJvdHRsZSk7XG4gICAgICAgIGNsb25lLiNnZXRVcmxGdW5jID0gdGhpcy4jZ2V0VXJsRnVuYztcbiAgICAgICAgcmV0dXJuIGNsb25lO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgTG9ja3MgYWxsIHN0YXRpYyBjb25maWd1cmF0aW9uIGZvciBnYXRld2F5cyBhbmQgRmV0Y2hHZXRVcmxGdW5jXG4gICAgICogIHJlZ2lzdHJhdGlvbi5cbiAgICAgKi9cbiAgICBzdGF0aWMgbG9ja0NvbmZpZygpIHtcbiAgICAgICAgbG9ja2VkID0gdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIEdldCB0aGUgY3VycmVudCBHYXRld2F5IGZ1bmN0aW9uIGZvciAlJXNjaGVtZSUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBnZXRHYXRld2F5KHNjaGVtZSkge1xuICAgICAgICByZXR1cm4gR2F0ZXdheXNbc2NoZW1lLnRvTG93ZXJDYXNlKCldIHx8IG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBVc2UgdGhlICUlZnVuYyUlIHdoZW4gZmV0Y2hpbmcgVVJJcyB1c2luZyAlJXNjaGVtZSUlLlxuICAgICAqXG4gICAgICogIFRoaXMgbWV0aG9kIGFmZmVjdHMgYWxsIHJlcXVlc3RzIGdsb2JhbGx5LlxuICAgICAqXG4gICAgICogIElmIFtbbG9ja0NvbmZpZ11dIGhhcyBiZWVuIGNhbGxlZCwgbm8gY2hhbmdlIGlzIG1hZGUgYW5kIHRoaXNcbiAgICAgKiAgdGhyb3dzLlxuICAgICAqL1xuICAgIHN0YXRpYyByZWdpc3RlckdhdGV3YXkoc2NoZW1lLCBmdW5jKSB7XG4gICAgICAgIHNjaGVtZSA9IHNjaGVtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBpZiAoc2NoZW1lID09PSBcImh0dHBcIiB8fCBzY2hlbWUgPT09IFwiaHR0cHNcIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBjYW5ub3QgaW50ZXJjZXB0ICR7c2NoZW1lfTsgdXNlIHJlZ2lzdGVyR2V0VXJsYCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxvY2tlZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZ2F0ZXdheXMgbG9ja2VkXCIpO1xuICAgICAgICB9XG4gICAgICAgIEdhdGV3YXlzW3NjaGVtZV0gPSBmdW5jO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVXNlICUlZ2V0VXJsJSUgd2hlbiBmZXRjaGluZyBVUklzIG92ZXIgSFRUUCBhbmQgSFRUUFMgcmVxdWVzdHMuXG4gICAgICpcbiAgICAgKiAgVGhpcyBtZXRob2QgYWZmZWN0cyBhbGwgcmVxdWVzdHMgZ2xvYmFsbHkuXG4gICAgICpcbiAgICAgKiAgSWYgW1tsb2NrQ29uZmlnXV0gaGFzIGJlZW4gY2FsbGVkLCBubyBjaGFuZ2UgaXMgbWFkZSBhbmQgdGhpc1xuICAgICAqICB0aHJvd3MuXG4gICAgICovXG4gICAgc3RhdGljIHJlZ2lzdGVyR2V0VXJsKGdldFVybCkge1xuICAgICAgICBpZiAobG9ja2VkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJnYXRld2F5cyBsb2NrZWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgZGVmYXVsdEdldFVybEZ1bmMgPSBnZXRVcmw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBDcmVhdGVzIGEgZ2V0VXJsIGZ1bmN0aW9uIHRoYXQgZmV0Y2hlcyBjb250ZW50IGZyb20gSFRUUCBhbmRcbiAgICAgKiAgSFRUUFMgVVJMcy5cbiAgICAgKlxuICAgICAqICBUaGUgYXZhaWxhYmxlICUlb3B0aW9ucyUlIGFyZSBkZXBlbmRlbnQgb24gdGhlIHBsYXRmb3JtXG4gICAgICogIGltcGxlbWVudGF0aW9uIG9mIHRoZSBkZWZhdWx0IGdldFVybCBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqICBUaGlzIGlzIG5vdCBnZW5lcmFsbHkgc29tZXRoaW5nIHRoYXQgaXMgbmVlZGVkLCBidXQgaXMgdXNlZnVsXG4gICAgICogIHdoZW4gdHJ5aW5nIHRvIGN1c3RvbWl6ZSBzaW1wbGUgYmVoYXZpb3VyIHdoZW4gZmV0Y2hpbmcgSFRUUFxuICAgICAqICBjb250ZW50LlxuICAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGVHZXRVcmxGdW5jKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUdldFVybChvcHRpb25zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGNhbiBcImZldGNoXCIgZGF0YSBVUklzLlxuICAgICAqXG4gICAgICogIE5vdGUgdGhhdCB0aGlzIGlzIGF1dG9tYXRpY2FsbHkgZG9uZSBpbnRlcm5hbGx5IHRvIHN1cHBvcnRcbiAgICAgKiAgZGF0YSBVUklzLCBzbyBpdCBpcyBub3QgbmVjZXNzYXJ5IHRvIHJlZ2lzdGVyIGl0LlxuICAgICAqXG4gICAgICogIFRoaXMgaXMgbm90IGdlbmVyYWxseSBzb21ldGhpbmcgdGhhdCBpcyBuZWVkZWQsIGJ1dCBtYXlcbiAgICAgKiAgYmUgdXNlZnVsIGluIGEgd3JhcHBlciB0byBwZXJmb20gY3VzdG9tIGRhdGEgVVJJIGZ1bmN0aW9uYWxpdHkuXG4gICAgICovXG4gICAgc3RhdGljIGNyZWF0ZURhdGFHYXRld2F5KCkge1xuICAgICAgICByZXR1cm4gZGF0YUdhdGV3YXlGdW5jO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgd2lsbCBmZXRjaCBJUEZTICh1bnZhbGlkYXRlZCkgZnJvbVxuICAgICAqICBhIGN1c3RvbSBnYXRld2F5IGJhc2VVcmwuXG4gICAgICpcbiAgICAgKiAgVGhlIGRlZmF1bHQgSVBGUyBnYXRld2F5IHVzZWQgaW50ZXJuYWxseSBpc1xuICAgICAqICBgYFwiaHR0cHM6L1xcL2dhdGV3YXkuaXBmcy5pby9pcGZzL1wiYGAuXG4gICAgICovXG4gICAgc3RhdGljIGNyZWF0ZUlwZnNHYXRld2F5RnVuYyhiYXNlVXJsKSB7XG4gICAgICAgIHJldHVybiBnZXRJcGZzR2F0ZXdheUZ1bmMoYmFzZVVybCk7XG4gICAgfVxufVxuO1xuLyoqXG4gKiAgVGhlIHJlc3BvbnNlIGZvciBhIEZldGNoUmVxdWVzdC5cbiAqL1xuZXhwb3J0IGNsYXNzIEZldGNoUmVzcG9uc2Uge1xuICAgICNzdGF0dXNDb2RlO1xuICAgICNzdGF0dXNNZXNzYWdlO1xuICAgICNoZWFkZXJzO1xuICAgICNib2R5O1xuICAgICNyZXF1ZXN0O1xuICAgICNlcnJvcjtcbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIGA8RmV0Y2hSZXNwb25zZSBzdGF0dXM9JHt0aGlzLnN0YXR1c0NvZGV9IGJvZHk9JHt0aGlzLiNib2R5ID8gaGV4bGlmeSh0aGlzLiNib2R5KSA6IFwibnVsbFwifT5gO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhlIHJlc3BvbnNlIHN0YXR1cyBjb2RlLlxuICAgICAqL1xuICAgIGdldCBzdGF0dXNDb2RlKCkgeyByZXR1cm4gdGhpcy4jc3RhdHVzQ29kZTsgfVxuICAgIC8qKlxuICAgICAqICBUaGUgcmVzcG9uc2Ugc3RhdHVzIG1lc3NhZ2UuXG4gICAgICovXG4gICAgZ2V0IHN0YXR1c01lc3NhZ2UoKSB7IHJldHVybiB0aGlzLiNzdGF0dXNNZXNzYWdlOyB9XG4gICAgLyoqXG4gICAgICogIFRoZSByZXNwb25zZSBoZWFkZXJzLiBBbGwga2V5cyBhcmUgbG93ZXItY2FzZS5cbiAgICAgKi9cbiAgICBnZXQgaGVhZGVycygpIHsgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIHRoaXMuI2hlYWRlcnMpOyB9XG4gICAgLyoqXG4gICAgICogIFRoZSByZXNwb25zZSBib2R5LCBvciBgYG51bGxgYCBpZiB0aGVyZSB3YXMgbm8gYm9keS5cbiAgICAgKi9cbiAgICBnZXQgYm9keSgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLiNib2R5ID09IG51bGwpID8gbnVsbCA6IG5ldyBVaW50OEFycmF5KHRoaXMuI2JvZHkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhlIHJlc3BvbnNlIGJvZHkgYXMgYSBVVEYtOCBlbmNvZGVkIHN0cmluZywgb3IgdGhlIGVtcHR5XG4gICAgICogIHN0cmluZyAoaS5lLiBgYFwiXCJgYCkgaWYgdGhlcmUgd2FzIG5vIGJvZHkuXG4gICAgICpcbiAgICAgKiAgQW4gZXJyb3IgaXMgdGhyb3duIGlmIHRoZSBib2R5IGlzIGludmFsaWQgVVRGLTggZGF0YS5cbiAgICAgKi9cbiAgICBnZXQgYm9keVRleHQoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gKHRoaXMuI2JvZHkgPT0gbnVsbCkgPyBcIlwiIDogdG9VdGY4U3RyaW5nKHRoaXMuI2JvZHkpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgYXNzZXJ0KGZhbHNlLCBcInJlc3BvbnNlIGJvZHkgaXMgbm90IHZhbGlkIFVURi04IGRhdGFcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwge1xuICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogXCJib2R5VGV4dFwiLCBpbmZvOiB7IHJlc3BvbnNlOiB0aGlzIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgcmVzcG9uc2UgYm9keSwgZGVjb2RlZCBhcyBKU09OLlxuICAgICAqXG4gICAgICogIEFuIGVycm9yIGlzIHRocm93biBpZiB0aGUgYm9keSBpcyBpbnZhbGlkIEpTT04tZW5jb2RlZCBkYXRhXG4gICAgICogIG9yIGlmIHRoZXJlIHdhcyBubyBib2R5LlxuICAgICAqL1xuICAgIGdldCBib2R5SnNvbigpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBKU09OLnBhcnNlKHRoaXMuYm9keVRleHQpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgYXNzZXJ0KGZhbHNlLCBcInJlc3BvbnNlIGJvZHkgaXMgbm90IHZhbGlkIEpTT05cIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwge1xuICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogXCJib2R5SnNvblwiLCBpbmZvOiB7IHJlc3BvbnNlOiB0aGlzIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIFtTeW1ib2wuaXRlcmF0b3JdKCkge1xuICAgICAgICBjb25zdCBoZWFkZXJzID0gdGhpcy5oZWFkZXJzO1xuICAgICAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoaGVhZGVycyk7XG4gICAgICAgIGxldCBpbmRleCA9IDA7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBuZXh0OiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGluZGV4IDwga2V5cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qga2V5ID0ga2V5c1tpbmRleCsrXTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBba2V5LCBoZWFkZXJzW2tleV1dLCBkb25lOiBmYWxzZVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKHN0YXR1c0NvZGUsIHN0YXR1c01lc3NhZ2UsIGhlYWRlcnMsIGJvZHksIHJlcXVlc3QpIHtcbiAgICAgICAgdGhpcy4jc3RhdHVzQ29kZSA9IHN0YXR1c0NvZGU7XG4gICAgICAgIHRoaXMuI3N0YXR1c01lc3NhZ2UgPSBzdGF0dXNNZXNzYWdlO1xuICAgICAgICB0aGlzLiNoZWFkZXJzID0gT2JqZWN0LmtleXMoaGVhZGVycykucmVkdWNlKChhY2N1bSwgaykgPT4ge1xuICAgICAgICAgICAgYWNjdW1bay50b0xvd2VyQ2FzZSgpXSA9IFN0cmluZyhoZWFkZXJzW2tdKTtcbiAgICAgICAgICAgIHJldHVybiBhY2N1bTtcbiAgICAgICAgfSwge30pO1xuICAgICAgICB0aGlzLiNib2R5ID0gKChib2R5ID09IG51bGwpID8gbnVsbCA6IG5ldyBVaW50OEFycmF5KGJvZHkpKTtcbiAgICAgICAgdGhpcy4jcmVxdWVzdCA9IChyZXF1ZXN0IHx8IG51bGwpO1xuICAgICAgICB0aGlzLiNlcnJvciA9IHsgbWVzc2FnZTogXCJcIiB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgUmVzcG9uc2Ugd2l0aCBtYXRjaGluZyBoZWFkZXJzIGFuZCBib2R5LCBidXQgd2l0aFxuICAgICAqICBhbiBlcnJvciBzdGF0dXMgY29kZSAoaS5lLiA1OTkpIGFuZCAlJW1lc3NhZ2UlJSB3aXRoIGFuXG4gICAgICogIG9wdGlvbmFsICUlZXJyb3IlJS5cbiAgICAgKi9cbiAgICBtYWtlU2VydmVyRXJyb3IobWVzc2FnZSwgZXJyb3IpIHtcbiAgICAgICAgbGV0IHN0YXR1c01lc3NhZ2U7XG4gICAgICAgIGlmICghbWVzc2FnZSkge1xuICAgICAgICAgICAgbWVzc2FnZSA9IGAke3RoaXMuc3RhdHVzQ29kZX0gJHt0aGlzLnN0YXR1c01lc3NhZ2V9YDtcbiAgICAgICAgICAgIHN0YXR1c01lc3NhZ2UgPSBgQ0xJRU5UIEVTQ0FMQVRFRCBTRVJWRVIgRVJST1IgKCR7bWVzc2FnZX0pYDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHN0YXR1c01lc3NhZ2UgPSBgQ0xJRU5UIEVTQ0FMQVRFRCBTRVJWRVIgRVJST1IgKCR7dGhpcy5zdGF0dXNDb2RlfSAke3RoaXMuc3RhdHVzTWVzc2FnZX07ICR7bWVzc2FnZX0pYDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXNwb25zZSA9IG5ldyBGZXRjaFJlc3BvbnNlKDU5OSwgc3RhdHVzTWVzc2FnZSwgdGhpcy5oZWFkZXJzLCB0aGlzLmJvZHksIHRoaXMuI3JlcXVlc3QgfHwgdW5kZWZpbmVkKTtcbiAgICAgICAgcmVzcG9uc2UuI2Vycm9yID0geyBtZXNzYWdlLCBlcnJvciB9O1xuICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBJZiBjYWxsZWQgd2l0aGluIGEgW3JlcXVlc3QucHJvY2Vzc0Z1bmNdKEZldGNoUmVxdWVzdC1wcm9jZXNzRnVuYylcbiAgICAgKiAgY2FsbCwgY2F1c2VzIHRoZSByZXF1ZXN0IHRvIHJldHJ5IGFzIGlmIHRocm90dGxlZCBmb3IgJSVzdGFsbCUlXG4gICAgICogIG1pbGxpc2Vjb25kcy5cbiAgICAgKi9cbiAgICB0aHJvd1Rocm90dGxlRXJyb3IobWVzc2FnZSwgc3RhbGwpIHtcbiAgICAgICAgaWYgKHN0YWxsID09IG51bGwpIHtcbiAgICAgICAgICAgIHN0YWxsID0gLTE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudChOdW1iZXIuaXNJbnRlZ2VyKHN0YWxsKSAmJiBzdGFsbCA+PSAwLCBcImludmFsaWQgc3RhbGwgdGltZW91dFwiLCBcInN0YWxsXCIsIHN0YWxsKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihtZXNzYWdlIHx8IFwidGhyb3R0bGluZyByZXF1ZXN0c1wiKTtcbiAgICAgICAgZGVmaW5lUHJvcGVydGllcyhlcnJvciwgeyBzdGFsbCwgdGhyb3R0bGU6IHRydWUgfSk7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgR2V0IHRoZSBoZWFkZXIgdmFsdWUgZm9yICUla2V5JSUsIGlnbm9yaW5nIGNhc2UuXG4gICAgICovXG4gICAgZ2V0SGVhZGVyKGtleSkge1xuICAgICAgICByZXR1cm4gdGhpcy5oZWFkZXJzW2tleS50b0xvd2VyQ2FzZSgpXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdHJ1ZSBpZiB0aGUgcmVzcG9uc2UgaGFzIGEgYm9keS5cbiAgICAgKi9cbiAgICBoYXNCb2R5KCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuI2JvZHkgIT0gbnVsbCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgcmVxdWVzdCBtYWRlIGZvciB0aGlzIHJlc3BvbnNlLlxuICAgICAqL1xuICAgIGdldCByZXF1ZXN0KCkgeyByZXR1cm4gdGhpcy4jcmVxdWVzdDsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRydWUgaWYgdGhpcyByZXNwb25zZSB3YXMgYSBzdWNjZXNzIHN0YXR1c0NvZGUuXG4gICAgICovXG4gICAgb2soKSB7XG4gICAgICAgIHJldHVybiAodGhpcy4jZXJyb3IubWVzc2FnZSA9PT0gXCJcIiAmJiB0aGlzLnN0YXR1c0NvZGUgPj0gMjAwICYmIHRoaXMuc3RhdHVzQ29kZSA8IDMwMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaHJvd3MgYSBgYFNFUlZFUl9FUlJPUmBgIGlmIHRoaXMgcmVzcG9uc2UgaXMgbm90IG9rLlxuICAgICAqL1xuICAgIGFzc2VydE9rKCkge1xuICAgICAgICBpZiAodGhpcy5vaygpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHsgbWVzc2FnZSwgZXJyb3IgfSA9IHRoaXMuI2Vycm9yO1xuICAgICAgICBpZiAobWVzc2FnZSA9PT0gXCJcIikge1xuICAgICAgICAgICAgbWVzc2FnZSA9IGBzZXJ2ZXIgcmVzcG9uc2UgJHt0aGlzLnN0YXR1c0NvZGV9ICR7dGhpcy5zdGF0dXNNZXNzYWdlfWA7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJlcXVlc3RVcmwgPSBudWxsO1xuICAgICAgICBpZiAodGhpcy5yZXF1ZXN0KSB7XG4gICAgICAgICAgICByZXF1ZXN0VXJsID0gdGhpcy5yZXF1ZXN0LnVybDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcmVzcG9uc2VCb2R5ID0gbnVsbDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICh0aGlzLiNib2R5KSB7XG4gICAgICAgICAgICAgICAgcmVzcG9uc2VCb2R5ID0gdG9VdGY4U3RyaW5nKHRoaXMuI2JvZHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7IH1cbiAgICAgICAgYXNzZXJ0KGZhbHNlLCBtZXNzYWdlLCBcIlNFUlZFUl9FUlJPUlwiLCB7XG4gICAgICAgICAgICByZXF1ZXN0OiAodGhpcy5yZXF1ZXN0IHx8IFwidW5rbm93biByZXF1ZXN0XCIpLCByZXNwb25zZTogdGhpcywgZXJyb3IsXG4gICAgICAgICAgICBpbmZvOiB7XG4gICAgICAgICAgICAgICAgcmVxdWVzdFVybCwgcmVzcG9uc2VCb2R5LFxuICAgICAgICAgICAgICAgIHJlc3BvbnNlU3RhdHVzOiBgJHt0aGlzLnN0YXR1c0NvZGV9ICR7dGhpcy5zdGF0dXNNZXNzYWdlfWBcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxufVxuZnVuY3Rpb24gZ2V0VGltZSgpIHsgcmV0dXJuIChuZXcgRGF0ZSgpKS5nZXRUaW1lKCk7IH1cbmZ1bmN0aW9uIHVucGVyY2VudCh2YWx1ZSkge1xuICAgIHJldHVybiB0b1V0ZjhCeXRlcyh2YWx1ZS5yZXBsYWNlKC8lKFswLTlhLWZdWzAtOWEtZl0pL2dpLCAoYWxsLCBjb2RlKSA9PiB7XG4gICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKHBhcnNlSW50KGNvZGUsIDE2KSk7XG4gICAgfSkpO1xufVxuZnVuY3Rpb24gd2FpdChkZWxheSkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gc2V0VGltZW91dChyZXNvbHZlLCBkZWxheSkpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZmV0Y2guanMubWFwIl0sIm5hbWVzIjpbImRlY29kZUJhc2U2NCIsImVuY29kZUJhc2U2NCIsImhleGxpZnkiLCJhc3NlcnQiLCJhc3NlcnRBcmd1bWVudCIsImRlZmluZVByb3BlcnRpZXMiLCJ0b1V0ZjhCeXRlcyIsInRvVXRmOFN0cmluZyIsImNyZWF0ZUdldFVybCIsIk1BWF9BVFRFTVBUUyIsIlNMT1RfSU5URVJWQUwiLCJkZWZhdWx0R2V0VXJsRnVuYyIsInJlRGF0YSIsIlJlZ0V4cCIsInJlSXBmcyIsImxvY2tlZCIsImRhdGFHYXRld2F5RnVuYyIsInVybCIsInNpZ25hbCIsIm1hdGNoIiwiRXJyb3IiLCJGZXRjaFJlc3BvbnNlIiwidW5wZXJjZW50IiwiZXJyb3IiLCJGZXRjaFJlcXVlc3QiLCJnZXRJcGZzR2F0ZXdheUZ1bmMiLCJiYXNlVXJsIiwiZ2F0ZXdheUlwZnMiLCJHYXRld2F5cyIsImZldGNoU2lnbmFscyIsIldlYWtNYXAiLCJGZXRjaENhbmNlbFNpZ25hbCIsImxpc3RlbmVycyIsImNhbmNlbGxlZCIsImNvbnN0cnVjdG9yIiwicmVxdWVzdCIsInNldCIsImxpc3RlbmVyIiwic2V0VGltZW91dCIsImFkZExpc3RlbmVyIiwib3BlcmF0aW9uIiwicHVzaCIsImNoZWNrU2lnbmFsIiwiYWxsb3dJbnNlY3VyZSIsImd6aXAiLCJoZWFkZXJzIiwibWV0aG9kIiwidGltZW91dCIsImJvZHkiLCJib2R5VHlwZSIsImNyZWRzIiwicHJlZmxpZ2h0IiwicHJvY2VzcyIsInJldHJ5IiwidGhyb3R0bGUiLCJnZXRVcmxGdW5jIiwiU3RyaW5nIiwiVWludDhBcnJheSIsInVuZGVmaW5lZCIsIkpTT04iLCJzdHJpbmdpZnkiLCJoYXNCb2R5IiwidG9VcHBlckNhc2UiLCJPYmplY3QiLCJhc3NpZ24iLCJhbGxvd0d6aXAiLCJsZW5ndGgiLCJnZXRIZWFkZXIiLCJrZXkiLCJ0b0xvd2VyQ2FzZSIsInNldEhlYWRlciIsInZhbHVlIiwiY2xlYXJIZWFkZXJzIiwiU3ltYm9sIiwiaXRlcmF0b3IiLCJrZXlzIiwiaW5kZXgiLCJuZXh0IiwiZG9uZSIsImNyZWRlbnRpYWxzIiwic2V0Q3JlZGVudGlhbHMiLCJ1c2VybmFtZSIsInBhc3N3b3JkIiwiYWxsb3dJbnNlY3VyZUF1dGhlbnRpY2F0aW9uIiwicHJlZmxpZ2h0RnVuYyIsInByb2Nlc3NGdW5jIiwicmV0cnlGdW5jIiwic2xvdEludGVydmFsIiwibWF4QXR0ZW1wdHMiLCJ0b1N0cmluZyIsInNldFRocm90dGxlUGFyYW1zIiwicGFyYW1zIiwic2VuZCIsImF0dGVtcHQiLCJleHBpcmVzIiwiZGVsYXkiLCJfcmVxdWVzdCIsIl9yZXNwb25zZSIsIm1ha2VTZXJ2ZXJFcnJvciIsImdldFRpbWUiLCJyZWFzb24iLCJ3YWl0IiwicmVxIiwiY2xvbmUiLCJzY2hlbWUiLCJzcGxpdCIsInJlc3VsdCIsInJlc3BvbnNlIiwic3RhbGwiLCJhc3NlcnRPayIsInJlc3AiLCJzdGF0dXNDb2RlIiwic3RhdHVzTWVzc2FnZSIsImxvY2F0aW9uIiwicmVkaXJlY3QiLCJyZXRyeUFmdGVyIiwiTWF0aCIsInRydW5jIiwicmFuZG9tIiwicG93IiwicGFyc2VJbnQiLCJjYW5jZWwiLCJnZXQiLCJjdXJyZW50IiwidGFyZ2V0IiwibG9ja0NvbmZpZyIsImdldEdhdGV3YXkiLCJyZWdpc3RlckdhdGV3YXkiLCJmdW5jIiwicmVnaXN0ZXJHZXRVcmwiLCJnZXRVcmwiLCJjcmVhdGVHZXRVcmxGdW5jIiwib3B0aW9ucyIsImNyZWF0ZURhdGFHYXRld2F5IiwiY3JlYXRlSXBmc0dhdGV3YXlGdW5jIiwiYm9keVRleHQiLCJpbmZvIiwiYm9keUpzb24iLCJwYXJzZSIsInJlZHVjZSIsImFjY3VtIiwiayIsIm1lc3NhZ2UiLCJ0aHJvd1Rocm90dGxlRXJyb3IiLCJOdW1iZXIiLCJpc0ludGVnZXIiLCJvayIsInJlcXVlc3RVcmwiLCJyZXNwb25zZUJvZHkiLCJlIiwicmVzcG9uc2VTdGF0dXMiLCJEYXRlIiwicmVwbGFjZSIsImFsbCIsImNvZGUiLCJmcm9tQ2hhckNvZGUiLCJQcm9taXNlIiwicmVzb2x2ZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.esm/utils/fetch.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.esm/utils/fixednumber.js":
/*!**********************************************************!*\
  !*** ./node_modules/ethers/lib.esm/utils/fixednumber.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FixedNumber: () => (/* binding */ FixedNumber)\n/* harmony export */ });\n/* harmony import */ var _data_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./data.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/data.js\");\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./errors.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/errors.js\");\n/* harmony import */ var _maths_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./maths.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/maths.js\");\n/* harmony import */ var _properties_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./properties.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/properties.js\");\n/**\n *  The **FixedNumber** class permits using values with decimal places,\n *  using fixed-pont math.\n *\n *  Fixed-point math is still based on integers under-the-hood, but uses an\n *  internal offset to store fractional components below, and each operation\n *  corrects for this after each operation.\n *\n *  @_section: api/utils/fixed-point-math:Fixed-Point Maths  [about-fixed-point-math]\n */ \n\n\n\nconst BN_N1 = BigInt(-1);\nconst BN_0 = BigInt(0);\nconst BN_1 = BigInt(1);\nconst BN_5 = BigInt(5);\nconst _guard = {};\n// Constant to pull zeros from for multipliers\nlet Zeros = \"0000\";\nwhile(Zeros.length < 80){\n    Zeros += Zeros;\n}\n// Returns a string \"1\" followed by decimal \"0\"s\nfunction getTens(decimals) {\n    let result = Zeros;\n    while(result.length < decimals){\n        result += result;\n    }\n    return BigInt(\"1\" + result.substring(0, decimals));\n}\nfunction checkValue(val, format, safeOp) {\n    const width = BigInt(format.width);\n    if (format.signed) {\n        const limit = BN_1 << width - BN_1;\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assert)(safeOp == null || val >= -limit && val < limit, \"overflow\", \"NUMERIC_FAULT\", {\n            operation: safeOp,\n            fault: \"overflow\",\n            value: val\n        });\n        if (val > BN_0) {\n            val = (0,_maths_js__WEBPACK_IMPORTED_MODULE_1__.fromTwos)((0,_maths_js__WEBPACK_IMPORTED_MODULE_1__.mask)(val, width), width);\n        } else {\n            val = -(0,_maths_js__WEBPACK_IMPORTED_MODULE_1__.fromTwos)((0,_maths_js__WEBPACK_IMPORTED_MODULE_1__.mask)(-val, width), width);\n        }\n    } else {\n        const limit = BN_1 << width;\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assert)(safeOp == null || val >= 0 && val < limit, \"overflow\", \"NUMERIC_FAULT\", {\n            operation: safeOp,\n            fault: \"overflow\",\n            value: val\n        });\n        val = (val % limit + limit) % limit & limit - BN_1;\n    }\n    return val;\n}\nfunction getFormat(value) {\n    if (typeof value === \"number\") {\n        value = `fixed128x${value}`;\n    }\n    let signed = true;\n    let width = 128;\n    let decimals = 18;\n    if (typeof value === \"string\") {\n        // Parse the format string\n        if (value === \"fixed\") {\n        // defaults...\n        } else if (value === \"ufixed\") {\n            signed = false;\n        } else {\n            const match = value.match(/^(u?)fixed([0-9]+)x([0-9]+)$/);\n            (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(match, \"invalid fixed format\", \"format\", value);\n            signed = match[1] !== \"u\";\n            width = parseInt(match[2]);\n            decimals = parseInt(match[3]);\n        }\n    } else if (value) {\n        // Extract the values from the object\n        const v = value;\n        const check = (key, type, defaultValue)=>{\n            if (v[key] == null) {\n                return defaultValue;\n            }\n            (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(typeof v[key] === type, \"invalid fixed format (\" + key + \" not \" + type + \")\", \"format.\" + key, v[key]);\n            return v[key];\n        };\n        signed = check(\"signed\", \"boolean\", signed);\n        width = check(\"width\", \"number\", width);\n        decimals = check(\"decimals\", \"number\", decimals);\n    }\n    (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(width % 8 === 0, \"invalid FixedNumber width (not byte aligned)\", \"format.width\", width);\n    (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(decimals <= 80, \"invalid FixedNumber decimals (too large)\", \"format.decimals\", decimals);\n    const name = (signed ? \"\" : \"u\") + \"fixed\" + String(width) + \"x\" + String(decimals);\n    return {\n        signed,\n        width,\n        decimals,\n        name\n    };\n}\nfunction toString(val, decimals) {\n    let negative = \"\";\n    if (val < BN_0) {\n        negative = \"-\";\n        val *= BN_N1;\n    }\n    let str = val.toString();\n    // No decimal point for whole values\n    if (decimals === 0) {\n        return negative + str;\n    }\n    // Pad out to the whole component (including a whole digit)\n    while(str.length <= decimals){\n        str = Zeros + str;\n    }\n    // Insert the decimal point\n    const index = str.length - decimals;\n    str = str.substring(0, index) + \".\" + str.substring(index);\n    // Trim the whole component (leaving at least one 0)\n    while(str[0] === \"0\" && str[1] !== \".\"){\n        str = str.substring(1);\n    }\n    // Trim the decimal component (leaving at least one 0)\n    while(str[str.length - 1] === \"0\" && str[str.length - 2] !== \".\"){\n        str = str.substring(0, str.length - 1);\n    }\n    return negative + str;\n}\n/**\n *  A FixedNumber represents a value over its [[FixedFormat]]\n *  arithmetic field.\n *\n *  A FixedNumber can be used to perform math, losslessly, on\n *  values which have decmial places.\n *\n *  A FixedNumber has a fixed bit-width to store values in, and stores all\n *  values internally by multiplying the value by 10 raised to the power of\n *  %%decimals%%.\n *\n *  If operations are performed that cause a value to grow too high (close to\n *  positive infinity) or too low (close to negative infinity), the value\n *  is said to //overflow//.\n *\n *  For example, an 8-bit signed value, with 0 decimals may only be within\n *  the range ``-128`` to ``127``; so ``-128 - 1`` will overflow and become\n *  ``127``. Likewise, ``127 + 1`` will overflow and become ``-127``.\n *\n *  Many operation have a normal and //unsafe// variant. The normal variant\n *  will throw a [[NumericFaultError]] on any overflow, while the //unsafe//\n *  variant will silently allow overflow, corrupting its value value.\n *\n *  If operations are performed that cause a value to become too small\n *  (close to zero), the value loses precison and is said to //underflow//.\n *\n *  For example, a value with 1 decimal place may store a number as small\n *  as ``0.1``, but the value of ``0.1 / 2`` is ``0.05``, which cannot fit\n *  into 1 decimal place, so underflow occurs which means precision is lost\n *  and the value becomes ``0``.\n *\n *  Some operations have a normal and //signalling// variant. The normal\n *  variant will silently ignore underflow, while the //signalling// variant\n *  will thow a [[NumericFaultError]] on underflow.\n */ class FixedNumber {\n    #format;\n    // The actual value (accounting for decimals)\n    #val;\n    // A base-10 value to multiple values by to maintain the magnitude\n    #tens;\n    // Use this when changing this file to get some typing info,\n    // but then switch to any to mask the internal type\n    //constructor(guard: any, value: bigint, format: _FixedFormat) {\n    /**\n     *  @private\n     */ constructor(guard, value, format){\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertPrivate)(guard, _guard, \"FixedNumber\");\n        this.#val = value;\n        this.#format = format;\n        const _value = toString(value, format.decimals);\n        (0,_properties_js__WEBPACK_IMPORTED_MODULE_2__.defineProperties)(this, {\n            format: format.name,\n            _value\n        });\n        this.#tens = getTens(format.decimals);\n    }\n    /**\n     *  If true, negative values are permitted, otherwise only\n     *  positive values and zero are allowed.\n     */ get signed() {\n        return this.#format.signed;\n    }\n    /**\n     *  The number of bits available to store the value.\n     */ get width() {\n        return this.#format.width;\n    }\n    /**\n     *  The number of decimal places in the fixed-point arithment field.\n     */ get decimals() {\n        return this.#format.decimals;\n    }\n    /**\n     *  The value as an integer, based on the smallest unit the\n     *  [[decimals]] allow.\n     */ get value() {\n        return this.#val;\n    }\n    #checkFormat(other) {\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(this.format === other.format, \"incompatible format; use fixedNumber.toFormat\", \"other\", other);\n    }\n    #checkValue(val, safeOp) {\n        /*\n                const width = BigInt(this.width);\n                if (this.signed) {\n                    const limit = (BN_1 << (width - BN_1));\n                    assert(safeOp == null || (val >= -limit  && val < limit), \"overflow\", \"NUMERIC_FAULT\", {\n                        operation: <string>safeOp, fault: \"overflow\", value: val\n                    });\n        \n                    if (val > BN_0) {\n                        val = fromTwos(mask(val, width), width);\n                    } else {\n                        val = -fromTwos(mask(-val, width), width);\n                    }\n        \n                } else {\n                    const masked = mask(val, width);\n                    assert(safeOp == null || (val >= 0 && val === masked), \"overflow\", \"NUMERIC_FAULT\", {\n                        operation: <string>safeOp, fault: \"overflow\", value: val\n                    });\n                    val = masked;\n                }\n        */ val = checkValue(val, this.#format, safeOp);\n        return new FixedNumber(_guard, val, this.#format);\n    }\n    #add(o, safeOp) {\n        this.#checkFormat(o);\n        return this.#checkValue(this.#val + o.#val, safeOp);\n    }\n    /**\n     *  Returns a new [[FixedNumber]] with the result of %%this%% added\n     *  to %%other%%, ignoring overflow.\n     */ addUnsafe(other) {\n        return this.#add(other);\n    }\n    /**\n     *  Returns a new [[FixedNumber]] with the result of %%this%% added\n     *  to %%other%%. A [[NumericFaultError]] is thrown if overflow\n     *  occurs.\n     */ add(other) {\n        return this.#add(other, \"add\");\n    }\n    #sub(o, safeOp) {\n        this.#checkFormat(o);\n        return this.#checkValue(this.#val - o.#val, safeOp);\n    }\n    /**\n     *  Returns a new [[FixedNumber]] with the result of %%other%% subtracted\n     *  from %%this%%, ignoring overflow.\n     */ subUnsafe(other) {\n        return this.#sub(other);\n    }\n    /**\n     *  Returns a new [[FixedNumber]] with the result of %%other%% subtracted\n     *  from %%this%%. A [[NumericFaultError]] is thrown if overflow\n     *  occurs.\n     */ sub(other) {\n        return this.#sub(other, \"sub\");\n    }\n    #mul(o, safeOp) {\n        this.#checkFormat(o);\n        return this.#checkValue(this.#val * o.#val / this.#tens, safeOp);\n    }\n    /**\n     *  Returns a new [[FixedNumber]] with the result of %%this%% multiplied\n     *  by %%other%%, ignoring overflow and underflow (precision loss).\n     */ mulUnsafe(other) {\n        return this.#mul(other);\n    }\n    /**\n     *  Returns a new [[FixedNumber]] with the result of %%this%% multiplied\n     *  by %%other%%. A [[NumericFaultError]] is thrown if overflow\n     *  occurs.\n     */ mul(other) {\n        return this.#mul(other, \"mul\");\n    }\n    /**\n     *  Returns a new [[FixedNumber]] with the result of %%this%% multiplied\n     *  by %%other%%. A [[NumericFaultError]] is thrown if overflow\n     *  occurs or if underflow (precision loss) occurs.\n     */ mulSignal(other) {\n        this.#checkFormat(other);\n        const value = this.#val * other.#val;\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assert)(value % this.#tens === BN_0, \"precision lost during signalling mul\", \"NUMERIC_FAULT\", {\n            operation: \"mulSignal\",\n            fault: \"underflow\",\n            value: this\n        });\n        return this.#checkValue(value / this.#tens, \"mulSignal\");\n    }\n    #div(o, safeOp) {\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assert)(o.#val !== BN_0, \"division by zero\", \"NUMERIC_FAULT\", {\n            operation: \"div\",\n            fault: \"divide-by-zero\",\n            value: this\n        });\n        this.#checkFormat(o);\n        return this.#checkValue(this.#val * this.#tens / o.#val, safeOp);\n    }\n    /**\n     *  Returns a new [[FixedNumber]] with the result of %%this%% divided\n     *  by %%other%%, ignoring underflow (precision loss). A\n     *  [[NumericFaultError]] is thrown if overflow occurs.\n     */ divUnsafe(other) {\n        return this.#div(other);\n    }\n    /**\n     *  Returns a new [[FixedNumber]] with the result of %%this%% divided\n     *  by %%other%%, ignoring underflow (precision loss). A\n     *  [[NumericFaultError]] is thrown if overflow occurs.\n     */ div(other) {\n        return this.#div(other, \"div\");\n    }\n    /**\n     *  Returns a new [[FixedNumber]] with the result of %%this%% divided\n     *  by %%other%%. A [[NumericFaultError]] is thrown if underflow\n     *  (precision loss) occurs.\n     */ divSignal(other) {\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assert)(other.#val !== BN_0, \"division by zero\", \"NUMERIC_FAULT\", {\n            operation: \"div\",\n            fault: \"divide-by-zero\",\n            value: this\n        });\n        this.#checkFormat(other);\n        const value = this.#val * this.#tens;\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assert)(value % other.#val === BN_0, \"precision lost during signalling div\", \"NUMERIC_FAULT\", {\n            operation: \"divSignal\",\n            fault: \"underflow\",\n            value: this\n        });\n        return this.#checkValue(value / other.#val, \"divSignal\");\n    }\n    /**\n     *  Returns a comparison result between %%this%% and %%other%%.\n     *\n     *  This is suitable for use in sorting, where ``-1`` implies %%this%%\n     *  is smaller, ``1`` implies %%this%% is larger and ``0`` implies\n     *  both are equal.\n     */ cmp(other) {\n        let a = this.value, b = other.value;\n        // Coerce a and b to the same magnitude\n        const delta = this.decimals - other.decimals;\n        if (delta > 0) {\n            b *= getTens(delta);\n        } else if (delta < 0) {\n            a *= getTens(-delta);\n        }\n        // Comnpare\n        if (a < b) {\n            return -1;\n        }\n        if (a > b) {\n            return 1;\n        }\n        return 0;\n    }\n    /**\n     *  Returns true if %%other%% is equal to %%this%%.\n     */ eq(other) {\n        return this.cmp(other) === 0;\n    }\n    /**\n     *  Returns true if %%other%% is less than to %%this%%.\n     */ lt(other) {\n        return this.cmp(other) < 0;\n    }\n    /**\n     *  Returns true if %%other%% is less than or equal to %%this%%.\n     */ lte(other) {\n        return this.cmp(other) <= 0;\n    }\n    /**\n     *  Returns true if %%other%% is greater than to %%this%%.\n     */ gt(other) {\n        return this.cmp(other) > 0;\n    }\n    /**\n     *  Returns true if %%other%% is greater than or equal to %%this%%.\n     */ gte(other) {\n        return this.cmp(other) >= 0;\n    }\n    /**\n     *  Returns a new [[FixedNumber]] which is the largest **integer**\n     *  that is less than or equal to %%this%%.\n     *\n     *  The decimal component of the result will always be ``0``.\n     */ floor() {\n        let val = this.#val;\n        if (this.#val < BN_0) {\n            val -= this.#tens - BN_1;\n        }\n        val = this.#val / this.#tens * this.#tens;\n        return this.#checkValue(val, \"floor\");\n    }\n    /**\n     *  Returns a new [[FixedNumber]] which is the smallest **integer**\n     *  that is greater than or equal to %%this%%.\n     *\n     *  The decimal component of the result will always be ``0``.\n     */ ceiling() {\n        let val = this.#val;\n        if (this.#val > BN_0) {\n            val += this.#tens - BN_1;\n        }\n        val = this.#val / this.#tens * this.#tens;\n        return this.#checkValue(val, \"ceiling\");\n    }\n    /**\n     *  Returns a new [[FixedNumber]] with the decimal component\n     *  rounded up on ties at %%decimals%% places.\n     */ round(decimals) {\n        if (decimals == null) {\n            decimals = 0;\n        }\n        // Not enough precision to not already be rounded\n        if (decimals >= this.decimals) {\n            return this;\n        }\n        const delta = this.decimals - decimals;\n        const bump = BN_5 * getTens(delta - 1);\n        let value = this.value + bump;\n        const tens = getTens(delta);\n        value = value / tens * tens;\n        checkValue(value, this.#format, \"round\");\n        return new FixedNumber(_guard, value, this.#format);\n    }\n    /**\n     *  Returns true if %%this%% is equal to ``0``.\n     */ isZero() {\n        return this.#val === BN_0;\n    }\n    /**\n     *  Returns true if %%this%% is less than ``0``.\n     */ isNegative() {\n        return this.#val < BN_0;\n    }\n    /**\n     *  Returns the string representation of %%this%%.\n     */ toString() {\n        return this._value;\n    }\n    /**\n     *  Returns a float approximation.\n     *\n     *  Due to IEEE 754 precission (or lack thereof), this function\n     *  can only return an approximation and most values will contain\n     *  rounding errors.\n     */ toUnsafeFloat() {\n        return parseFloat(this.toString());\n    }\n    /**\n     *  Return a new [[FixedNumber]] with the same value but has had\n     *  its field set to %%format%%.\n     *\n     *  This will throw if the value cannot fit into %%format%%.\n     */ toFormat(format) {\n        return FixedNumber.fromString(this.toString(), format);\n    }\n    /**\n     *  Creates a new [[FixedNumber]] for %%value%% divided by\n     *  %%decimal%% places with %%format%%.\n     *\n     *  This will throw a [[NumericFaultError]] if %%value%% (once adjusted\n     *  for %%decimals%%) cannot fit in %%format%%, either due to overflow\n     *  or underflow (precision loss).\n     */ static fromValue(_value, _decimals, _format) {\n        const decimals = _decimals == null ? 0 : (0,_maths_js__WEBPACK_IMPORTED_MODULE_1__.getNumber)(_decimals);\n        const format = getFormat(_format);\n        let value = (0,_maths_js__WEBPACK_IMPORTED_MODULE_1__.getBigInt)(_value, \"value\");\n        const delta = decimals - format.decimals;\n        if (delta > 0) {\n            const tens = getTens(delta);\n            (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assert)(value % tens === BN_0, \"value loses precision for format\", \"NUMERIC_FAULT\", {\n                operation: \"fromValue\",\n                fault: \"underflow\",\n                value: _value\n            });\n            value /= tens;\n        } else if (delta < 0) {\n            value *= getTens(-delta);\n        }\n        checkValue(value, format, \"fromValue\");\n        return new FixedNumber(_guard, value, format);\n    }\n    /**\n     *  Creates a new [[FixedNumber]] for %%value%% with %%format%%.\n     *\n     *  This will throw a [[NumericFaultError]] if %%value%% cannot fit\n     *  in %%format%%, either due to overflow or underflow (precision loss).\n     */ static fromString(_value, _format) {\n        const match = _value.match(/^(-?)([0-9]*)\\.?([0-9]*)$/);\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(match && match[2].length + match[3].length > 0, \"invalid FixedNumber string value\", \"value\", _value);\n        const format = getFormat(_format);\n        let whole = match[2] || \"0\", decimal = match[3] || \"\";\n        // Pad out the decimals\n        while(decimal.length < format.decimals){\n            decimal += Zeros;\n        }\n        // Check precision is safe\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assert)(decimal.substring(format.decimals).match(/^0*$/), \"too many decimals for format\", \"NUMERIC_FAULT\", {\n            operation: \"fromString\",\n            fault: \"underflow\",\n            value: _value\n        });\n        // Remove extra padding\n        decimal = decimal.substring(0, format.decimals);\n        const value = BigInt(match[1] + whole + decimal);\n        checkValue(value, format, \"fromString\");\n        return new FixedNumber(_guard, value, format);\n    }\n    /**\n     *  Creates a new [[FixedNumber]] with the big-endian representation\n     *  %%value%% with %%format%%.\n     *\n     *  This will throw a [[NumericFaultError]] if %%value%% cannot fit\n     *  in %%format%% due to overflow.\n     */ static fromBytes(_value, _format) {\n        let value = (0,_maths_js__WEBPACK_IMPORTED_MODULE_1__.toBigInt)((0,_data_js__WEBPACK_IMPORTED_MODULE_3__.getBytes)(_value, \"value\"));\n        const format = getFormat(_format);\n        if (format.signed) {\n            value = (0,_maths_js__WEBPACK_IMPORTED_MODULE_1__.fromTwos)(value, format.width);\n        }\n        checkValue(value, format, \"fromBytes\");\n        return new FixedNumber(_guard, value, format);\n    }\n} //const f1 = FixedNumber.fromString(\"12.56\", \"fixed16x2\");\n //const f2 = FixedNumber.fromString(\"0.3\", \"fixed16x2\");\n //console.log(f1.divSignal(f2));\n //const BUMP = FixedNumber.from(\"0.5\");\n //# sourceMappingURL=fixednumber.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vdXRpbHMvZml4ZWRudW1iZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTs7Ozs7Ozs7O0NBU0MsR0FDb0M7QUFDK0I7QUFDUTtBQUN6QjtBQUNuRCxNQUFNVSxRQUFRQyxPQUFPLENBQUM7QUFDdEIsTUFBTUMsT0FBT0QsT0FBTztBQUNwQixNQUFNRSxPQUFPRixPQUFPO0FBQ3BCLE1BQU1HLE9BQU9ILE9BQU87QUFDcEIsTUFBTUksU0FBUyxDQUFDO0FBQ2hCLDhDQUE4QztBQUM5QyxJQUFJQyxRQUFRO0FBQ1osTUFBT0EsTUFBTUMsTUFBTSxHQUFHLEdBQUk7SUFDdEJELFNBQVNBO0FBQ2I7QUFDQSxnREFBZ0Q7QUFDaEQsU0FBU0UsUUFBUUMsUUFBUTtJQUNyQixJQUFJQyxTQUFTSjtJQUNiLE1BQU9JLE9BQU9ILE1BQU0sR0FBR0UsU0FBVTtRQUM3QkMsVUFBVUE7SUFDZDtJQUNBLE9BQU9ULE9BQU8sTUFBTVMsT0FBT0MsU0FBUyxDQUFDLEdBQUdGO0FBQzVDO0FBQ0EsU0FBU0csV0FBV0MsR0FBRyxFQUFFQyxNQUFNLEVBQUVDLE1BQU07SUFDbkMsTUFBTUMsUUFBUWYsT0FBT2EsT0FBT0UsS0FBSztJQUNqQyxJQUFJRixPQUFPRyxNQUFNLEVBQUU7UUFDZixNQUFNQyxRQUFTZixRQUFTYSxRQUFRYjtRQUNoQ1osa0RBQU1BLENBQUN3QixVQUFVLFFBQVNGLE9BQU8sQ0FBQ0ssU0FBU0wsTUFBTUssT0FBUSxZQUFZLGlCQUFpQjtZQUNsRkMsV0FBV0o7WUFBUUssT0FBTztZQUFZQyxPQUFPUjtRQUNqRDtRQUNBLElBQUlBLE1BQU1YLE1BQU07WUFDWlcsTUFBTWpCLG1EQUFRQSxDQUFDQywrQ0FBSUEsQ0FBQ2dCLEtBQUtHLFFBQVFBO1FBQ3JDLE9BQ0s7WUFDREgsTUFBTSxDQUFDakIsbURBQVFBLENBQUNDLCtDQUFJQSxDQUFDLENBQUNnQixLQUFLRyxRQUFRQTtRQUN2QztJQUNK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ZXRoZXJzL2xpYi5lc20vdXRpbHMvZml4ZWRudW1iZXIuanM/NDU0MyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqICBUaGUgKipGaXhlZE51bWJlcioqIGNsYXNzIHBlcm1pdHMgdXNpbmcgdmFsdWVzIHdpdGggZGVjaW1hbCBwbGFjZXMsXG4gKiAgdXNpbmcgZml4ZWQtcG9udCBtYXRoLlxuICpcbiAqICBGaXhlZC1wb2ludCBtYXRoIGlzIHN0aWxsIGJhc2VkIG9uIGludGVnZXJzIHVuZGVyLXRoZS1ob29kLCBidXQgdXNlcyBhblxuICogIGludGVybmFsIG9mZnNldCB0byBzdG9yZSBmcmFjdGlvbmFsIGNvbXBvbmVudHMgYmVsb3csIGFuZCBlYWNoIG9wZXJhdGlvblxuICogIGNvcnJlY3RzIGZvciB0aGlzIGFmdGVyIGVhY2ggb3BlcmF0aW9uLlxuICpcbiAqICBAX3NlY3Rpb246IGFwaS91dGlscy9maXhlZC1wb2ludC1tYXRoOkZpeGVkLVBvaW50IE1hdGhzICBbYWJvdXQtZml4ZWQtcG9pbnQtbWF0aF1cbiAqL1xuaW1wb3J0IHsgZ2V0Qnl0ZXMgfSBmcm9tIFwiLi9kYXRhLmpzXCI7XG5pbXBvcnQgeyBhc3NlcnQsIGFzc2VydEFyZ3VtZW50LCBhc3NlcnRQcml2YXRlIH0gZnJvbSBcIi4vZXJyb3JzLmpzXCI7XG5pbXBvcnQgeyBnZXRCaWdJbnQsIGdldE51bWJlciwgZnJvbVR3b3MsIG1hc2ssIHRvQmlnSW50IH0gZnJvbSBcIi4vbWF0aHMuanNcIjtcbmltcG9ydCB7IGRlZmluZVByb3BlcnRpZXMgfSBmcm9tIFwiLi9wcm9wZXJ0aWVzLmpzXCI7XG5jb25zdCBCTl9OMSA9IEJpZ0ludCgtMSk7XG5jb25zdCBCTl8wID0gQmlnSW50KDApO1xuY29uc3QgQk5fMSA9IEJpZ0ludCgxKTtcbmNvbnN0IEJOXzUgPSBCaWdJbnQoNSk7XG5jb25zdCBfZ3VhcmQgPSB7fTtcbi8vIENvbnN0YW50IHRvIHB1bGwgemVyb3MgZnJvbSBmb3IgbXVsdGlwbGllcnNcbmxldCBaZXJvcyA9IFwiMDAwMFwiO1xud2hpbGUgKFplcm9zLmxlbmd0aCA8IDgwKSB7XG4gICAgWmVyb3MgKz0gWmVyb3M7XG59XG4vLyBSZXR1cm5zIGEgc3RyaW5nIFwiMVwiIGZvbGxvd2VkIGJ5IGRlY2ltYWwgXCIwXCJzXG5mdW5jdGlvbiBnZXRUZW5zKGRlY2ltYWxzKSB7XG4gICAgbGV0IHJlc3VsdCA9IFplcm9zO1xuICAgIHdoaWxlIChyZXN1bHQubGVuZ3RoIDwgZGVjaW1hbHMpIHtcbiAgICAgICAgcmVzdWx0ICs9IHJlc3VsdDtcbiAgICB9XG4gICAgcmV0dXJuIEJpZ0ludChcIjFcIiArIHJlc3VsdC5zdWJzdHJpbmcoMCwgZGVjaW1hbHMpKTtcbn1cbmZ1bmN0aW9uIGNoZWNrVmFsdWUodmFsLCBmb3JtYXQsIHNhZmVPcCkge1xuICAgIGNvbnN0IHdpZHRoID0gQmlnSW50KGZvcm1hdC53aWR0aCk7XG4gICAgaWYgKGZvcm1hdC5zaWduZWQpIHtcbiAgICAgICAgY29uc3QgbGltaXQgPSAoQk5fMSA8PCAod2lkdGggLSBCTl8xKSk7XG4gICAgICAgIGFzc2VydChzYWZlT3AgPT0gbnVsbCB8fCAodmFsID49IC1saW1pdCAmJiB2YWwgPCBsaW1pdCksIFwib3ZlcmZsb3dcIiwgXCJOVU1FUklDX0ZBVUxUXCIsIHtcbiAgICAgICAgICAgIG9wZXJhdGlvbjogc2FmZU9wLCBmYXVsdDogXCJvdmVyZmxvd1wiLCB2YWx1ZTogdmFsXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAodmFsID4gQk5fMCkge1xuICAgICAgICAgICAgdmFsID0gZnJvbVR3b3MobWFzayh2YWwsIHdpZHRoKSwgd2lkdGgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFsID0gLWZyb21Ud29zKG1hc2soLXZhbCwgd2lkdGgpLCB3aWR0aCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IGxpbWl0ID0gKEJOXzEgPDwgd2lkdGgpO1xuICAgICAgICBhc3NlcnQoc2FmZU9wID09IG51bGwgfHwgKHZhbCA+PSAwICYmIHZhbCA8IGxpbWl0KSwgXCJvdmVyZmxvd1wiLCBcIk5VTUVSSUNfRkFVTFRcIiwge1xuICAgICAgICAgICAgb3BlcmF0aW9uOiBzYWZlT3AsIGZhdWx0OiBcIm92ZXJmbG93XCIsIHZhbHVlOiB2YWxcbiAgICAgICAgfSk7XG4gICAgICAgIHZhbCA9ICgoKHZhbCAlIGxpbWl0KSArIGxpbWl0KSAlIGxpbWl0KSAmIChsaW1pdCAtIEJOXzEpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsO1xufVxuZnVuY3Rpb24gZ2V0Rm9ybWF0KHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiAodmFsdWUpID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgIHZhbHVlID0gYGZpeGVkMTI4eCR7dmFsdWV9YDtcbiAgICB9XG4gICAgbGV0IHNpZ25lZCA9IHRydWU7XG4gICAgbGV0IHdpZHRoID0gMTI4O1xuICAgIGxldCBkZWNpbWFscyA9IDE4O1xuICAgIGlmICh0eXBlb2YgKHZhbHVlKSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAvLyBQYXJzZSB0aGUgZm9ybWF0IHN0cmluZ1xuICAgICAgICBpZiAodmFsdWUgPT09IFwiZml4ZWRcIikge1xuICAgICAgICAgICAgLy8gZGVmYXVsdHMuLi5cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh2YWx1ZSA9PT0gXCJ1Zml4ZWRcIikge1xuICAgICAgICAgICAgc2lnbmVkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBtYXRjaCA9IHZhbHVlLm1hdGNoKC9eKHU/KWZpeGVkKFswLTldKyl4KFswLTldKykkLyk7XG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudChtYXRjaCwgXCJpbnZhbGlkIGZpeGVkIGZvcm1hdFwiLCBcImZvcm1hdFwiLCB2YWx1ZSk7XG4gICAgICAgICAgICBzaWduZWQgPSAobWF0Y2hbMV0gIT09IFwidVwiKTtcbiAgICAgICAgICAgIHdpZHRoID0gcGFyc2VJbnQobWF0Y2hbMl0pO1xuICAgICAgICAgICAgZGVjaW1hbHMgPSBwYXJzZUludChtYXRjaFszXSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAodmFsdWUpIHtcbiAgICAgICAgLy8gRXh0cmFjdCB0aGUgdmFsdWVzIGZyb20gdGhlIG9iamVjdFxuICAgICAgICBjb25zdCB2ID0gdmFsdWU7XG4gICAgICAgIGNvbnN0IGNoZWNrID0gKGtleSwgdHlwZSwgZGVmYXVsdFZhbHVlKSA9PiB7XG4gICAgICAgICAgICBpZiAodltrZXldID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGVmYXVsdFZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQodHlwZW9mICh2W2tleV0pID09PSB0eXBlLCBcImludmFsaWQgZml4ZWQgZm9ybWF0IChcIiArIGtleSArIFwiIG5vdCBcIiArIHR5cGUgKyBcIilcIiwgXCJmb3JtYXQuXCIgKyBrZXksIHZba2V5XSk7XG4gICAgICAgICAgICByZXR1cm4gdltrZXldO1xuICAgICAgICB9O1xuICAgICAgICBzaWduZWQgPSBjaGVjayhcInNpZ25lZFwiLCBcImJvb2xlYW5cIiwgc2lnbmVkKTtcbiAgICAgICAgd2lkdGggPSBjaGVjayhcIndpZHRoXCIsIFwibnVtYmVyXCIsIHdpZHRoKTtcbiAgICAgICAgZGVjaW1hbHMgPSBjaGVjayhcImRlY2ltYWxzXCIsIFwibnVtYmVyXCIsIGRlY2ltYWxzKTtcbiAgICB9XG4gICAgYXNzZXJ0QXJndW1lbnQoKHdpZHRoICUgOCkgPT09IDAsIFwiaW52YWxpZCBGaXhlZE51bWJlciB3aWR0aCAobm90IGJ5dGUgYWxpZ25lZClcIiwgXCJmb3JtYXQud2lkdGhcIiwgd2lkdGgpO1xuICAgIGFzc2VydEFyZ3VtZW50KGRlY2ltYWxzIDw9IDgwLCBcImludmFsaWQgRml4ZWROdW1iZXIgZGVjaW1hbHMgKHRvbyBsYXJnZSlcIiwgXCJmb3JtYXQuZGVjaW1hbHNcIiwgZGVjaW1hbHMpO1xuICAgIGNvbnN0IG5hbWUgPSAoc2lnbmVkID8gXCJcIiA6IFwidVwiKSArIFwiZml4ZWRcIiArIFN0cmluZyh3aWR0aCkgKyBcInhcIiArIFN0cmluZyhkZWNpbWFscyk7XG4gICAgcmV0dXJuIHsgc2lnbmVkLCB3aWR0aCwgZGVjaW1hbHMsIG5hbWUgfTtcbn1cbmZ1bmN0aW9uIHRvU3RyaW5nKHZhbCwgZGVjaW1hbHMpIHtcbiAgICBsZXQgbmVnYXRpdmUgPSBcIlwiO1xuICAgIGlmICh2YWwgPCBCTl8wKSB7XG4gICAgICAgIG5lZ2F0aXZlID0gXCItXCI7XG4gICAgICAgIHZhbCAqPSBCTl9OMTtcbiAgICB9XG4gICAgbGV0IHN0ciA9IHZhbC50b1N0cmluZygpO1xuICAgIC8vIE5vIGRlY2ltYWwgcG9pbnQgZm9yIHdob2xlIHZhbHVlc1xuICAgIGlmIChkZWNpbWFscyA9PT0gMCkge1xuICAgICAgICByZXR1cm4gKG5lZ2F0aXZlICsgc3RyKTtcbiAgICB9XG4gICAgLy8gUGFkIG91dCB0byB0aGUgd2hvbGUgY29tcG9uZW50IChpbmNsdWRpbmcgYSB3aG9sZSBkaWdpdClcbiAgICB3aGlsZSAoc3RyLmxlbmd0aCA8PSBkZWNpbWFscykge1xuICAgICAgICBzdHIgPSBaZXJvcyArIHN0cjtcbiAgICB9XG4gICAgLy8gSW5zZXJ0IHRoZSBkZWNpbWFsIHBvaW50XG4gICAgY29uc3QgaW5kZXggPSBzdHIubGVuZ3RoIC0gZGVjaW1hbHM7XG4gICAgc3RyID0gc3RyLnN1YnN0cmluZygwLCBpbmRleCkgKyBcIi5cIiArIHN0ci5zdWJzdHJpbmcoaW5kZXgpO1xuICAgIC8vIFRyaW0gdGhlIHdob2xlIGNvbXBvbmVudCAobGVhdmluZyBhdCBsZWFzdCBvbmUgMClcbiAgICB3aGlsZSAoc3RyWzBdID09PSBcIjBcIiAmJiBzdHJbMV0gIT09IFwiLlwiKSB7XG4gICAgICAgIHN0ciA9IHN0ci5zdWJzdHJpbmcoMSk7XG4gICAgfVxuICAgIC8vIFRyaW0gdGhlIGRlY2ltYWwgY29tcG9uZW50IChsZWF2aW5nIGF0IGxlYXN0IG9uZSAwKVxuICAgIHdoaWxlIChzdHJbc3RyLmxlbmd0aCAtIDFdID09PSBcIjBcIiAmJiBzdHJbc3RyLmxlbmd0aCAtIDJdICE9PSBcIi5cIikge1xuICAgICAgICBzdHIgPSBzdHIuc3Vic3RyaW5nKDAsIHN0ci5sZW5ndGggLSAxKTtcbiAgICB9XG4gICAgcmV0dXJuIChuZWdhdGl2ZSArIHN0cik7XG59XG4vKipcbiAqICBBIEZpeGVkTnVtYmVyIHJlcHJlc2VudHMgYSB2YWx1ZSBvdmVyIGl0cyBbW0ZpeGVkRm9ybWF0XV1cbiAqICBhcml0aG1ldGljIGZpZWxkLlxuICpcbiAqICBBIEZpeGVkTnVtYmVyIGNhbiBiZSB1c2VkIHRvIHBlcmZvcm0gbWF0aCwgbG9zc2xlc3NseSwgb25cbiAqICB2YWx1ZXMgd2hpY2ggaGF2ZSBkZWNtaWFsIHBsYWNlcy5cbiAqXG4gKiAgQSBGaXhlZE51bWJlciBoYXMgYSBmaXhlZCBiaXQtd2lkdGggdG8gc3RvcmUgdmFsdWVzIGluLCBhbmQgc3RvcmVzIGFsbFxuICogIHZhbHVlcyBpbnRlcm5hbGx5IGJ5IG11bHRpcGx5aW5nIHRoZSB2YWx1ZSBieSAxMCByYWlzZWQgdG8gdGhlIHBvd2VyIG9mXG4gKiAgJSVkZWNpbWFscyUlLlxuICpcbiAqICBJZiBvcGVyYXRpb25zIGFyZSBwZXJmb3JtZWQgdGhhdCBjYXVzZSBhIHZhbHVlIHRvIGdyb3cgdG9vIGhpZ2ggKGNsb3NlIHRvXG4gKiAgcG9zaXRpdmUgaW5maW5pdHkpIG9yIHRvbyBsb3cgKGNsb3NlIHRvIG5lZ2F0aXZlIGluZmluaXR5KSwgdGhlIHZhbHVlXG4gKiAgaXMgc2FpZCB0byAvL292ZXJmbG93Ly8uXG4gKlxuICogIEZvciBleGFtcGxlLCBhbiA4LWJpdCBzaWduZWQgdmFsdWUsIHdpdGggMCBkZWNpbWFscyBtYXkgb25seSBiZSB3aXRoaW5cbiAqICB0aGUgcmFuZ2UgYGAtMTI4YGAgdG8gYGAxMjdgYDsgc28gYGAtMTI4IC0gMWBgIHdpbGwgb3ZlcmZsb3cgYW5kIGJlY29tZVxuICogIGBgMTI3YGAuIExpa2V3aXNlLCBgYDEyNyArIDFgYCB3aWxsIG92ZXJmbG93IGFuZCBiZWNvbWUgYGAtMTI3YGAuXG4gKlxuICogIE1hbnkgb3BlcmF0aW9uIGhhdmUgYSBub3JtYWwgYW5kIC8vdW5zYWZlLy8gdmFyaWFudC4gVGhlIG5vcm1hbCB2YXJpYW50XG4gKiAgd2lsbCB0aHJvdyBhIFtbTnVtZXJpY0ZhdWx0RXJyb3JdXSBvbiBhbnkgb3ZlcmZsb3csIHdoaWxlIHRoZSAvL3Vuc2FmZS8vXG4gKiAgdmFyaWFudCB3aWxsIHNpbGVudGx5IGFsbG93IG92ZXJmbG93LCBjb3JydXB0aW5nIGl0cyB2YWx1ZSB2YWx1ZS5cbiAqXG4gKiAgSWYgb3BlcmF0aW9ucyBhcmUgcGVyZm9ybWVkIHRoYXQgY2F1c2UgYSB2YWx1ZSB0byBiZWNvbWUgdG9vIHNtYWxsXG4gKiAgKGNsb3NlIHRvIHplcm8pLCB0aGUgdmFsdWUgbG9zZXMgcHJlY2lzb24gYW5kIGlzIHNhaWQgdG8gLy91bmRlcmZsb3cvLy5cbiAqXG4gKiAgRm9yIGV4YW1wbGUsIGEgdmFsdWUgd2l0aCAxIGRlY2ltYWwgcGxhY2UgbWF5IHN0b3JlIGEgbnVtYmVyIGFzIHNtYWxsXG4gKiAgYXMgYGAwLjFgYCwgYnV0IHRoZSB2YWx1ZSBvZiBgYDAuMSAvIDJgYCBpcyBgYDAuMDVgYCwgd2hpY2ggY2Fubm90IGZpdFxuICogIGludG8gMSBkZWNpbWFsIHBsYWNlLCBzbyB1bmRlcmZsb3cgb2NjdXJzIHdoaWNoIG1lYW5zIHByZWNpc2lvbiBpcyBsb3N0XG4gKiAgYW5kIHRoZSB2YWx1ZSBiZWNvbWVzIGBgMGBgLlxuICpcbiAqICBTb21lIG9wZXJhdGlvbnMgaGF2ZSBhIG5vcm1hbCBhbmQgLy9zaWduYWxsaW5nLy8gdmFyaWFudC4gVGhlIG5vcm1hbFxuICogIHZhcmlhbnQgd2lsbCBzaWxlbnRseSBpZ25vcmUgdW5kZXJmbG93LCB3aGlsZSB0aGUgLy9zaWduYWxsaW5nLy8gdmFyaWFudFxuICogIHdpbGwgdGhvdyBhIFtbTnVtZXJpY0ZhdWx0RXJyb3JdXSBvbiB1bmRlcmZsb3cuXG4gKi9cbmV4cG9ydCBjbGFzcyBGaXhlZE51bWJlciB7XG4gICAgLyoqXG4gICAgICogIFRoZSBzcGVjaWZpYyBmaXhlZC1wb2ludCBhcml0aG1ldGljIGZpZWxkIGZvciB0aGlzIHZhbHVlLlxuICAgICAqL1xuICAgIGZvcm1hdDtcbiAgICAjZm9ybWF0O1xuICAgIC8vIFRoZSBhY3R1YWwgdmFsdWUgKGFjY291bnRpbmcgZm9yIGRlY2ltYWxzKVxuICAgICN2YWw7XG4gICAgLy8gQSBiYXNlLTEwIHZhbHVlIHRvIG11bHRpcGxlIHZhbHVlcyBieSB0byBtYWludGFpbiB0aGUgbWFnbml0dWRlXG4gICAgI3RlbnM7XG4gICAgLyoqXG4gICAgICogIFRoaXMgaXMgYSBwcm9wZXJ0eSBzbyBjb25zb2xlLmxvZyBzaG93cyBhIGh1bWFuLW1lYW5pbmdmdWwgdmFsdWUuXG4gICAgICpcbiAgICAgKiAgQHByaXZhdGVcbiAgICAgKi9cbiAgICBfdmFsdWU7XG4gICAgLy8gVXNlIHRoaXMgd2hlbiBjaGFuZ2luZyB0aGlzIGZpbGUgdG8gZ2V0IHNvbWUgdHlwaW5nIGluZm8sXG4gICAgLy8gYnV0IHRoZW4gc3dpdGNoIHRvIGFueSB0byBtYXNrIHRoZSBpbnRlcm5hbCB0eXBlXG4gICAgLy9jb25zdHJ1Y3RvcihndWFyZDogYW55LCB2YWx1ZTogYmlnaW50LCBmb3JtYXQ6IF9GaXhlZEZvcm1hdCkge1xuICAgIC8qKlxuICAgICAqICBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGd1YXJkLCB2YWx1ZSwgZm9ybWF0KSB7XG4gICAgICAgIGFzc2VydFByaXZhdGUoZ3VhcmQsIF9ndWFyZCwgXCJGaXhlZE51bWJlclwiKTtcbiAgICAgICAgdGhpcy4jdmFsID0gdmFsdWU7XG4gICAgICAgIHRoaXMuI2Zvcm1hdCA9IGZvcm1hdDtcbiAgICAgICAgY29uc3QgX3ZhbHVlID0gdG9TdHJpbmcodmFsdWUsIGZvcm1hdC5kZWNpbWFscyk7XG4gICAgICAgIGRlZmluZVByb3BlcnRpZXModGhpcywgeyBmb3JtYXQ6IGZvcm1hdC5uYW1lLCBfdmFsdWUgfSk7XG4gICAgICAgIHRoaXMuI3RlbnMgPSBnZXRUZW5zKGZvcm1hdC5kZWNpbWFscyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBJZiB0cnVlLCBuZWdhdGl2ZSB2YWx1ZXMgYXJlIHBlcm1pdHRlZCwgb3RoZXJ3aXNlIG9ubHlcbiAgICAgKiAgcG9zaXRpdmUgdmFsdWVzIGFuZCB6ZXJvIGFyZSBhbGxvd2VkLlxuICAgICAqL1xuICAgIGdldCBzaWduZWQoKSB7IHJldHVybiB0aGlzLiNmb3JtYXQuc2lnbmVkOyB9XG4gICAgLyoqXG4gICAgICogIFRoZSBudW1iZXIgb2YgYml0cyBhdmFpbGFibGUgdG8gc3RvcmUgdGhlIHZhbHVlLlxuICAgICAqL1xuICAgIGdldCB3aWR0aCgpIHsgcmV0dXJuIHRoaXMuI2Zvcm1hdC53aWR0aDsgfVxuICAgIC8qKlxuICAgICAqICBUaGUgbnVtYmVyIG9mIGRlY2ltYWwgcGxhY2VzIGluIHRoZSBmaXhlZC1wb2ludCBhcml0aG1lbnQgZmllbGQuXG4gICAgICovXG4gICAgZ2V0IGRlY2ltYWxzKCkgeyByZXR1cm4gdGhpcy4jZm9ybWF0LmRlY2ltYWxzOyB9XG4gICAgLyoqXG4gICAgICogIFRoZSB2YWx1ZSBhcyBhbiBpbnRlZ2VyLCBiYXNlZCBvbiB0aGUgc21hbGxlc3QgdW5pdCB0aGVcbiAgICAgKiAgW1tkZWNpbWFsc11dIGFsbG93LlxuICAgICAqL1xuICAgIGdldCB2YWx1ZSgpIHsgcmV0dXJuIHRoaXMuI3ZhbDsgfVxuICAgICNjaGVja0Zvcm1hdChvdGhlcikge1xuICAgICAgICBhc3NlcnRBcmd1bWVudCh0aGlzLmZvcm1hdCA9PT0gb3RoZXIuZm9ybWF0LCBcImluY29tcGF0aWJsZSBmb3JtYXQ7IHVzZSBmaXhlZE51bWJlci50b0Zvcm1hdFwiLCBcIm90aGVyXCIsIG90aGVyKTtcbiAgICB9XG4gICAgI2NoZWNrVmFsdWUodmFsLCBzYWZlT3ApIHtcbiAgICAgICAgLypcbiAgICAgICAgICAgICAgICBjb25zdCB3aWR0aCA9IEJpZ0ludCh0aGlzLndpZHRoKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zaWduZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbGltaXQgPSAoQk5fMSA8PCAod2lkdGggLSBCTl8xKSk7XG4gICAgICAgICAgICAgICAgICAgIGFzc2VydChzYWZlT3AgPT0gbnVsbCB8fCAodmFsID49IC1saW1pdCAgJiYgdmFsIDwgbGltaXQpLCBcIm92ZXJmbG93XCIsIFwiTlVNRVJJQ19GQVVMVFwiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcGVyYXRpb246IDxzdHJpbmc+c2FmZU9wLCBmYXVsdDogXCJvdmVyZmxvd1wiLCB2YWx1ZTogdmFsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbCA+IEJOXzApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbCA9IGZyb21Ud29zKG1hc2sodmFsLCB3aWR0aCksIHdpZHRoKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbCA9IC1mcm9tVHdvcyhtYXNrKC12YWwsIHdpZHRoKSwgd2lkdGgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG1hc2tlZCA9IG1hc2sodmFsLCB3aWR0aCk7XG4gICAgICAgICAgICAgICAgICAgIGFzc2VydChzYWZlT3AgPT0gbnVsbCB8fCAodmFsID49IDAgJiYgdmFsID09PSBtYXNrZWQpLCBcIm92ZXJmbG93XCIsIFwiTlVNRVJJQ19GQVVMVFwiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcGVyYXRpb246IDxzdHJpbmc+c2FmZU9wLCBmYXVsdDogXCJvdmVyZmxvd1wiLCB2YWx1ZTogdmFsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB2YWwgPSBtYXNrZWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAqL1xuICAgICAgICB2YWwgPSBjaGVja1ZhbHVlKHZhbCwgdGhpcy4jZm9ybWF0LCBzYWZlT3ApO1xuICAgICAgICByZXR1cm4gbmV3IEZpeGVkTnVtYmVyKF9ndWFyZCwgdmFsLCB0aGlzLiNmb3JtYXQpO1xuICAgIH1cbiAgICAjYWRkKG8sIHNhZmVPcCkge1xuICAgICAgICB0aGlzLiNjaGVja0Zvcm1hdChvKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuI2NoZWNrVmFsdWUodGhpcy4jdmFsICsgby4jdmFsLCBzYWZlT3ApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBhIG5ldyBbW0ZpeGVkTnVtYmVyXV0gd2l0aCB0aGUgcmVzdWx0IG9mICUldGhpcyUlIGFkZGVkXG4gICAgICogIHRvICUlb3RoZXIlJSwgaWdub3Jpbmcgb3ZlcmZsb3cuXG4gICAgICovXG4gICAgYWRkVW5zYWZlKG90aGVyKSB7IHJldHVybiB0aGlzLiNhZGQob3RoZXIpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYSBuZXcgW1tGaXhlZE51bWJlcl1dIHdpdGggdGhlIHJlc3VsdCBvZiAlJXRoaXMlJSBhZGRlZFxuICAgICAqICB0byAlJW90aGVyJSUuIEEgW1tOdW1lcmljRmF1bHRFcnJvcl1dIGlzIHRocm93biBpZiBvdmVyZmxvd1xuICAgICAqICBvY2N1cnMuXG4gICAgICovXG4gICAgYWRkKG90aGVyKSB7IHJldHVybiB0aGlzLiNhZGQob3RoZXIsIFwiYWRkXCIpOyB9XG4gICAgI3N1YihvLCBzYWZlT3ApIHtcbiAgICAgICAgdGhpcy4jY2hlY2tGb3JtYXQobyk7XG4gICAgICAgIHJldHVybiB0aGlzLiNjaGVja1ZhbHVlKHRoaXMuI3ZhbCAtIG8uI3ZhbCwgc2FmZU9wKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYSBuZXcgW1tGaXhlZE51bWJlcl1dIHdpdGggdGhlIHJlc3VsdCBvZiAlJW90aGVyJSUgc3VidHJhY3RlZFxuICAgICAqICBmcm9tICUldGhpcyUlLCBpZ25vcmluZyBvdmVyZmxvdy5cbiAgICAgKi9cbiAgICBzdWJVbnNhZmUob3RoZXIpIHsgcmV0dXJuIHRoaXMuI3N1YihvdGhlcik7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBhIG5ldyBbW0ZpeGVkTnVtYmVyXV0gd2l0aCB0aGUgcmVzdWx0IG9mICUlb3RoZXIlJSBzdWJ0cmFjdGVkXG4gICAgICogIGZyb20gJSV0aGlzJSUuIEEgW1tOdW1lcmljRmF1bHRFcnJvcl1dIGlzIHRocm93biBpZiBvdmVyZmxvd1xuICAgICAqICBvY2N1cnMuXG4gICAgICovXG4gICAgc3ViKG90aGVyKSB7IHJldHVybiB0aGlzLiNzdWIob3RoZXIsIFwic3ViXCIpOyB9XG4gICAgI211bChvLCBzYWZlT3ApIHtcbiAgICAgICAgdGhpcy4jY2hlY2tGb3JtYXQobyk7XG4gICAgICAgIHJldHVybiB0aGlzLiNjaGVja1ZhbHVlKCh0aGlzLiN2YWwgKiBvLiN2YWwpIC8gdGhpcy4jdGVucywgc2FmZU9wKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYSBuZXcgW1tGaXhlZE51bWJlcl1dIHdpdGggdGhlIHJlc3VsdCBvZiAlJXRoaXMlJSBtdWx0aXBsaWVkXG4gICAgICogIGJ5ICUlb3RoZXIlJSwgaWdub3Jpbmcgb3ZlcmZsb3cgYW5kIHVuZGVyZmxvdyAocHJlY2lzaW9uIGxvc3MpLlxuICAgICAqL1xuICAgIG11bFVuc2FmZShvdGhlcikgeyByZXR1cm4gdGhpcy4jbXVsKG90aGVyKTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGEgbmV3IFtbRml4ZWROdW1iZXJdXSB3aXRoIHRoZSByZXN1bHQgb2YgJSV0aGlzJSUgbXVsdGlwbGllZFxuICAgICAqICBieSAlJW90aGVyJSUuIEEgW1tOdW1lcmljRmF1bHRFcnJvcl1dIGlzIHRocm93biBpZiBvdmVyZmxvd1xuICAgICAqICBvY2N1cnMuXG4gICAgICovXG4gICAgbXVsKG90aGVyKSB7IHJldHVybiB0aGlzLiNtdWwob3RoZXIsIFwibXVsXCIpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYSBuZXcgW1tGaXhlZE51bWJlcl1dIHdpdGggdGhlIHJlc3VsdCBvZiAlJXRoaXMlJSBtdWx0aXBsaWVkXG4gICAgICogIGJ5ICUlb3RoZXIlJS4gQSBbW051bWVyaWNGYXVsdEVycm9yXV0gaXMgdGhyb3duIGlmIG92ZXJmbG93XG4gICAgICogIG9jY3VycyBvciBpZiB1bmRlcmZsb3cgKHByZWNpc2lvbiBsb3NzKSBvY2N1cnMuXG4gICAgICovXG4gICAgbXVsU2lnbmFsKG90aGVyKSB7XG4gICAgICAgIHRoaXMuI2NoZWNrRm9ybWF0KG90aGVyKTtcbiAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLiN2YWwgKiBvdGhlci4jdmFsO1xuICAgICAgICBhc3NlcnQoKHZhbHVlICUgdGhpcy4jdGVucykgPT09IEJOXzAsIFwicHJlY2lzaW9uIGxvc3QgZHVyaW5nIHNpZ25hbGxpbmcgbXVsXCIsIFwiTlVNRVJJQ19GQVVMVFwiLCB7XG4gICAgICAgICAgICBvcGVyYXRpb246IFwibXVsU2lnbmFsXCIsIGZhdWx0OiBcInVuZGVyZmxvd1wiLCB2YWx1ZTogdGhpc1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuI2NoZWNrVmFsdWUodmFsdWUgLyB0aGlzLiN0ZW5zLCBcIm11bFNpZ25hbFwiKTtcbiAgICB9XG4gICAgI2RpdihvLCBzYWZlT3ApIHtcbiAgICAgICAgYXNzZXJ0KG8uI3ZhbCAhPT0gQk5fMCwgXCJkaXZpc2lvbiBieSB6ZXJvXCIsIFwiTlVNRVJJQ19GQVVMVFwiLCB7XG4gICAgICAgICAgICBvcGVyYXRpb246IFwiZGl2XCIsIGZhdWx0OiBcImRpdmlkZS1ieS16ZXJvXCIsIHZhbHVlOiB0aGlzXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLiNjaGVja0Zvcm1hdChvKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuI2NoZWNrVmFsdWUoKHRoaXMuI3ZhbCAqIHRoaXMuI3RlbnMpIC8gby4jdmFsLCBzYWZlT3ApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBhIG5ldyBbW0ZpeGVkTnVtYmVyXV0gd2l0aCB0aGUgcmVzdWx0IG9mICUldGhpcyUlIGRpdmlkZWRcbiAgICAgKiAgYnkgJSVvdGhlciUlLCBpZ25vcmluZyB1bmRlcmZsb3cgKHByZWNpc2lvbiBsb3NzKS4gQVxuICAgICAqICBbW051bWVyaWNGYXVsdEVycm9yXV0gaXMgdGhyb3duIGlmIG92ZXJmbG93IG9jY3Vycy5cbiAgICAgKi9cbiAgICBkaXZVbnNhZmUob3RoZXIpIHsgcmV0dXJuIHRoaXMuI2RpdihvdGhlcik7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBhIG5ldyBbW0ZpeGVkTnVtYmVyXV0gd2l0aCB0aGUgcmVzdWx0IG9mICUldGhpcyUlIGRpdmlkZWRcbiAgICAgKiAgYnkgJSVvdGhlciUlLCBpZ25vcmluZyB1bmRlcmZsb3cgKHByZWNpc2lvbiBsb3NzKS4gQVxuICAgICAqICBbW051bWVyaWNGYXVsdEVycm9yXV0gaXMgdGhyb3duIGlmIG92ZXJmbG93IG9jY3Vycy5cbiAgICAgKi9cbiAgICBkaXYob3RoZXIpIHsgcmV0dXJuIHRoaXMuI2RpdihvdGhlciwgXCJkaXZcIik7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBhIG5ldyBbW0ZpeGVkTnVtYmVyXV0gd2l0aCB0aGUgcmVzdWx0IG9mICUldGhpcyUlIGRpdmlkZWRcbiAgICAgKiAgYnkgJSVvdGhlciUlLiBBIFtbTnVtZXJpY0ZhdWx0RXJyb3JdXSBpcyB0aHJvd24gaWYgdW5kZXJmbG93XG4gICAgICogIChwcmVjaXNpb24gbG9zcykgb2NjdXJzLlxuICAgICAqL1xuICAgIGRpdlNpZ25hbChvdGhlcikge1xuICAgICAgICBhc3NlcnQob3RoZXIuI3ZhbCAhPT0gQk5fMCwgXCJkaXZpc2lvbiBieSB6ZXJvXCIsIFwiTlVNRVJJQ19GQVVMVFwiLCB7XG4gICAgICAgICAgICBvcGVyYXRpb246IFwiZGl2XCIsIGZhdWx0OiBcImRpdmlkZS1ieS16ZXJvXCIsIHZhbHVlOiB0aGlzXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLiNjaGVja0Zvcm1hdChvdGhlcik7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gKHRoaXMuI3ZhbCAqIHRoaXMuI3RlbnMpO1xuICAgICAgICBhc3NlcnQoKHZhbHVlICUgb3RoZXIuI3ZhbCkgPT09IEJOXzAsIFwicHJlY2lzaW9uIGxvc3QgZHVyaW5nIHNpZ25hbGxpbmcgZGl2XCIsIFwiTlVNRVJJQ19GQVVMVFwiLCB7XG4gICAgICAgICAgICBvcGVyYXRpb246IFwiZGl2U2lnbmFsXCIsIGZhdWx0OiBcInVuZGVyZmxvd1wiLCB2YWx1ZTogdGhpc1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuI2NoZWNrVmFsdWUodmFsdWUgLyBvdGhlci4jdmFsLCBcImRpdlNpZ25hbFwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYSBjb21wYXJpc29uIHJlc3VsdCBiZXR3ZWVuICUldGhpcyUlIGFuZCAlJW90aGVyJSUuXG4gICAgICpcbiAgICAgKiAgVGhpcyBpcyBzdWl0YWJsZSBmb3IgdXNlIGluIHNvcnRpbmcsIHdoZXJlIGBgLTFgYCBpbXBsaWVzICUldGhpcyUlXG4gICAgICogIGlzIHNtYWxsZXIsIGBgMWBgIGltcGxpZXMgJSV0aGlzJSUgaXMgbGFyZ2VyIGFuZCBgYDBgYCBpbXBsaWVzXG4gICAgICogIGJvdGggYXJlIGVxdWFsLlxuICAgICAqL1xuICAgIGNtcChvdGhlcikge1xuICAgICAgICBsZXQgYSA9IHRoaXMudmFsdWUsIGIgPSBvdGhlci52YWx1ZTtcbiAgICAgICAgLy8gQ29lcmNlIGEgYW5kIGIgdG8gdGhlIHNhbWUgbWFnbml0dWRlXG4gICAgICAgIGNvbnN0IGRlbHRhID0gdGhpcy5kZWNpbWFscyAtIG90aGVyLmRlY2ltYWxzO1xuICAgICAgICBpZiAoZGVsdGEgPiAwKSB7XG4gICAgICAgICAgICBiICo9IGdldFRlbnMoZGVsdGEpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGRlbHRhIDwgMCkge1xuICAgICAgICAgICAgYSAqPSBnZXRUZW5zKC1kZWx0YSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ29tbnBhcmVcbiAgICAgICAgaWYgKGEgPCBiKSB7XG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGEgPiBiKSB7XG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdHJ1ZSBpZiAlJW90aGVyJSUgaXMgZXF1YWwgdG8gJSV0aGlzJSUuXG4gICAgICovXG4gICAgZXEob3RoZXIpIHsgcmV0dXJuIHRoaXMuY21wKG90aGVyKSA9PT0gMDsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRydWUgaWYgJSVvdGhlciUlIGlzIGxlc3MgdGhhbiB0byAlJXRoaXMlJS5cbiAgICAgKi9cbiAgICBsdChvdGhlcikgeyByZXR1cm4gdGhpcy5jbXAob3RoZXIpIDwgMDsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRydWUgaWYgJSVvdGhlciUlIGlzIGxlc3MgdGhhbiBvciBlcXVhbCB0byAlJXRoaXMlJS5cbiAgICAgKi9cbiAgICBsdGUob3RoZXIpIHsgcmV0dXJuIHRoaXMuY21wKG90aGVyKSA8PSAwOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdHJ1ZSBpZiAlJW90aGVyJSUgaXMgZ3JlYXRlciB0aGFuIHRvICUldGhpcyUlLlxuICAgICAqL1xuICAgIGd0KG90aGVyKSB7IHJldHVybiB0aGlzLmNtcChvdGhlcikgPiAwOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdHJ1ZSBpZiAlJW90aGVyJSUgaXMgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvICUldGhpcyUlLlxuICAgICAqL1xuICAgIGd0ZShvdGhlcikgeyByZXR1cm4gdGhpcy5jbXAob3RoZXIpID49IDA7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBhIG5ldyBbW0ZpeGVkTnVtYmVyXV0gd2hpY2ggaXMgdGhlIGxhcmdlc3QgKippbnRlZ2VyKipcbiAgICAgKiAgdGhhdCBpcyBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gJSV0aGlzJSUuXG4gICAgICpcbiAgICAgKiAgVGhlIGRlY2ltYWwgY29tcG9uZW50IG9mIHRoZSByZXN1bHQgd2lsbCBhbHdheXMgYmUgYGAwYGAuXG4gICAgICovXG4gICAgZmxvb3IoKSB7XG4gICAgICAgIGxldCB2YWwgPSB0aGlzLiN2YWw7XG4gICAgICAgIGlmICh0aGlzLiN2YWwgPCBCTl8wKSB7XG4gICAgICAgICAgICB2YWwgLT0gdGhpcy4jdGVucyAtIEJOXzE7XG4gICAgICAgIH1cbiAgICAgICAgdmFsID0gKHRoaXMuI3ZhbCAvIHRoaXMuI3RlbnMpICogdGhpcy4jdGVucztcbiAgICAgICAgcmV0dXJuIHRoaXMuI2NoZWNrVmFsdWUodmFsLCBcImZsb29yXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBhIG5ldyBbW0ZpeGVkTnVtYmVyXV0gd2hpY2ggaXMgdGhlIHNtYWxsZXN0ICoqaW50ZWdlcioqXG4gICAgICogIHRoYXQgaXMgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvICUldGhpcyUlLlxuICAgICAqXG4gICAgICogIFRoZSBkZWNpbWFsIGNvbXBvbmVudCBvZiB0aGUgcmVzdWx0IHdpbGwgYWx3YXlzIGJlIGBgMGBgLlxuICAgICAqL1xuICAgIGNlaWxpbmcoKSB7XG4gICAgICAgIGxldCB2YWwgPSB0aGlzLiN2YWw7XG4gICAgICAgIGlmICh0aGlzLiN2YWwgPiBCTl8wKSB7XG4gICAgICAgICAgICB2YWwgKz0gdGhpcy4jdGVucyAtIEJOXzE7XG4gICAgICAgIH1cbiAgICAgICAgdmFsID0gKHRoaXMuI3ZhbCAvIHRoaXMuI3RlbnMpICogdGhpcy4jdGVucztcbiAgICAgICAgcmV0dXJuIHRoaXMuI2NoZWNrVmFsdWUodmFsLCBcImNlaWxpbmdcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGEgbmV3IFtbRml4ZWROdW1iZXJdXSB3aXRoIHRoZSBkZWNpbWFsIGNvbXBvbmVudFxuICAgICAqICByb3VuZGVkIHVwIG9uIHRpZXMgYXQgJSVkZWNpbWFscyUlIHBsYWNlcy5cbiAgICAgKi9cbiAgICByb3VuZChkZWNpbWFscykge1xuICAgICAgICBpZiAoZGVjaW1hbHMgPT0gbnVsbCkge1xuICAgICAgICAgICAgZGVjaW1hbHMgPSAwO1xuICAgICAgICB9XG4gICAgICAgIC8vIE5vdCBlbm91Z2ggcHJlY2lzaW9uIHRvIG5vdCBhbHJlYWR5IGJlIHJvdW5kZWRcbiAgICAgICAgaWYgKGRlY2ltYWxzID49IHRoaXMuZGVjaW1hbHMpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRlbHRhID0gdGhpcy5kZWNpbWFscyAtIGRlY2ltYWxzO1xuICAgICAgICBjb25zdCBidW1wID0gQk5fNSAqIGdldFRlbnMoZGVsdGEgLSAxKTtcbiAgICAgICAgbGV0IHZhbHVlID0gdGhpcy52YWx1ZSArIGJ1bXA7XG4gICAgICAgIGNvbnN0IHRlbnMgPSBnZXRUZW5zKGRlbHRhKTtcbiAgICAgICAgdmFsdWUgPSAodmFsdWUgLyB0ZW5zKSAqIHRlbnM7XG4gICAgICAgIGNoZWNrVmFsdWUodmFsdWUsIHRoaXMuI2Zvcm1hdCwgXCJyb3VuZFwiKTtcbiAgICAgICAgcmV0dXJuIG5ldyBGaXhlZE51bWJlcihfZ3VhcmQsIHZhbHVlLCB0aGlzLiNmb3JtYXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0cnVlIGlmICUldGhpcyUlIGlzIGVxdWFsIHRvIGBgMGBgLlxuICAgICAqL1xuICAgIGlzWmVybygpIHsgcmV0dXJuICh0aGlzLiN2YWwgPT09IEJOXzApOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdHJ1ZSBpZiAlJXRoaXMlJSBpcyBsZXNzIHRoYW4gYGAwYGAuXG4gICAgICovXG4gICAgaXNOZWdhdGl2ZSgpIHsgcmV0dXJuICh0aGlzLiN2YWwgPCBCTl8wKTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgJSV0aGlzJSUuXG4gICAgICovXG4gICAgdG9TdHJpbmcoKSB7IHJldHVybiB0aGlzLl92YWx1ZTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGEgZmxvYXQgYXBwcm94aW1hdGlvbi5cbiAgICAgKlxuICAgICAqICBEdWUgdG8gSUVFRSA3NTQgcHJlY2lzc2lvbiAob3IgbGFjayB0aGVyZW9mKSwgdGhpcyBmdW5jdGlvblxuICAgICAqICBjYW4gb25seSByZXR1cm4gYW4gYXBwcm94aW1hdGlvbiBhbmQgbW9zdCB2YWx1ZXMgd2lsbCBjb250YWluXG4gICAgICogIHJvdW5kaW5nIGVycm9ycy5cbiAgICAgKi9cbiAgICB0b1Vuc2FmZUZsb2F0KCkgeyByZXR1cm4gcGFyc2VGbG9hdCh0aGlzLnRvU3RyaW5nKCkpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBbW0ZpeGVkTnVtYmVyXV0gd2l0aCB0aGUgc2FtZSB2YWx1ZSBidXQgaGFzIGhhZFxuICAgICAqICBpdHMgZmllbGQgc2V0IHRvICUlZm9ybWF0JSUuXG4gICAgICpcbiAgICAgKiAgVGhpcyB3aWxsIHRocm93IGlmIHRoZSB2YWx1ZSBjYW5ub3QgZml0IGludG8gJSVmb3JtYXQlJS5cbiAgICAgKi9cbiAgICB0b0Zvcm1hdChmb3JtYXQpIHtcbiAgICAgICAgcmV0dXJuIEZpeGVkTnVtYmVyLmZyb21TdHJpbmcodGhpcy50b1N0cmluZygpLCBmb3JtYXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlcyBhIG5ldyBbW0ZpeGVkTnVtYmVyXV0gZm9yICUldmFsdWUlJSBkaXZpZGVkIGJ5XG4gICAgICogICUlZGVjaW1hbCUlIHBsYWNlcyB3aXRoICUlZm9ybWF0JSUuXG4gICAgICpcbiAgICAgKiAgVGhpcyB3aWxsIHRocm93IGEgW1tOdW1lcmljRmF1bHRFcnJvcl1dIGlmICUldmFsdWUlJSAob25jZSBhZGp1c3RlZFxuICAgICAqICBmb3IgJSVkZWNpbWFscyUlKSBjYW5ub3QgZml0IGluICUlZm9ybWF0JSUsIGVpdGhlciBkdWUgdG8gb3ZlcmZsb3dcbiAgICAgKiAgb3IgdW5kZXJmbG93IChwcmVjaXNpb24gbG9zcykuXG4gICAgICovXG4gICAgc3RhdGljIGZyb21WYWx1ZShfdmFsdWUsIF9kZWNpbWFscywgX2Zvcm1hdCkge1xuICAgICAgICBjb25zdCBkZWNpbWFscyA9IChfZGVjaW1hbHMgPT0gbnVsbCkgPyAwIDogZ2V0TnVtYmVyKF9kZWNpbWFscyk7XG4gICAgICAgIGNvbnN0IGZvcm1hdCA9IGdldEZvcm1hdChfZm9ybWF0KTtcbiAgICAgICAgbGV0IHZhbHVlID0gZ2V0QmlnSW50KF92YWx1ZSwgXCJ2YWx1ZVwiKTtcbiAgICAgICAgY29uc3QgZGVsdGEgPSBkZWNpbWFscyAtIGZvcm1hdC5kZWNpbWFscztcbiAgICAgICAgaWYgKGRlbHRhID4gMCkge1xuICAgICAgICAgICAgY29uc3QgdGVucyA9IGdldFRlbnMoZGVsdGEpO1xuICAgICAgICAgICAgYXNzZXJ0KCh2YWx1ZSAlIHRlbnMpID09PSBCTl8wLCBcInZhbHVlIGxvc2VzIHByZWNpc2lvbiBmb3IgZm9ybWF0XCIsIFwiTlVNRVJJQ19GQVVMVFwiLCB7XG4gICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBcImZyb21WYWx1ZVwiLCBmYXVsdDogXCJ1bmRlcmZsb3dcIiwgdmFsdWU6IF92YWx1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB2YWx1ZSAvPSB0ZW5zO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGRlbHRhIDwgMCkge1xuICAgICAgICAgICAgdmFsdWUgKj0gZ2V0VGVucygtZGVsdGEpO1xuICAgICAgICB9XG4gICAgICAgIGNoZWNrVmFsdWUodmFsdWUsIGZvcm1hdCwgXCJmcm9tVmFsdWVcIik7XG4gICAgICAgIHJldHVybiBuZXcgRml4ZWROdW1iZXIoX2d1YXJkLCB2YWx1ZSwgZm9ybWF0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIENyZWF0ZXMgYSBuZXcgW1tGaXhlZE51bWJlcl1dIGZvciAlJXZhbHVlJSUgd2l0aCAlJWZvcm1hdCUlLlxuICAgICAqXG4gICAgICogIFRoaXMgd2lsbCB0aHJvdyBhIFtbTnVtZXJpY0ZhdWx0RXJyb3JdXSBpZiAlJXZhbHVlJSUgY2Fubm90IGZpdFxuICAgICAqICBpbiAlJWZvcm1hdCUlLCBlaXRoZXIgZHVlIHRvIG92ZXJmbG93IG9yIHVuZGVyZmxvdyAocHJlY2lzaW9uIGxvc3MpLlxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tU3RyaW5nKF92YWx1ZSwgX2Zvcm1hdCkge1xuICAgICAgICBjb25zdCBtYXRjaCA9IF92YWx1ZS5tYXRjaCgvXigtPykoWzAtOV0qKVxcLj8oWzAtOV0qKSQvKTtcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQobWF0Y2ggJiYgKG1hdGNoWzJdLmxlbmd0aCArIG1hdGNoWzNdLmxlbmd0aCkgPiAwLCBcImludmFsaWQgRml4ZWROdW1iZXIgc3RyaW5nIHZhbHVlXCIsIFwidmFsdWVcIiwgX3ZhbHVlKTtcbiAgICAgICAgY29uc3QgZm9ybWF0ID0gZ2V0Rm9ybWF0KF9mb3JtYXQpO1xuICAgICAgICBsZXQgd2hvbGUgPSAobWF0Y2hbMl0gfHwgXCIwXCIpLCBkZWNpbWFsID0gKG1hdGNoWzNdIHx8IFwiXCIpO1xuICAgICAgICAvLyBQYWQgb3V0IHRoZSBkZWNpbWFsc1xuICAgICAgICB3aGlsZSAoZGVjaW1hbC5sZW5ndGggPCBmb3JtYXQuZGVjaW1hbHMpIHtcbiAgICAgICAgICAgIGRlY2ltYWwgKz0gWmVyb3M7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2hlY2sgcHJlY2lzaW9uIGlzIHNhZmVcbiAgICAgICAgYXNzZXJ0KGRlY2ltYWwuc3Vic3RyaW5nKGZvcm1hdC5kZWNpbWFscykubWF0Y2goL14wKiQvKSwgXCJ0b28gbWFueSBkZWNpbWFscyBmb3IgZm9ybWF0XCIsIFwiTlVNRVJJQ19GQVVMVFwiLCB7XG4gICAgICAgICAgICBvcGVyYXRpb246IFwiZnJvbVN0cmluZ1wiLCBmYXVsdDogXCJ1bmRlcmZsb3dcIiwgdmFsdWU6IF92YWx1ZVxuICAgICAgICB9KTtcbiAgICAgICAgLy8gUmVtb3ZlIGV4dHJhIHBhZGRpbmdcbiAgICAgICAgZGVjaW1hbCA9IGRlY2ltYWwuc3Vic3RyaW5nKDAsIGZvcm1hdC5kZWNpbWFscyk7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gQmlnSW50KG1hdGNoWzFdICsgd2hvbGUgKyBkZWNpbWFsKTtcbiAgICAgICAgY2hlY2tWYWx1ZSh2YWx1ZSwgZm9ybWF0LCBcImZyb21TdHJpbmdcIik7XG4gICAgICAgIHJldHVybiBuZXcgRml4ZWROdW1iZXIoX2d1YXJkLCB2YWx1ZSwgZm9ybWF0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIENyZWF0ZXMgYSBuZXcgW1tGaXhlZE51bWJlcl1dIHdpdGggdGhlIGJpZy1lbmRpYW4gcmVwcmVzZW50YXRpb25cbiAgICAgKiAgJSV2YWx1ZSUlIHdpdGggJSVmb3JtYXQlJS5cbiAgICAgKlxuICAgICAqICBUaGlzIHdpbGwgdGhyb3cgYSBbW051bWVyaWNGYXVsdEVycm9yXV0gaWYgJSV2YWx1ZSUlIGNhbm5vdCBmaXRcbiAgICAgKiAgaW4gJSVmb3JtYXQlJSBkdWUgdG8gb3ZlcmZsb3cuXG4gICAgICovXG4gICAgc3RhdGljIGZyb21CeXRlcyhfdmFsdWUsIF9mb3JtYXQpIHtcbiAgICAgICAgbGV0IHZhbHVlID0gdG9CaWdJbnQoZ2V0Qnl0ZXMoX3ZhbHVlLCBcInZhbHVlXCIpKTtcbiAgICAgICAgY29uc3QgZm9ybWF0ID0gZ2V0Rm9ybWF0KF9mb3JtYXQpO1xuICAgICAgICBpZiAoZm9ybWF0LnNpZ25lZCkge1xuICAgICAgICAgICAgdmFsdWUgPSBmcm9tVHdvcyh2YWx1ZSwgZm9ybWF0LndpZHRoKTtcbiAgICAgICAgfVxuICAgICAgICBjaGVja1ZhbHVlKHZhbHVlLCBmb3JtYXQsIFwiZnJvbUJ5dGVzXCIpO1xuICAgICAgICByZXR1cm4gbmV3IEZpeGVkTnVtYmVyKF9ndWFyZCwgdmFsdWUsIGZvcm1hdCk7XG4gICAgfVxufVxuLy9jb25zdCBmMSA9IEZpeGVkTnVtYmVyLmZyb21TdHJpbmcoXCIxMi41NlwiLCBcImZpeGVkMTZ4MlwiKTtcbi8vY29uc3QgZjIgPSBGaXhlZE51bWJlci5mcm9tU3RyaW5nKFwiMC4zXCIsIFwiZml4ZWQxNngyXCIpO1xuLy9jb25zb2xlLmxvZyhmMS5kaXZTaWduYWwoZjIpKTtcbi8vY29uc3QgQlVNUCA9IEZpeGVkTnVtYmVyLmZyb20oXCIwLjVcIik7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1maXhlZG51bWJlci5qcy5tYXAiXSwibmFtZXMiOlsiZ2V0Qnl0ZXMiLCJhc3NlcnQiLCJhc3NlcnRBcmd1bWVudCIsImFzc2VydFByaXZhdGUiLCJnZXRCaWdJbnQiLCJnZXROdW1iZXIiLCJmcm9tVHdvcyIsIm1hc2siLCJ0b0JpZ0ludCIsImRlZmluZVByb3BlcnRpZXMiLCJCTl9OMSIsIkJpZ0ludCIsIkJOXzAiLCJCTl8xIiwiQk5fNSIsIl9ndWFyZCIsIlplcm9zIiwibGVuZ3RoIiwiZ2V0VGVucyIsImRlY2ltYWxzIiwicmVzdWx0Iiwic3Vic3RyaW5nIiwiY2hlY2tWYWx1ZSIsInZhbCIsImZvcm1hdCIsInNhZmVPcCIsIndpZHRoIiwic2lnbmVkIiwibGltaXQiLCJvcGVyYXRpb24iLCJmYXVsdCIsInZhbHVlIiwiZ2V0Rm9ybWF0IiwibWF0Y2giLCJwYXJzZUludCIsInYiLCJjaGVjayIsImtleSIsInR5cGUiLCJkZWZhdWx0VmFsdWUiLCJuYW1lIiwiU3RyaW5nIiwidG9TdHJpbmciLCJuZWdhdGl2ZSIsInN0ciIsImluZGV4IiwiRml4ZWROdW1iZXIiLCJ0ZW5zIiwiY29uc3RydWN0b3IiLCJndWFyZCIsIl92YWx1ZSIsImNoZWNrRm9ybWF0Iiwib3RoZXIiLCJhZGQiLCJvIiwiYWRkVW5zYWZlIiwic3ViIiwic3ViVW5zYWZlIiwibXVsIiwibXVsVW5zYWZlIiwibXVsU2lnbmFsIiwiZGl2IiwiZGl2VW5zYWZlIiwiZGl2U2lnbmFsIiwiY21wIiwiYSIsImIiLCJkZWx0YSIsImVxIiwibHQiLCJsdGUiLCJndCIsImd0ZSIsImZsb29yIiwiY2VpbGluZyIsInJvdW5kIiwiYnVtcCIsImlzWmVybyIsImlzTmVnYXRpdmUiLCJ0b1Vuc2FmZUZsb2F0IiwicGFyc2VGbG9hdCIsInRvRm9ybWF0IiwiZnJvbVN0cmluZyIsImZyb21WYWx1ZSIsIl9kZWNpbWFscyIsIl9mb3JtYXQiLCJ3aG9sZSIsImRlY2ltYWwiLCJmcm9tQnl0ZXMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.esm/utils/fixednumber.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.esm/utils/geturl.js":
/*!*****************************************************!*\
  !*** ./node_modules/ethers/lib.esm/utils/geturl.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createGetUrl: () => (/* binding */ createGetUrl),\n/* harmony export */   getUrl: () => (/* binding */ getUrl)\n/* harmony export */ });\n/* harmony import */ var http__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! http */ \"http\");\n/* harmony import */ var https__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! https */ \"https\");\n/* harmony import */ var zlib__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! zlib */ \"zlib\");\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./errors.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/errors.js\");\n/* harmony import */ var _data_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./data.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/data.js\");\n\n\n\n\n\n/**\n *  @_ignore:\n */ function createGetUrl(options) {\n    async function getUrl(req, signal) {\n        // Make sure we weren't cancelled before sending\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_3__.assert)(signal == null || !signal.cancelled, \"request cancelled before sending\", \"CANCELLED\");\n        const protocol = req.url.split(\":\")[0].toLowerCase();\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_3__.assert)(protocol === \"http\" || protocol === \"https\", `unsupported protocol ${protocol}`, \"UNSUPPORTED_OPERATION\", {\n            info: {\n                protocol\n            },\n            operation: \"request\"\n        });\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_3__.assert)(protocol === \"https\" || !req.credentials || req.allowInsecureAuthentication, \"insecure authorized connections unsupported\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"request\"\n        });\n        const method = req.method;\n        const headers = Object.assign({}, req.headers);\n        const reqOptions = {\n            method,\n            headers\n        };\n        if (options) {\n            if (options.agent) {\n                reqOptions.agent = options.agent;\n            }\n        }\n        // Create a Node-specific AbortController, if available\n        let abort = null;\n        try {\n            abort = new AbortController();\n            reqOptions.abort = abort.signal;\n        } catch (e) {\n            console.log(e);\n        }\n        const request = (protocol === \"http\" ? http__WEBPACK_IMPORTED_MODULE_0__ : https__WEBPACK_IMPORTED_MODULE_1__).request(req.url, reqOptions);\n        request.setTimeout(req.timeout);\n        const body = req.body;\n        if (body) {\n            request.write(Buffer.from(body));\n        }\n        request.end();\n        return new Promise((resolve, reject)=>{\n            if (signal) {\n                signal.addListener(()=>{\n                    if (abort) {\n                        abort.abort();\n                    }\n                    reject((0,_errors_js__WEBPACK_IMPORTED_MODULE_3__.makeError)(\"request cancelled\", \"CANCELLED\"));\n                });\n            }\n            request.on(\"timeout\", ()=>{\n                reject((0,_errors_js__WEBPACK_IMPORTED_MODULE_3__.makeError)(\"request timeout\", \"TIMEOUT\"));\n            });\n            request.once(\"response\", (resp)=>{\n                const statusCode = resp.statusCode || 0;\n                const statusMessage = resp.statusMessage || \"\";\n                const headers = Object.keys(resp.headers || {}).reduce((accum, name)=>{\n                    let value = resp.headers[name] || \"\";\n                    if (Array.isArray(value)) {\n                        value = value.join(\", \");\n                    }\n                    accum[name] = value;\n                    return accum;\n                }, {});\n                let body = null;\n                //resp.setEncoding(\"utf8\");\n                resp.on(\"data\", (chunk)=>{\n                    if (signal) {\n                        try {\n                            signal.checkSignal();\n                        } catch (error) {\n                            return reject(error);\n                        }\n                    }\n                    if (body == null) {\n                        body = chunk;\n                    } else {\n                        const newBody = new Uint8Array(body.length + chunk.length);\n                        newBody.set(body, 0);\n                        newBody.set(chunk, body.length);\n                        body = newBody;\n                    }\n                });\n                resp.on(\"end\", ()=>{\n                    try {\n                        if (headers[\"content-encoding\"] === \"gzip\" && body) {\n                            body = (0,_data_js__WEBPACK_IMPORTED_MODULE_4__.getBytes)((0,zlib__WEBPACK_IMPORTED_MODULE_2__.gunzipSync)(body));\n                        }\n                        resolve({\n                            statusCode,\n                            statusMessage,\n                            headers,\n                            body\n                        });\n                    } catch (error) {\n                        reject((0,_errors_js__WEBPACK_IMPORTED_MODULE_3__.makeError)(\"bad response data\", \"SERVER_ERROR\", {\n                            request: req,\n                            info: {\n                                response: resp,\n                                error\n                            }\n                        }));\n                    }\n                });\n                resp.on(\"error\", (error)=>{\n                    //@TODO: Should this just return nornal response with a server error?\n                    error.response = {\n                        statusCode,\n                        statusMessage,\n                        headers,\n                        body\n                    };\n                    reject(error);\n                });\n            });\n            request.on(\"error\", (error)=>{\n                reject(error);\n            });\n        });\n    }\n    return getUrl;\n}\n// @TODO: remove in v7; provided for backwards compat\nconst defaultGetUrl = createGetUrl({});\n/**\n *  @_ignore:\n */ async function getUrl(req, signal) {\n    return defaultGetUrl(req, signal);\n} //# sourceMappingURL=geturl.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vdXRpbHMvZ2V0dXJsLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBd0I7QUFDRTtBQUNRO0FBQ2M7QUFDWDtBQUNyQzs7Q0FFQyxHQUNNLFNBQVNNLGFBQWFDLE9BQU87SUFDaEMsZUFBZUMsT0FBT0MsR0FBRyxFQUFFQyxNQUFNO1FBQzdCLGdEQUFnRDtRQUNoRFAsa0RBQU1BLENBQUNPLFVBQVUsUUFBUSxDQUFDQSxPQUFPQyxTQUFTLEVBQUUsb0NBQW9DO1FBQ2hGLE1BQU1DLFdBQVdILElBQUlJLEdBQUcsQ0FBQ0MsS0FBSyxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUNDLFdBQVc7UUFDbERaLGtEQUFNQSxDQUFDUyxhQUFhLFVBQVVBLGFBQWEsU0FBUyxDQUFDLHFCQUFxQixFQUFFQSxTQUFTLENBQUMsRUFBRSx5QkFBeUI7WUFDN0dJLE1BQU07Z0JBQUVKO1lBQVM7WUFDakJLLFdBQVc7UUFDZjtRQUNBZCxrREFBTUEsQ0FBQ1MsYUFBYSxXQUFXLENBQUNILElBQUlTLFdBQVcsSUFBSVQsSUFBSVUsMkJBQTJCLEVBQUUsK0NBQStDLHlCQUF5QjtZQUN4SkYsV0FBVztRQUNmO1FBQ0EsTUFBTUcsU0FBU1gsSUFBSVcsTUFBTTtRQUN6QixNQUFNQyxVQUFVQyxPQUFPQyxNQUFNLENBQUMsQ0FBQyxHQUFHZCxJQUFJWSxPQUFPO1FBQzdDLE1BQU1HLGFBQWE7WUFBRUo7WUFBUUM7UUFBUTtRQUNyQyxJQUFJZCxTQUFTO1lBQ1QsSUFBSUEsUUFBUWtCLEtBQUssRUFBRTtnQkFDZkQsV0FBV0MsS0FBSyxHQUFHbEIsUUFBUWtCLEtBQUs7WUFDcEM7UUFDSjtRQUNBLHVEQUF1RDtRQUN2RCxJQUFJQyxRQUFRO1FBQ1osSUFBSTtZQUNBQSxRQUFRLElBQUlDO1lBQ1pILFdBQVdFLEtBQUssR0FBR0EsTUFBTWhCLE1BQU07UUFDbkMsRUFDQSxPQUFPa0IsR0FBRztZQUNOQyxRQUFRQyxHQUFHLENB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QUFhLENBQUM7QUFDcEM7O0NBRUMsR0FDTSxlQUFlRSxPQUFPQyxHQUFHLEVBQUVDLE1BQU07SUFDcEMsT0FBT3NELGNBQWN2RCxLQUFLQztBQUM5QixFQUNBLGtDQUFrQyIsInNvdXJjZXMiOlsid2VicGFjazovL21lZ2F2aWJlLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL3V0aWxzL2dldHVybC5qcz80Yzc5Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBodHRwIGZyb20gXCJodHRwXCI7XG5pbXBvcnQgaHR0cHMgZnJvbSBcImh0dHBzXCI7XG5pbXBvcnQgeyBndW56aXBTeW5jIH0gZnJvbSBcInpsaWJcIjtcbmltcG9ydCB7IGFzc2VydCwgbWFrZUVycm9yIH0gZnJvbSBcIi4vZXJyb3JzLmpzXCI7XG5pbXBvcnQgeyBnZXRCeXRlcyB9IGZyb20gXCIuL2RhdGEuanNcIjtcbi8qKlxuICogIEBfaWdub3JlOlxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlR2V0VXJsKG9wdGlvbnMpIHtcbiAgICBhc3luYyBmdW5jdGlvbiBnZXRVcmwocmVxLCBzaWduYWwpIHtcbiAgICAgICAgLy8gTWFrZSBzdXJlIHdlIHdlcmVuJ3QgY2FuY2VsbGVkIGJlZm9yZSBzZW5kaW5nXG4gICAgICAgIGFzc2VydChzaWduYWwgPT0gbnVsbCB8fCAhc2lnbmFsLmNhbmNlbGxlZCwgXCJyZXF1ZXN0IGNhbmNlbGxlZCBiZWZvcmUgc2VuZGluZ1wiLCBcIkNBTkNFTExFRFwiKTtcbiAgICAgICAgY29uc3QgcHJvdG9jb2wgPSByZXEudXJsLnNwbGl0KFwiOlwiKVswXS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBhc3NlcnQocHJvdG9jb2wgPT09IFwiaHR0cFwiIHx8IHByb3RvY29sID09PSBcImh0dHBzXCIsIGB1bnN1cHBvcnRlZCBwcm90b2NvbCAke3Byb3RvY29sfWAsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHtcbiAgICAgICAgICAgIGluZm86IHsgcHJvdG9jb2wgfSxcbiAgICAgICAgICAgIG9wZXJhdGlvbjogXCJyZXF1ZXN0XCJcbiAgICAgICAgfSk7XG4gICAgICAgIGFzc2VydChwcm90b2NvbCA9PT0gXCJodHRwc1wiIHx8ICFyZXEuY3JlZGVudGlhbHMgfHwgcmVxLmFsbG93SW5zZWN1cmVBdXRoZW50aWNhdGlvbiwgXCJpbnNlY3VyZSBhdXRob3JpemVkIGNvbm5lY3Rpb25zIHVuc3VwcG9ydGVkXCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHtcbiAgICAgICAgICAgIG9wZXJhdGlvbjogXCJyZXF1ZXN0XCJcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IG1ldGhvZCA9IHJlcS5tZXRob2Q7XG4gICAgICAgIGNvbnN0IGhlYWRlcnMgPSBPYmplY3QuYXNzaWduKHt9LCByZXEuaGVhZGVycyk7XG4gICAgICAgIGNvbnN0IHJlcU9wdGlvbnMgPSB7IG1ldGhvZCwgaGVhZGVycyB9O1xuICAgICAgICBpZiAob3B0aW9ucykge1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMuYWdlbnQpIHtcbiAgICAgICAgICAgICAgICByZXFPcHRpb25zLmFnZW50ID0gb3B0aW9ucy5hZ2VudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBDcmVhdGUgYSBOb2RlLXNwZWNpZmljIEFib3J0Q29udHJvbGxlciwgaWYgYXZhaWxhYmxlXG4gICAgICAgIGxldCBhYm9ydCA9IG51bGw7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBhYm9ydCA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICAgICAgICAgIHJlcU9wdGlvbnMuYWJvcnQgPSBhYm9ydC5zaWduYWw7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGUpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlcXVlc3QgPSAoKHByb3RvY29sID09PSBcImh0dHBcIikgPyBodHRwIDogaHR0cHMpLnJlcXVlc3QocmVxLnVybCwgcmVxT3B0aW9ucyk7XG4gICAgICAgIHJlcXVlc3Quc2V0VGltZW91dChyZXEudGltZW91dCk7XG4gICAgICAgIGNvbnN0IGJvZHkgPSByZXEuYm9keTtcbiAgICAgICAgaWYgKGJvZHkpIHtcbiAgICAgICAgICAgIHJlcXVlc3Qud3JpdGUoQnVmZmVyLmZyb20oYm9keSkpO1xuICAgICAgICB9XG4gICAgICAgIHJlcXVlc3QuZW5kKCk7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBpZiAoc2lnbmFsKSB7XG4gICAgICAgICAgICAgICAgc2lnbmFsLmFkZExpc3RlbmVyKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFib3J0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhYm9ydC5hYm9ydCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChtYWtlRXJyb3IoXCJyZXF1ZXN0IGNhbmNlbGxlZFwiLCBcIkNBTkNFTExFRFwiKSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXF1ZXN0Lm9uKFwidGltZW91dFwiLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgcmVqZWN0KG1ha2VFcnJvcihcInJlcXVlc3QgdGltZW91dFwiLCBcIlRJTUVPVVRcIikpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXF1ZXN0Lm9uY2UoXCJyZXNwb25zZVwiLCAocmVzcCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0YXR1c0NvZGUgPSByZXNwLnN0YXR1c0NvZGUgfHwgMDtcbiAgICAgICAgICAgICAgICBjb25zdCBzdGF0dXNNZXNzYWdlID0gcmVzcC5zdGF0dXNNZXNzYWdlIHx8IFwiXCI7XG4gICAgICAgICAgICAgICAgY29uc3QgaGVhZGVycyA9IE9iamVjdC5rZXlzKHJlc3AuaGVhZGVycyB8fCB7fSkucmVkdWNlKChhY2N1bSwgbmFtZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBsZXQgdmFsdWUgPSByZXNwLmhlYWRlcnNbbmFtZV0gfHwgXCJcIjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLmpvaW4oXCIsIFwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBhY2N1bVtuYW1lXSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYWNjdW07XG4gICAgICAgICAgICAgICAgfSwge30pO1xuICAgICAgICAgICAgICAgIGxldCBib2R5ID0gbnVsbDtcbiAgICAgICAgICAgICAgICAvL3Jlc3Auc2V0RW5jb2RpbmcoXCJ1dGY4XCIpO1xuICAgICAgICAgICAgICAgIHJlc3Aub24oXCJkYXRhXCIsIChjaHVuaykgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2lnbmFsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNpZ25hbC5jaGVja1NpZ25hbCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGJvZHkgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYm9keSA9IGNodW5rO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV3Qm9keSA9IG5ldyBVaW50OEFycmF5KGJvZHkubGVuZ3RoICsgY2h1bmsubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld0JvZHkuc2V0KGJvZHksIDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3Qm9keS5zZXQoY2h1bmssIGJvZHkubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvZHkgPSBuZXdCb2R5O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmVzcC5vbihcImVuZFwiLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaGVhZGVyc1tcImNvbnRlbnQtZW5jb2RpbmdcIl0gPT09IFwiZ3ppcFwiICYmIGJvZHkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBib2R5ID0gZ2V0Qnl0ZXMoZ3VuemlwU3luYyhib2R5KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHsgc3RhdHVzQ29kZSwgc3RhdHVzTWVzc2FnZSwgaGVhZGVycywgYm9keSB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChtYWtlRXJyb3IoXCJiYWQgcmVzcG9uc2UgZGF0YVwiLCBcIlNFUlZFUl9FUlJPUlwiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdDogcmVxLCBpbmZvOiB7IHJlc3BvbnNlOiByZXNwLCBlcnJvciB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXNwLm9uKFwiZXJyb3JcIiwgKGVycm9yKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIC8vQFRPRE86IFNob3VsZCB0aGlzIGp1c3QgcmV0dXJuIG5vcm5hbCByZXNwb25zZSB3aXRoIGEgc2VydmVyIGVycm9yP1xuICAgICAgICAgICAgICAgICAgICBlcnJvci5yZXNwb25zZSA9IHsgc3RhdHVzQ29kZSwgc3RhdHVzTWVzc2FnZSwgaGVhZGVycywgYm9keSB9O1xuICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXF1ZXN0Lm9uKFwiZXJyb3JcIiwgKGVycm9yKSA9PiB7IHJlamVjdChlcnJvcik7IH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGdldFVybDtcbn1cbi8vIEBUT0RPOiByZW1vdmUgaW4gdjc7IHByb3ZpZGVkIGZvciBiYWNrd2FyZHMgY29tcGF0XG5jb25zdCBkZWZhdWx0R2V0VXJsID0gY3JlYXRlR2V0VXJsKHt9KTtcbi8qKlxuICogIEBfaWdub3JlOlxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0VXJsKHJlcSwgc2lnbmFsKSB7XG4gICAgcmV0dXJuIGRlZmF1bHRHZXRVcmwocmVxLCBzaWduYWwpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Z2V0dXJsLmpzLm1hcCJdLCJuYW1lcyI6WyJodHRwIiwiaHR0cHMiLCJndW56aXBTeW5jIiwiYXNzZXJ0IiwibWFrZUVycm9yIiwiZ2V0Qnl0ZXMiLCJjcmVhdGVHZXRVcmwiLCJvcHRpb25zIiwiZ2V0VXJsIiwicmVxIiwic2lnbmFsIiwiY2FuY2VsbGVkIiwicHJvdG9jb2wiLCJ1cmwiLCJzcGxpdCIsInRvTG93ZXJDYXNlIiwiaW5mbyIsIm9wZXJhdGlvbiIsImNyZWRlbnRpYWxzIiwiYWxsb3dJbnNlY3VyZUF1dGhlbnRpY2F0aW9uIiwibWV0aG9kIiwiaGVhZGVycyIsIk9iamVjdCIsImFzc2lnbiIsInJlcU9wdGlvbnMiLCJhZ2VudCIsImFib3J0IiwiQWJvcnRDb250cm9sbGVyIiwiZSIsImNvbnNvbGUiLCJsb2ciLCJyZXF1ZXN0Iiwic2V0VGltZW91dCIsInRpbWVvdXQiLCJib2R5Iiwid3JpdGUiLCJCdWZmZXIiLCJmcm9tIiwiZW5kIiwiUHJvbWlzZSIsInJlc29sdmUiLCJyZWplY3QiLCJhZGRMaXN0ZW5lciIsIm9uIiwib25jZSIsInJlc3AiLCJzdGF0dXNDb2RlIiwic3RhdHVzTWVzc2FnZSIsImtleXMiLCJyZWR1Y2UiLCJhY2N1bSIsIm5hbWUiLCJ2YWx1ZSIsIkFycmF5IiwiaXNBcnJheSIsImpvaW4iLCJjaHVuayIsImNoZWNrU2lnbmFsIiwiZXJyb3IiLCJuZXdCb2R5IiwiVWludDhBcnJheSIsImxlbmd0aCIsInNldCIsInJlc3BvbnNlIiwiZGVmYXVsdEdldFVybCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.esm/utils/geturl.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.esm/utils/maths.js":
/*!****************************************************!*\
  !*** ./node_modules/ethers/lib.esm/utils/maths.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   fromTwos: () => (/* binding */ fromTwos),\n/* harmony export */   getBigInt: () => (/* binding */ getBigInt),\n/* harmony export */   getNumber: () => (/* binding */ getNumber),\n/* harmony export */   getUint: () => (/* binding */ getUint),\n/* harmony export */   mask: () => (/* binding */ mask),\n/* harmony export */   toBeArray: () => (/* binding */ toBeArray),\n/* harmony export */   toBeHex: () => (/* binding */ toBeHex),\n/* harmony export */   toBigInt: () => (/* binding */ toBigInt),\n/* harmony export */   toNumber: () => (/* binding */ toNumber),\n/* harmony export */   toQuantity: () => (/* binding */ toQuantity),\n/* harmony export */   toTwos: () => (/* binding */ toTwos)\n/* harmony export */ });\n/* harmony import */ var _data_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./data.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/data.js\");\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./errors.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/errors.js\");\n/**\n *  Some mathematic operations.\n *\n *  @_subsection: api/utils:Math Helpers  [about-maths]\n */ \n\nconst BN_0 = BigInt(0);\nconst BN_1 = BigInt(1);\n//const BN_Max256 = (BN_1 << BigInt(256)) - BN_1;\n// IEEE 754 support 53-bits of mantissa\nconst maxValue = 0x1fffffffffffff;\n/**\n *  Convert %%value%% from a twos-compliment representation of %%width%%\n *  bits to its value.\n *\n *  If the highest bit is ``1``, the result will be negative.\n */ function fromTwos(_value, _width) {\n    const value = getUint(_value, \"value\");\n    const width = BigInt(getNumber(_width, \"width\"));\n    (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assert)(value >> width === BN_0, \"overflow\", \"NUMERIC_FAULT\", {\n        operation: \"fromTwos\",\n        fault: \"overflow\",\n        value: _value\n    });\n    // Top bit set; treat as a negative value\n    if (value >> width - BN_1) {\n        const mask = (BN_1 << width) - BN_1;\n        return -((~value & mask) + BN_1);\n    }\n    return value;\n}\n/**\n *  Convert %%value%% to a twos-compliment representation of\n *  %%width%% bits.\n *\n *  The result will always be positive.\n */ function toTwos(_value, _width) {\n    let value = getBigInt(_value, \"value\");\n    const width = BigInt(getNumber(_width, \"width\"));\n    const limit = BN_1 << width - BN_1;\n    if (value < BN_0) {\n        value = -value;\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assert)(value <= limit, \"too low\", \"NUMERIC_FAULT\", {\n            operation: \"toTwos\",\n            fault: \"overflow\",\n            value: _value\n        });\n        const mask = (BN_1 << width) - BN_1;\n        return (~value & mask) + BN_1;\n    } else {\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assert)(value < limit, \"too high\", \"NUMERIC_FAULT\", {\n            operation: \"toTwos\",\n            fault: \"overflow\",\n            value: _value\n        });\n    }\n    return value;\n}\n/**\n *  Mask %%value%% with a bitmask of %%bits%% ones.\n */ function mask(_value, _bits) {\n    const value = getUint(_value, \"value\");\n    const bits = BigInt(getNumber(_bits, \"bits\"));\n    return value & (BN_1 << bits) - BN_1;\n}\n/**\n *  Gets a BigInt from %%value%%. If it is an invalid value for\n *  a BigInt, then an ArgumentError will be thrown for %%name%%.\n */ function getBigInt(value, name) {\n    switch(typeof value){\n        case \"bigint\":\n            return value;\n        case \"number\":\n            (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(Number.isInteger(value), \"underflow\", name || \"value\", value);\n            (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(value >= -maxValue && value <= maxValue, \"overflow\", name || \"value\", value);\n            return BigInt(value);\n        case \"string\":\n            try {\n                if (value === \"\") {\n                    throw new Error(\"empty string\");\n                }\n                if (value[0] === \"-\" && value[1] !== \"-\") {\n                    return -BigInt(value.substring(1));\n                }\n                return BigInt(value);\n            } catch (e) {\n                (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(false, `invalid BigNumberish string: ${e.message}`, name || \"value\", value);\n            }\n    }\n    (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(false, \"invalid BigNumberish value\", name || \"value\", value);\n}\n/**\n *  Returns %%value%% as a bigint, validating it is valid as a bigint\n *  value and that it is positive.\n */ function getUint(value, name) {\n    const result = getBigInt(value, name);\n    (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assert)(result >= BN_0, \"unsigned value cannot be negative\", \"NUMERIC_FAULT\", {\n        fault: \"overflow\",\n        operation: \"getUint\",\n        value\n    });\n    return result;\n}\nconst Nibbles = \"0123456789abcdef\";\n/*\n * Converts %%value%% to a BigInt. If %%value%% is a Uint8Array, it\n * is treated as Big Endian data.\n */ function toBigInt(value) {\n    if (value instanceof Uint8Array) {\n        let result = \"0x0\";\n        for (const v of value){\n            result += Nibbles[v >> 4];\n            result += Nibbles[v & 0x0f];\n        }\n        return BigInt(result);\n    }\n    return getBigInt(value);\n}\n/**\n *  Gets a //number// from %%value%%. If it is an invalid value for\n *  a //number//, then an ArgumentError will be thrown for %%name%%.\n */ function getNumber(value, name) {\n    switch(typeof value){\n        case \"bigint\":\n            (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(value >= -maxValue && value <= maxValue, \"overflow\", name || \"value\", value);\n            return Number(value);\n        case \"number\":\n            (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(Number.isInteger(value), \"underflow\", name || \"value\", value);\n            (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(value >= -maxValue && value <= maxValue, \"overflow\", name || \"value\", value);\n            return value;\n        case \"string\":\n            try {\n                if (value === \"\") {\n                    throw new Error(\"empty string\");\n                }\n                return getNumber(BigInt(value), name);\n            } catch (e) {\n                (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(false, `invalid numeric string: ${e.message}`, name || \"value\", value);\n            }\n    }\n    (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(false, \"invalid numeric value\", name || \"value\", value);\n}\n/**\n *  Converts %%value%% to a number. If %%value%% is a Uint8Array, it\n *  is treated as Big Endian data. Throws if the value is not safe.\n */ function toNumber(value) {\n    return getNumber(toBigInt(value));\n}\n/**\n *  Converts %%value%% to a Big Endian hexstring, optionally padded to\n *  %%width%% bytes.\n */ function toBeHex(_value, _width) {\n    const value = getUint(_value, \"value\");\n    let result = value.toString(16);\n    if (_width == null) {\n        // Ensure the value is of even length\n        if (result.length % 2) {\n            result = \"0\" + result;\n        }\n    } else {\n        const width = getNumber(_width, \"width\");\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assert)(width * 2 >= result.length, `value exceeds width (${width} bytes)`, \"NUMERIC_FAULT\", {\n            operation: \"toBeHex\",\n            fault: \"overflow\",\n            value: _value\n        });\n        // Pad the value to the required width\n        while(result.length < width * 2){\n            result = \"0\" + result;\n        }\n    }\n    return \"0x\" + result;\n}\n/**\n *  Converts %%value%% to a Big Endian Uint8Array.\n */ function toBeArray(_value) {\n    const value = getUint(_value, \"value\");\n    if (value === BN_0) {\n        return new Uint8Array([]);\n    }\n    let hex = value.toString(16);\n    if (hex.length % 2) {\n        hex = \"0\" + hex;\n    }\n    const result = new Uint8Array(hex.length / 2);\n    for(let i = 0; i < result.length; i++){\n        const offset = i * 2;\n        result[i] = parseInt(hex.substring(offset, offset + 2), 16);\n    }\n    return result;\n}\n/**\n *  Returns a [[HexString]] for %%value%% safe to use as a //Quantity//.\n *\n *  A //Quantity// does not have and leading 0 values unless the value is\n *  the literal value `0x0`. This is most commonly used for JSSON-RPC\n *  numeric values.\n */ function toQuantity(value) {\n    let result = (0,_data_js__WEBPACK_IMPORTED_MODULE_1__.hexlify)((0,_data_js__WEBPACK_IMPORTED_MODULE_1__.isBytesLike)(value) ? value : toBeArray(value)).substring(2);\n    while(result.startsWith(\"0\")){\n        result = result.substring(1);\n    }\n    if (result === \"\") {\n        result = \"0\";\n    }\n    return \"0x\" + result;\n} //# sourceMappingURL=maths.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vdXRpbHMvbWF0aHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7OztBQUFBOzs7O0NBSUMsR0FDZ0Q7QUFDSTtBQUNyRCxNQUFNSSxPQUFPQyxPQUFPO0FBQ3BCLE1BQU1DLE9BQU9ELE9BQU87QUFDcEIsaURBQWlEO0FBQ2pELHVDQUF1QztBQUN2QyxNQUFNRSxXQUFXO0FBQ2pCOzs7OztDQUtDLEdBQ00sU0FBU0MsU0FBU0MsTUFBTSxFQUFFQyxNQUFNO0lBQ25DLE1BQU1DLFFBQVFDLFFBQVFILFFBQVE7SUFDOUIsTUFBTUksUUFBUVIsT0FBT1MsVUFBVUosUUFBUTtJQUN2Q1Isa0RBQU1BLENBQUMsU0FBVVcsVUFBV1QsTUFBTSxZQUFZLGlCQUFpQjtRQUMzRFcsV0FBVztRQUFZQyxPQUFPO1FBQVlMLE9BQU9GO0lBQ3JEO0lBQ0EseUNBQXlDO0lBQ3pDLElBQUlFLFNBQVVFLFFBQVFQLE1BQU87UUFDekIsTUFBTVcsT0FBTyxDQUFDWCxRQUFRTyxLQUFJLElBQUtQO1FBQy9CLE9BQU8sQ0FBRSxFQUFDLENBQUVLLFFBQVNNLElBQUcsSUFBS1gsSUFBRztJQUNwQztJQUNBLE9BQU9LO0FBQ1g7QUFDQTs7Ozs7Q0FLQyxHQUNNLFNBQVNPLE9BQU9ULE1BQU0sRUFBRUMsTUFBTTtJQUNqQyxJQUFJQyxRQUFRUSxVQUFVVixRQUFRO0lBQzlCLE1BQU1JLFFBQVFSLE9BQU9TLFVBQVVKLFFBQVE7SUFDdkMsTUFBTVUsUUFBU2QsUUFBU08sUUFBUVA7SUFDaEMsSUFBSUssUUFBUVAsTUFBTTtRQUNkTyxRQUFRLENBQUNBO1FBQ1RULGtEQUFNQSxDQUFDUyxTQUFTUyxPQUFPLFdBQVcsaUJBQWlCO1lBQy9DTCxXQUFXO1lBQVVDLE9BQU87WUFBWUwsT0FBT0Y7UUFDbkQ7UUFDQSxNQUFNUSxPQUFPLENBQUNYLFFBQVFPLEtBQUksSUFBS1A7UUFDL0IsT0FBTyxDQUFDLENBQUVLLFFBQVNNLElB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SUFBSSxHQUFHQSxJQUFJWCxPQUFPUSxNQUFNLEVBQUVHLElBQUs7UUFDcEMsTUFBTUMsU0FBU0QsSUFBSTtRQUNuQlgsTUFBTSxDQUFDVyxFQUFFLEdBQUdFLFNBQVNILElBQUliLFNBQVMsQ0FBQ2UsUUFBUUEsU0FBUyxJQUFJO0lBQzVEO0lBQ0EsT0FBT1o7QUFDWDtBQUNBOzs7Ozs7Q0FNQyxHQUNNLFNBQVNjLFdBQVdqQyxLQUFLO0lBQzVCLElBQUltQixTQUFTOUIsaURBQU9BLENBQUNDLHFEQUFXQSxDQUFDVSxTQUFTQSxRQUFRNEIsVUFBVTVCLFFBQVFnQixTQUFTLENBQUM7SUFDOUUsTUFBT0csT0FBT2UsVUFBVSxDQUFDLEtBQU07UUFDM0JmLFNBQVNBLE9BQU9ILFNBQVMsQ0FBQztJQUM5QjtJQUNBLElBQUlHLFdBQVcsSUFBSTtRQUNmQSxTQUFTO0lBQ2I7SUFDQSxPQUFPLE9BQU9BO0FBQ2xCLEVBQ0EsaUNBQWlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbWVnYXZpYmUtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vdXRpbHMvbWF0aHMuanM/YmNlMCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqICBTb21lIG1hdGhlbWF0aWMgb3BlcmF0aW9ucy5cbiAqXG4gKiAgQF9zdWJzZWN0aW9uOiBhcGkvdXRpbHM6TWF0aCBIZWxwZXJzICBbYWJvdXQtbWF0aHNdXG4gKi9cbmltcG9ydCB7IGhleGxpZnksIGlzQnl0ZXNMaWtlIH0gZnJvbSBcIi4vZGF0YS5qc1wiO1xuaW1wb3J0IHsgYXNzZXJ0LCBhc3NlcnRBcmd1bWVudCB9IGZyb20gXCIuL2Vycm9ycy5qc1wiO1xuY29uc3QgQk5fMCA9IEJpZ0ludCgwKTtcbmNvbnN0IEJOXzEgPSBCaWdJbnQoMSk7XG4vL2NvbnN0IEJOX01heDI1NiA9IChCTl8xIDw8IEJpZ0ludCgyNTYpKSAtIEJOXzE7XG4vLyBJRUVFIDc1NCBzdXBwb3J0IDUzLWJpdHMgb2YgbWFudGlzc2FcbmNvbnN0IG1heFZhbHVlID0gMHgxZmZmZmZmZmZmZmZmZjtcbi8qKlxuICogIENvbnZlcnQgJSV2YWx1ZSUlIGZyb20gYSB0d29zLWNvbXBsaW1lbnQgcmVwcmVzZW50YXRpb24gb2YgJSV3aWR0aCUlXG4gKiAgYml0cyB0byBpdHMgdmFsdWUuXG4gKlxuICogIElmIHRoZSBoaWdoZXN0IGJpdCBpcyBgYDFgYCwgdGhlIHJlc3VsdCB3aWxsIGJlIG5lZ2F0aXZlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbVR3b3MoX3ZhbHVlLCBfd2lkdGgpIHtcbiAgICBjb25zdCB2YWx1ZSA9IGdldFVpbnQoX3ZhbHVlLCBcInZhbHVlXCIpO1xuICAgIGNvbnN0IHdpZHRoID0gQmlnSW50KGdldE51bWJlcihfd2lkdGgsIFwid2lkdGhcIikpO1xuICAgIGFzc2VydCgodmFsdWUgPj4gd2lkdGgpID09PSBCTl8wLCBcIm92ZXJmbG93XCIsIFwiTlVNRVJJQ19GQVVMVFwiLCB7XG4gICAgICAgIG9wZXJhdGlvbjogXCJmcm9tVHdvc1wiLCBmYXVsdDogXCJvdmVyZmxvd1wiLCB2YWx1ZTogX3ZhbHVlXG4gICAgfSk7XG4gICAgLy8gVG9wIGJpdCBzZXQ7IHRyZWF0IGFzIGEgbmVnYXRpdmUgdmFsdWVcbiAgICBpZiAodmFsdWUgPj4gKHdpZHRoIC0gQk5fMSkpIHtcbiAgICAgICAgY29uc3QgbWFzayA9IChCTl8xIDw8IHdpZHRoKSAtIEJOXzE7XG4gICAgICAgIHJldHVybiAtKCgofnZhbHVlKSAmIG1hc2spICsgQk5fMSk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbn1cbi8qKlxuICogIENvbnZlcnQgJSV2YWx1ZSUlIHRvIGEgdHdvcy1jb21wbGltZW50IHJlcHJlc2VudGF0aW9uIG9mXG4gKiAgJSV3aWR0aCUlIGJpdHMuXG4gKlxuICogIFRoZSByZXN1bHQgd2lsbCBhbHdheXMgYmUgcG9zaXRpdmUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b1R3b3MoX3ZhbHVlLCBfd2lkdGgpIHtcbiAgICBsZXQgdmFsdWUgPSBnZXRCaWdJbnQoX3ZhbHVlLCBcInZhbHVlXCIpO1xuICAgIGNvbnN0IHdpZHRoID0gQmlnSW50KGdldE51bWJlcihfd2lkdGgsIFwid2lkdGhcIikpO1xuICAgIGNvbnN0IGxpbWl0ID0gKEJOXzEgPDwgKHdpZHRoIC0gQk5fMSkpO1xuICAgIGlmICh2YWx1ZSA8IEJOXzApIHtcbiAgICAgICAgdmFsdWUgPSAtdmFsdWU7XG4gICAgICAgIGFzc2VydCh2YWx1ZSA8PSBsaW1pdCwgXCJ0b28gbG93XCIsIFwiTlVNRVJJQ19GQVVMVFwiLCB7XG4gICAgICAgICAgICBvcGVyYXRpb246IFwidG9Ud29zXCIsIGZhdWx0OiBcIm92ZXJmbG93XCIsIHZhbHVlOiBfdmFsdWVcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IG1hc2sgPSAoQk5fMSA8PCB3aWR0aCkgLSBCTl8xO1xuICAgICAgICByZXR1cm4gKCh+dmFsdWUpICYgbWFzaykgKyBCTl8xO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgYXNzZXJ0KHZhbHVlIDwgbGltaXQsIFwidG9vIGhpZ2hcIiwgXCJOVU1FUklDX0ZBVUxUXCIsIHtcbiAgICAgICAgICAgIG9wZXJhdGlvbjogXCJ0b1R3b3NcIiwgZmF1bHQ6IFwib3ZlcmZsb3dcIiwgdmFsdWU6IF92YWx1ZVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xufVxuLyoqXG4gKiAgTWFzayAlJXZhbHVlJSUgd2l0aCBhIGJpdG1hc2sgb2YgJSViaXRzJSUgb25lcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1hc2soX3ZhbHVlLCBfYml0cykge1xuICAgIGNvbnN0IHZhbHVlID0gZ2V0VWludChfdmFsdWUsIFwidmFsdWVcIik7XG4gICAgY29uc3QgYml0cyA9IEJpZ0ludChnZXROdW1iZXIoX2JpdHMsIFwiYml0c1wiKSk7XG4gICAgcmV0dXJuIHZhbHVlICYgKChCTl8xIDw8IGJpdHMpIC0gQk5fMSk7XG59XG4vKipcbiAqICBHZXRzIGEgQmlnSW50IGZyb20gJSV2YWx1ZSUlLiBJZiBpdCBpcyBhbiBpbnZhbGlkIHZhbHVlIGZvclxuICogIGEgQmlnSW50LCB0aGVuIGFuIEFyZ3VtZW50RXJyb3Igd2lsbCBiZSB0aHJvd24gZm9yICUlbmFtZSUlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0QmlnSW50KHZhbHVlLCBuYW1lKSB7XG4gICAgc3dpdGNoICh0eXBlb2YgKHZhbHVlKSkge1xuICAgICAgICBjYXNlIFwiYmlnaW50XCI6IHJldHVybiB2YWx1ZTtcbiAgICAgICAgY2FzZSBcIm51bWJlclwiOlxuICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoTnVtYmVyLmlzSW50ZWdlcih2YWx1ZSksIFwidW5kZXJmbG93XCIsIG5hbWUgfHwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudCh2YWx1ZSA+PSAtbWF4VmFsdWUgJiYgdmFsdWUgPD0gbWF4VmFsdWUsIFwib3ZlcmZsb3dcIiwgbmFtZSB8fCBcInZhbHVlXCIsIHZhbHVlKTtcbiAgICAgICAgICAgIHJldHVybiBCaWdJbnQodmFsdWUpO1xuICAgICAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gXCJcIikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJlbXB0eSBzdHJpbmdcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZVswXSA9PT0gXCItXCIgJiYgdmFsdWVbMV0gIT09IFwiLVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAtQmlnSW50KHZhbHVlLnN1YnN0cmluZygxKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBCaWdJbnQodmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBhc3NlcnRBcmd1bWVudChmYWxzZSwgYGludmFsaWQgQmlnTnVtYmVyaXNoIHN0cmluZzogJHtlLm1lc3NhZ2V9YCwgbmFtZSB8fCBcInZhbHVlXCIsIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICB9XG4gICAgYXNzZXJ0QXJndW1lbnQoZmFsc2UsIFwiaW52YWxpZCBCaWdOdW1iZXJpc2ggdmFsdWVcIiwgbmFtZSB8fCBcInZhbHVlXCIsIHZhbHVlKTtcbn1cbi8qKlxuICogIFJldHVybnMgJSV2YWx1ZSUlIGFzIGEgYmlnaW50LCB2YWxpZGF0aW5nIGl0IGlzIHZhbGlkIGFzIGEgYmlnaW50XG4gKiAgdmFsdWUgYW5kIHRoYXQgaXQgaXMgcG9zaXRpdmUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRVaW50KHZhbHVlLCBuYW1lKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gZ2V0QmlnSW50KHZhbHVlLCBuYW1lKTtcbiAgICBhc3NlcnQocmVzdWx0ID49IEJOXzAsIFwidW5zaWduZWQgdmFsdWUgY2Fubm90IGJlIG5lZ2F0aXZlXCIsIFwiTlVNRVJJQ19GQVVMVFwiLCB7XG4gICAgICAgIGZhdWx0OiBcIm92ZXJmbG93XCIsIG9wZXJhdGlvbjogXCJnZXRVaW50XCIsIHZhbHVlXG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmNvbnN0IE5pYmJsZXMgPSBcIjAxMjM0NTY3ODlhYmNkZWZcIjtcbi8qXG4gKiBDb252ZXJ0cyAlJXZhbHVlJSUgdG8gYSBCaWdJbnQuIElmICUldmFsdWUlJSBpcyBhIFVpbnQ4QXJyYXksIGl0XG4gKiBpcyB0cmVhdGVkIGFzIEJpZyBFbmRpYW4gZGF0YS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvQmlnSW50KHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgICAgICBsZXQgcmVzdWx0ID0gXCIweDBcIjtcbiAgICAgICAgZm9yIChjb25zdCB2IG9mIHZhbHVlKSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gTmliYmxlc1t2ID4+IDRdO1xuICAgICAgICAgICAgcmVzdWx0ICs9IE5pYmJsZXNbdiAmIDB4MGZdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBCaWdJbnQocmVzdWx0KTtcbiAgICB9XG4gICAgcmV0dXJuIGdldEJpZ0ludCh2YWx1ZSk7XG59XG4vKipcbiAqICBHZXRzIGEgLy9udW1iZXIvLyBmcm9tICUldmFsdWUlJS4gSWYgaXQgaXMgYW4gaW52YWxpZCB2YWx1ZSBmb3JcbiAqICBhIC8vbnVtYmVyLy8sIHRoZW4gYW4gQXJndW1lbnRFcnJvciB3aWxsIGJlIHRocm93biBmb3IgJSVuYW1lJSUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXROdW1iZXIodmFsdWUsIG5hbWUpIHtcbiAgICBzd2l0Y2ggKHR5cGVvZiAodmFsdWUpKSB7XG4gICAgICAgIGNhc2UgXCJiaWdpbnRcIjpcbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KHZhbHVlID49IC1tYXhWYWx1ZSAmJiB2YWx1ZSA8PSBtYXhWYWx1ZSwgXCJvdmVyZmxvd1wiLCBuYW1lIHx8IFwidmFsdWVcIiwgdmFsdWUpO1xuICAgICAgICAgICAgcmV0dXJuIE51bWJlcih2YWx1ZSk7XG4gICAgICAgIGNhc2UgXCJudW1iZXJcIjpcbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KE51bWJlci5pc0ludGVnZXIodmFsdWUpLCBcInVuZGVyZmxvd1wiLCBuYW1lIHx8IFwidmFsdWVcIiwgdmFsdWUpO1xuICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQodmFsdWUgPj0gLW1heFZhbHVlICYmIHZhbHVlIDw9IG1heFZhbHVlLCBcIm92ZXJmbG93XCIsIG5hbWUgfHwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID09PSBcIlwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImVtcHR5IHN0cmluZ1wiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGdldE51bWJlcihCaWdJbnQodmFsdWUpLCBuYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoZmFsc2UsIGBpbnZhbGlkIG51bWVyaWMgc3RyaW5nOiAke2UubWVzc2FnZX1gLCBuYW1lIHx8IFwidmFsdWVcIiwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgIH1cbiAgICBhc3NlcnRBcmd1bWVudChmYWxzZSwgXCJpbnZhbGlkIG51bWVyaWMgdmFsdWVcIiwgbmFtZSB8fCBcInZhbHVlXCIsIHZhbHVlKTtcbn1cbi8qKlxuICogIENvbnZlcnRzICUldmFsdWUlJSB0byBhIG51bWJlci4gSWYgJSV2YWx1ZSUlIGlzIGEgVWludDhBcnJheSwgaXRcbiAqICBpcyB0cmVhdGVkIGFzIEJpZyBFbmRpYW4gZGF0YS4gVGhyb3dzIGlmIHRoZSB2YWx1ZSBpcyBub3Qgc2FmZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvTnVtYmVyKHZhbHVlKSB7XG4gICAgcmV0dXJuIGdldE51bWJlcih0b0JpZ0ludCh2YWx1ZSkpO1xufVxuLyoqXG4gKiAgQ29udmVydHMgJSV2YWx1ZSUlIHRvIGEgQmlnIEVuZGlhbiBoZXhzdHJpbmcsIG9wdGlvbmFsbHkgcGFkZGVkIHRvXG4gKiAgJSV3aWR0aCUlIGJ5dGVzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9CZUhleChfdmFsdWUsIF93aWR0aCkge1xuICAgIGNvbnN0IHZhbHVlID0gZ2V0VWludChfdmFsdWUsIFwidmFsdWVcIik7XG4gICAgbGV0IHJlc3VsdCA9IHZhbHVlLnRvU3RyaW5nKDE2KTtcbiAgICBpZiAoX3dpZHRoID09IG51bGwpIHtcbiAgICAgICAgLy8gRW5zdXJlIHRoZSB2YWx1ZSBpcyBvZiBldmVuIGxlbmd0aFxuICAgICAgICBpZiAocmVzdWx0Lmxlbmd0aCAlIDIpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IFwiMFwiICsgcmVzdWx0O1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb25zdCB3aWR0aCA9IGdldE51bWJlcihfd2lkdGgsIFwid2lkdGhcIik7XG4gICAgICAgIGFzc2VydCh3aWR0aCAqIDIgPj0gcmVzdWx0Lmxlbmd0aCwgYHZhbHVlIGV4Y2VlZHMgd2lkdGggKCR7d2lkdGh9IGJ5dGVzKWAsIFwiTlVNRVJJQ19GQVVMVFwiLCB7XG4gICAgICAgICAgICBvcGVyYXRpb246IFwidG9CZUhleFwiLFxuICAgICAgICAgICAgZmF1bHQ6IFwib3ZlcmZsb3dcIixcbiAgICAgICAgICAgIHZhbHVlOiBfdmFsdWVcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIFBhZCB0aGUgdmFsdWUgdG8gdGhlIHJlcXVpcmVkIHdpZHRoXG4gICAgICAgIHdoaWxlIChyZXN1bHQubGVuZ3RoIDwgKHdpZHRoICogMikpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IFwiMFwiICsgcmVzdWx0O1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBcIjB4XCIgKyByZXN1bHQ7XG59XG4vKipcbiAqICBDb252ZXJ0cyAlJXZhbHVlJSUgdG8gYSBCaWcgRW5kaWFuIFVpbnQ4QXJyYXkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0JlQXJyYXkoX3ZhbHVlKSB7XG4gICAgY29uc3QgdmFsdWUgPSBnZXRVaW50KF92YWx1ZSwgXCJ2YWx1ZVwiKTtcbiAgICBpZiAodmFsdWUgPT09IEJOXzApIHtcbiAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KFtdKTtcbiAgICB9XG4gICAgbGV0IGhleCA9IHZhbHVlLnRvU3RyaW5nKDE2KTtcbiAgICBpZiAoaGV4Lmxlbmd0aCAlIDIpIHtcbiAgICAgICAgaGV4ID0gXCIwXCIgKyBoZXg7XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBVaW50OEFycmF5KGhleC5sZW5ndGggLyAyKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlc3VsdC5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBvZmZzZXQgPSBpICogMjtcbiAgICAgICAgcmVzdWx0W2ldID0gcGFyc2VJbnQoaGV4LnN1YnN0cmluZyhvZmZzZXQsIG9mZnNldCArIDIpLCAxNik7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG4vKipcbiAqICBSZXR1cm5zIGEgW1tIZXhTdHJpbmddXSBmb3IgJSV2YWx1ZSUlIHNhZmUgdG8gdXNlIGFzIGEgLy9RdWFudGl0eS8vLlxuICpcbiAqICBBIC8vUXVhbnRpdHkvLyBkb2VzIG5vdCBoYXZlIGFuZCBsZWFkaW5nIDAgdmFsdWVzIHVubGVzcyB0aGUgdmFsdWUgaXNcbiAqICB0aGUgbGl0ZXJhbCB2YWx1ZSBgMHgwYC4gVGhpcyBpcyBtb3N0IGNvbW1vbmx5IHVzZWQgZm9yIEpTU09OLVJQQ1xuICogIG51bWVyaWMgdmFsdWVzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9RdWFudGl0eSh2YWx1ZSkge1xuICAgIGxldCByZXN1bHQgPSBoZXhsaWZ5KGlzQnl0ZXNMaWtlKHZhbHVlKSA/IHZhbHVlIDogdG9CZUFycmF5KHZhbHVlKSkuc3Vic3RyaW5nKDIpO1xuICAgIHdoaWxlIChyZXN1bHQuc3RhcnRzV2l0aChcIjBcIikpIHtcbiAgICAgICAgcmVzdWx0ID0gcmVzdWx0LnN1YnN0cmluZygxKTtcbiAgICB9XG4gICAgaWYgKHJlc3VsdCA9PT0gXCJcIikge1xuICAgICAgICByZXN1bHQgPSBcIjBcIjtcbiAgICB9XG4gICAgcmV0dXJuIFwiMHhcIiArIHJlc3VsdDtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1hdGhzLmpzLm1hcCJdLCJuYW1lcyI6WyJoZXhsaWZ5IiwiaXNCeXRlc0xpa2UiLCJhc3NlcnQiLCJhc3NlcnRBcmd1bWVudCIsIkJOXzAiLCJCaWdJbnQiLCJCTl8xIiwibWF4VmFsdWUiLCJmcm9tVHdvcyIsIl92YWx1ZSIsIl93aWR0aCIsInZhbHVlIiwiZ2V0VWludCIsIndpZHRoIiwiZ2V0TnVtYmVyIiwib3BlcmF0aW9uIiwiZmF1bHQiLCJtYXNrIiwidG9Ud29zIiwiZ2V0QmlnSW50IiwibGltaXQiLCJfYml0cyIsImJpdHMiLCJuYW1lIiwiTnVtYmVyIiwiaXNJbnRlZ2VyIiwiRXJyb3IiLCJzdWJzdHJpbmciLCJlIiwibWVzc2FnZSIsInJlc3VsdCIsIk5pYmJsZXMiLCJ0b0JpZ0ludCIsIlVpbnQ4QXJyYXkiLCJ2IiwidG9OdW1iZXIiLCJ0b0JlSGV4IiwidG9TdHJpbmciLCJsZW5ndGgiLCJ0b0JlQXJyYXkiLCJoZXgiLCJpIiwib2Zmc2V0IiwicGFyc2VJbnQiLCJ0b1F1YW50aXR5Iiwic3RhcnRzV2l0aCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.esm/utils/maths.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.esm/utils/properties.js":
/*!*********************************************************!*\
  !*** ./node_modules/ethers/lib.esm/utils/properties.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   defineProperties: () => (/* binding */ defineProperties),\n/* harmony export */   resolveProperties: () => (/* binding */ resolveProperties)\n/* harmony export */ });\n/**\n *  Property helper functions.\n *\n *  @_subsection api/utils:Properties  [about-properties]\n */ function checkType(value, type, name) {\n    const types = type.split(\"|\").map((t)=>t.trim());\n    for(let i = 0; i < types.length; i++){\n        switch(type){\n            case \"any\":\n                return;\n            case \"bigint\":\n            case \"boolean\":\n            case \"number\":\n            case \"string\":\n                if (typeof value === type) {\n                    return;\n                }\n        }\n    }\n    const error = new Error(`invalid value for type ${type}`);\n    error.code = \"INVALID_ARGUMENT\";\n    error.argument = `value.${name}`;\n    error.value = value;\n    throw error;\n}\n/**\n *  Resolves to a new object that is a copy of %%value%%, but with all\n *  values resolved.\n */ async function resolveProperties(value) {\n    const keys = Object.keys(value);\n    const results = await Promise.all(keys.map((k)=>Promise.resolve(value[k])));\n    return results.reduce((accum, v, index)=>{\n        accum[keys[index]] = v;\n        return accum;\n    }, {});\n}\n/**\n *  Assigns the %%values%% to %%target%% as read-only values.\n *\n *  It %%types%% is specified, the values are checked.\n */ function defineProperties(target, values, types) {\n    for(let key in values){\n        let value = values[key];\n        const type = types ? types[key] : null;\n        if (type) {\n            checkType(value, type, key);\n        }\n        Object.defineProperty(target, key, {\n            enumerable: true,\n            value,\n            writable: false\n        });\n    }\n} //# sourceMappingURL=properties.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vdXRpbHMvcHJvcGVydGllcy5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBOzs7O0NBSUMsR0FDRCxTQUFTQSxVQUFVQyxLQUFLLEVBQUVDLElBQUksRUFBRUMsSUFBSTtJQUNoQyxNQUFNQyxRQUFRRixLQUFLRyxLQUFLLENBQUMsS0FBS0MsR0FBRyxDQUFDQyxDQUFBQSxJQUFLQSxFQUFFQyxJQUFJO0lBQzdDLElBQUssSUFBSUMsSUFBSSxHQUFHQSxJQUFJTCxNQUFNTSxNQUFNLEVBQUVELElBQUs7UUFDbkMsT0FBUVA7WUFDSixLQUFLO2dCQUNEO1lBQ0osS0FBSztZQUNMLEtBQUs7WUFDTCxLQUFLO1lBQ0wsS0FBSztnQkFDRCxJQUFJLE9BQVFELFVBQVdDLE1BQU07b0JBQ3pCO2dCQUNKO1FBQ1I7SUFDSjtJQUNBLE1BQU1TLFFBQVEsSUFBSUMsTUFBTSxDQUFDLHVCQUF1QixFQUFFVixLQUFLLENBQUM7SUFDeERTLE1BQU1FLElBQUksR0FBRztJQUNiRixNQUFNRyxRQUFRLEdBQUcsQ0FBQyxNQUFNLEVBQUVYLEtBQUssQ0FBQztJQUNoQ1EsTUFBTVYsS0FBSyxHQUFHQTtJQUNkLE1BQU1VO0FBQ1Y7QUFDQTs7O0NBR0MsR0FDTSxlQUFlSSxrQkFBa0JkLEtBQUs7SUFDekMsTUFBTWUsT0FBT0MsT0FBT0QsSUFBSSxDQUFDZjtJQUN6QixNQUFNaUIsVUFBVSxNQUFNQyxRQUFRQyxHQUFHLENBQUNKLEtBQUtWLEdBQUcsQ0FBQyxDQUFDZSxJQUFNRixRQUFRRyxPQUFPLENBQUNyQixLQUFLLENBQUNvQixFQUFFO0lBQzFFLE9BQU9ILFFBQVFLLE1BQU0sQ0FBQyxDQUFDQyxPQUFPQyxHQUFHQztRQUM3QkYsS0FBSyxDQUFDUixJQUFJLENBQUNVLE1BQU0sQ0FBQyxHQUFHRDtRQUNyQixPQUFPRDtJQUNYLEdBQUcsQ0FBQztBQUNSO0FBQ0E7Ozs7Q0FJQyxHQUNNLFNBQVNHLGlCQUFpQkMsTUFBTSxFQUFFQyxNQUFNLEVBQUV6QixLQUFLO0lBQ2xELElBQUssSUFBSTBCLE9BQU9ELE9BQVE7UUFDcEIsSUFBSTVCLFFBQVE0QixNQUFNLENBQUNDLElBQUk7UUFDdkIsTUFBTTVCLE9BQVFFLFFBQVFBLEtBQUssQ0FBQzBCLElBQUksR0FBRztRQUNuQyxJQUFJNUIsTUFBTTtZQUNORixVQUFVQyxPQUFPQyxNQUFNNEI7UUFDM0I7UUFDQWIsT0FBT2MsY0FBYyxDQUFDSCxRQUFRRSxLQUFLO1lBQUVFLFlBQVk7WUFBTS9CO1lBQU9nQyxVQUFVO1FBQU07SUFDbEY7QUFDSixFQUNBLHNDQUFzQyIsInNvdXJjZXMiOlsid2VicGFjazovL21lZ2F2aWJlLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL3V0aWxzL3Byb3BlcnRpZXMuanM/NTIwNyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqICBQcm9wZXJ0eSBoZWxwZXIgZnVuY3Rpb25zLlxuICpcbiAqICBAX3N1YnNlY3Rpb24gYXBpL3V0aWxzOlByb3BlcnRpZXMgIFthYm91dC1wcm9wZXJ0aWVzXVxuICovXG5mdW5jdGlvbiBjaGVja1R5cGUodmFsdWUsIHR5cGUsIG5hbWUpIHtcbiAgICBjb25zdCB0eXBlcyA9IHR5cGUuc3BsaXQoXCJ8XCIpLm1hcCh0ID0+IHQudHJpbSgpKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHR5cGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgICAgY2FzZSBcImFueVwiOlxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGNhc2UgXCJiaWdpbnRcIjpcbiAgICAgICAgICAgIGNhc2UgXCJib29sZWFuXCI6XG4gICAgICAgICAgICBjYXNlIFwibnVtYmVyXCI6XG4gICAgICAgICAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiAodmFsdWUpID09PSB0eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoYGludmFsaWQgdmFsdWUgZm9yIHR5cGUgJHt0eXBlfWApO1xuICAgIGVycm9yLmNvZGUgPSBcIklOVkFMSURfQVJHVU1FTlRcIjtcbiAgICBlcnJvci5hcmd1bWVudCA9IGB2YWx1ZS4ke25hbWV9YDtcbiAgICBlcnJvci52YWx1ZSA9IHZhbHVlO1xuICAgIHRocm93IGVycm9yO1xufVxuLyoqXG4gKiAgUmVzb2x2ZXMgdG8gYSBuZXcgb2JqZWN0IHRoYXQgaXMgYSBjb3B5IG9mICUldmFsdWUlJSwgYnV0IHdpdGggYWxsXG4gKiAgdmFsdWVzIHJlc29sdmVkLlxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcmVzb2x2ZVByb3BlcnRpZXModmFsdWUpIHtcbiAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXModmFsdWUpO1xuICAgIGNvbnN0IHJlc3VsdHMgPSBhd2FpdCBQcm9taXNlLmFsbChrZXlzLm1hcCgoaykgPT4gUHJvbWlzZS5yZXNvbHZlKHZhbHVlW2tdKSkpO1xuICAgIHJldHVybiByZXN1bHRzLnJlZHVjZSgoYWNjdW0sIHYsIGluZGV4KSA9PiB7XG4gICAgICAgIGFjY3VtW2tleXNbaW5kZXhdXSA9IHY7XG4gICAgICAgIHJldHVybiBhY2N1bTtcbiAgICB9LCB7fSk7XG59XG4vKipcbiAqICBBc3NpZ25zIHRoZSAlJXZhbHVlcyUlIHRvICUldGFyZ2V0JSUgYXMgcmVhZC1vbmx5IHZhbHVlcy5cbiAqXG4gKiAgSXQgJSV0eXBlcyUlIGlzIHNwZWNpZmllZCwgdGhlIHZhbHVlcyBhcmUgY2hlY2tlZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCB2YWx1ZXMsIHR5cGVzKSB7XG4gICAgZm9yIChsZXQga2V5IGluIHZhbHVlcykge1xuICAgICAgICBsZXQgdmFsdWUgPSB2YWx1ZXNba2V5XTtcbiAgICAgICAgY29uc3QgdHlwZSA9ICh0eXBlcyA/IHR5cGVzW2tleV0gOiBudWxsKTtcbiAgICAgICAgaWYgKHR5cGUpIHtcbiAgICAgICAgICAgIGNoZWNrVHlwZSh2YWx1ZSwgdHlwZSwga2V5KTtcbiAgICAgICAgfVxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWUsIHdyaXRhYmxlOiBmYWxzZSB9KTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wcm9wZXJ0aWVzLmpzLm1hcCJdLCJuYW1lcyI6WyJjaGVja1R5cGUiLCJ2YWx1ZSIsInR5cGUiLCJuYW1lIiwidHlwZXMiLCJzcGxpdCIsIm1hcCIsInQiLCJ0cmltIiwiaSIsImxlbmd0aCIsImVycm9yIiwiRXJyb3IiLCJjb2RlIiwiYXJndW1lbnQiLCJyZXNvbHZlUHJvcGVydGllcyIsImtleXMiLCJPYmplY3QiLCJyZXN1bHRzIiwiUHJvbWlzZSIsImFsbCIsImsiLCJyZXNvbHZlIiwicmVkdWNlIiwiYWNjdW0iLCJ2IiwiaW5kZXgiLCJkZWZpbmVQcm9wZXJ0aWVzIiwidGFyZ2V0IiwidmFsdWVzIiwia2V5IiwiZGVmaW5lUHJvcGVydHkiLCJlbnVtZXJhYmxlIiwid3JpdGFibGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.esm/utils/properties.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.esm/utils/rlp-decode.js":
/*!*********************************************************!*\
  !*** ./node_modules/ethers/lib.esm/utils/rlp-decode.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   decodeRlp: () => (/* binding */ decodeRlp)\n/* harmony export */ });\n/* harmony import */ var _data_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./data.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/data.js\");\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./errors.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/errors.js\");\n//See: https://github.com/ethereum/wiki/wiki/RLP\n\n\n\nfunction hexlifyByte(value) {\n    let result = value.toString(16);\n    while(result.length < 2){\n        result = \"0\" + result;\n    }\n    return \"0x\" + result;\n}\nfunction unarrayifyInteger(data, offset, length) {\n    let result = 0;\n    for(let i = 0; i < length; i++){\n        result = result * 256 + data[offset + i];\n    }\n    return result;\n}\nfunction _decodeChildren(data, offset, childOffset, length) {\n    const result = [];\n    while(childOffset < offset + 1 + length){\n        const decoded = _decode(data, childOffset);\n        result.push(decoded.result);\n        childOffset += decoded.consumed;\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assert)(childOffset <= offset + 1 + length, \"child data too short\", \"BUFFER_OVERRUN\", {\n            buffer: data,\n            length,\n            offset\n        });\n    }\n    return {\n        consumed: 1 + length,\n        result: result\n    };\n}\n// returns { consumed: number, result: Object }\nfunction _decode(data, offset) {\n    (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assert)(data.length !== 0, \"data too short\", \"BUFFER_OVERRUN\", {\n        buffer: data,\n        length: 0,\n        offset: 1\n    });\n    const checkOffset = (offset)=>{\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assert)(offset <= data.length, \"data short segment too short\", \"BUFFER_OVERRUN\", {\n            buffer: data,\n            length: data.length,\n            offset\n        });\n    };\n    // Array with extra length prefix\n    if (data[offset] >= 0xf8) {\n        const lengthLength = data[offset] - 0xf7;\n        checkOffset(offset + 1 + lengthLength);\n        const length = unarrayifyInteger(data, offset + 1, lengthLength);\n        checkOffset(offset + 1 + lengthLength + length);\n        return _decodeChildren(data, offset, offset + 1 + lengthLength, lengthLength + length);\n    } else if (data[offset] >= 0xc0) {\n        const length = data[offset] - 0xc0;\n        checkOffset(offset + 1 + length);\n        return _decodeChildren(data, offset, offset + 1, length);\n    } else if (data[offset] >= 0xb8) {\n        const lengthLength = data[offset] - 0xb7;\n        checkOffset(offset + 1 + lengthLength);\n        const length = unarrayifyInteger(data, offset + 1, lengthLength);\n        checkOffset(offset + 1 + lengthLength + length);\n        const result = (0,_data_js__WEBPACK_IMPORTED_MODULE_1__.hexlify)(data.slice(offset + 1 + lengthLength, offset + 1 + lengthLength + length));\n        return {\n            consumed: 1 + lengthLength + length,\n            result: result\n        };\n    } else if (data[offset] >= 0x80) {\n        const length = data[offset] - 0x80;\n        checkOffset(offset + 1 + length);\n        const result = (0,_data_js__WEBPACK_IMPORTED_MODULE_1__.hexlify)(data.slice(offset + 1, offset + 1 + length));\n        return {\n            consumed: 1 + length,\n            result: result\n        };\n    }\n    return {\n        consumed: 1,\n        result: hexlifyByte(data[offset])\n    };\n}\n/**\n *  Decodes %%data%% into the structured data it represents.\n */ function decodeRlp(_data) {\n    const data = (0,_data_js__WEBPACK_IMPORTED_MODULE_1__.getBytes)(_data, \"data\");\n    const decoded = _decode(data, 0);\n    (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(decoded.consumed === data.length, \"unexpected junk after rlp payload\", \"data\", _data);\n    return decoded.result;\n} //# sourceMappingURL=rlp-decode.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vdXRpbHMvcmxwLWRlY29kZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQSxnREFBZ0Q7QUFDWjtBQUNpQjtBQUNoQjtBQUNyQyxTQUFTSSxZQUFZQyxLQUFLO0lBQ3RCLElBQUlDLFNBQVNELE1BQU1FLFFBQVEsQ0FBQztJQUM1QixNQUFPRCxPQUFPRSxNQUFNLEdBQUcsRUFBRztRQUN0QkYsU0FBUyxNQUFNQTtJQUNuQjtJQUNBLE9BQU8sT0FBT0E7QUFDbEI7QUFDQSxTQUFTRyxrQkFBa0JDLElBQUksRUFBRUMsTUFBTSxFQUFFSCxNQUFNO0lBQzNDLElBQUlGLFNBQVM7SUFDYixJQUFLLElBQUlNLElBQUksR0FBR0EsSUFBSUosUUFBUUksSUFBSztRQUM3Qk4sU0FBUyxTQUFVLE1BQU9JLElBQUksQ0FBQ0MsU0FBU0MsRUFBRTtJQUM5QztJQUNBLE9BQU9OO0FBQ1g7QUFDQSxTQUFTTyxnQkFBZ0JILElBQUksRUFBRUMsTUFBTSxFQUFFRyxXQUFXLEVBQUVOLE1BQU07SUFDdEQsTUFBTUYsU0FBUyxFQUFFO0lBQ2pCLE1BQU9RLGNBQWNILFNBQVMsSUFBSUgsT0FBUTtRQUN0QyxNQUFNTyxVQUFVQyxRQUFRTixNQUFNSTtRQUM5QlIsT0FBT1csSUFBSSxDQUFDRixRQUFRVCxNQUFNO1FBQzFCUSxlQUFlQyxRQUFRRyxRQUFRO1FBQy9CakIsa0RBQU1BLENBQUNhLGVBQWVILFNBQVMsSUFBSUgsUUFBUSx3QkFBd0Isa0JBQWtCO1lBQ2pGVyxRQUFRVDtZQUFNRjtZQUFRRztRQUMxQjtJQUNKO0lBQ0EsT0FBTztRQUFFTyxVQUFXLElBQUlWO1FBQVNGLFFBQVFBO0lBQU87QUFDcEQ7QUFDQSwrQ0FBK0M7QUFDL0MsU0FBU1UsUUFBUU4sSUFBSSxFQUFFQyxNQUFNO0lBQ3pCVixrREFBTUEsQ0FBQ1MsS0FBS0YsTUFBTSxLQUFLLEdBQUcsa0JBQWtCLGtCQUFrQjtRQUMxRFcsUUFBUVQ7UUFBTUYsUUFBUTtRQUFHRyxRQUFRO0lBQ3JDO0lBQ0EsTUFBTVMsY0FBYyxDQUFDVDtRQUNqQlYsa0RBQU1BLENBQUNVLFVBQVVELEtBQUtGLE1BQU0sRUFBRSxnQ0FBZ0Msa0JBQWtCO1lBQzVFVyxRQUFRVDtZQUFNRixRQUFRRSxLQUFLRixNQUFNO1lBQUVHO1FBQ3ZDO0lBQ0o7SUFDQSxpQ0FBaUM7SUFDakMsSUFBSUQsSUFBSSxDQUFDQyxPQUFPLElBQUksTUFBTTtRQUN0QixNQUFNVSxlQUFlWCxJQUFJLENBQUNDLE9BQU8sR0FBRztRQUNwQ1MsWUFBWVQsU0FBUyxJQUFJVTtRQUN6QixNQUFNYixTQUFTQyxrQkFBa0JDLE1BQU1DLFNBQVMsR0FBR1U7UUFDbkRELFlBQVlULFNBQVMsSUFBSVUsZUFBZWI7UUFDeEMsT0FBT0ssZ0JBQWdCSCxNQUFNQyxRQUFRQSxTQUFTLElBQUlVLGNBQWNBLGVBQWViO0lBQ25GLE9BQ0ssSUFBSUUsSUFBSSxDQUFDQyxPQUFPLElBQUksTUFBTTtRQUMzQixNQUFNSCxTQUFTRSxJQUFJLENBQUNDLE9BQU8sR0FBRztRQUM5QlMsWUFBWVQsU0FBUyxJQUFJSDtRQUN6QixPQUFPSyxnQkFBZ0JILE1BQU1DLFFBQVFBLFNBQVMsR0FBR0g7SUFDckQsT0FDSyxJQUFJRSxJQUFJLENBQUNDLE9BQU8sSUFBSSxNQUFNO1FBQzNCLE1BQU1VLGVBQWVYLElBQUksQ0FBQ0MsT0FBTyxHQUFHO1FBQ3BDUyxZQUFZVCxTQUFTLElBQUlVO1FBQ3pCLE1BQU1iLFNBQVNDLGtCQUFrQkMsTUFBTUMsU0FBUyxHQUFHVTtRQUNuREQsWUFBWVQsU0FBUyxJQUFJVSxlQUFlYjtRQUN4QyxNQUFNRixTQUFTTixpREFBT0EsQ0FBQ1UsS0FBS1ksS0FBSyxDQUFDWCxTQUFTLElBQUlVLGNBQWNWLFNBQVMsSUFBSVUsZUFBZWI7UUFDekYsT0FBTztZQUFFVSxVQUFXLElBQUlHLGVBQWViO1lBQVNGLFFBQVFBO1FBQU87SUFDbkUsT0FDSyxJQUFJSSxJQUFJLENBQUNDLE9BQU8sSUFBSSxNQUFNO1FBQzNCLE1BQU1ILFNBQVNFLElBQUksQ0FBQ0MsT0FBTyxHQUFHO1FBQzlCUyxZQUFZVCxTQUFTLElBQUlIO1FBQ3pCLE1BQU1GLFNBQVNOLGlEQUFPQSxDQUFDVSxLQUFLWSxLQUFLLENBQUNYLFNBQVMsR0FBR0EsU0FBUyxJQUFJSDtRQUMzRCxPQUFPO1lBQUVVLFVBQVcsSUFBSVY7WUFBU0YsUUFBUUE7UUFBTztJQUNwRDtJQUNBLE9BQU87UUFBRVksVUFBVTtRQUFHWixRQUFRRixZQUFZTSxJQUFJLENBQUNDLE9BQU87SUFBRTtBQUM1RDtBQUNBOztDQUVDLEdBQ00sU0FBU1ksVUFBVUMsS0FBSztJQUMzQixNQUFNZCxPQUFPUCxrREFBUUEsQ0FBQ3FCLE9BQU87SUFDN0IsTUFBTVQsVUFBVUMsUUFBUU4sTUFBTTtJQUM5QlIsMERBQWNBLENBQUNhLFFBQVFHLFFBQVEsS0FBS1IsS0FBS0YsTUFBTSxFQUFFLHFDQUFxQyxRQUFRZ0I7SUFDOUYsT0FBT1QsUUFBUVQsTUFBTTtBQUN6QixFQUNBLHNDQUFzQyIsInNvdXJjZXMiOlsid2VicGFjazovL21lZ2F2aWJlLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL3V0aWxzL3JscC1kZWNvZGUuanM/NmUzMCJdLCJzb3VyY2VzQ29udGVudCI6WyIvL1NlZTogaHR0cHM6Ly9naXRodWIuY29tL2V0aGVyZXVtL3dpa2kvd2lraS9STFBcbmltcG9ydCB7IGhleGxpZnkgfSBmcm9tIFwiLi9kYXRhLmpzXCI7XG5pbXBvcnQgeyBhc3NlcnQsIGFzc2VydEFyZ3VtZW50IH0gZnJvbSBcIi4vZXJyb3JzLmpzXCI7XG5pbXBvcnQgeyBnZXRCeXRlcyB9IGZyb20gXCIuL2RhdGEuanNcIjtcbmZ1bmN0aW9uIGhleGxpZnlCeXRlKHZhbHVlKSB7XG4gICAgbGV0IHJlc3VsdCA9IHZhbHVlLnRvU3RyaW5nKDE2KTtcbiAgICB3aGlsZSAocmVzdWx0Lmxlbmd0aCA8IDIpIHtcbiAgICAgICAgcmVzdWx0ID0gXCIwXCIgKyByZXN1bHQ7XG4gICAgfVxuICAgIHJldHVybiBcIjB4XCIgKyByZXN1bHQ7XG59XG5mdW5jdGlvbiB1bmFycmF5aWZ5SW50ZWdlcihkYXRhLCBvZmZzZXQsIGxlbmd0aCkge1xuICAgIGxldCByZXN1bHQgPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcmVzdWx0ID0gKHJlc3VsdCAqIDI1NikgKyBkYXRhW29mZnNldCArIGldO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gX2RlY29kZUNoaWxkcmVuKGRhdGEsIG9mZnNldCwgY2hpbGRPZmZzZXQsIGxlbmd0aCkge1xuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgIHdoaWxlIChjaGlsZE9mZnNldCA8IG9mZnNldCArIDEgKyBsZW5ndGgpIHtcbiAgICAgICAgY29uc3QgZGVjb2RlZCA9IF9kZWNvZGUoZGF0YSwgY2hpbGRPZmZzZXQpO1xuICAgICAgICByZXN1bHQucHVzaChkZWNvZGVkLnJlc3VsdCk7XG4gICAgICAgIGNoaWxkT2Zmc2V0ICs9IGRlY29kZWQuY29uc3VtZWQ7XG4gICAgICAgIGFzc2VydChjaGlsZE9mZnNldCA8PSBvZmZzZXQgKyAxICsgbGVuZ3RoLCBcImNoaWxkIGRhdGEgdG9vIHNob3J0XCIsIFwiQlVGRkVSX09WRVJSVU5cIiwge1xuICAgICAgICAgICAgYnVmZmVyOiBkYXRhLCBsZW5ndGgsIG9mZnNldFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHsgY29uc3VtZWQ6ICgxICsgbGVuZ3RoKSwgcmVzdWx0OiByZXN1bHQgfTtcbn1cbi8vIHJldHVybnMgeyBjb25zdW1lZDogbnVtYmVyLCByZXN1bHQ6IE9iamVjdCB9XG5mdW5jdGlvbiBfZGVjb2RlKGRhdGEsIG9mZnNldCkge1xuICAgIGFzc2VydChkYXRhLmxlbmd0aCAhPT0gMCwgXCJkYXRhIHRvbyBzaG9ydFwiLCBcIkJVRkZFUl9PVkVSUlVOXCIsIHtcbiAgICAgICAgYnVmZmVyOiBkYXRhLCBsZW5ndGg6IDAsIG9mZnNldDogMVxuICAgIH0pO1xuICAgIGNvbnN0IGNoZWNrT2Zmc2V0ID0gKG9mZnNldCkgPT4ge1xuICAgICAgICBhc3NlcnQob2Zmc2V0IDw9IGRhdGEubGVuZ3RoLCBcImRhdGEgc2hvcnQgc2VnbWVudCB0b28gc2hvcnRcIiwgXCJCVUZGRVJfT1ZFUlJVTlwiLCB7XG4gICAgICAgICAgICBidWZmZXI6IGRhdGEsIGxlbmd0aDogZGF0YS5sZW5ndGgsIG9mZnNldFxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8vIEFycmF5IHdpdGggZXh0cmEgbGVuZ3RoIHByZWZpeFxuICAgIGlmIChkYXRhW29mZnNldF0gPj0gMHhmOCkge1xuICAgICAgICBjb25zdCBsZW5ndGhMZW5ndGggPSBkYXRhW29mZnNldF0gLSAweGY3O1xuICAgICAgICBjaGVja09mZnNldChvZmZzZXQgKyAxICsgbGVuZ3RoTGVuZ3RoKTtcbiAgICAgICAgY29uc3QgbGVuZ3RoID0gdW5hcnJheWlmeUludGVnZXIoZGF0YSwgb2Zmc2V0ICsgMSwgbGVuZ3RoTGVuZ3RoKTtcbiAgICAgICAgY2hlY2tPZmZzZXQob2Zmc2V0ICsgMSArIGxlbmd0aExlbmd0aCArIGxlbmd0aCk7XG4gICAgICAgIHJldHVybiBfZGVjb2RlQ2hpbGRyZW4oZGF0YSwgb2Zmc2V0LCBvZmZzZXQgKyAxICsgbGVuZ3RoTGVuZ3RoLCBsZW5ndGhMZW5ndGggKyBsZW5ndGgpO1xuICAgIH1cbiAgICBlbHNlIGlmIChkYXRhW29mZnNldF0gPj0gMHhjMCkge1xuICAgICAgICBjb25zdCBsZW5ndGggPSBkYXRhW29mZnNldF0gLSAweGMwO1xuICAgICAgICBjaGVja09mZnNldChvZmZzZXQgKyAxICsgbGVuZ3RoKTtcbiAgICAgICAgcmV0dXJuIF9kZWNvZGVDaGlsZHJlbihkYXRhLCBvZmZzZXQsIG9mZnNldCArIDEsIGxlbmd0aCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGRhdGFbb2Zmc2V0XSA+PSAweGI4KSB7XG4gICAgICAgIGNvbnN0IGxlbmd0aExlbmd0aCA9IGRhdGFbb2Zmc2V0XSAtIDB4Yjc7XG4gICAgICAgIGNoZWNrT2Zmc2V0KG9mZnNldCArIDEgKyBsZW5ndGhMZW5ndGgpO1xuICAgICAgICBjb25zdCBsZW5ndGggPSB1bmFycmF5aWZ5SW50ZWdlcihkYXRhLCBvZmZzZXQgKyAxLCBsZW5ndGhMZW5ndGgpO1xuICAgICAgICBjaGVja09mZnNldChvZmZzZXQgKyAxICsgbGVuZ3RoTGVuZ3RoICsgbGVuZ3RoKTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gaGV4bGlmeShkYXRhLnNsaWNlKG9mZnNldCArIDEgKyBsZW5ndGhMZW5ndGgsIG9mZnNldCArIDEgKyBsZW5ndGhMZW5ndGggKyBsZW5ndGgpKTtcbiAgICAgICAgcmV0dXJuIHsgY29uc3VtZWQ6ICgxICsgbGVuZ3RoTGVuZ3RoICsgbGVuZ3RoKSwgcmVzdWx0OiByZXN1bHQgfTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZGF0YVtvZmZzZXRdID49IDB4ODApIHtcbiAgICAgICAgY29uc3QgbGVuZ3RoID0gZGF0YVtvZmZzZXRdIC0gMHg4MDtcbiAgICAgICAgY2hlY2tPZmZzZXQob2Zmc2V0ICsgMSArIGxlbmd0aCk7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGhleGxpZnkoZGF0YS5zbGljZShvZmZzZXQgKyAxLCBvZmZzZXQgKyAxICsgbGVuZ3RoKSk7XG4gICAgICAgIHJldHVybiB7IGNvbnN1bWVkOiAoMSArIGxlbmd0aCksIHJlc3VsdDogcmVzdWx0IH07XG4gICAgfVxuICAgIHJldHVybiB7IGNvbnN1bWVkOiAxLCByZXN1bHQ6IGhleGxpZnlCeXRlKGRhdGFbb2Zmc2V0XSkgfTtcbn1cbi8qKlxuICogIERlY29kZXMgJSVkYXRhJSUgaW50byB0aGUgc3RydWN0dXJlZCBkYXRhIGl0IHJlcHJlc2VudHMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZWNvZGVSbHAoX2RhdGEpIHtcbiAgICBjb25zdCBkYXRhID0gZ2V0Qnl0ZXMoX2RhdGEsIFwiZGF0YVwiKTtcbiAgICBjb25zdCBkZWNvZGVkID0gX2RlY29kZShkYXRhLCAwKTtcbiAgICBhc3NlcnRBcmd1bWVudChkZWNvZGVkLmNvbnN1bWVkID09PSBkYXRhLmxlbmd0aCwgXCJ1bmV4cGVjdGVkIGp1bmsgYWZ0ZXIgcmxwIHBheWxvYWRcIiwgXCJkYXRhXCIsIF9kYXRhKTtcbiAgICByZXR1cm4gZGVjb2RlZC5yZXN1bHQ7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ybHAtZGVjb2RlLmpzLm1hcCJdLCJuYW1lcyI6WyJoZXhsaWZ5IiwiYXNzZXJ0IiwiYXNzZXJ0QXJndW1lbnQiLCJnZXRCeXRlcyIsImhleGxpZnlCeXRlIiwidmFsdWUiLCJyZXN1bHQiLCJ0b1N0cmluZyIsImxlbmd0aCIsInVuYXJyYXlpZnlJbnRlZ2VyIiwiZGF0YSIsIm9mZnNldCIsImkiLCJfZGVjb2RlQ2hpbGRyZW4iLCJjaGlsZE9mZnNldCIsImRlY29kZWQiLCJfZGVjb2RlIiwicHVzaCIsImNvbnN1bWVkIiwiYnVmZmVyIiwiY2hlY2tPZmZzZXQiLCJsZW5ndGhMZW5ndGgiLCJzbGljZSIsImRlY29kZVJscCIsIl9kYXRhIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.esm/utils/rlp-decode.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.esm/utils/rlp-encode.js":
/*!*********************************************************!*\
  !*** ./node_modules/ethers/lib.esm/utils/rlp-encode.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   encodeRlp: () => (/* binding */ encodeRlp)\n/* harmony export */ });\n/* harmony import */ var _data_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./data.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/data.js\");\n//See: https://github.com/ethereum/wiki/wiki/RLP\n\nfunction arrayifyInteger(value) {\n    const result = [];\n    while(value){\n        result.unshift(value & 0xff);\n        value >>= 8;\n    }\n    return result;\n}\nfunction _encode(object) {\n    if (Array.isArray(object)) {\n        let payload = [];\n        object.forEach(function(child) {\n            payload = payload.concat(_encode(child));\n        });\n        if (payload.length <= 55) {\n            payload.unshift(0xc0 + payload.length);\n            return payload;\n        }\n        const length = arrayifyInteger(payload.length);\n        length.unshift(0xf7 + length.length);\n        return length.concat(payload);\n    }\n    const data = Array.prototype.slice.call((0,_data_js__WEBPACK_IMPORTED_MODULE_0__.getBytes)(object, \"object\"));\n    if (data.length === 1 && data[0] <= 0x7f) {\n        return data;\n    } else if (data.length <= 55) {\n        data.unshift(0x80 + data.length);\n        return data;\n    }\n    const length = arrayifyInteger(data.length);\n    length.unshift(0xb7 + length.length);\n    return length.concat(data);\n}\nconst nibbles = \"0123456789abcdef\";\n/**\n *  Encodes %%object%% as an RLP-encoded [[DataHexString]].\n */ function encodeRlp(object) {\n    let result = \"0x\";\n    for (const v of _encode(object)){\n        result += nibbles[v >> 4];\n        result += nibbles[v & 0xf];\n    }\n    return result;\n} //# sourceMappingURL=rlp-encode.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vdXRpbHMvcmxwLWVuY29kZS5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBLGdEQUFnRDtBQUNYO0FBQ3JDLFNBQVNDLGdCQUFnQkMsS0FBSztJQUMxQixNQUFNQyxTQUFTLEVBQUU7SUFDakIsTUFBT0QsTUFBTztRQUNWQyxPQUFPQyxPQUFPLENBQUNGLFFBQVE7UUFDdkJBLFVBQVU7SUFDZDtJQUNBLE9BQU9DO0FBQ1g7QUFDQSxTQUFTRSxRQUFRQyxNQUFNO0lBQ25CLElBQUlDLE1BQU1DLE9BQU8sQ0FBQ0YsU0FBUztRQUN2QixJQUFJRyxVQUFVLEVBQUU7UUFDaEJILE9BQU9JLE9BQU8sQ0FBQyxTQUFVQyxLQUFLO1lBQzFCRixVQUFVQSxRQUFRRyxNQUFNLENBQUNQLFFBQVFNO1FBQ3JDO1FBQ0EsSUFBSUYsUUFBUUksTUFBTSxJQUFJLElBQUk7WUFDdEJKLFFBQVFMLE9BQU8sQ0FBQyxPQUFPSyxRQUFRSSxNQUFNO1lBQ3JDLE9BQU9KO1FBQ1g7UUFDQSxNQUFNSSxTQUFTWixnQkFBZ0JRLFFBQVFJLE1BQU07UUFDN0NBLE9BQU9ULE9BQU8sQ0FBQyxPQUFPUyxPQUFPQSxNQUFNO1FBQ25DLE9BQU9BLE9BQU9ELE1BQU0sQ0FBQ0g7SUFDekI7SUFDQSxNQUFNSyxPQUFPUCxNQUFNUSxTQUFTLENBQUNDLEtBQUssQ0FBQ0MsSUFBSSxDQUFDakIsa0RBQVFBLENBQUNNLFFBQVE7SUFDekQsSUFBSVEsS0FBS0QsTUFBTSxLQUFLLEtBQUtDLElBQUksQ0FBQyxFQUFFLElBQUksTUFBTTtRQUN0QyxPQUFPQTtJQUNYLE9BQ0ssSUFBSUEsS0FBS0QsTUFBTSxJQUFJLElBQUk7UUFDeEJDLEtBQUtWLE9BQU8sQ0FBQyxPQUFPVSxLQUFLRCxNQUFNO1FBQy9CLE9BQU9DO0lBQ1g7SUFDQSxNQUFNRCxTQUFTWixnQkFBZ0JhLEtBQUtELE1BQU07SUFDMUNBLE9BQU9ULE9BQU8sQ0FBQyxPQUFPUyxPQUFPQSxNQUFNO0lBQ25DLE9BQU9BLE9BQU9ELE1BQU0sQ0FBQ0U7QUFDekI7QUFDQSxNQUFNSSxVQUFVO0FBQ2hCOztDQUVDLEdBQ00sU0FBU0MsVUFBVWIsTUFBTTtJQUM1QixJQUFJSCxTQUFTO0lBQ2IsS0FBSyxNQUFNaUIsS0FBS2YsUUFBUUMsUUFBUztRQUM3QkgsVUFBVWUsT0FBTyxDQUFDRSxLQUFLLEVBQUU7UUFDekJqQixVQUFVZSxPQUFPLENBQUNFLElBQUksSUFBSTtJQUM5QjtJQUNBLE9BQU9qQjtBQUNYLEVBQ0Esc0NBQXNDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbWVnYXZpYmUtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vdXRpbHMvcmxwLWVuY29kZS5qcz8wNzgxIl0sInNvdXJjZXNDb250ZW50IjpbIi8vU2VlOiBodHRwczovL2dpdGh1Yi5jb20vZXRoZXJldW0vd2lraS93aWtpL1JMUFxuaW1wb3J0IHsgZ2V0Qnl0ZXMgfSBmcm9tIFwiLi9kYXRhLmpzXCI7XG5mdW5jdGlvbiBhcnJheWlmeUludGVnZXIodmFsdWUpIHtcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICB3aGlsZSAodmFsdWUpIHtcbiAgICAgICAgcmVzdWx0LnVuc2hpZnQodmFsdWUgJiAweGZmKTtcbiAgICAgICAgdmFsdWUgPj49IDg7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBfZW5jb2RlKG9iamVjdCkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KG9iamVjdCkpIHtcbiAgICAgICAgbGV0IHBheWxvYWQgPSBbXTtcbiAgICAgICAgb2JqZWN0LmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgICAgICBwYXlsb2FkID0gcGF5bG9hZC5jb25jYXQoX2VuY29kZShjaGlsZCkpO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHBheWxvYWQubGVuZ3RoIDw9IDU1KSB7XG4gICAgICAgICAgICBwYXlsb2FkLnVuc2hpZnQoMHhjMCArIHBheWxvYWQubGVuZ3RoKTtcbiAgICAgICAgICAgIHJldHVybiBwYXlsb2FkO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGxlbmd0aCA9IGFycmF5aWZ5SW50ZWdlcihwYXlsb2FkLmxlbmd0aCk7XG4gICAgICAgIGxlbmd0aC51bnNoaWZ0KDB4ZjcgKyBsZW5ndGgubGVuZ3RoKTtcbiAgICAgICAgcmV0dXJuIGxlbmd0aC5jb25jYXQocGF5bG9hZCk7XG4gICAgfVxuICAgIGNvbnN0IGRhdGEgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChnZXRCeXRlcyhvYmplY3QsIFwib2JqZWN0XCIpKTtcbiAgICBpZiAoZGF0YS5sZW5ndGggPT09IDEgJiYgZGF0YVswXSA8PSAweDdmKSB7XG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cbiAgICBlbHNlIGlmIChkYXRhLmxlbmd0aCA8PSA1NSkge1xuICAgICAgICBkYXRhLnVuc2hpZnQoMHg4MCArIGRhdGEubGVuZ3RoKTtcbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuICAgIGNvbnN0IGxlbmd0aCA9IGFycmF5aWZ5SW50ZWdlcihkYXRhLmxlbmd0aCk7XG4gICAgbGVuZ3RoLnVuc2hpZnQoMHhiNyArIGxlbmd0aC5sZW5ndGgpO1xuICAgIHJldHVybiBsZW5ndGguY29uY2F0KGRhdGEpO1xufVxuY29uc3QgbmliYmxlcyA9IFwiMDEyMzQ1Njc4OWFiY2RlZlwiO1xuLyoqXG4gKiAgRW5jb2RlcyAlJW9iamVjdCUlIGFzIGFuIFJMUC1lbmNvZGVkIFtbRGF0YUhleFN0cmluZ11dLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZW5jb2RlUmxwKG9iamVjdCkge1xuICAgIGxldCByZXN1bHQgPSBcIjB4XCI7XG4gICAgZm9yIChjb25zdCB2IG9mIF9lbmNvZGUob2JqZWN0KSkge1xuICAgICAgICByZXN1bHQgKz0gbmliYmxlc1t2ID4+IDRdO1xuICAgICAgICByZXN1bHQgKz0gbmliYmxlc1t2ICYgMHhmXTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJscC1lbmNvZGUuanMubWFwIl0sIm5hbWVzIjpbImdldEJ5dGVzIiwiYXJyYXlpZnlJbnRlZ2VyIiwidmFsdWUiLCJyZXN1bHQiLCJ1bnNoaWZ0IiwiX2VuY29kZSIsIm9iamVjdCIsIkFycmF5IiwiaXNBcnJheSIsInBheWxvYWQiLCJmb3JFYWNoIiwiY2hpbGQiLCJjb25jYXQiLCJsZW5ndGgiLCJkYXRhIiwicHJvdG90eXBlIiwic2xpY2UiLCJjYWxsIiwibmliYmxlcyIsImVuY29kZVJscCIsInYiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.esm/utils/rlp-encode.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.esm/utils/units.js":
/*!****************************************************!*\
  !*** ./node_modules/ethers/lib.esm/utils/units.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   formatEther: () => (/* binding */ formatEther),\n/* harmony export */   formatUnits: () => (/* binding */ formatUnits),\n/* harmony export */   parseEther: () => (/* binding */ parseEther),\n/* harmony export */   parseUnits: () => (/* binding */ parseUnits)\n/* harmony export */ });\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./errors.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/errors.js\");\n/* harmony import */ var _fixednumber_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./fixednumber.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/fixednumber.js\");\n/* harmony import */ var _maths_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./maths.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/maths.js\");\n/**\n *  Most interactions with Ethereum requires integer values, which use\n *  the smallest magnitude unit.\n *\n *  For example, imagine dealing with dollars and cents. Since dollars\n *  are divisible, non-integer values are possible, such as ``$10.77``.\n *  By using the smallest indivisible unit (i.e. cents), the value can\n *  be kept as the integer ``1077``.\n *\n *  When receiving decimal input from the user (as a decimal string),\n *  the value should be converted to an integer and when showing a user\n *  a value, the integer value should be converted to a decimal string.\n *\n *  This creates a clear distinction, between values to be used by code\n *  (integers) and values used for display logic to users (decimals).\n *\n *  The native unit in Ethereum, //ether// is divisible to 18 decimal places,\n *  where each individual unit is called a //wei//.\n *\n *  @_subsection api/utils:Unit Conversion  [about-units]\n */ \n\n\nconst names = [\n    \"wei\",\n    \"kwei\",\n    \"mwei\",\n    \"gwei\",\n    \"szabo\",\n    \"finney\",\n    \"ether\"\n];\n/**\n *  Converts %%value%% into a //decimal string//, assuming %%unit%% decimal\n *  places. The %%unit%% may be the number of decimal places or the name of\n *  a unit (e.g. ``\"gwei\"`` for 9 decimal places).\n *\n */ function formatUnits(value, unit) {\n    let decimals = 18;\n    if (typeof unit === \"string\") {\n        const index = names.indexOf(unit);\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(index >= 0, \"invalid unit\", \"unit\", unit);\n        decimals = 3 * index;\n    } else if (unit != null) {\n        decimals = (0,_maths_js__WEBPACK_IMPORTED_MODULE_1__.getNumber)(unit, \"unit\");\n    }\n    return _fixednumber_js__WEBPACK_IMPORTED_MODULE_2__.FixedNumber.fromValue(value, decimals, {\n        decimals,\n        width: 512\n    }).toString();\n}\n/**\n *  Converts the //decimal string// %%value%% to a BigInt, assuming\n *  %%unit%% decimal places. The %%unit%% may the number of decimal places\n *  or the name of a unit (e.g. ``\"gwei\"`` for 9 decimal places).\n */ function parseUnits(value, unit) {\n    (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(typeof value === \"string\", \"value must be a string\", \"value\", value);\n    let decimals = 18;\n    if (typeof unit === \"string\") {\n        const index = names.indexOf(unit);\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(index >= 0, \"invalid unit\", \"unit\", unit);\n        decimals = 3 * index;\n    } else if (unit != null) {\n        decimals = (0,_maths_js__WEBPACK_IMPORTED_MODULE_1__.getNumber)(unit, \"unit\");\n    }\n    return _fixednumber_js__WEBPACK_IMPORTED_MODULE_2__.FixedNumber.fromString(value, {\n        decimals,\n        width: 512\n    }).value;\n}\n/**\n *  Converts %%value%% into a //decimal string// using 18 decimal places.\n */ function formatEther(wei) {\n    return formatUnits(wei, 18);\n}\n/**\n *  Converts the //decimal string// %%ether%% to a BigInt, using 18\n *  decimal places.\n */ function parseEther(ether) {\n    return parseUnits(ether, 18);\n} //# sourceMappingURL=units.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vdXRpbHMvdW5pdHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQW9CQyxHQUM0QztBQUNFO0FBQ1I7QUFDdkMsTUFBTUcsUUFBUTtJQUNWO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0NBQ0g7QUFDRDs7Ozs7Q0FLQyxHQUNNLFNBQVNDLFlBQVlDLEtBQUssRUFBRUMsSUFBSTtJQUNuQyxJQUFJQyxXQUFXO0lBQ2YsSUFBSSxPQUFRRCxTQUFVLFVBQVU7UUFDNUIsTUFBTUUsUUFBUUwsTUFBTU0sT0FBTyxDQUFDSDtRQUM1Qk4sMERBQWNBLENBQUNRLFNBQVMsR0FBRyxnQkFBZ0IsUUFBUUY7UUFDbkRDLFdBQVcsSUFBSUM7SUFDbkIsT0FDSyxJQUFJRixRQUFRLE1BQU07UUFDbkJDLFdBQVdMLG9EQUFTQSxDQUFDSSxNQUFNO0lBQy9CO0lBQ0EsT0FBT0wsd0RBQVdBLENBQUNTLFNBQVMsQ0FBQ0wsT0FBT0UsVUFBVTtRQUFFQTtRQUFVSSxPQUFPO0lBQUksR0FBR0MsUUFBUTtBQUNwRjtBQUNBOzs7O0NBSUMsR0FDTSxTQUFTQyxXQUFXUixLQUFLLEVBQUVDLElBQUk7SUFDbENOLDBEQUFjQSxDQUFDLE9BQVFLLFVBQVcsVUFBVSwwQkFBMEIsU0FBU0E7SUFDL0UsSUFBSUUsV0FBVztJQUNmLElBQUksT0FBUUQsU0FBVSxVQUFVO1FBQzVCLE1BQU1FLFFBQVFMLE1BQU1NLE9BQU8sQ0FBQ0g7UUFDNUJOLDBEQUFjQSxDQUFDUSxTQUFTLEdBQUcsZ0JBQWdCLFFBQVFGO1FBQ25EQyxXQUFXLElBQUlDO0lBQ25CLE9BQ0ssSUFBSUYsUUFBUSxNQUFNO1FBQ25CQyxXQUFXTCxvREFBU0EsQ0FBQ0ksTUFBTTtJQUMvQjtJQUNBLE9BQU9MLHdEQUFXQSxDQUFDYSxVQUFVLENBQUNULE9BQU87UUFBRUU7UUFBVUksT0FBTztJQUFJLEdBQUdOLEtBQUs7QUFDeEU7QUFDQTs7Q0FFQyxHQUNNLFNBQVNVLFlBQVlDLEdBQUc7SUFDM0IsT0FBT1osWUFBWVksS0FBSztBQUM1QjtBQUNBOzs7Q0FHQyxHQUNNLFNBQVNDLFdBQVdDLEtBQUs7SUFDNUIsT0FBT0wsV0FBV0ssT0FBTztBQUM3QixFQUNBLGlDQUFpQyIsInNvdXJjZXMiOlsid2VicGFjazovL21lZ2F2aWJlLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL3V0aWxzL3VuaXRzLmpzPzY4YWEiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiAgTW9zdCBpbnRlcmFjdGlvbnMgd2l0aCBFdGhlcmV1bSByZXF1aXJlcyBpbnRlZ2VyIHZhbHVlcywgd2hpY2ggdXNlXG4gKiAgdGhlIHNtYWxsZXN0IG1hZ25pdHVkZSB1bml0LlxuICpcbiAqICBGb3IgZXhhbXBsZSwgaW1hZ2luZSBkZWFsaW5nIHdpdGggZG9sbGFycyBhbmQgY2VudHMuIFNpbmNlIGRvbGxhcnNcbiAqICBhcmUgZGl2aXNpYmxlLCBub24taW50ZWdlciB2YWx1ZXMgYXJlIHBvc3NpYmxlLCBzdWNoIGFzIGBgJDEwLjc3YGAuXG4gKiAgQnkgdXNpbmcgdGhlIHNtYWxsZXN0IGluZGl2aXNpYmxlIHVuaXQgKGkuZS4gY2VudHMpLCB0aGUgdmFsdWUgY2FuXG4gKiAgYmUga2VwdCBhcyB0aGUgaW50ZWdlciBgYDEwNzdgYC5cbiAqXG4gKiAgV2hlbiByZWNlaXZpbmcgZGVjaW1hbCBpbnB1dCBmcm9tIHRoZSB1c2VyIChhcyBhIGRlY2ltYWwgc3RyaW5nKSxcbiAqICB0aGUgdmFsdWUgc2hvdWxkIGJlIGNvbnZlcnRlZCB0byBhbiBpbnRlZ2VyIGFuZCB3aGVuIHNob3dpbmcgYSB1c2VyXG4gKiAgYSB2YWx1ZSwgdGhlIGludGVnZXIgdmFsdWUgc2hvdWxkIGJlIGNvbnZlcnRlZCB0byBhIGRlY2ltYWwgc3RyaW5nLlxuICpcbiAqICBUaGlzIGNyZWF0ZXMgYSBjbGVhciBkaXN0aW5jdGlvbiwgYmV0d2VlbiB2YWx1ZXMgdG8gYmUgdXNlZCBieSBjb2RlXG4gKiAgKGludGVnZXJzKSBhbmQgdmFsdWVzIHVzZWQgZm9yIGRpc3BsYXkgbG9naWMgdG8gdXNlcnMgKGRlY2ltYWxzKS5cbiAqXG4gKiAgVGhlIG5hdGl2ZSB1bml0IGluIEV0aGVyZXVtLCAvL2V0aGVyLy8gaXMgZGl2aXNpYmxlIHRvIDE4IGRlY2ltYWwgcGxhY2VzLFxuICogIHdoZXJlIGVhY2ggaW5kaXZpZHVhbCB1bml0IGlzIGNhbGxlZCBhIC8vd2VpLy8uXG4gKlxuICogIEBfc3Vic2VjdGlvbiBhcGkvdXRpbHM6VW5pdCBDb252ZXJzaW9uICBbYWJvdXQtdW5pdHNdXG4gKi9cbmltcG9ydCB7IGFzc2VydEFyZ3VtZW50IH0gZnJvbSBcIi4vZXJyb3JzLmpzXCI7XG5pbXBvcnQgeyBGaXhlZE51bWJlciB9IGZyb20gXCIuL2ZpeGVkbnVtYmVyLmpzXCI7XG5pbXBvcnQgeyBnZXROdW1iZXIgfSBmcm9tIFwiLi9tYXRocy5qc1wiO1xuY29uc3QgbmFtZXMgPSBbXG4gICAgXCJ3ZWlcIixcbiAgICBcImt3ZWlcIixcbiAgICBcIm13ZWlcIixcbiAgICBcImd3ZWlcIixcbiAgICBcInN6YWJvXCIsXG4gICAgXCJmaW5uZXlcIixcbiAgICBcImV0aGVyXCIsXG5dO1xuLyoqXG4gKiAgQ29udmVydHMgJSV2YWx1ZSUlIGludG8gYSAvL2RlY2ltYWwgc3RyaW5nLy8sIGFzc3VtaW5nICUldW5pdCUlIGRlY2ltYWxcbiAqICBwbGFjZXMuIFRoZSAlJXVuaXQlJSBtYXkgYmUgdGhlIG51bWJlciBvZiBkZWNpbWFsIHBsYWNlcyBvciB0aGUgbmFtZSBvZlxuICogIGEgdW5pdCAoZS5nLiBgYFwiZ3dlaVwiYGAgZm9yIDkgZGVjaW1hbCBwbGFjZXMpLlxuICpcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZvcm1hdFVuaXRzKHZhbHVlLCB1bml0KSB7XG4gICAgbGV0IGRlY2ltYWxzID0gMTg7XG4gICAgaWYgKHR5cGVvZiAodW5pdCkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgY29uc3QgaW5kZXggPSBuYW1lcy5pbmRleE9mKHVuaXQpO1xuICAgICAgICBhc3NlcnRBcmd1bWVudChpbmRleCA+PSAwLCBcImludmFsaWQgdW5pdFwiLCBcInVuaXRcIiwgdW5pdCk7XG4gICAgICAgIGRlY2ltYWxzID0gMyAqIGluZGV4O1xuICAgIH1cbiAgICBlbHNlIGlmICh1bml0ICE9IG51bGwpIHtcbiAgICAgICAgZGVjaW1hbHMgPSBnZXROdW1iZXIodW5pdCwgXCJ1bml0XCIpO1xuICAgIH1cbiAgICByZXR1cm4gRml4ZWROdW1iZXIuZnJvbVZhbHVlKHZhbHVlLCBkZWNpbWFscywgeyBkZWNpbWFscywgd2lkdGg6IDUxMiB9KS50b1N0cmluZygpO1xufVxuLyoqXG4gKiAgQ29udmVydHMgdGhlIC8vZGVjaW1hbCBzdHJpbmcvLyAlJXZhbHVlJSUgdG8gYSBCaWdJbnQsIGFzc3VtaW5nXG4gKiAgJSV1bml0JSUgZGVjaW1hbCBwbGFjZXMuIFRoZSAlJXVuaXQlJSBtYXkgdGhlIG51bWJlciBvZiBkZWNpbWFsIHBsYWNlc1xuICogIG9yIHRoZSBuYW1lIG9mIGEgdW5pdCAoZS5nLiBgYFwiZ3dlaVwiYGAgZm9yIDkgZGVjaW1hbCBwbGFjZXMpLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VVbml0cyh2YWx1ZSwgdW5pdCkge1xuICAgIGFzc2VydEFyZ3VtZW50KHR5cGVvZiAodmFsdWUpID09PSBcInN0cmluZ1wiLCBcInZhbHVlIG11c3QgYmUgYSBzdHJpbmdcIiwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG4gICAgbGV0IGRlY2ltYWxzID0gMTg7XG4gICAgaWYgKHR5cGVvZiAodW5pdCkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgY29uc3QgaW5kZXggPSBuYW1lcy5pbmRleE9mKHVuaXQpO1xuICAgICAgICBhc3NlcnRBcmd1bWVudChpbmRleCA+PSAwLCBcImludmFsaWQgdW5pdFwiLCBcInVuaXRcIiwgdW5pdCk7XG4gICAgICAgIGRlY2ltYWxzID0gMyAqIGluZGV4O1xuICAgIH1cbiAgICBlbHNlIGlmICh1bml0ICE9IG51bGwpIHtcbiAgICAgICAgZGVjaW1hbHMgPSBnZXROdW1iZXIodW5pdCwgXCJ1bml0XCIpO1xuICAgIH1cbiAgICByZXR1cm4gRml4ZWROdW1iZXIuZnJvbVN0cmluZyh2YWx1ZSwgeyBkZWNpbWFscywgd2lkdGg6IDUxMiB9KS52YWx1ZTtcbn1cbi8qKlxuICogIENvbnZlcnRzICUldmFsdWUlJSBpbnRvIGEgLy9kZWNpbWFsIHN0cmluZy8vIHVzaW5nIDE4IGRlY2ltYWwgcGxhY2VzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZm9ybWF0RXRoZXIod2VpKSB7XG4gICAgcmV0dXJuIGZvcm1hdFVuaXRzKHdlaSwgMTgpO1xufVxuLyoqXG4gKiAgQ29udmVydHMgdGhlIC8vZGVjaW1hbCBzdHJpbmcvLyAlJWV0aGVyJSUgdG8gYSBCaWdJbnQsIHVzaW5nIDE4XG4gKiAgZGVjaW1hbCBwbGFjZXMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZUV0aGVyKGV0aGVyKSB7XG4gICAgcmV0dXJuIHBhcnNlVW5pdHMoZXRoZXIsIDE4KTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXVuaXRzLmpzLm1hcCJdLCJuYW1lcyI6WyJhc3NlcnRBcmd1bWVudCIsIkZpeGVkTnVtYmVyIiwiZ2V0TnVtYmVyIiwibmFtZXMiLCJmb3JtYXRVbml0cyIsInZhbHVlIiwidW5pdCIsImRlY2ltYWxzIiwiaW5kZXgiLCJpbmRleE9mIiwiZnJvbVZhbHVlIiwid2lkdGgiLCJ0b1N0cmluZyIsInBhcnNlVW5pdHMiLCJmcm9tU3RyaW5nIiwiZm9ybWF0RXRoZXIiLCJ3ZWkiLCJwYXJzZUV0aGVyIiwiZXRoZXIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.esm/utils/units.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.esm/utils/utf8.js":
/*!***************************************************!*\
  !*** ./node_modules/ethers/lib.esm/utils/utf8.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Utf8ErrorFuncs: () => (/* binding */ Utf8ErrorFuncs),\n/* harmony export */   toUtf8Bytes: () => (/* binding */ toUtf8Bytes),\n/* harmony export */   toUtf8CodePoints: () => (/* binding */ toUtf8CodePoints),\n/* harmony export */   toUtf8String: () => (/* binding */ toUtf8String)\n/* harmony export */ });\n/* harmony import */ var _data_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./data.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/data.js\");\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./errors.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/errors.js\");\n/**\n *  Using strings in Ethereum (or any security-basd system) requires\n *  additional care. These utilities attempt to mitigate some of the\n *  safety issues as well as provide the ability to recover and analyse\n *  strings.\n *\n *  @_subsection api/utils:Strings and UTF-8  [about-strings]\n */ \n\nfunction errorFunc(reason, offset, bytes, output, badCodepoint) {\n    (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(false, `invalid codepoint at offset ${offset}; ${reason}`, \"bytes\", bytes);\n}\nfunction ignoreFunc(reason, offset, bytes, output, badCodepoint) {\n    // If there is an invalid prefix (including stray continuation), skip any additional continuation bytes\n    if (reason === \"BAD_PREFIX\" || reason === \"UNEXPECTED_CONTINUE\") {\n        let i = 0;\n        for(let o = offset + 1; o < bytes.length; o++){\n            if (bytes[o] >> 6 !== 0x02) {\n                break;\n            }\n            i++;\n        }\n        return i;\n    }\n    // This byte runs us past the end of the string, so just jump to the end\n    // (but the first byte was read already read and therefore skipped)\n    if (reason === \"OVERRUN\") {\n        return bytes.length - offset - 1;\n    }\n    // Nothing to skip\n    return 0;\n}\nfunction replaceFunc(reason, offset, bytes, output, badCodepoint) {\n    // Overlong representations are otherwise \"valid\" code points; just non-deistingtished\n    if (reason === \"OVERLONG\") {\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(typeof badCodepoint === \"number\", \"invalid bad code point for replacement\", \"badCodepoint\", badCodepoint);\n        output.push(badCodepoint);\n        return 0;\n    }\n    // Put the replacement character into the output\n    output.push(0xfffd);\n    // Otherwise, process as if ignoring errors\n    return ignoreFunc(reason, offset, bytes, output, badCodepoint);\n}\n/**\n *  A handful of popular, built-in UTF-8 error handling strategies.\n *\n *  **``\"error\"``** - throws on ANY illegal UTF-8 sequence or\n *  non-canonical (overlong) codepoints (this is the default)\n *\n *  **``\"ignore\"``** - silently drops any illegal UTF-8 sequence\n *  and accepts non-canonical (overlong) codepoints\n *\n *  **``\"replace\"``** - replace any illegal UTF-8 sequence with the\n *  UTF-8 replacement character (i.e. ``\"\\\\ufffd\"``) and accepts\n *  non-canonical (overlong) codepoints\n *\n *  @returns: Record<\"error\" | \"ignore\" | \"replace\", Utf8ErrorFunc>\n */ const Utf8ErrorFuncs = Object.freeze({\n    error: errorFunc,\n    ignore: ignoreFunc,\n    replace: replaceFunc\n});\n// http://stackoverflow.com/questions/13356493/decode-utf-8-with-javascript#13691499\nfunction getUtf8CodePoints(_bytes, onError) {\n    if (onError == null) {\n        onError = Utf8ErrorFuncs.error;\n    }\n    const bytes = (0,_data_js__WEBPACK_IMPORTED_MODULE_1__.getBytes)(_bytes, \"bytes\");\n    const result = [];\n    let i = 0;\n    // Invalid bytes are ignored\n    while(i < bytes.length){\n        const c = bytes[i++];\n        // 0xxx xxxx\n        if (c >> 7 === 0) {\n            result.push(c);\n            continue;\n        }\n        // Multibyte; how many bytes left for this character?\n        let extraLength = null;\n        let overlongMask = null;\n        // 110x xxxx 10xx xxxx\n        if ((c & 0xe0) === 0xc0) {\n            extraLength = 1;\n            overlongMask = 0x7f;\n        // 1110 xxxx 10xx xxxx 10xx xxxx\n        } else if ((c & 0xf0) === 0xe0) {\n            extraLength = 2;\n            overlongMask = 0x7ff;\n        // 1111 0xxx 10xx xxxx 10xx xxxx 10xx xxxx\n        } else if ((c & 0xf8) === 0xf0) {\n            extraLength = 3;\n            overlongMask = 0xffff;\n        } else {\n            if ((c & 0xc0) === 0x80) {\n                i += onError(\"UNEXPECTED_CONTINUE\", i - 1, bytes, result);\n            } else {\n                i += onError(\"BAD_PREFIX\", i - 1, bytes, result);\n            }\n            continue;\n        }\n        // Do we have enough bytes in our data?\n        if (i - 1 + extraLength >= bytes.length) {\n            i += onError(\"OVERRUN\", i - 1, bytes, result);\n            continue;\n        }\n        // Remove the length prefix from the char\n        let res = c & (1 << 8 - extraLength - 1) - 1;\n        for(let j = 0; j < extraLength; j++){\n            let nextChar = bytes[i];\n            // Invalid continuation byte\n            if ((nextChar & 0xc0) != 0x80) {\n                i += onError(\"MISSING_CONTINUE\", i, bytes, result);\n                res = null;\n                break;\n            }\n            ;\n            res = res << 6 | nextChar & 0x3f;\n            i++;\n        }\n        // See above loop for invalid continuation byte\n        if (res === null) {\n            continue;\n        }\n        // Maximum code point\n        if (res > 0x10ffff) {\n            i += onError(\"OUT_OF_RANGE\", i - 1 - extraLength, bytes, result, res);\n            continue;\n        }\n        // Reserved for UTF-16 surrogate halves\n        if (res >= 0xd800 && res <= 0xdfff) {\n            i += onError(\"UTF16_SURROGATE\", i - 1 - extraLength, bytes, result, res);\n            continue;\n        }\n        // Check for overlong sequences (more bytes than needed)\n        if (res <= overlongMask) {\n            i += onError(\"OVERLONG\", i - 1 - extraLength, bytes, result, res);\n            continue;\n        }\n        result.push(res);\n    }\n    return result;\n}\n// http://stackoverflow.com/questions/18729405/how-to-convert-utf8-string-to-byte-array\n/**\n *  Returns the UTF-8 byte representation of %%str%%.\n *\n *  If %%form%% is specified, the string is normalized.\n */ function toUtf8Bytes(str, form) {\n    (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(typeof str === \"string\", \"invalid string value\", \"str\", str);\n    if (form != null) {\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertNormalize)(form);\n        str = str.normalize(form);\n    }\n    let result = [];\n    for(let i = 0; i < str.length; i++){\n        const c = str.charCodeAt(i);\n        if (c < 0x80) {\n            result.push(c);\n        } else if (c < 0x800) {\n            result.push(c >> 6 | 0xc0);\n            result.push(c & 0x3f | 0x80);\n        } else if ((c & 0xfc00) == 0xd800) {\n            i++;\n            const c2 = str.charCodeAt(i);\n            (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(i < str.length && (c2 & 0xfc00) === 0xdc00, \"invalid surrogate pair\", \"str\", str);\n            // Surrogate Pair\n            const pair = 0x10000 + ((c & 0x03ff) << 10) + (c2 & 0x03ff);\n            result.push(pair >> 18 | 0xf0);\n            result.push(pair >> 12 & 0x3f | 0x80);\n            result.push(pair >> 6 & 0x3f | 0x80);\n            result.push(pair & 0x3f | 0x80);\n        } else {\n            result.push(c >> 12 | 0xe0);\n            result.push(c >> 6 & 0x3f | 0x80);\n            result.push(c & 0x3f | 0x80);\n        }\n    }\n    return new Uint8Array(result);\n}\n;\n//export \nfunction _toUtf8String(codePoints) {\n    return codePoints.map((codePoint)=>{\n        if (codePoint <= 0xffff) {\n            return String.fromCharCode(codePoint);\n        }\n        codePoint -= 0x10000;\n        return String.fromCharCode((codePoint >> 10 & 0x3ff) + 0xd800, (codePoint & 0x3ff) + 0xdc00);\n    }).join(\"\");\n}\n/**\n *  Returns the string represented by the UTF-8 data %%bytes%%.\n *\n *  When %%onError%% function is specified, it is called on UTF-8\n *  errors allowing recovery using the [[Utf8ErrorFunc]] API.\n *  (default: [error](Utf8ErrorFuncs))\n */ function toUtf8String(bytes, onError) {\n    return _toUtf8String(getUtf8CodePoints(bytes, onError));\n}\n/**\n *  Returns the UTF-8 code-points for %%str%%.\n *\n *  If %%form%% is specified, the string is normalized.\n */ function toUtf8CodePoints(str, form) {\n    return getUtf8CodePoints(toUtf8Bytes(str, form));\n} //# sourceMappingURL=utf8.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vdXRpbHMvdXRmOC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBQTs7Ozs7OztDQU9DLEdBQ29DO0FBQ3lCO0FBQzlELFNBQVNHLFVBQVVDLE1BQU0sRUFBRUMsTUFBTSxFQUFFQyxLQUFLLEVBQUVDLE1BQU0sRUFBRUMsWUFBWTtJQUMxRFAsMERBQWNBLENBQUMsT0FBTyxDQUFDLDRCQUE0QixFQUFFSSxPQUFPLEVBQUUsRUFBRUQsT0FBTyxDQUFDLEVBQUUsU0FBU0U7QUFDdkY7QUFDQSxTQUFTRyxXQUFXTCxNQUFNLEVBQUVDLE1BQU0sRUFBRUMsS0FBSyxFQUFFQyxNQUFNLEVBQUVDLFlBQVk7SUFDM0QsdUdBQXVHO0lBQ3ZHLElBQUlKLFdBQVcsZ0JBQWdCQSxXQUFXLHVCQUF1QjtRQUM3RCxJQUFJTSxJQUFJO1FBQ1IsSUFBSyxJQUFJQyxJQUFJTixTQUFTLEdBQUdNLElBQUlMLE1BQU1NLE1BQU0sRUFBRUQsSUFBSztZQUM1QyxJQUFJTCxLQUFLLENBQUNLLEVBQUUsSUFBSSxNQUFNLE1BQU07Z0JBQ3hCO1lBQ0o7WUFDQUQ7UUFDSjtRQUNBLE9BQU9BO0lBQ1g7SUFDQSx3RUFBd0U7SUFDeEUsbUVBQW1FO0lBQ25FLElBQUlOLFdBQVcsV0FBVztRQUN0QixPQUFPRSxNQUFNTSxNQUFNLEdBQUdQLFNBQVM7SUFDbkM7SUFDQSxrQkFBa0I7SUFDbEIsT0FBTztBQUNYO0FBQ0EsU0FBU1EsWUFBWVQsTUFBTSxFQUFFQyxNQUFNLEVBQUVDLEtBQUssRUFBRUMsTUFBTSxFQUFFQyxZQUFZO0lBQzVELHNGQUFzRjtJQUN0RixJQUFJSixXQUFXLFlBQVk7UUFDdkJILDBEQUFjQSxDQUFDLE9BQVFPLGlCQUFrQixVQUFVLDBDQUEwQyxnQkFBZ0JBO1FBQzdHRCxPQUFPTyxJQUFJLENBQUNOO1FBQ1osT0FBTztJQUNYO0lBQ0EsZ0RBQWdEO0lBQ2hERCxPQUFPTyxJQUFJLENBQUM7SUFDWiwyQ0FBMkM7SUFDM0MsT0FBT0wsV0FBV0wsUUFBUUMsUUFBUUMsT0FBT0MsUUFBUUM7QUFDckQ7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Q0FjQyxHQUNNLE1BQU1PLGlCQUFpQkMsT0FBT0MsTUFBTSxDQUFDO0lBQ3hDQyxPQUFPZjtJQUNQZ0IsUUFBUVY7SUFDUlcsU0FBU1A7QUFDYixHQUFHO0FBQ0gsb0ZBQW9GO0FBQ3BGLFNBQVNRLGtCQUFrQkMsTUFBTSxFQUFFQyxPQUFPO0lBQ3RDLElBQUlBLFdBQVcsTUFBTTtRQUNqQkEsVUFBVVIsZUFBZUcsS0FBSztJQUNsQztJQUNBLE1BQU1aLFFBQVFOLGtEQUFRQSxDQUFDc0IsUUFBUTtJQUMvQixNQUFNRSxTQUFTLEVBQUU7SUFDakIsSUFBSWQsSUFBSTtJQUNSLDRCQUE0QjtJQUM1QixNQUFPQSxJQUFJSixNQUFNTSxNQUFNLENBQUU7UUFDckIsTUFBTWEsSUFBSW5CLEtBQUssQ0FBQ0ksSUFBSTtRQUNwQixZQUFZO1FBQ1osSUFBSWUsS0FBSyxNQUFNLEdBQUc7WUFDZEQsT0FBT1YsSUFBSSxDQUFDVztZQUNaO1FBQ0o7UUFDQSxxREFBcUQ7UUFDckQsSUFBSUMsY0FBYztRQUNsQixJQUFJQyxlQUFlO1FBQ25CLHNCQUFzQjtRQUN0QixJQUFJLENBQUNGLElBQUksSUFBRyxNQUFPLE1BQU07WUFDckJDLGNBQWM7WUFDZEMsZUFBZTtRQUNmLGdDQUFnQztRQUNwQyxPQUNLLElBQUksQ0FBQ0YsSUFBSSxJQUFHLE1BQU8sTUFBTTtZQUMxQkMsY0FBYztZQUNkQyxlQUFlO1FBQ2YsMENBQTBDO1FBQzlDLE9BQ0ssSUFBSSxDQUFDRixJQUFJLElBQUcsTUFBTyxNQUFNO1lBQzFCQyxjQUFjO1lBQ2RDLGVBQWU7UUFDbkIsT0FDSztZQUNELElBQUksQ0FBQ0YsSUFBSSxJQUFHLE1BQU8sTUFBTTtnQkFDckJmLEtBQUthLFFBQVEsdUJBQXVCYixJQUFJLEdBQUdKLE9BQU9rQjtZQUN0RCxPQUNLO2dCQUNEZCxLQUFLYSxRQUFRLGNBQWNiLElBQUksR0FBR0osT0FBT2tCO1lBQzdDO1lBQ0E7UUFDSjtRQUNBLHVDQUF1QztRQUN2QyxJQUFJZCxJQUFJLElBQUlnQixlQUFlcEIsTUFBTU0sTUFBTSxFQUFFO1lBQ3JDRixLQUFLYSxRQUFRLFdBQVdiLElBQUksR0FBR0osT0FBT2tCO1lBQ3RDO1FBQ0o7UUFDQSx5Q0FBeUM7UUFDekMsSUFBSUksTUFBTUgsSUFBSyxDQUFDLEtBQU0sSUFBSUMsY0FBYyxDQUFDLElBQUs7UUFDOUMsSUFBSyxJQUFJRyxJQUFJLEdBQUdBLElBQUlILGFBQWFHLElBQUs7WUFDbEMsSUFBSUMsV0FBV3hCLEtBQUssQ0FBQ0ksRUFBRTtZQUN2Qiw0QkFBNEI7WUFDNUIsSUFBSSxDQUFDb0IsV0FBVyxJQUFHLEtBQU0sTUFBTTtnQkFDM0JwQixLQUFLYSxRQUFRLG9CQUFvQmIsR0FBR0osT0FBT2tCO2dCQUMzQ0ksTUFBTTtnQkFDTjtZQUNKOztZQUVBQSxNQUFNLE9BQVEsSUFBTUUsV0FBVztZQUMvQnBCO1FBQ0o7UUFDQSwrQ0FBK0M7UUFDL0MsSUFBSWtCLFFBQVEsTUFBTTtZQUNkO1FBQ0o7UUFDQSxxQkFBcUI7UUFDckIsSUFBSUEsTUFBTSxVQUFVO1lBQ2hCbEIsS0FBS2EsUUFBUSxnQkFBZ0JiLElBQUksSUFBSWdCLGFBQWFwQixPQUFPa0IsUUFBUUk7WUFDakU7UUFDSjtRQUNBLHVDQUF1QztRQUN2QyxJQUFJQSxPQUFPLFVBQVVBLE9BQU8sUUFBUTtZQUNoQ2xCLEtBQUthLFFBQVEsbUJBQW1CYixJQUFJLElBQUlnQixhQUFhcEIsT0FBT2tCLFFBQVFJO1lBQ3BFO1FBQ0o7UUFDQSx3REFBd0Q7UUFDeEQsSUFBSUEsT0FBT0QsY0FBYztZQUNyQmpCLEtBQUthLFFBQVEsWUFBWWIsSUFBSSxJQUFJZ0IsYUFBYXBCLE9BQU9rQixRQUFRSTtZQUM3RDtRQUNKO1FBQ0FKLE9BQU9WLElBQUksQ0FBQ2M7SUFDaEI7SUFDQSxPQUFPSjtBQUNYO0FBQ0EsdUZBQXVGO0FBQ3ZGOzs7O0NBSUMsR0FDTSxTQUFTTyxZQUFZQyxHQUFHLEVBQUVDLElBQUk7SUFDakNoQywwREFBY0EsQ0FBQyxPQUFRK0IsUUFBUyxVQUFVLHdCQUF3QixPQUFPQTtJQUN6RSxJQUFJQyxRQUFRLE1BQU07UUFDZC9CLDJEQUFlQSxDQUFDK0I7UUFDaEJELE1BQU1BLElBQUlFLFNBQVMsQ0FBQ0Q7SUFDeEI7SUFDQSxJQUFJVCxTQUFTLEVBQUU7SUFDZixJQUFLLElBQUlkLElBQUksR0FBR0EsSUFBSXNCLElBQUlwQixNQUFNLEVBQUVGLElBQUs7UUFDakMsTUFBTWUsSUFBSU8sSUFBSUcsVUFBVSxDQUFDekI7UUFDekIsSUFBSWUsSUFBSSxNQUFNO1lBQ1ZELE9BQU9WLElBQUksQ0FBQ1c7UUFDaEIsT0FDSyxJQUFJQSxJQUFJLE9BQU87WUFDaEJELE9BQU9WLElBQUksQ0FBQyxLQUFNLElBQUs7WUFDdkJVLE9BQU9WLElBQUksQ0FBQyxJQUFLLE9BQVE7UUFDN0IsT0FDSyxJQUFJLENBQUNXLElBQUksTUFBSyxLQUFNLFFBQVE7WUFDN0JmO1lBQ0EsTUFBTTBCLEtBQUtKLElBQUlHLFVBQVUsQ0FBQ3pCO1lBQzFCVCwwREFBY0EsQ0FBQ1MsSUFBSXNCLElBQUlwQixNQUFNLElBQUssQ0FBQ3dCLEtBQUssTUFBSyxNQUFPLFFBQVMsMEJBQTBCLE9BQU9KO1lBQzlGLGlCQUFpQjtZQUNqQixNQUFNSyxPQUFPLFVBQVcsRUFBQ1osSUFBSSxNQUFLLEtBQU0sRUFBQyxJQUFNVyxDQUFBQSxLQUFLLE1BQUs7WUFDekRaLE9BQU9WLElBQUksQ0FBQyxRQUFTLEtBQU07WUFDM0JVLE9BQU9WLElBQUksQ0FBQyxRQUFVLEtBQU0sT0FBUTtZQUNwQ1UsT0FBT1YsSUFBSSxDQUFDLFFBQVUsSUFBSyxPQUFRO1lBQ25DVSxPQUFPVixJQUFJLENBQUMsT0FBUSxPQUFRO1FBQ2hDLE9BQ0s7WUFDRFUsT0FBT1YsSUFBSSxDQUFDLEtBQU0sS0FBTTtZQUN4QlUsT0FBT1YsSUFBSSxDQUFDLEtBQU8sSUFBSyxPQUFRO1lBQ2hDVSxPQUFPVixJQUFJLENBQUMsSUFBSyxPQUFRO1FBQzdCO0lBQ0o7SUFDQSxPQUFPLElBQUl3QixXQUFXZDtBQUMxQjs7QUFFQSxTQUFTO0FBQ1QsU0FBU2UsY0FBY0MsVUFBVTtJQUM3QixPQUFPQSxXQUFXQyxHQUFHLENBQUMsQ0FBQ0M7UUFDbkIsSUFBSUEsYUFBYSxRQUFRO1lBQ3JCLE9BQU9DLE9BQU9DLFlBQVksQ0FBQ0Y7UUFDL0I7UUFDQUEsYUFBYTtRQUNiLE9BQU9DLE9BQU9DLFlBQVksQ0FBRSxDQUFDLGFBQWMsS0FBTSxLQUFJLElBQUssUUFBVSxDQUFDRixZQUFZLEtBQUksSUFBSztJQUM5RixHQUFHRyxJQUFJLENBQUM7QUFDWjtBQUNBOzs7Ozs7Q0FNQyxHQUNNLFNBQVNDLGFBQWF4QyxLQUFLLEVBQUVpQixPQUFPO0lBQ3ZDLE9BQU9nQixjQUFjbEIsa0JBQWtCZixPQUFPaUI7QUFDbEQ7QUFDQTs7OztDQUlDLEdBQ00sU0FBU3dCLGlCQUFpQmYsR0FBRyxFQUFFQyxJQUFJO0lBQ3RDLE9BQU9aLGtCQUFrQlUsWUFBWUMsS0FBS0M7QUFDOUMsRUFDQSxnQ0FBZ0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tZWdhdmliZS1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS91dGlscy91dGY4LmpzPzMyYmMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiAgVXNpbmcgc3RyaW5ncyBpbiBFdGhlcmV1bSAob3IgYW55IHNlY3VyaXR5LWJhc2Qgc3lzdGVtKSByZXF1aXJlc1xuICogIGFkZGl0aW9uYWwgY2FyZS4gVGhlc2UgdXRpbGl0aWVzIGF0dGVtcHQgdG8gbWl0aWdhdGUgc29tZSBvZiB0aGVcbiAqICBzYWZldHkgaXNzdWVzIGFzIHdlbGwgYXMgcHJvdmlkZSB0aGUgYWJpbGl0eSB0byByZWNvdmVyIGFuZCBhbmFseXNlXG4gKiAgc3RyaW5ncy5cbiAqXG4gKiAgQF9zdWJzZWN0aW9uIGFwaS91dGlsczpTdHJpbmdzIGFuZCBVVEYtOCAgW2Fib3V0LXN0cmluZ3NdXG4gKi9cbmltcG9ydCB7IGdldEJ5dGVzIH0gZnJvbSBcIi4vZGF0YS5qc1wiO1xuaW1wb3J0IHsgYXNzZXJ0QXJndW1lbnQsIGFzc2VydE5vcm1hbGl6ZSB9IGZyb20gXCIuL2Vycm9ycy5qc1wiO1xuZnVuY3Rpb24gZXJyb3JGdW5jKHJlYXNvbiwgb2Zmc2V0LCBieXRlcywgb3V0cHV0LCBiYWRDb2RlcG9pbnQpIHtcbiAgICBhc3NlcnRBcmd1bWVudChmYWxzZSwgYGludmFsaWQgY29kZXBvaW50IGF0IG9mZnNldCAke29mZnNldH07ICR7cmVhc29ufWAsIFwiYnl0ZXNcIiwgYnl0ZXMpO1xufVxuZnVuY3Rpb24gaWdub3JlRnVuYyhyZWFzb24sIG9mZnNldCwgYnl0ZXMsIG91dHB1dCwgYmFkQ29kZXBvaW50KSB7XG4gICAgLy8gSWYgdGhlcmUgaXMgYW4gaW52YWxpZCBwcmVmaXggKGluY2x1ZGluZyBzdHJheSBjb250aW51YXRpb24pLCBza2lwIGFueSBhZGRpdGlvbmFsIGNvbnRpbnVhdGlvbiBieXRlc1xuICAgIGlmIChyZWFzb24gPT09IFwiQkFEX1BSRUZJWFwiIHx8IHJlYXNvbiA9PT0gXCJVTkVYUEVDVEVEX0NPTlRJTlVFXCIpIHtcbiAgICAgICAgbGV0IGkgPSAwO1xuICAgICAgICBmb3IgKGxldCBvID0gb2Zmc2V0ICsgMTsgbyA8IGJ5dGVzLmxlbmd0aDsgbysrKSB7XG4gICAgICAgICAgICBpZiAoYnl0ZXNbb10gPj4gNiAhPT0gMHgwMikge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaSsrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpO1xuICAgIH1cbiAgICAvLyBUaGlzIGJ5dGUgcnVucyB1cyBwYXN0IHRoZSBlbmQgb2YgdGhlIHN0cmluZywgc28ganVzdCBqdW1wIHRvIHRoZSBlbmRcbiAgICAvLyAoYnV0IHRoZSBmaXJzdCBieXRlIHdhcyByZWFkIGFscmVhZHkgcmVhZCBhbmQgdGhlcmVmb3JlIHNraXBwZWQpXG4gICAgaWYgKHJlYXNvbiA9PT0gXCJPVkVSUlVOXCIpIHtcbiAgICAgICAgcmV0dXJuIGJ5dGVzLmxlbmd0aCAtIG9mZnNldCAtIDE7XG4gICAgfVxuICAgIC8vIE5vdGhpbmcgdG8gc2tpcFxuICAgIHJldHVybiAwO1xufVxuZnVuY3Rpb24gcmVwbGFjZUZ1bmMocmVhc29uLCBvZmZzZXQsIGJ5dGVzLCBvdXRwdXQsIGJhZENvZGVwb2ludCkge1xuICAgIC8vIE92ZXJsb25nIHJlcHJlc2VudGF0aW9ucyBhcmUgb3RoZXJ3aXNlIFwidmFsaWRcIiBjb2RlIHBvaW50czsganVzdCBub24tZGVpc3Rpbmd0aXNoZWRcbiAgICBpZiAocmVhc29uID09PSBcIk9WRVJMT05HXCIpIHtcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQodHlwZW9mIChiYWRDb2RlcG9pbnQpID09PSBcIm51bWJlclwiLCBcImludmFsaWQgYmFkIGNvZGUgcG9pbnQgZm9yIHJlcGxhY2VtZW50XCIsIFwiYmFkQ29kZXBvaW50XCIsIGJhZENvZGVwb2ludCk7XG4gICAgICAgIG91dHB1dC5wdXNoKGJhZENvZGVwb2ludCk7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICAvLyBQdXQgdGhlIHJlcGxhY2VtZW50IGNoYXJhY3RlciBpbnRvIHRoZSBvdXRwdXRcbiAgICBvdXRwdXQucHVzaCgweGZmZmQpO1xuICAgIC8vIE90aGVyd2lzZSwgcHJvY2VzcyBhcyBpZiBpZ25vcmluZyBlcnJvcnNcbiAgICByZXR1cm4gaWdub3JlRnVuYyhyZWFzb24sIG9mZnNldCwgYnl0ZXMsIG91dHB1dCwgYmFkQ29kZXBvaW50KTtcbn1cbi8qKlxuICogIEEgaGFuZGZ1bCBvZiBwb3B1bGFyLCBidWlsdC1pbiBVVEYtOCBlcnJvciBoYW5kbGluZyBzdHJhdGVnaWVzLlxuICpcbiAqICAqKmBgXCJlcnJvclwiYGAqKiAtIHRocm93cyBvbiBBTlkgaWxsZWdhbCBVVEYtOCBzZXF1ZW5jZSBvclxuICogIG5vbi1jYW5vbmljYWwgKG92ZXJsb25nKSBjb2RlcG9pbnRzICh0aGlzIGlzIHRoZSBkZWZhdWx0KVxuICpcbiAqICAqKmBgXCJpZ25vcmVcImBgKiogLSBzaWxlbnRseSBkcm9wcyBhbnkgaWxsZWdhbCBVVEYtOCBzZXF1ZW5jZVxuICogIGFuZCBhY2NlcHRzIG5vbi1jYW5vbmljYWwgKG92ZXJsb25nKSBjb2RlcG9pbnRzXG4gKlxuICogICoqYGBcInJlcGxhY2VcImBgKiogLSByZXBsYWNlIGFueSBpbGxlZ2FsIFVURi04IHNlcXVlbmNlIHdpdGggdGhlXG4gKiAgVVRGLTggcmVwbGFjZW1lbnQgY2hhcmFjdGVyIChpLmUuIGBgXCJcXFxcdWZmZmRcImBgKSBhbmQgYWNjZXB0c1xuICogIG5vbi1jYW5vbmljYWwgKG92ZXJsb25nKSBjb2RlcG9pbnRzXG4gKlxuICogIEByZXR1cm5zOiBSZWNvcmQ8XCJlcnJvclwiIHwgXCJpZ25vcmVcIiB8IFwicmVwbGFjZVwiLCBVdGY4RXJyb3JGdW5jPlxuICovXG5leHBvcnQgY29uc3QgVXRmOEVycm9yRnVuY3MgPSBPYmplY3QuZnJlZXplKHtcbiAgICBlcnJvcjogZXJyb3JGdW5jLFxuICAgIGlnbm9yZTogaWdub3JlRnVuYyxcbiAgICByZXBsYWNlOiByZXBsYWNlRnVuY1xufSk7XG4vLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzEzMzU2NDkzL2RlY29kZS11dGYtOC13aXRoLWphdmFzY3JpcHQjMTM2OTE0OTlcbmZ1bmN0aW9uIGdldFV0ZjhDb2RlUG9pbnRzKF9ieXRlcywgb25FcnJvcikge1xuICAgIGlmIChvbkVycm9yID09IG51bGwpIHtcbiAgICAgICAgb25FcnJvciA9IFV0ZjhFcnJvckZ1bmNzLmVycm9yO1xuICAgIH1cbiAgICBjb25zdCBieXRlcyA9IGdldEJ5dGVzKF9ieXRlcywgXCJieXRlc1wiKTtcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICBsZXQgaSA9IDA7XG4gICAgLy8gSW52YWxpZCBieXRlcyBhcmUgaWdub3JlZFxuICAgIHdoaWxlIChpIDwgYnl0ZXMubGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IGMgPSBieXRlc1tpKytdO1xuICAgICAgICAvLyAweHh4IHh4eHhcbiAgICAgICAgaWYgKGMgPj4gNyA9PT0gMCkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goYyk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBNdWx0aWJ5dGU7IGhvdyBtYW55IGJ5dGVzIGxlZnQgZm9yIHRoaXMgY2hhcmFjdGVyP1xuICAgICAgICBsZXQgZXh0cmFMZW5ndGggPSBudWxsO1xuICAgICAgICBsZXQgb3ZlcmxvbmdNYXNrID0gbnVsbDtcbiAgICAgICAgLy8gMTEweCB4eHh4IDEweHggeHh4eFxuICAgICAgICBpZiAoKGMgJiAweGUwKSA9PT0gMHhjMCkge1xuICAgICAgICAgICAgZXh0cmFMZW5ndGggPSAxO1xuICAgICAgICAgICAgb3ZlcmxvbmdNYXNrID0gMHg3ZjtcbiAgICAgICAgICAgIC8vIDExMTAgeHh4eCAxMHh4IHh4eHggMTB4eCB4eHh4XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoKGMgJiAweGYwKSA9PT0gMHhlMCkge1xuICAgICAgICAgICAgZXh0cmFMZW5ndGggPSAyO1xuICAgICAgICAgICAgb3ZlcmxvbmdNYXNrID0gMHg3ZmY7XG4gICAgICAgICAgICAvLyAxMTExIDB4eHggMTB4eCB4eHh4IDEweHggeHh4eCAxMHh4IHh4eHhcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgoYyAmIDB4ZjgpID09PSAweGYwKSB7XG4gICAgICAgICAgICBleHRyYUxlbmd0aCA9IDM7XG4gICAgICAgICAgICBvdmVybG9uZ01hc2sgPSAweGZmZmY7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoKGMgJiAweGMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgICAgIGkgKz0gb25FcnJvcihcIlVORVhQRUNURURfQ09OVElOVUVcIiwgaSAtIDEsIGJ5dGVzLCByZXN1bHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaSArPSBvbkVycm9yKFwiQkFEX1BSRUZJWFwiLCBpIC0gMSwgYnl0ZXMsIHJlc3VsdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBEbyB3ZSBoYXZlIGVub3VnaCBieXRlcyBpbiBvdXIgZGF0YT9cbiAgICAgICAgaWYgKGkgLSAxICsgZXh0cmFMZW5ndGggPj0gYnl0ZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBpICs9IG9uRXJyb3IoXCJPVkVSUlVOXCIsIGkgLSAxLCBieXRlcywgcmVzdWx0KTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJlbW92ZSB0aGUgbGVuZ3RoIHByZWZpeCBmcm9tIHRoZSBjaGFyXG4gICAgICAgIGxldCByZXMgPSBjICYgKCgxIDw8ICg4IC0gZXh0cmFMZW5ndGggLSAxKSkgLSAxKTtcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBleHRyYUxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICBsZXQgbmV4dENoYXIgPSBieXRlc1tpXTtcbiAgICAgICAgICAgIC8vIEludmFsaWQgY29udGludWF0aW9uIGJ5dGVcbiAgICAgICAgICAgIGlmICgobmV4dENoYXIgJiAweGMwKSAhPSAweDgwKSB7XG4gICAgICAgICAgICAgICAgaSArPSBvbkVycm9yKFwiTUlTU0lOR19DT05USU5VRVwiLCBpLCBieXRlcywgcmVzdWx0KTtcbiAgICAgICAgICAgICAgICByZXMgPSBudWxsO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgO1xuICAgICAgICAgICAgcmVzID0gKHJlcyA8PCA2KSB8IChuZXh0Q2hhciAmIDB4M2YpO1xuICAgICAgICAgICAgaSsrO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNlZSBhYm92ZSBsb29wIGZvciBpbnZhbGlkIGNvbnRpbnVhdGlvbiBieXRlXG4gICAgICAgIGlmIChyZXMgPT09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIE1heGltdW0gY29kZSBwb2ludFxuICAgICAgICBpZiAocmVzID4gMHgxMGZmZmYpIHtcbiAgICAgICAgICAgIGkgKz0gb25FcnJvcihcIk9VVF9PRl9SQU5HRVwiLCBpIC0gMSAtIGV4dHJhTGVuZ3RoLCBieXRlcywgcmVzdWx0LCByZXMpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVzZXJ2ZWQgZm9yIFVURi0xNiBzdXJyb2dhdGUgaGFsdmVzXG4gICAgICAgIGlmIChyZXMgPj0gMHhkODAwICYmIHJlcyA8PSAweGRmZmYpIHtcbiAgICAgICAgICAgIGkgKz0gb25FcnJvcihcIlVURjE2X1NVUlJPR0FURVwiLCBpIC0gMSAtIGV4dHJhTGVuZ3RoLCBieXRlcywgcmVzdWx0LCByZXMpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2hlY2sgZm9yIG92ZXJsb25nIHNlcXVlbmNlcyAobW9yZSBieXRlcyB0aGFuIG5lZWRlZClcbiAgICAgICAgaWYgKHJlcyA8PSBvdmVybG9uZ01hc2spIHtcbiAgICAgICAgICAgIGkgKz0gb25FcnJvcihcIk9WRVJMT05HXCIsIGkgLSAxIC0gZXh0cmFMZW5ndGgsIGJ5dGVzLCByZXN1bHQsIHJlcyk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQucHVzaChyZXMpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xODcyOTQwNS9ob3ctdG8tY29udmVydC11dGY4LXN0cmluZy10by1ieXRlLWFycmF5XG4vKipcbiAqICBSZXR1cm5zIHRoZSBVVEYtOCBieXRlIHJlcHJlc2VudGF0aW9uIG9mICUlc3RyJSUuXG4gKlxuICogIElmICUlZm9ybSUlIGlzIHNwZWNpZmllZCwgdGhlIHN0cmluZyBpcyBub3JtYWxpemVkLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9VdGY4Qnl0ZXMoc3RyLCBmb3JtKSB7XG4gICAgYXNzZXJ0QXJndW1lbnQodHlwZW9mIChzdHIpID09PSBcInN0cmluZ1wiLCBcImludmFsaWQgc3RyaW5nIHZhbHVlXCIsIFwic3RyXCIsIHN0cik7XG4gICAgaWYgKGZvcm0gIT0gbnVsbCkge1xuICAgICAgICBhc3NlcnROb3JtYWxpemUoZm9ybSk7XG4gICAgICAgIHN0ciA9IHN0ci5ub3JtYWxpemUoZm9ybSk7XG4gICAgfVxuICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBjID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIGlmIChjIDwgMHg4MCkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goYyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYyA8IDB4ODAwKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaCgoYyA+PiA2KSB8IDB4YzApO1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goKGMgJiAweDNmKSB8IDB4ODApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKChjICYgMHhmYzAwKSA9PSAweGQ4MDApIHtcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgIGNvbnN0IGMyID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudChpIDwgc3RyLmxlbmd0aCAmJiAoKGMyICYgMHhmYzAwKSA9PT0gMHhkYzAwKSwgXCJpbnZhbGlkIHN1cnJvZ2F0ZSBwYWlyXCIsIFwic3RyXCIsIHN0cik7XG4gICAgICAgICAgICAvLyBTdXJyb2dhdGUgUGFpclxuICAgICAgICAgICAgY29uc3QgcGFpciA9IDB4MTAwMDAgKyAoKGMgJiAweDAzZmYpIDw8IDEwKSArIChjMiAmIDB4MDNmZik7XG4gICAgICAgICAgICByZXN1bHQucHVzaCgocGFpciA+PiAxOCkgfCAweGYwKTtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKCgocGFpciA+PiAxMikgJiAweDNmKSB8IDB4ODApO1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goKChwYWlyID4+IDYpICYgMHgzZikgfCAweDgwKTtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKChwYWlyICYgMHgzZikgfCAweDgwKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKChjID4+IDEyKSB8IDB4ZTApO1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goKChjID4+IDYpICYgMHgzZikgfCAweDgwKTtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKChjICYgMHgzZikgfCAweDgwKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkocmVzdWx0KTtcbn1cbjtcbi8vZXhwb3J0IFxuZnVuY3Rpb24gX3RvVXRmOFN0cmluZyhjb2RlUG9pbnRzKSB7XG4gICAgcmV0dXJuIGNvZGVQb2ludHMubWFwKChjb2RlUG9pbnQpID0+IHtcbiAgICAgICAgaWYgKGNvZGVQb2ludCA8PSAweGZmZmYpIHtcbiAgICAgICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGVQb2ludCk7XG4gICAgICAgIH1cbiAgICAgICAgY29kZVBvaW50IC09IDB4MTAwMDA7XG4gICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKCgoKGNvZGVQb2ludCA+PiAxMCkgJiAweDNmZikgKyAweGQ4MDApLCAoKGNvZGVQb2ludCAmIDB4M2ZmKSArIDB4ZGMwMCkpO1xuICAgIH0pLmpvaW4oXCJcIik7XG59XG4vKipcbiAqICBSZXR1cm5zIHRoZSBzdHJpbmcgcmVwcmVzZW50ZWQgYnkgdGhlIFVURi04IGRhdGEgJSVieXRlcyUlLlxuICpcbiAqICBXaGVuICUlb25FcnJvciUlIGZ1bmN0aW9uIGlzIHNwZWNpZmllZCwgaXQgaXMgY2FsbGVkIG9uIFVURi04XG4gKiAgZXJyb3JzIGFsbG93aW5nIHJlY292ZXJ5IHVzaW5nIHRoZSBbW1V0ZjhFcnJvckZ1bmNdXSBBUEkuXG4gKiAgKGRlZmF1bHQ6IFtlcnJvcl0oVXRmOEVycm9yRnVuY3MpKVxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9VdGY4U3RyaW5nKGJ5dGVzLCBvbkVycm9yKSB7XG4gICAgcmV0dXJuIF90b1V0ZjhTdHJpbmcoZ2V0VXRmOENvZGVQb2ludHMoYnl0ZXMsIG9uRXJyb3IpKTtcbn1cbi8qKlxuICogIFJldHVybnMgdGhlIFVURi04IGNvZGUtcG9pbnRzIGZvciAlJXN0ciUlLlxuICpcbiAqICBJZiAlJWZvcm0lJSBpcyBzcGVjaWZpZWQsIHRoZSBzdHJpbmcgaXMgbm9ybWFsaXplZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvVXRmOENvZGVQb2ludHMoc3RyLCBmb3JtKSB7XG4gICAgcmV0dXJuIGdldFV0ZjhDb2RlUG9pbnRzKHRvVXRmOEJ5dGVzKHN0ciwgZm9ybSkpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXRmOC5qcy5tYXAiXSwibmFtZXMiOlsiZ2V0Qnl0ZXMiLCJhc3NlcnRBcmd1bWVudCIsImFzc2VydE5vcm1hbGl6ZSIsImVycm9yRnVuYyIsInJlYXNvbiIsIm9mZnNldCIsImJ5dGVzIiwib3V0cHV0IiwiYmFkQ29kZXBvaW50IiwiaWdub3JlRnVuYyIsImkiLCJvIiwibGVuZ3RoIiwicmVwbGFjZUZ1bmMiLCJwdXNoIiwiVXRmOEVycm9yRnVuY3MiLCJPYmplY3QiLCJmcmVlemUiLCJlcnJvciIsImlnbm9yZSIsInJlcGxhY2UiLCJnZXRVdGY4Q29kZVBvaW50cyIsIl9ieXRlcyIsIm9uRXJyb3IiLCJyZXN1bHQiLCJjIiwiZXh0cmFMZW5ndGgiLCJvdmVybG9uZ01hc2siLCJyZXMiLCJqIiwibmV4dENoYXIiLCJ0b1V0ZjhCeXRlcyIsInN0ciIsImZvcm0iLCJub3JtYWxpemUiLCJjaGFyQ29kZUF0IiwiYzIiLCJwYWlyIiwiVWludDhBcnJheSIsIl90b1V0ZjhTdHJpbmciLCJjb2RlUG9pbnRzIiwibWFwIiwiY29kZVBvaW50IiwiU3RyaW5nIiwiZnJvbUNoYXJDb2RlIiwiam9pbiIsInRvVXRmOFN0cmluZyIsInRvVXRmOENvZGVQb2ludHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.esm/utils/utf8.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ethers/lib.esm/_version.js":
/*!*************************************************!*\
  !*** ./node_modules/ethers/lib.esm/_version.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   version: () => (/* binding */ version)\n/* harmony export */ });\n/* Do NOT modify this file; see /src.ts/_admin/update-version.ts */ /**\n *  The current version of Ethers.\n */ const version = \"6.15.0\"; //# sourceMappingURL=_version.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vX3ZlcnNpb24uanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLGlFQUFpRSxHQUNqRTs7Q0FFQyxHQUNNLE1BQU1BLFVBQVUsU0FBUyxDQUNoQyxvQ0FBb0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tZWdhdmliZS1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9fdmVyc2lvbi5qcz82ZTE5Il0sInNvdXJjZXNDb250ZW50IjpbIi8qIERvIE5PVCBtb2RpZnkgdGhpcyBmaWxlOyBzZWUgL3NyYy50cy9fYWRtaW4vdXBkYXRlLXZlcnNpb24udHMgKi9cbi8qKlxuICogIFRoZSBjdXJyZW50IHZlcnNpb24gb2YgRXRoZXJzLlxuICovXG5leHBvcnQgY29uc3QgdmVyc2lvbiA9IFwiNi4xNS4wXCI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1fdmVyc2lvbi5qcy5tYXAiXSwibmFtZXMiOlsidmVyc2lvbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ethers/lib.esm/_version.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ethers/lib.esm/utils/data.js":
/*!***************************************************!*\
  !*** ./node_modules/ethers/lib.esm/utils/data.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   concat: () => (/* binding */ concat),\n/* harmony export */   dataLength: () => (/* binding */ dataLength),\n/* harmony export */   dataSlice: () => (/* binding */ dataSlice),\n/* harmony export */   getBytes: () => (/* binding */ getBytes),\n/* harmony export */   getBytesCopy: () => (/* binding */ getBytesCopy),\n/* harmony export */   hexlify: () => (/* binding */ hexlify),\n/* harmony export */   isBytesLike: () => (/* binding */ isBytesLike),\n/* harmony export */   isHexString: () => (/* binding */ isHexString),\n/* harmony export */   stripZerosLeft: () => (/* binding */ stripZerosLeft),\n/* harmony export */   zeroPadBytes: () => (/* binding */ zeroPadBytes),\n/* harmony export */   zeroPadValue: () => (/* binding */ zeroPadValue)\n/* harmony export */ });\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./errors.js */ \"(rsc)/./node_modules/ethers/lib.esm/utils/errors.js\");\n/**\n *  Some data helpers.\n *\n *\n *  @_subsection api/utils:Data Helpers  [about-data]\n */ \nfunction _getBytes(value, name, copy) {\n    if (value instanceof Uint8Array) {\n        if (copy) {\n            return new Uint8Array(value);\n        }\n        return value;\n    }\n    if (typeof value === \"string\" && value.match(/^0x(?:[0-9a-f][0-9a-f])*$/i)) {\n        const result = new Uint8Array((value.length - 2) / 2);\n        let offset = 2;\n        for(let i = 0; i < result.length; i++){\n            result[i] = parseInt(value.substring(offset, offset + 2), 16);\n            offset += 2;\n        }\n        return result;\n    }\n    (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(false, \"invalid BytesLike value\", name || \"value\", value);\n}\n/**\n *  Get a typed Uint8Array for %%value%%. If already a Uint8Array\n *  the original %%value%% is returned; if a copy is required use\n *  [[getBytesCopy]].\n *\n *  @see: getBytesCopy\n */ function getBytes(value, name) {\n    return _getBytes(value, name, false);\n}\n/**\n *  Get a typed Uint8Array for %%value%%, creating a copy if necessary\n *  to prevent any modifications of the returned value from being\n *  reflected elsewhere.\n *\n *  @see: getBytes\n */ function getBytesCopy(value, name) {\n    return _getBytes(value, name, true);\n}\n/**\n *  Returns true if %%value%% is a valid [[HexString]].\n *\n *  If %%length%% is ``true`` or a //number//, it also checks that\n *  %%value%% is a valid [[DataHexString]] of %%length%% (if a //number//)\n *  bytes of data (e.g. ``0x1234`` is 2 bytes).\n */ function isHexString(value, length) {\n    if (typeof value !== \"string\" || !value.match(/^0x[0-9A-Fa-f]*$/)) {\n        return false;\n    }\n    if (typeof length === \"number\" && value.length !== 2 + 2 * length) {\n        return false;\n    }\n    if (length === true && value.length % 2 !== 0) {\n        return false;\n    }\n    return true;\n}\n/**\n *  Returns true if %%value%% is a valid representation of arbitrary\n *  data (i.e. a valid [[DataHexString]] or a Uint8Array).\n */ function isBytesLike(value) {\n    return isHexString(value, true) || value instanceof Uint8Array;\n}\nconst HexCharacters = \"0123456789abcdef\";\n/**\n *  Returns a [[DataHexString]] representation of %%data%%.\n */ function hexlify(data) {\n    const bytes = getBytes(data);\n    let result = \"0x\";\n    for(let i = 0; i < bytes.length; i++){\n        const v = bytes[i];\n        result += HexCharacters[(v & 0xf0) >> 4] + HexCharacters[v & 0x0f];\n    }\n    return result;\n}\n/**\n *  Returns a [[DataHexString]] by concatenating all values\n *  within %%data%%.\n */ function concat(datas) {\n    return \"0x\" + datas.map((d)=>hexlify(d).substring(2)).join(\"\");\n}\n/**\n *  Returns the length of %%data%%, in bytes.\n */ function dataLength(data) {\n    if (isHexString(data, true)) {\n        return (data.length - 2) / 2;\n    }\n    return getBytes(data).length;\n}\n/**\n *  Returns a [[DataHexString]] by slicing %%data%% from the %%start%%\n *  offset to the %%end%% offset.\n *\n *  By default %%start%% is 0 and %%end%% is the length of %%data%%.\n */ function dataSlice(data, start, end) {\n    const bytes = getBytes(data);\n    if (end != null && end > bytes.length) {\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assert)(false, \"cannot slice beyond data bounds\", \"BUFFER_OVERRUN\", {\n            buffer: bytes,\n            length: bytes.length,\n            offset: end\n        });\n    }\n    return hexlify(bytes.slice(start == null ? 0 : start, end == null ? bytes.length : end));\n}\n/**\n *  Return the [[DataHexString]] result by stripping all **leading**\n ** zero bytes from %%data%%.\n */ function stripZerosLeft(data) {\n    let bytes = hexlify(data).substring(2);\n    while(bytes.startsWith(\"00\")){\n        bytes = bytes.substring(2);\n    }\n    return \"0x\" + bytes;\n}\nfunction zeroPad(data, length, left) {\n    const bytes = getBytes(data);\n    (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assert)(length >= bytes.length, \"padding exceeds data length\", \"BUFFER_OVERRUN\", {\n        buffer: new Uint8Array(bytes),\n        length: length,\n        offset: length + 1\n    });\n    const result = new Uint8Array(length);\n    result.fill(0);\n    if (left) {\n        result.set(bytes, length - bytes.length);\n    } else {\n        result.set(bytes, 0);\n    }\n    return hexlify(result);\n}\n/**\n *  Return the [[DataHexString]] of %%data%% padded on the **left**\n *  to %%length%% bytes.\n *\n *  If %%data%% already exceeds %%length%%, a [[BufferOverrunError]] is\n *  thrown.\n *\n *  This pads data the same as **values** are in Solidity\n *  (e.g. ``uint128``).\n */ function zeroPadValue(data, length) {\n    return zeroPad(data, length, true);\n}\n/**\n *  Return the [[DataHexString]] of %%data%% padded on the **right**\n *  to %%length%% bytes.\n *\n *  If %%data%% already exceeds %%length%%, a [[BufferOverrunError]] is\n *  thrown.\n *\n *  This pads data the same as **bytes** are in Solidity\n *  (e.g. ``bytes16``).\n */ function zeroPadBytes(data, length) {\n    return zeroPad(data, length, false);\n} //# sourceMappingURL=data.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vdXRpbHMvZGF0YS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7Ozs7Q0FLQyxHQUNvRDtBQUNyRCxTQUFTRSxVQUFVQyxLQUFLLEVBQUVDLElBQUksRUFBRUMsSUFBSTtJQUNoQyxJQUFJRixpQkFBaUJHLFlBQVk7UUFDN0IsSUFBSUQsTUFBTTtZQUNOLE9BQU8sSUFBSUMsV0FBV0g7UUFDMUI7UUFDQSxPQUFPQTtJQUNYO0lBQ0EsSUFBSSxPQUFRQSxVQUFXLFlBQVlBLE1BQU1JLEtBQUssQ0FBQywrQkFBK0I7UUFDMUUsTUFBTUMsU0FBUyxJQUFJRixXQUFXLENBQUNILE1BQU1NLE1BQU0sR0FBRyxLQUFLO1FBQ25ELElBQUlDLFNBQVM7UUFDYixJQUFLLElBQUlDLElBQUksR0FBR0EsSUFBSUgsT0FBT0MsTUFBTSxFQUFFRSxJQUFLO1lBQ3BDSCxNQUFNLENBQUNHLEVBQUUsR0FBR0MsU0FBU1QsTUFBTVUsU0FBUyxDQUFDSCxRQUFRQSxTQUFTLElBQUk7WUFDMURBLFVBQVU7UUFDZDtRQUNBLE9BQU9GO0lBQ1g7SUFDQVAsMERBQWNBLENBQUMsT0FBTywyQkFBMkJHLFFBQVEsU0FBU0Q7QUFDdEU7QUFDQTs7Ozs7O0NBTUMsR0FDTSxTQUFTVyxTQUFTWCxLQUFLLEVBQUVDLElBQUk7SUFDaEMsT0FBT0YsVUFBVUMsT0FBT0MsTUFBTTtBQUNsQztBQUNBOzs7Ozs7Q0FNQyxHQUNNLFNBQVNXLGFBQWFaLEtBQUssRUFBRUMsSUFBSTtJQUNwQyxPQUFPRixVQUFVQyxPQUFPQyxNQUFNO0FBQ2xDO0FBQ0E7Ozs7OztDQU1DLEdBQ00sU0FBU1ksWUFBWWIsS0FBSyxFQUFFTSxNQUFNO0lBQ3JDLElBQUksT0FBUU4sVUFBVyxZQUFZLENBQUNBLE1BQU1JLEtBQUssQ0FBQyxxQkFBcUI7UUFDakUsT0FBTztJQUNYO0lBQ0EsSUFBSSxPQUFRRSxXQUFZLFlBQVlOLE1BQU1NLE1BQU0s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YWNrOi8vbWVnYXZpYmUtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vdXRpbHMvZGF0YS5qcz9jNjhhIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogIFNvbWUgZGF0YSBoZWxwZXJzLlxuICpcbiAqXG4gKiAgQF9zdWJzZWN0aW9uIGFwaS91dGlsczpEYXRhIEhlbHBlcnMgIFthYm91dC1kYXRhXVxuICovXG5pbXBvcnQgeyBhc3NlcnQsIGFzc2VydEFyZ3VtZW50IH0gZnJvbSBcIi4vZXJyb3JzLmpzXCI7XG5mdW5jdGlvbiBfZ2V0Qnl0ZXModmFsdWUsIG5hbWUsIGNvcHkpIHtcbiAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgICAgIGlmIChjb3B5KSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiAodmFsdWUpID09PSBcInN0cmluZ1wiICYmIHZhbHVlLm1hdGNoKC9eMHgoPzpbMC05YS1mXVswLTlhLWZdKSokL2kpKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBVaW50OEFycmF5KCh2YWx1ZS5sZW5ndGggLSAyKSAvIDIpO1xuICAgICAgICBsZXQgb2Zmc2V0ID0gMjtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZXN1bHQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHJlc3VsdFtpXSA9IHBhcnNlSW50KHZhbHVlLnN1YnN0cmluZyhvZmZzZXQsIG9mZnNldCArIDIpLCAxNik7XG4gICAgICAgICAgICBvZmZzZXQgKz0gMjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBhc3NlcnRBcmd1bWVudChmYWxzZSwgXCJpbnZhbGlkIEJ5dGVzTGlrZSB2YWx1ZVwiLCBuYW1lIHx8IFwidmFsdWVcIiwgdmFsdWUpO1xufVxuLyoqXG4gKiAgR2V0IGEgdHlwZWQgVWludDhBcnJheSBmb3IgJSV2YWx1ZSUlLiBJZiBhbHJlYWR5IGEgVWludDhBcnJheVxuICogIHRoZSBvcmlnaW5hbCAlJXZhbHVlJSUgaXMgcmV0dXJuZWQ7IGlmIGEgY29weSBpcyByZXF1aXJlZCB1c2VcbiAqICBbW2dldEJ5dGVzQ29weV1dLlxuICpcbiAqICBAc2VlOiBnZXRCeXRlc0NvcHlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEJ5dGVzKHZhbHVlLCBuYW1lKSB7XG4gICAgcmV0dXJuIF9nZXRCeXRlcyh2YWx1ZSwgbmFtZSwgZmFsc2UpO1xufVxuLyoqXG4gKiAgR2V0IGEgdHlwZWQgVWludDhBcnJheSBmb3IgJSV2YWx1ZSUlLCBjcmVhdGluZyBhIGNvcHkgaWYgbmVjZXNzYXJ5XG4gKiAgdG8gcHJldmVudCBhbnkgbW9kaWZpY2F0aW9ucyBvZiB0aGUgcmV0dXJuZWQgdmFsdWUgZnJvbSBiZWluZ1xuICogIHJlZmxlY3RlZCBlbHNld2hlcmUuXG4gKlxuICogIEBzZWU6IGdldEJ5dGVzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRCeXRlc0NvcHkodmFsdWUsIG5hbWUpIHtcbiAgICByZXR1cm4gX2dldEJ5dGVzKHZhbHVlLCBuYW1lLCB0cnVlKTtcbn1cbi8qKlxuICogIFJldHVybnMgdHJ1ZSBpZiAlJXZhbHVlJSUgaXMgYSB2YWxpZCBbW0hleFN0cmluZ11dLlxuICpcbiAqICBJZiAlJWxlbmd0aCUlIGlzIGBgdHJ1ZWBgIG9yIGEgLy9udW1iZXIvLywgaXQgYWxzbyBjaGVja3MgdGhhdFxuICogICUldmFsdWUlJSBpcyBhIHZhbGlkIFtbRGF0YUhleFN0cmluZ11dIG9mICUlbGVuZ3RoJSUgKGlmIGEgLy9udW1iZXIvLylcbiAqICBieXRlcyBvZiBkYXRhIChlLmcuIGBgMHgxMjM0YGAgaXMgMiBieXRlcykuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0hleFN0cmluZyh2YWx1ZSwgbGVuZ3RoKSB7XG4gICAgaWYgKHR5cGVvZiAodmFsdWUpICE9PSBcInN0cmluZ1wiIHx8ICF2YWx1ZS5tYXRjaCgvXjB4WzAtOUEtRmEtZl0qJC8pKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiAobGVuZ3RoKSA9PT0gXCJudW1iZXJcIiAmJiB2YWx1ZS5sZW5ndGggIT09IDIgKyAyICogbGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKGxlbmd0aCA9PT0gdHJ1ZSAmJiAodmFsdWUubGVuZ3RoICUgMikgIT09IDApIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbi8qKlxuICogIFJldHVybnMgdHJ1ZSBpZiAlJXZhbHVlJSUgaXMgYSB2YWxpZCByZXByZXNlbnRhdGlvbiBvZiBhcmJpdHJhcnlcbiAqICBkYXRhIChpLmUuIGEgdmFsaWQgW1tEYXRhSGV4U3RyaW5nXV0gb3IgYSBVaW50OEFycmF5KS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzQnl0ZXNMaWtlKHZhbHVlKSB7XG4gICAgcmV0dXJuIChpc0hleFN0cmluZyh2YWx1ZSwgdHJ1ZSkgfHwgKHZhbHVlIGluc3RhbmNlb2YgVWludDhBcnJheSkpO1xufVxuY29uc3QgSGV4Q2hhcmFjdGVycyA9IFwiMDEyMzQ1Njc4OWFiY2RlZlwiO1xuLyoqXG4gKiAgUmV0dXJucyBhIFtbRGF0YUhleFN0cmluZ11dIHJlcHJlc2VudGF0aW9uIG9mICUlZGF0YSUlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gaGV4bGlmeShkYXRhKSB7XG4gICAgY29uc3QgYnl0ZXMgPSBnZXRCeXRlcyhkYXRhKTtcbiAgICBsZXQgcmVzdWx0ID0gXCIweFwiO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgdiA9IGJ5dGVzW2ldO1xuICAgICAgICByZXN1bHQgKz0gSGV4Q2hhcmFjdGVyc1sodiAmIDB4ZjApID4+IDRdICsgSGV4Q2hhcmFjdGVyc1t2ICYgMHgwZl07XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG4vKipcbiAqICBSZXR1cm5zIGEgW1tEYXRhSGV4U3RyaW5nXV0gYnkgY29uY2F0ZW5hdGluZyBhbGwgdmFsdWVzXG4gKiAgd2l0aGluICUlZGF0YSUlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY29uY2F0KGRhdGFzKSB7XG4gICAgcmV0dXJuIFwiMHhcIiArIGRhdGFzLm1hcCgoZCkgPT4gaGV4bGlmeShkKS5zdWJzdHJpbmcoMikpLmpvaW4oXCJcIik7XG59XG4vKipcbiAqICBSZXR1cm5zIHRoZSBsZW5ndGggb2YgJSVkYXRhJSUsIGluIGJ5dGVzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZGF0YUxlbmd0aChkYXRhKSB7XG4gICAgaWYgKGlzSGV4U3RyaW5nKGRhdGEsIHRydWUpKSB7XG4gICAgICAgIHJldHVybiAoZGF0YS5sZW5ndGggLSAyKSAvIDI7XG4gICAgfVxuICAgIHJldHVybiBnZXRCeXRlcyhkYXRhKS5sZW5ndGg7XG59XG4vKipcbiAqICBSZXR1cm5zIGEgW1tEYXRhSGV4U3RyaW5nXV0gYnkgc2xpY2luZyAlJWRhdGElJSBmcm9tIHRoZSAlJXN0YXJ0JSVcbiAqICBvZmZzZXQgdG8gdGhlICUlZW5kJSUgb2Zmc2V0LlxuICpcbiAqICBCeSBkZWZhdWx0ICUlc3RhcnQlJSBpcyAwIGFuZCAlJWVuZCUlIGlzIHRoZSBsZW5ndGggb2YgJSVkYXRhJSUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkYXRhU2xpY2UoZGF0YSwgc3RhcnQsIGVuZCkge1xuICAgIGNvbnN0IGJ5dGVzID0gZ2V0Qnl0ZXMoZGF0YSk7XG4gICAgaWYgKGVuZCAhPSBudWxsICYmIGVuZCA+IGJ5dGVzLmxlbmd0aCkge1xuICAgICAgICBhc3NlcnQoZmFsc2UsIFwiY2Fubm90IHNsaWNlIGJleW9uZCBkYXRhIGJvdW5kc1wiLCBcIkJVRkZFUl9PVkVSUlVOXCIsIHtcbiAgICAgICAgICAgIGJ1ZmZlcjogYnl0ZXMsIGxlbmd0aDogYnl0ZXMubGVuZ3RoLCBvZmZzZXQ6IGVuZFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGhleGxpZnkoYnl0ZXMuc2xpY2UoKHN0YXJ0ID09IG51bGwpID8gMCA6IHN0YXJ0LCAoZW5kID09IG51bGwpID8gYnl0ZXMubGVuZ3RoIDogZW5kKSk7XG59XG4vKipcbiAqICBSZXR1cm4gdGhlIFtbRGF0YUhleFN0cmluZ11dIHJlc3VsdCBieSBzdHJpcHBpbmcgYWxsICoqbGVhZGluZyoqXG4gKiogemVybyBieXRlcyBmcm9tICUlZGF0YSUlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gc3RyaXBaZXJvc0xlZnQoZGF0YSkge1xuICAgIGxldCBieXRlcyA9IGhleGxpZnkoZGF0YSkuc3Vic3RyaW5nKDIpO1xuICAgIHdoaWxlIChieXRlcy5zdGFydHNXaXRoKFwiMDBcIikpIHtcbiAgICAgICAgYnl0ZXMgPSBieXRlcy5zdWJzdHJpbmcoMik7XG4gICAgfVxuICAgIHJldHVybiBcIjB4XCIgKyBieXRlcztcbn1cbmZ1bmN0aW9uIHplcm9QYWQoZGF0YSwgbGVuZ3RoLCBsZWZ0KSB7XG4gICAgY29uc3QgYnl0ZXMgPSBnZXRCeXRlcyhkYXRhKTtcbiAgICBhc3NlcnQobGVuZ3RoID49IGJ5dGVzLmxlbmd0aCwgXCJwYWRkaW5nIGV4Y2VlZHMgZGF0YSBsZW5ndGhcIiwgXCJCVUZGRVJfT1ZFUlJVTlwiLCB7XG4gICAgICAgIGJ1ZmZlcjogbmV3IFVpbnQ4QXJyYXkoYnl0ZXMpLFxuICAgICAgICBsZW5ndGg6IGxlbmd0aCxcbiAgICAgICAgb2Zmc2V0OiBsZW5ndGggKyAxXG4gICAgfSk7XG4gICAgY29uc3QgcmVzdWx0ID0gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoKTtcbiAgICByZXN1bHQuZmlsbCgwKTtcbiAgICBpZiAobGVmdCkge1xuICAgICAgICByZXN1bHQuc2V0KGJ5dGVzLCBsZW5ndGggLSBieXRlcy5sZW5ndGgpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmVzdWx0LnNldChieXRlcywgMCk7XG4gICAgfVxuICAgIHJldHVybiBoZXhsaWZ5KHJlc3VsdCk7XG59XG4vKipcbiAqICBSZXR1cm4gdGhlIFtbRGF0YUhleFN0cmluZ11dIG9mICUlZGF0YSUlIHBhZGRlZCBvbiB0aGUgKipsZWZ0KipcbiAqICB0byAlJWxlbmd0aCUlIGJ5dGVzLlxuICpcbiAqICBJZiAlJWRhdGElJSBhbHJlYWR5IGV4Y2VlZHMgJSVsZW5ndGglJSwgYSBbW0J1ZmZlck92ZXJydW5FcnJvcl1dIGlzXG4gKiAgdGhyb3duLlxuICpcbiAqICBUaGlzIHBhZHMgZGF0YSB0aGUgc2FtZSBhcyAqKnZhbHVlcyoqIGFyZSBpbiBTb2xpZGl0eVxuICogIChlLmcuIGBgdWludDEyOGBgKS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHplcm9QYWRWYWx1ZShkYXRhLCBsZW5ndGgpIHtcbiAgICByZXR1cm4gemVyb1BhZChkYXRhLCBsZW5ndGgsIHRydWUpO1xufVxuLyoqXG4gKiAgUmV0dXJuIHRoZSBbW0RhdGFIZXhTdHJpbmddXSBvZiAlJWRhdGElJSBwYWRkZWQgb24gdGhlICoqcmlnaHQqKlxuICogIHRvICUlbGVuZ3RoJSUgYnl0ZXMuXG4gKlxuICogIElmICUlZGF0YSUlIGFscmVhZHkgZXhjZWVkcyAlJWxlbmd0aCUlLCBhIFtbQnVmZmVyT3ZlcnJ1bkVycm9yXV0gaXNcbiAqICB0aHJvd24uXG4gKlxuICogIFRoaXMgcGFkcyBkYXRhIHRoZSBzYW1lIGFzICoqYnl0ZXMqKiBhcmUgaW4gU29saWRpdHlcbiAqICAoZS5nLiBgYGJ5dGVzMTZgYCkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB6ZXJvUGFkQnl0ZXMoZGF0YSwgbGVuZ3RoKSB7XG4gICAgcmV0dXJuIHplcm9QYWQoZGF0YSwgbGVuZ3RoLCBmYWxzZSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhLmpzLm1hcCJdLCJuYW1lcyI6WyJhc3NlcnQiLCJhc3NlcnRBcmd1bWVudCIsIl9nZXRCeXRlcyIsInZhbHVlIiwibmFtZSIsImNvcHkiLCJVaW50OEFycmF5IiwibWF0Y2giLCJyZXN1bHQiLCJsZW5ndGgiLCJvZmZzZXQiLCJpIiwicGFyc2VJbnQiLCJzdWJzdHJpbmciLCJnZXRCeXRlcyIsImdldEJ5dGVzQ29weSIsImlzSGV4U3RyaW5nIiwiaXNCeXRlc0xpa2UiLCJIZXhDaGFyYWN0ZXJzIiwiaGV4bGlmeSIsImRhdGEiLCJieXRlcyIsInYiLCJjb25jYXQiLCJkYXRhcyIsIm1hcCIsImQiLCJqb2luIiwiZGF0YUxlbmd0aCIsImRhdGFTbGljZSIsInN0YXJ0IiwiZW5kIiwiYnVmZmVyIiwic2xpY2UiLCJzdHJpcFplcm9zTGVmdCIsInN0YXJ0c1dpdGgiLCJ6ZXJvUGFkIiwibGVmdCIsImZpbGwiLCJzZXQiLCJ6ZXJvUGFkVmFsdWUiLCJ6ZXJvUGFkQnl0ZXMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ethers/lib.esm/utils/data.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ethers/lib.esm/utils/errors.js":
/*!*****************************************************!*\
  !*** ./node_modules/ethers/lib.esm/utils/errors.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   assert: () => (/* binding */ assert),\n/* harmony export */   assertArgument: () => (/* binding */ assertArgument),\n/* harmony export */   assertArgumentCount: () => (/* binding */ assertArgumentCount),\n/* harmony export */   assertNormalize: () => (/* binding */ assertNormalize),\n/* harmony export */   assertPrivate: () => (/* binding */ assertPrivate),\n/* harmony export */   isCallException: () => (/* binding */ isCallException),\n/* harmony export */   isError: () => (/* binding */ isError),\n/* harmony export */   makeError: () => (/* binding */ makeError)\n/* harmony export */ });\n/* harmony import */ var _version_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../_version.js */ \"(rsc)/./node_modules/ethers/lib.esm/_version.js\");\n/* harmony import */ var _properties_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./properties.js */ \"(rsc)/./node_modules/ethers/lib.esm/utils/properties.js\");\n/**\n *  All errors in ethers include properties to ensure they are both\n *  human-readable (i.e. ``.message``) and machine-readable (i.e. ``.code``).\n *\n *  The [[isError]] function can be used to check the error ``code`` and\n *  provide a type guard for the properties present on that error interface.\n *\n *  @_section: api/utils/errors:Errors  [about-errors]\n */ \n\nfunction stringify(value, seen) {\n    if (value == null) {\n        return \"null\";\n    }\n    if (seen == null) {\n        seen = new Set();\n    }\n    if (typeof value === \"object\") {\n        if (seen.has(value)) {\n            return \"[Circular]\";\n        }\n        seen.add(value);\n    }\n    if (Array.isArray(value)) {\n        return \"[ \" + value.map((v)=>stringify(v, seen)).join(\", \") + \" ]\";\n    }\n    if (value instanceof Uint8Array) {\n        const HEX = \"0123456789abcdef\";\n        let result = \"0x\";\n        for(let i = 0; i < value.length; i++){\n            result += HEX[value[i] >> 4];\n            result += HEX[value[i] & 0xf];\n        }\n        return result;\n    }\n    if (typeof value === \"object\" && typeof value.toJSON === \"function\") {\n        return stringify(value.toJSON(), seen);\n    }\n    switch(typeof value){\n        case \"boolean\":\n        case \"number\":\n        case \"symbol\":\n            return value.toString();\n        case \"bigint\":\n            return BigInt(value).toString();\n        case \"string\":\n            return JSON.stringify(value);\n        case \"object\":\n            {\n                const keys = Object.keys(value);\n                keys.sort();\n                return \"{ \" + keys.map((k)=>`${stringify(k, seen)}: ${stringify(value[k], seen)}`).join(\", \") + \" }\";\n            }\n    }\n    return `[ COULD NOT SERIALIZE ]`;\n}\n/**\n *  Returns true if the %%error%% matches an error thrown by ethers\n *  that matches the error %%code%%.\n *\n *  In TypeScript environments, this can be used to check that %%error%%\n *  matches an EthersError type, which means the expected properties will\n *  be set.\n *\n *  @See [ErrorCodes](api:ErrorCode)\n *  @example\n *    try {\n *      // code....\n *    } catch (e) {\n *      if (isError(e, \"CALL_EXCEPTION\")) {\n *          // The Type Guard has validated this object\n *          console.log(e.data);\n *      }\n *    }\n */ function isError(error, code) {\n    return error && error.code === code;\n}\n/**\n *  Returns true if %%error%% is a [[CallExceptionError].\n */ function isCallException(error) {\n    return isError(error, \"CALL_EXCEPTION\");\n}\n/**\n *  Returns a new Error configured to the format ethers emits errors, with\n *  the %%message%%, [[api:ErrorCode]] %%code%% and additional properties\n *  for the corresponding EthersError.\n *\n *  Each error in ethers includes the version of ethers, a\n *  machine-readable [[ErrorCode]], and depending on %%code%%, additional\n *  required properties. The error message will also include the %%message%%,\n *  ethers version, %%code%% and all additional properties, serialized.\n */ function makeError(message, code, info) {\n    let shortMessage = message;\n    {\n        const details = [];\n        if (info) {\n            if (\"message\" in info || \"code\" in info || \"name\" in info) {\n                throw new Error(`value will overwrite populated values: ${stringify(info)}`);\n            }\n            for(const key in info){\n                if (key === \"shortMessage\") {\n                    continue;\n                }\n                const value = info[key];\n                //                try {\n                details.push(key + \"=\" + stringify(value));\n            //                } catch (error: any) {\n            //                console.log(\"MMM\", error.message);\n            //                    details.push(key + \"=[could not serialize object]\");\n            //                }\n            }\n        }\n        details.push(`code=${code}`);\n        details.push(`version=${_version_js__WEBPACK_IMPORTED_MODULE_0__.version}`);\n        if (details.length) {\n            message += \" (\" + details.join(\", \") + \")\";\n        }\n    }\n    let error;\n    switch(code){\n        case \"INVALID_ARGUMENT\":\n            error = new TypeError(message);\n            break;\n        case \"NUMERIC_FAULT\":\n        case \"BUFFER_OVERRUN\":\n            error = new RangeError(message);\n            break;\n        default:\n            error = new Error(message);\n    }\n    (0,_properties_js__WEBPACK_IMPORTED_MODULE_1__.defineProperties)(error, {\n        code\n    });\n    if (info) {\n        Object.assign(error, info);\n    }\n    if (error.shortMessage == null) {\n        (0,_properties_js__WEBPACK_IMPORTED_MODULE_1__.defineProperties)(error, {\n            shortMessage\n        });\n    }\n    return error;\n}\n/**\n *  Throws an EthersError with %%message%%, %%code%% and additional error\n *  %%info%% when %%check%% is falsish..\n *\n *  @see [[api:makeError]]\n */ function assert(check, message, code, info) {\n    if (!check) {\n        throw makeError(message, code, info);\n    }\n}\n/**\n *  A simple helper to simply ensuring provided arguments match expected\n *  constraints, throwing if not.\n *\n *  In TypeScript environments, the %%check%% has been asserted true, so\n *  any further code does not need additional compile-time checks.\n */ function assertArgument(check, message, name, value) {\n    assert(check, message, \"INVALID_ARGUMENT\", {\n        argument: name,\n        value: value\n    });\n}\nfunction assertArgumentCount(count, expectedCount, message) {\n    if (message == null) {\n        message = \"\";\n    }\n    if (message) {\n        message = \": \" + message;\n    }\n    assert(count >= expectedCount, \"missing argument\" + message, \"MISSING_ARGUMENT\", {\n        count: count,\n        expectedCount: expectedCount\n    });\n    assert(count <= expectedCount, \"too many arguments\" + message, \"UNEXPECTED_ARGUMENT\", {\n        count: count,\n        expectedCount: expectedCount\n    });\n}\nconst _normalizeForms = [\n    \"NFD\",\n    \"NFC\",\n    \"NFKD\",\n    \"NFKC\"\n].reduce((accum, form)=>{\n    try {\n        // General test for normalize\n        /* c8 ignore start */ if (\"test\".normalize(form) !== \"test\") {\n            throw new Error(\"bad\");\n        }\n        ;\n        /* c8 ignore stop */ if (form === \"NFD\") {\n            const check = String.fromCharCode(0xe9).normalize(\"NFD\");\n            const expected = String.fromCharCode(0x65, 0x0301);\n            /* c8 ignore start */ if (check !== expected) {\n                throw new Error(\"broken\");\n            }\n        /* c8 ignore stop */ }\n        accum.push(form);\n    } catch (error) {}\n    return accum;\n}, []);\n/**\n *  Throws if the normalization %%form%% is not supported.\n */ function assertNormalize(form) {\n    assert(_normalizeForms.indexOf(form) >= 0, \"platform missing String.prototype.normalize\", \"UNSUPPORTED_OPERATION\", {\n        operation: \"String.prototype.normalize\",\n        info: {\n            form\n        }\n    });\n}\n/**\n *  Many classes use file-scoped values to guard the constructor,\n *  making it effectively private. This facilitates that pattern\n *  by ensuring the %%givenGaurd%% matches the file-scoped %%guard%%,\n *  throwing if not, indicating the %%className%% if provided.\n */ function assertPrivate(givenGuard, guard, className) {\n    if (className == null) {\n        className = \"\";\n    }\n    if (givenGuard !== guard) {\n        let method = className, operation = \"new\";\n        if (className) {\n            method += \".\";\n            operation += \" \" + className;\n        }\n        assert(false, `private constructor; use ${method}from* methods`, \"UNSUPPORTED_OPERATION\", {\n            operation\n        });\n    }\n} //# sourceMappingURL=errors.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vdXRpbHMvZXJyb3JzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFBQTs7Ozs7Ozs7Q0FRQyxHQUN3QztBQUNVO0FBQ25ELFNBQVNFLFVBQVVDLEtBQUssRUFBRUMsSUFBSTtJQUMxQixJQUFJRCxTQUFTLE1BQU07UUFDZixPQUFPO0lBQ1g7SUFDQSxJQUFJQyxRQUFRLE1BQU07UUFDZEEsT0FBTyxJQUFJQztJQUNmO0lBQ0EsSUFBSSxPQUFRRixVQUFXLFVBQVU7UUFDN0IsSUFBSUMsS0FBS0UsR0FBRyxDQUFDSCxRQUFRO1lBQ2pCLE9BQU87UUFDWDtRQUNBQyxLQUFLRyxHQUFHLENBQUNKO0lBQ2I7SUFDQSxJQUFJSyxNQUFNQyxPQUFPLENBQUNOLFFBQVE7UUFDdEIsT0FBTyxPQUFPLE1BQU9PLEdBQUcsQ0FBQyxDQUFDQyxJQUFNVCxVQUFVUyxHQUFHUCxPQUFRUSxJQUFJLENBQUMsUUFBUTtJQUN0RTtJQUNBLElBQUlULGlCQUFpQlUsWUFBWTtRQUM3QixNQUFNQyxNQUFNO1FBQ1osSUFBSUMsU0FBUztRQUNiLElBQUssSUFBSUMsSUFBSSxHQUFHQSxJQUFJYixNQUFNYyxNQUFNLEVBQUVELElBQUs7WUFDbkNELFVBQVVELEdBQUcsQ0FBQ1gsS0FBSyxDQUFDYSxFQUFFLElBQUksRUFBRTtZQUM1QkQsVUFBVUQsR0FBRyxDQUFDWCxLQUFLLENBQUNhLEVBQUUsR0FBRyxJQUFJO1FBQ2pDO1FBQ0EsT0FBT0Q7SUFDWDtJQUNBLElBQUksT0FBUVosVUFBVyxZQUFZLE9BQVFBLE1BQU1lLE1BQU0sS0FBTSxZQUFZO1FBQ3JFLE9BQU9oQixVQUFVQyxNQUFNZSxNQUFNLElBQUlkO0lBQ3JDO0lBQ0EsT0FBUSxPQUFRRDtRQUNaLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztZQUNELE9BQU9BLE1BQU1nQixRQUFRO1FBQ3pCLEtBQUs7WUFDRCxPQUFPQyxPQUFPakIsT0FBT2dCLFFBQVE7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LGVBQWVDLE9BQU87UUFDdEIsSUFBSUUsU0FBU0QsV0FBV0osWUFBWTtRQUNwQyxJQUFJSSxXQUFXO1lBQ1hDLFVBQVU7WUFDVkwsYUFBYSxNQUFNSTtRQUN2QjtRQUNBdEIsT0FBTyxPQUFPLENBQUMseUJBQXlCLEVBQUV1QixPQUFPLGFBQWEsQ0FBQyxFQUFFLHlCQUF5QjtZQUN0Rkw7UUFDSjtJQUNKO0FBQ0osRUFDQSxrQ0FBa0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tZWdhdmliZS1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS91dGlscy9lcnJvcnMuanM/ODY2ZSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqICBBbGwgZXJyb3JzIGluIGV0aGVycyBpbmNsdWRlIHByb3BlcnRpZXMgdG8gZW5zdXJlIHRoZXkgYXJlIGJvdGhcbiAqICBodW1hbi1yZWFkYWJsZSAoaS5lLiBgYC5tZXNzYWdlYGApIGFuZCBtYWNoaW5lLXJlYWRhYmxlIChpLmUuIGBgLmNvZGVgYCkuXG4gKlxuICogIFRoZSBbW2lzRXJyb3JdXSBmdW5jdGlvbiBjYW4gYmUgdXNlZCB0byBjaGVjayB0aGUgZXJyb3IgYGBjb2RlYGAgYW5kXG4gKiAgcHJvdmlkZSBhIHR5cGUgZ3VhcmQgZm9yIHRoZSBwcm9wZXJ0aWVzIHByZXNlbnQgb24gdGhhdCBlcnJvciBpbnRlcmZhY2UuXG4gKlxuICogIEBfc2VjdGlvbjogYXBpL3V0aWxzL2Vycm9yczpFcnJvcnMgIFthYm91dC1lcnJvcnNdXG4gKi9cbmltcG9ydCB7IHZlcnNpb24gfSBmcm9tIFwiLi4vX3ZlcnNpb24uanNcIjtcbmltcG9ydCB7IGRlZmluZVByb3BlcnRpZXMgfSBmcm9tIFwiLi9wcm9wZXJ0aWVzLmpzXCI7XG5mdW5jdGlvbiBzdHJpbmdpZnkodmFsdWUsIHNlZW4pIHtcbiAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gXCJudWxsXCI7XG4gICAgfVxuICAgIGlmIChzZWVuID09IG51bGwpIHtcbiAgICAgICAgc2VlbiA9IG5ldyBTZXQoKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiAodmFsdWUpID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIGlmIChzZWVuLmhhcyh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBcIltDaXJjdWxhcl1cIjtcbiAgICAgICAgfVxuICAgICAgICBzZWVuLmFkZCh2YWx1ZSk7XG4gICAgfVxuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gXCJbIFwiICsgKHZhbHVlLm1hcCgodikgPT4gc3RyaW5naWZ5KHYsIHNlZW4pKSkuam9pbihcIiwgXCIpICsgXCIgXVwiO1xuICAgIH1cbiAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgICAgIGNvbnN0IEhFWCA9IFwiMDEyMzQ1Njc4OWFiY2RlZlwiO1xuICAgICAgICBsZXQgcmVzdWx0ID0gXCIweFwiO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gSEVYW3ZhbHVlW2ldID4+IDRdO1xuICAgICAgICAgICAgcmVzdWx0ICs9IEhFWFt2YWx1ZVtpXSAmIDB4Zl07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiAodmFsdWUpID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiAodmFsdWUudG9KU09OKSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHJldHVybiBzdHJpbmdpZnkodmFsdWUudG9KU09OKCksIHNlZW4pO1xuICAgIH1cbiAgICBzd2l0Y2ggKHR5cGVvZiAodmFsdWUpKSB7XG4gICAgICAgIGNhc2UgXCJib29sZWFuXCI6XG4gICAgICAgIGNhc2UgXCJudW1iZXJcIjpcbiAgICAgICAgY2FzZSBcInN5bWJvbFwiOlxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlLnRvU3RyaW5nKCk7XG4gICAgICAgIGNhc2UgXCJiaWdpbnRcIjpcbiAgICAgICAgICAgIHJldHVybiBCaWdJbnQodmFsdWUpLnRvU3RyaW5nKCk7XG4gICAgICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh2YWx1ZSk7XG4gICAgICAgIGNhc2UgXCJvYmplY3RcIjoge1xuICAgICAgICAgICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHZhbHVlKTtcbiAgICAgICAgICAgIGtleXMuc29ydCgpO1xuICAgICAgICAgICAgcmV0dXJuIFwieyBcIiArIGtleXMubWFwKChrKSA9PiBgJHtzdHJpbmdpZnkoaywgc2Vlbil9OiAke3N0cmluZ2lmeSh2YWx1ZVtrXSwgc2Vlbil9YCkuam9pbihcIiwgXCIpICsgXCIgfVwiO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBgWyBDT1VMRCBOT1QgU0VSSUFMSVpFIF1gO1xufVxuLyoqXG4gKiAgUmV0dXJucyB0cnVlIGlmIHRoZSAlJWVycm9yJSUgbWF0Y2hlcyBhbiBlcnJvciB0aHJvd24gYnkgZXRoZXJzXG4gKiAgdGhhdCBtYXRjaGVzIHRoZSBlcnJvciAlJWNvZGUlJS5cbiAqXG4gKiAgSW4gVHlwZVNjcmlwdCBlbnZpcm9ubWVudHMsIHRoaXMgY2FuIGJlIHVzZWQgdG8gY2hlY2sgdGhhdCAlJWVycm9yJSVcbiAqICBtYXRjaGVzIGFuIEV0aGVyc0Vycm9yIHR5cGUsIHdoaWNoIG1lYW5zIHRoZSBleHBlY3RlZCBwcm9wZXJ0aWVzIHdpbGxcbiAqICBiZSBzZXQuXG4gKlxuICogIEBTZWUgW0Vycm9yQ29kZXNdKGFwaTpFcnJvckNvZGUpXG4gKiAgQGV4YW1wbGVcbiAqICAgIHRyeSB7XG4gKiAgICAgIC8vIGNvZGUuLi4uXG4gKiAgICB9IGNhdGNoIChlKSB7XG4gKiAgICAgIGlmIChpc0Vycm9yKGUsIFwiQ0FMTF9FWENFUFRJT05cIikpIHtcbiAqICAgICAgICAgIC8vIFRoZSBUeXBlIEd1YXJkIGhhcyB2YWxpZGF0ZWQgdGhpcyBvYmplY3RcbiAqICAgICAgICAgIGNvbnNvbGUubG9nKGUuZGF0YSk7XG4gKiAgICAgIH1cbiAqICAgIH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzRXJyb3IoZXJyb3IsIGNvZGUpIHtcbiAgICByZXR1cm4gKGVycm9yICYmIGVycm9yLmNvZGUgPT09IGNvZGUpO1xufVxuLyoqXG4gKiAgUmV0dXJucyB0cnVlIGlmICUlZXJyb3IlJSBpcyBhIFtbQ2FsbEV4Y2VwdGlvbkVycm9yXS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzQ2FsbEV4Y2VwdGlvbihlcnJvcikge1xuICAgIHJldHVybiBpc0Vycm9yKGVycm9yLCBcIkNBTExfRVhDRVBUSU9OXCIpO1xufVxuLyoqXG4gKiAgUmV0dXJucyBhIG5ldyBFcnJvciBjb25maWd1cmVkIHRvIHRoZSBmb3JtYXQgZXRoZXJzIGVtaXRzIGVycm9ycywgd2l0aFxuICogIHRoZSAlJW1lc3NhZ2UlJSwgW1thcGk6RXJyb3JDb2RlXV0gJSVjb2RlJSUgYW5kIGFkZGl0aW9uYWwgcHJvcGVydGllc1xuICogIGZvciB0aGUgY29ycmVzcG9uZGluZyBFdGhlcnNFcnJvci5cbiAqXG4gKiAgRWFjaCBlcnJvciBpbiBldGhlcnMgaW5jbHVkZXMgdGhlIHZlcnNpb24gb2YgZXRoZXJzLCBhXG4gKiAgbWFjaGluZS1yZWFkYWJsZSBbW0Vycm9yQ29kZV1dLCBhbmQgZGVwZW5kaW5nIG9uICUlY29kZSUlLCBhZGRpdGlvbmFsXG4gKiAgcmVxdWlyZWQgcHJvcGVydGllcy4gVGhlIGVycm9yIG1lc3NhZ2Ugd2lsbCBhbHNvIGluY2x1ZGUgdGhlICUlbWVzc2FnZSUlLFxuICogIGV0aGVycyB2ZXJzaW9uLCAlJWNvZGUlJSBhbmQgYWxsIGFkZGl0aW9uYWwgcHJvcGVydGllcywgc2VyaWFsaXplZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1ha2VFcnJvcihtZXNzYWdlLCBjb2RlLCBpbmZvKSB7XG4gICAgbGV0IHNob3J0TWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAge1xuICAgICAgICBjb25zdCBkZXRhaWxzID0gW107XG4gICAgICAgIGlmIChpbmZvKSB7XG4gICAgICAgICAgICBpZiAoXCJtZXNzYWdlXCIgaW4gaW5mbyB8fCBcImNvZGVcIiBpbiBpbmZvIHx8IFwibmFtZVwiIGluIGluZm8pIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHZhbHVlIHdpbGwgb3ZlcndyaXRlIHBvcHVsYXRlZCB2YWx1ZXM6ICR7c3RyaW5naWZ5KGluZm8pfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gaW5mbykge1xuICAgICAgICAgICAgICAgIGlmIChrZXkgPT09IFwic2hvcnRNZXNzYWdlXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gKGluZm9ba2V5XSk7XG4gICAgICAgICAgICAgICAgLy8gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBkZXRhaWxzLnB1c2goa2V5ICsgXCI9XCIgKyBzdHJpbmdpZnkodmFsdWUpKTtcbiAgICAgICAgICAgICAgICAvLyAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgICAgICAgICAgICAgLy8gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJNTU1cIiwgZXJyb3IubWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgLy8gICAgICAgICAgICAgICAgICAgIGRldGFpbHMucHVzaChrZXkgKyBcIj1bY291bGQgbm90IHNlcmlhbGl6ZSBvYmplY3RdXCIpO1xuICAgICAgICAgICAgICAgIC8vICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBkZXRhaWxzLnB1c2goYGNvZGU9JHtjb2RlfWApO1xuICAgICAgICBkZXRhaWxzLnB1c2goYHZlcnNpb249JHt2ZXJzaW9ufWApO1xuICAgICAgICBpZiAoZGV0YWlscy5sZW5ndGgpIHtcbiAgICAgICAgICAgIG1lc3NhZ2UgKz0gXCIgKFwiICsgZGV0YWlscy5qb2luKFwiLCBcIikgKyBcIilcIjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBsZXQgZXJyb3I7XG4gICAgc3dpdGNoIChjb2RlKSB7XG4gICAgICAgIGNhc2UgXCJJTlZBTElEX0FSR1VNRU5UXCI6XG4gICAgICAgICAgICBlcnJvciA9IG5ldyBUeXBlRXJyb3IobWVzc2FnZSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIk5VTUVSSUNfRkFVTFRcIjpcbiAgICAgICAgY2FzZSBcIkJVRkZFUl9PVkVSUlVOXCI6XG4gICAgICAgICAgICBlcnJvciA9IG5ldyBSYW5nZUVycm9yKG1lc3NhZ2UpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBlcnJvciA9IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICB9XG4gICAgZGVmaW5lUHJvcGVydGllcyhlcnJvciwgeyBjb2RlIH0pO1xuICAgIGlmIChpbmZvKSB7XG4gICAgICAgIE9iamVjdC5hc3NpZ24oZXJyb3IsIGluZm8pO1xuICAgIH1cbiAgICBpZiAoZXJyb3Iuc2hvcnRNZXNzYWdlID09IG51bGwpIHtcbiAgICAgICAgZGVmaW5lUHJvcGVydGllcyhlcnJvciwgeyBzaG9ydE1lc3NhZ2UgfSk7XG4gICAgfVxuICAgIHJldHVybiBlcnJvcjtcbn1cbi8qKlxuICogIFRocm93cyBhbiBFdGhlcnNFcnJvciB3aXRoICUlbWVzc2FnZSUlLCAlJWNvZGUlJSBhbmQgYWRkaXRpb25hbCBlcnJvclxuICogICUlaW5mbyUlIHdoZW4gJSVjaGVjayUlIGlzIGZhbHNpc2guLlxuICpcbiAqICBAc2VlIFtbYXBpOm1ha2VFcnJvcl1dXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnQoY2hlY2ssIG1lc3NhZ2UsIGNvZGUsIGluZm8pIHtcbiAgICBpZiAoIWNoZWNrKSB7XG4gICAgICAgIHRocm93IG1ha2VFcnJvcihtZXNzYWdlLCBjb2RlLCBpbmZvKTtcbiAgICB9XG59XG4vKipcbiAqICBBIHNpbXBsZSBoZWxwZXIgdG8gc2ltcGx5IGVuc3VyaW5nIHByb3ZpZGVkIGFyZ3VtZW50cyBtYXRjaCBleHBlY3RlZFxuICogIGNvbnN0cmFpbnRzLCB0aHJvd2luZyBpZiBub3QuXG4gKlxuICogIEluIFR5cGVTY3JpcHQgZW52aXJvbm1lbnRzLCB0aGUgJSVjaGVjayUlIGhhcyBiZWVuIGFzc2VydGVkIHRydWUsIHNvXG4gKiAgYW55IGZ1cnRoZXIgY29kZSBkb2VzIG5vdCBuZWVkIGFkZGl0aW9uYWwgY29tcGlsZS10aW1lIGNoZWNrcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFzc2VydEFyZ3VtZW50KGNoZWNrLCBtZXNzYWdlLCBuYW1lLCB2YWx1ZSkge1xuICAgIGFzc2VydChjaGVjaywgbWVzc2FnZSwgXCJJTlZBTElEX0FSR1VNRU5UXCIsIHsgYXJndW1lbnQ6IG5hbWUsIHZhbHVlOiB2YWx1ZSB9KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnRBcmd1bWVudENvdW50KGNvdW50LCBleHBlY3RlZENvdW50LCBtZXNzYWdlKSB7XG4gICAgaWYgKG1lc3NhZ2UgPT0gbnVsbCkge1xuICAgICAgICBtZXNzYWdlID0gXCJcIjtcbiAgICB9XG4gICAgaWYgKG1lc3NhZ2UpIHtcbiAgICAgICAgbWVzc2FnZSA9IFwiOiBcIiArIG1lc3NhZ2U7XG4gICAgfVxuICAgIGFzc2VydChjb3VudCA+PSBleHBlY3RlZENvdW50LCBcIm1pc3NpbmcgYXJndW1lbnRcIiArIG1lc3NhZ2UsIFwiTUlTU0lOR19BUkdVTUVOVFwiLCB7XG4gICAgICAgIGNvdW50OiBjb3VudCxcbiAgICAgICAgZXhwZWN0ZWRDb3VudDogZXhwZWN0ZWRDb3VudFxuICAgIH0pO1xuICAgIGFzc2VydChjb3VudCA8PSBleHBlY3RlZENvdW50LCBcInRvbyBtYW55IGFyZ3VtZW50c1wiICsgbWVzc2FnZSwgXCJVTkVYUEVDVEVEX0FSR1VNRU5UXCIsIHtcbiAgICAgICAgY291bnQ6IGNvdW50LFxuICAgICAgICBleHBlY3RlZENvdW50OiBleHBlY3RlZENvdW50XG4gICAgfSk7XG59XG5jb25zdCBfbm9ybWFsaXplRm9ybXMgPSBbXCJORkRcIiwgXCJORkNcIiwgXCJORktEXCIsIFwiTkZLQ1wiXS5yZWR1Y2UoKGFjY3VtLCBmb3JtKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gR2VuZXJhbCB0ZXN0IGZvciBub3JtYWxpemVcbiAgICAgICAgLyogYzggaWdub3JlIHN0YXJ0ICovXG4gICAgICAgIGlmIChcInRlc3RcIi5ub3JtYWxpemUoZm9ybSkgIT09IFwidGVzdFwiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJiYWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgO1xuICAgICAgICAvKiBjOCBpZ25vcmUgc3RvcCAqL1xuICAgICAgICBpZiAoZm9ybSA9PT0gXCJORkRcIikge1xuICAgICAgICAgICAgY29uc3QgY2hlY2sgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4ZTkpLm5vcm1hbGl6ZShcIk5GRFwiKTtcbiAgICAgICAgICAgIGNvbnN0IGV4cGVjdGVkID0gU3RyaW5nLmZyb21DaGFyQ29kZSgweDY1LCAweDAzMDEpO1xuICAgICAgICAgICAgLyogYzggaWdub3JlIHN0YXJ0ICovXG4gICAgICAgICAgICBpZiAoY2hlY2sgIT09IGV4cGVjdGVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYnJva2VuXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLyogYzggaWdub3JlIHN0b3AgKi9cbiAgICAgICAgfVxuICAgICAgICBhY2N1bS5wdXNoKGZvcm0pO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHsgfVxuICAgIHJldHVybiBhY2N1bTtcbn0sIFtdKTtcbi8qKlxuICogIFRocm93cyBpZiB0aGUgbm9ybWFsaXphdGlvbiAlJWZvcm0lJSBpcyBub3Qgc3VwcG9ydGVkLlxuICovXG5leHBvcnQgZnVuY3Rpb24gYXNzZXJ0Tm9ybWFsaXplKGZvcm0pIHtcbiAgICBhc3NlcnQoX25vcm1hbGl6ZUZvcm1zLmluZGV4T2YoZm9ybSkgPj0gMCwgXCJwbGF0Zm9ybSBtaXNzaW5nIFN0cmluZy5wcm90b3R5cGUubm9ybWFsaXplXCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHtcbiAgICAgICAgb3BlcmF0aW9uOiBcIlN0cmluZy5wcm90b3R5cGUubm9ybWFsaXplXCIsIGluZm86IHsgZm9ybSB9XG4gICAgfSk7XG59XG4vKipcbiAqICBNYW55IGNsYXNzZXMgdXNlIGZpbGUtc2NvcGVkIHZhbHVlcyB0byBndWFyZCB0aGUgY29uc3RydWN0b3IsXG4gKiAgbWFraW5nIGl0IGVmZmVjdGl2ZWx5IHByaXZhdGUuIFRoaXMgZmFjaWxpdGF0ZXMgdGhhdCBwYXR0ZXJuXG4gKiAgYnkgZW5zdXJpbmcgdGhlICUlZ2l2ZW5HYXVyZCUlIG1hdGNoZXMgdGhlIGZpbGUtc2NvcGVkICUlZ3VhcmQlJSxcbiAqICB0aHJvd2luZyBpZiBub3QsIGluZGljYXRpbmcgdGhlICUlY2xhc3NOYW1lJSUgaWYgcHJvdmlkZWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnRQcml2YXRlKGdpdmVuR3VhcmQsIGd1YXJkLCBjbGFzc05hbWUpIHtcbiAgICBpZiAoY2xhc3NOYW1lID09IG51bGwpIHtcbiAgICAgICAgY2xhc3NOYW1lID0gXCJcIjtcbiAgICB9XG4gICAgaWYgKGdpdmVuR3VhcmQgIT09IGd1YXJkKSB7XG4gICAgICAgIGxldCBtZXRob2QgPSBjbGFzc05hbWUsIG9wZXJhdGlvbiA9IFwibmV3XCI7XG4gICAgICAgIGlmIChjbGFzc05hbWUpIHtcbiAgICAgICAgICAgIG1ldGhvZCArPSBcIi5cIjtcbiAgICAgICAgICAgIG9wZXJhdGlvbiArPSBcIiBcIiArIGNsYXNzTmFtZTtcbiAgICAgICAgfVxuICAgICAgICBhc3NlcnQoZmFsc2UsIGBwcml2YXRlIGNvbnN0cnVjdG9yOyB1c2UgJHttZXRob2R9ZnJvbSogbWV0aG9kc2AsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHtcbiAgICAgICAgICAgIG9wZXJhdGlvblxuICAgICAgICB9KTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1lcnJvcnMuanMubWFwIl0sIm5hbWVzIjpbInZlcnNpb24iLCJkZWZpbmVQcm9wZXJ0aWVzIiwic3RyaW5naWZ5IiwidmFsdWUiLCJzZWVuIiwiU2V0IiwiaGFzIiwiYWRkIiwiQXJyYXkiLCJpc0FycmF5IiwibWFwIiwidiIsImpvaW4iLCJVaW50OEFycmF5IiwiSEVYIiwicmVzdWx0IiwiaSIsImxlbmd0aCIsInRvSlNPTiIsInRvU3RyaW5nIiwiQmlnSW50IiwiSlNPTiIsImtleXMiLCJPYmplY3QiLCJzb3J0IiwiayIsImlzRXJyb3IiLCJlcnJvciIsImNvZGUiLCJpc0NhbGxFeGNlcHRpb24iLCJtYWtlRXJyb3IiLCJtZXNzYWdlIiwiaW5mbyIsInNob3J0TWVzc2FnZSIsImRldGFpbHMiLCJFcnJvciIsImtleSIsInB1c2giLCJUeXBlRXJyb3IiLCJSYW5nZUVycm9yIiwiYXNzaWduIiwiYXNzZXJ0IiwiY2hlY2siLCJhc3NlcnRBcmd1bWVudCIsIm5hbWUiLCJhcmd1bWVudCIsImFzc2VydEFyZ3VtZW50Q291bnQiLCJjb3VudCIsImV4cGVjdGVkQ291bnQiLCJfbm9ybWFsaXplRm9ybXMiLCJyZWR1Y2UiLCJhY2N1bSIsImZvcm0iLCJub3JtYWxpemUiLCJTdHJpbmciLCJmcm9tQ2hhckNvZGUiLCJleHBlY3RlZCIsImFzc2VydE5vcm1hbGl6ZSIsImluZGV4T2YiLCJvcGVyYXRpb24iLCJhc3NlcnRQcml2YXRlIiwiZ2l2ZW5HdWFyZCIsImd1YXJkIiwiY2xhc3NOYW1lIiwibWV0aG9kIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ethers/lib.esm/utils/errors.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ethers/lib.esm/utils/fixednumber.js":
/*!**********************************************************!*\
  !*** ./node_modules/ethers/lib.esm/utils/fixednumber.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FixedNumber: () => (/* binding */ FixedNumber)\n/* harmony export */ });\n/* harmony import */ var _data_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./data.js */ \"(rsc)/./node_modules/ethers/lib.esm/utils/data.js\");\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./errors.js */ \"(rsc)/./node_modules/ethers/lib.esm/utils/errors.js\");\n/* harmony import */ var _maths_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./maths.js */ \"(rsc)/./node_modules/ethers/lib.esm/utils/maths.js\");\n/* harmony import */ var _properties_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./properties.js */ \"(rsc)/./node_modules/ethers/lib.esm/utils/properties.js\");\n/**\n *  The **FixedNumber** class permits using values with decimal places,\n *  using fixed-pont math.\n *\n *  Fixed-point math is still based on integers under-the-hood, but uses an\n *  internal offset to store fractional components below, and each operation\n *  corrects for this after each operation.\n *\n *  @_section: api/utils/fixed-point-math:Fixed-Point Maths  [about-fixed-point-math]\n */ \n\n\n\nconst BN_N1 = BigInt(-1);\nconst BN_0 = BigInt(0);\nconst BN_1 = BigInt(1);\nconst BN_5 = BigInt(5);\nconst _guard = {};\n// Constant to pull zeros from for multipliers\nlet Zeros = \"0000\";\nwhile(Zeros.length < 80){\n    Zeros += Zeros;\n}\n// Returns a string \"1\" followed by decimal \"0\"s\nfunction getTens(decimals) {\n    let result = Zeros;\n    while(result.length < decimals){\n        result += result;\n    }\n    return BigInt(\"1\" + result.substring(0, decimals));\n}\nfunction checkValue(val, format, safeOp) {\n    const width = BigInt(format.width);\n    if (format.signed) {\n        const limit = BN_1 << width - BN_1;\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assert)(safeOp == null || val >= -limit && val < limit, \"overflow\", \"NUMERIC_FAULT\", {\n            operation: safeOp,\n            fault: \"overflow\",\n            value: val\n        });\n        if (val > BN_0) {\n            val = (0,_maths_js__WEBPACK_IMPORTED_MODULE_1__.fromTwos)((0,_maths_js__WEBPACK_IMPORTED_MODULE_1__.mask)(val, width), width);\n        } else {\n            val = -(0,_maths_js__WEBPACK_IMPORTED_MODULE_1__.fromTwos)((0,_maths_js__WEBPACK_IMPORTED_MODULE_1__.mask)(-val, width), width);\n        }\n    } else {\n        const limit = BN_1 << width;\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assert)(safeOp == null || val >= 0 && val < limit, \"overflow\", \"NUMERIC_FAULT\", {\n            operation: safeOp,\n            fault: \"overflow\",\n            value: val\n        });\n        val = (val % limit + limit) % limit & limit - BN_1;\n    }\n    return val;\n}\nfunction getFormat(value) {\n    if (typeof value === \"number\") {\n        value = `fixed128x${value}`;\n    }\n    let signed = true;\n    let width = 128;\n    let decimals = 18;\n    if (typeof value === \"string\") {\n        // Parse the format string\n        if (value === \"fixed\") {\n        // defaults...\n        } else if (value === \"ufixed\") {\n            signed = false;\n        } else {\n            const match = value.match(/^(u?)fixed([0-9]+)x([0-9]+)$/);\n            (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(match, \"invalid fixed format\", \"format\", value);\n            signed = match[1] !== \"u\";\n            width = parseInt(match[2]);\n            decimals = parseInt(match[3]);\n        }\n    } else if (value) {\n        // Extract the values from the object\n        const v = value;\n        const check = (key, type, defaultValue)=>{\n            if (v[key] == null) {\n                return defaultValue;\n            }\n            (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(typeof v[key] === type, \"invalid fixed format (\" + key + \" not \" + type + \")\", \"format.\" + key, v[key]);\n            return v[key];\n        };\n        signed = check(\"signed\", \"boolean\", signed);\n        width = check(\"width\", \"number\", width);\n        decimals = check(\"decimals\", \"number\", decimals);\n    }\n    (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(width % 8 === 0, \"invalid FixedNumber width (not byte aligned)\", \"format.width\", width);\n    (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(decimals <= 80, \"invalid FixedNumber decimals (too large)\", \"format.decimals\", decimals);\n    const name = (signed ? \"\" : \"u\") + \"fixed\" + String(width) + \"x\" + String(decimals);\n    return {\n        signed,\n        width,\n        decimals,\n        name\n    };\n}\nfunction toString(val, decimals) {\n    let negative = \"\";\n    if (val < BN_0) {\n        negative = \"-\";\n        val *= BN_N1;\n    }\n    let str = val.toString();\n    // No decimal point for whole values\n    if (decimals === 0) {\n        return negative + str;\n    }\n    // Pad out to the whole component (including a whole digit)\n    while(str.length <= decimals){\n        str = Zeros + str;\n    }\n    // Insert the decimal point\n    const index = str.length - decimals;\n    str = str.substring(0, index) + \".\" + str.substring(index);\n    // Trim the whole component (leaving at least one 0)\n    while(str[0] === \"0\" && str[1] !== \".\"){\n        str = str.substring(1);\n    }\n    // Trim the decimal component (leaving at least one 0)\n    while(str[str.length - 1] === \"0\" && str[str.length - 2] !== \".\"){\n        str = str.substring(0, str.length - 1);\n    }\n    return negative + str;\n}\n/**\n *  A FixedNumber represents a value over its [[FixedFormat]]\n *  arithmetic field.\n *\n *  A FixedNumber can be used to perform math, losslessly, on\n *  values which have decmial places.\n *\n *  A FixedNumber has a fixed bit-width to store values in, and stores all\n *  values internally by multiplying the value by 10 raised to the power of\n *  %%decimals%%.\n *\n *  If operations are performed that cause a value to grow too high (close to\n *  positive infinity) or too low (close to negative infinity), the value\n *  is said to //overflow//.\n *\n *  For example, an 8-bit signed value, with 0 decimals may only be within\n *  the range ``-128`` to ``127``; so ``-128 - 1`` will overflow and become\n *  ``127``. Likewise, ``127 + 1`` will overflow and become ``-127``.\n *\n *  Many operation have a normal and //unsafe// variant. The normal variant\n *  will throw a [[NumericFaultError]] on any overflow, while the //unsafe//\n *  variant will silently allow overflow, corrupting its value value.\n *\n *  If operations are performed that cause a value to become too small\n *  (close to zero), the value loses precison and is said to //underflow//.\n *\n *  For example, a value with 1 decimal place may store a number as small\n *  as ``0.1``, but the value of ``0.1 / 2`` is ``0.05``, which cannot fit\n *  into 1 decimal place, so underflow occurs which means precision is lost\n *  and the value becomes ``0``.\n *\n *  Some operations have a normal and //signalling// variant. The normal\n *  variant will silently ignore underflow, while the //signalling// variant\n *  will thow a [[NumericFaultError]] on underflow.\n */ class FixedNumber {\n    #format;\n    // The actual value (accounting for decimals)\n    #val;\n    // A base-10 value to multiple values by to maintain the magnitude\n    #tens;\n    // Use this when changing this file to get some typing info,\n    // but then switch to any to mask the internal type\n    //constructor(guard: any, value: bigint, format: _FixedFormat) {\n    /**\n     *  @private\n     */ constructor(guard, value, format){\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertPrivate)(guard, _guard, \"FixedNumber\");\n        this.#val = value;\n        this.#format = format;\n        const _value = toString(value, format.decimals);\n        (0,_properties_js__WEBPACK_IMPORTED_MODULE_2__.defineProperties)(this, {\n            format: format.name,\n            _value\n        });\n        this.#tens = getTens(format.decimals);\n    }\n    /**\n     *  If true, negative values are permitted, otherwise only\n     *  positive values and zero are allowed.\n     */ get signed() {\n        return this.#format.signed;\n    }\n    /**\n     *  The number of bits available to store the value.\n     */ get width() {\n        return this.#format.width;\n    }\n    /**\n     *  The number of decimal places in the fixed-point arithment field.\n     */ get decimals() {\n        return this.#format.decimals;\n    }\n    /**\n     *  The value as an integer, based on the smallest unit the\n     *  [[decimals]] allow.\n     */ get value() {\n        return this.#val;\n    }\n    #checkFormat(other) {\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(this.format === other.format, \"incompatible format; use fixedNumber.toFormat\", \"other\", other);\n    }\n    #checkValue(val, safeOp) {\n        /*\n                const width = BigInt(this.width);\n                if (this.signed) {\n                    const limit = (BN_1 << (width - BN_1));\n                    assert(safeOp == null || (val >= -limit  && val < limit), \"overflow\", \"NUMERIC_FAULT\", {\n                        operation: <string>safeOp, fault: \"overflow\", value: val\n                    });\n        \n                    if (val > BN_0) {\n                        val = fromTwos(mask(val, width), width);\n                    } else {\n                        val = -fromTwos(mask(-val, width), width);\n                    }\n        \n                } else {\n                    const masked = mask(val, width);\n                    assert(safeOp == null || (val >= 0 && val === masked), \"overflow\", \"NUMERIC_FAULT\", {\n                        operation: <string>safeOp, fault: \"overflow\", value: val\n                    });\n                    val = masked;\n                }\n        */ val = checkValue(val, this.#format, safeOp);\n        return new FixedNumber(_guard, val, this.#format);\n    }\n    #add(o, safeOp) {\n        this.#checkFormat(o);\n        return this.#checkValue(this.#val + o.#val, safeOp);\n    }\n    /**\n     *  Returns a new [[FixedNumber]] with the result of %%this%% added\n     *  to %%other%%, ignoring overflow.\n     */ addUnsafe(other) {\n        return this.#add(other);\n    }\n    /**\n     *  Returns a new [[FixedNumber]] with the result of %%this%% added\n     *  to %%other%%. A [[NumericFaultError]] is thrown if overflow\n     *  occurs.\n     */ add(other) {\n        return this.#add(other, \"add\");\n    }\n    #sub(o, safeOp) {\n        this.#checkFormat(o);\n        return this.#checkValue(this.#val - o.#val, safeOp);\n    }\n    /**\n     *  Returns a new [[FixedNumber]] with the result of %%other%% subtracted\n     *  from %%this%%, ignoring overflow.\n     */ subUnsafe(other) {\n        return this.#sub(other);\n    }\n    /**\n     *  Returns a new [[FixedNumber]] with the result of %%other%% subtracted\n     *  from %%this%%. A [[NumericFaultError]] is thrown if overflow\n     *  occurs.\n     */ sub(other) {\n        return this.#sub(other, \"sub\");\n    }\n    #mul(o, safeOp) {\n        this.#checkFormat(o);\n        return this.#checkValue(this.#val * o.#val / this.#tens, safeOp);\n    }\n    /**\n     *  Returns a new [[FixedNumber]] with the result of %%this%% multiplied\n     *  by %%other%%, ignoring overflow and underflow (precision loss).\n     */ mulUnsafe(other) {\n        return this.#mul(other);\n    }\n    /**\n     *  Returns a new [[FixedNumber]] with the result of %%this%% multiplied\n     *  by %%other%%. A [[NumericFaultError]] is thrown if overflow\n     *  occurs.\n     */ mul(other) {\n        return this.#mul(other, \"mul\");\n    }\n    /**\n     *  Returns a new [[FixedNumber]] with the result of %%this%% multiplied\n     *  by %%other%%. A [[NumericFaultError]] is thrown if overflow\n     *  occurs or if underflow (precision loss) occurs.\n     */ mulSignal(other) {\n        this.#checkFormat(other);\n        const value = this.#val * other.#val;\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assert)(value % this.#tens === BN_0, \"precision lost during signalling mul\", \"NUMERIC_FAULT\", {\n            operation: \"mulSignal\",\n            fault: \"underflow\",\n            value: this\n        });\n        return this.#checkValue(value / this.#tens, \"mulSignal\");\n    }\n    #div(o, safeOp) {\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assert)(o.#val !== BN_0, \"division by zero\", \"NUMERIC_FAULT\", {\n            operation: \"div\",\n            fault: \"divide-by-zero\",\n            value: this\n        });\n        this.#checkFormat(o);\n        return this.#checkValue(this.#val * this.#tens / o.#val, safeOp);\n    }\n    /**\n     *  Returns a new [[FixedNumber]] with the result of %%this%% divided\n     *  by %%other%%, ignoring underflow (precision loss). A\n     *  [[NumericFaultError]] is thrown if overflow occurs.\n     */ divUnsafe(other) {\n        return this.#div(other);\n    }\n    /**\n     *  Returns a new [[FixedNumber]] with the result of %%this%% divided\n     *  by %%other%%, ignoring underflow (precision loss). A\n     *  [[NumericFaultError]] is thrown if overflow occurs.\n     */ div(other) {\n        return this.#div(other, \"div\");\n    }\n    /**\n     *  Returns a new [[FixedNumber]] with the result of %%this%% divided\n     *  by %%other%%. A [[NumericFaultError]] is thrown if underflow\n     *  (precision loss) occurs.\n     */ divSignal(other) {\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assert)(other.#val !== BN_0, \"division by zero\", \"NUMERIC_FAULT\", {\n            operation: \"div\",\n            fault: \"divide-by-zero\",\n            value: this\n        });\n        this.#checkFormat(other);\n        const value = this.#val * this.#tens;\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assert)(value % other.#val === BN_0, \"precision lost during signalling div\", \"NUMERIC_FAULT\", {\n            operation: \"divSignal\",\n            fault: \"underflow\",\n            value: this\n        });\n        return this.#checkValue(value / other.#val, \"divSignal\");\n    }\n    /**\n     *  Returns a comparison result between %%this%% and %%other%%.\n     *\n     *  This is suitable for use in sorting, where ``-1`` implies %%this%%\n     *  is smaller, ``1`` implies %%this%% is larger and ``0`` implies\n     *  both are equal.\n     */ cmp(other) {\n        let a = this.value, b = other.value;\n        // Coerce a and b to the same magnitude\n        const delta = this.decimals - other.decimals;\n        if (delta > 0) {\n            b *= getTens(delta);\n        } else if (delta < 0) {\n            a *= getTens(-delta);\n        }\n        // Comnpare\n        if (a < b) {\n            return -1;\n        }\n        if (a > b) {\n            return 1;\n        }\n        return 0;\n    }\n    /**\n     *  Returns true if %%other%% is equal to %%this%%.\n     */ eq(other) {\n        return this.cmp(other) === 0;\n    }\n    /**\n     *  Returns true if %%other%% is less than to %%this%%.\n     */ lt(other) {\n        return this.cmp(other) < 0;\n    }\n    /**\n     *  Returns true if %%other%% is less than or equal to %%this%%.\n     */ lte(other) {\n        return this.cmp(other) <= 0;\n    }\n    /**\n     *  Returns true if %%other%% is greater than to %%this%%.\n     */ gt(other) {\n        return this.cmp(other) > 0;\n    }\n    /**\n     *  Returns true if %%other%% is greater than or equal to %%this%%.\n     */ gte(other) {\n        return this.cmp(other) >= 0;\n    }\n    /**\n     *  Returns a new [[FixedNumber]] which is the largest **integer**\n     *  that is less than or equal to %%this%%.\n     *\n     *  The decimal component of the result will always be ``0``.\n     */ floor() {\n        let val = this.#val;\n        if (this.#val < BN_0) {\n            val -= this.#tens - BN_1;\n        }\n        val = this.#val / this.#tens * this.#tens;\n        return this.#checkValue(val, \"floor\");\n    }\n    /**\n     *  Returns a new [[FixedNumber]] which is the smallest **integer**\n     *  that is greater than or equal to %%this%%.\n     *\n     *  The decimal component of the result will always be ``0``.\n     */ ceiling() {\n        let val = this.#val;\n        if (this.#val > BN_0) {\n            val += this.#tens - BN_1;\n        }\n        val = this.#val / this.#tens * this.#tens;\n        return this.#checkValue(val, \"ceiling\");\n    }\n    /**\n     *  Returns a new [[FixedNumber]] with the decimal component\n     *  rounded up on ties at %%decimals%% places.\n     */ round(decimals) {\n        if (decimals == null) {\n            decimals = 0;\n        }\n        // Not enough precision to not already be rounded\n        if (decimals >= this.decimals) {\n            return this;\n        }\n        const delta = this.decimals - decimals;\n        const bump = BN_5 * getTens(delta - 1);\n        let value = this.value + bump;\n        const tens = getTens(delta);\n        value = value / tens * tens;\n        checkValue(value, this.#format, \"round\");\n        return new FixedNumber(_guard, value, this.#format);\n    }\n    /**\n     *  Returns true if %%this%% is equal to ``0``.\n     */ isZero() {\n        return this.#val === BN_0;\n    }\n    /**\n     *  Returns true if %%this%% is less than ``0``.\n     */ isNegative() {\n        return this.#val < BN_0;\n    }\n    /**\n     *  Returns the string representation of %%this%%.\n     */ toString() {\n        return this._value;\n    }\n    /**\n     *  Returns a float approximation.\n     *\n     *  Due to IEEE 754 precission (or lack thereof), this function\n     *  can only return an approximation and most values will contain\n     *  rounding errors.\n     */ toUnsafeFloat() {\n        return parseFloat(this.toString());\n    }\n    /**\n     *  Return a new [[FixedNumber]] with the same value but has had\n     *  its field set to %%format%%.\n     *\n     *  This will throw if the value cannot fit into %%format%%.\n     */ toFormat(format) {\n        return FixedNumber.fromString(this.toString(), format);\n    }\n    /**\n     *  Creates a new [[FixedNumber]] for %%value%% divided by\n     *  %%decimal%% places with %%format%%.\n     *\n     *  This will throw a [[NumericFaultError]] if %%value%% (once adjusted\n     *  for %%decimals%%) cannot fit in %%format%%, either due to overflow\n     *  or underflow (precision loss).\n     */ static fromValue(_value, _decimals, _format) {\n        const decimals = _decimals == null ? 0 : (0,_maths_js__WEBPACK_IMPORTED_MODULE_1__.getNumber)(_decimals);\n        const format = getFormat(_format);\n        let value = (0,_maths_js__WEBPACK_IMPORTED_MODULE_1__.getBigInt)(_value, \"value\");\n        const delta = decimals - format.decimals;\n        if (delta > 0) {\n            const tens = getTens(delta);\n            (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assert)(value % tens === BN_0, \"value loses precision for format\", \"NUMERIC_FAULT\", {\n                operation: \"fromValue\",\n                fault: \"underflow\",\n                value: _value\n            });\n            value /= tens;\n        } else if (delta < 0) {\n            value *= getTens(-delta);\n        }\n        checkValue(value, format, \"fromValue\");\n        return new FixedNumber(_guard, value, format);\n    }\n    /**\n     *  Creates a new [[FixedNumber]] for %%value%% with %%format%%.\n     *\n     *  This will throw a [[NumericFaultError]] if %%value%% cannot fit\n     *  in %%format%%, either due to overflow or underflow (precision loss).\n     */ static fromString(_value, _format) {\n        const match = _value.match(/^(-?)([0-9]*)\\.?([0-9]*)$/);\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(match && match[2].length + match[3].length > 0, \"invalid FixedNumber string value\", \"value\", _value);\n        const format = getFormat(_format);\n        let whole = match[2] || \"0\", decimal = match[3] || \"\";\n        // Pad out the decimals\n        while(decimal.length < format.decimals){\n            decimal += Zeros;\n        }\n        // Check precision is safe\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assert)(decimal.substring(format.decimals).match(/^0*$/), \"too many decimals for format\", \"NUMERIC_FAULT\", {\n            operation: \"fromString\",\n            fault: \"underflow\",\n            value: _value\n        });\n        // Remove extra padding\n        decimal = decimal.substring(0, format.decimals);\n        const value = BigInt(match[1] + whole + decimal);\n        checkValue(value, format, \"fromString\");\n        return new FixedNumber(_guard, value, format);\n    }\n    /**\n     *  Creates a new [[FixedNumber]] with the big-endian representation\n     *  %%value%% with %%format%%.\n     *\n     *  This will throw a [[NumericFaultError]] if %%value%% cannot fit\n     *  in %%format%% due to overflow.\n     */ static fromBytes(_value, _format) {\n        let value = (0,_maths_js__WEBPACK_IMPORTED_MODULE_1__.toBigInt)((0,_data_js__WEBPACK_IMPORTED_MODULE_3__.getBytes)(_value, \"value\"));\n        const format = getFormat(_format);\n        if (format.signed) {\n            value = (0,_maths_js__WEBPACK_IMPORTED_MODULE_1__.fromTwos)(value, format.width);\n        }\n        checkValue(value, format, \"fromBytes\");\n        return new FixedNumber(_guard, value, format);\n    }\n} //const f1 = FixedNumber.fromString(\"12.56\", \"fixed16x2\");\n //const f2 = FixedNumber.fromString(\"0.3\", \"fixed16x2\");\n //console.log(f1.divSignal(f2));\n //const BUMP = FixedNumber.from(\"0.5\");\n //# sourceMappingURL=fixednumber.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vdXRpbHMvZml4ZWRudW1iZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTs7Ozs7Ozs7O0NBU0MsR0FDb0M7QUFDK0I7QUFDUTtBQUN6QjtBQUNuRCxNQUFNVSxRQUFRQyxPQUFPLENBQUM7QUFDdEIsTUFBTUMsT0FBT0QsT0FBTztBQUNwQixNQUFNRSxPQUFPRixPQUFPO0FBQ3BCLE1BQU1HLE9BQU9ILE9BQU87QUFDcEIsTUFBTUksU0FBUyxDQUFDO0FBQ2hCLDhDQUE4QztBQUM5QyxJQUFJQyxRQUFRO0FBQ1osTUFBT0EsTUFBTUMsTUFBTSxHQUFHLEdBQUk7SUFDdEJELFNBQVNBO0FBQ2I7QUFDQSxnREFBZ0Q7QUFDaEQsU0FBU0UsUUFBUUMsUUFBUTtJQUNyQixJQUFJQyxTQUFTSjtJQUNiLE1BQU9JLE9BQU9ILE1BQU0sR0FBR0UsU0FBVTtRQUM3QkMsVUFBVUE7SUFDZDtJQUNBLE9BQU9ULE9BQU8sTUFBTVMsT0FBT0MsU0FBUyxDQUFDLEdBQUdGO0FBQzVDO0FBQ0EsU0FBU0csV0FBV0MsR0FBRyxFQUFFQyxNQUFNLEVBQUVDLE1BQU07SUFDbkMsTUFBTUMsUUFBUWYsT0FBT2EsT0FBT0UsS0FBSztJQUNqQyxJQUFJRixPQUFPRyxNQUFNLEVBQUU7UUFDZixNQUFNQyxRQUFTZixRQUFTYSxRQUFRYjtRQUNoQ1osa0RBQU1BLENBQUN3QixVQUFVLFFBQVNGLE9BQU8sQ0FBQ0ssU0FBU0wsTUFBTUssT0FBUSxZQUFZLGlCQUFpQjtZQUNsRkMsV0FBV0o7WUFBUUssT0FBTztZQUFZQyxPQUFPUjtRQUNqRDtRQUNBLElBQUlBLE1BQU1YLE1BQU07WUFDWlcsTUFBTWpCLG1EQUFRQSxDQUFDQywrQ0FBSUEsQ0FBQ2dCLEtBQUtHLFFBQVFBO1FBQ3JDLE9BQ0s7WUFDREgsTUFBTSxDQUFDakIsbURBQVFBLENBQUNDLCtDQUFJQSxDQUFDLENBQUNnQixLQUFLRyxRQUFRQTtRQUN2QztJQUNK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ZXRoZXJzL2xpYi5lc20vdXRpbHMvZml4ZWRudW1iZXIuanM/NDU0MyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqICBUaGUgKipGaXhlZE51bWJlcioqIGNsYXNzIHBlcm1pdHMgdXNpbmcgdmFsdWVzIHdpdGggZGVjaW1hbCBwbGFjZXMsXG4gKiAgdXNpbmcgZml4ZWQtcG9udCBtYXRoLlxuICpcbiAqICBGaXhlZC1wb2ludCBtYXRoIGlzIHN0aWxsIGJhc2VkIG9uIGludGVnZXJzIHVuZGVyLXRoZS1ob29kLCBidXQgdXNlcyBhblxuICogIGludGVybmFsIG9mZnNldCB0byBzdG9yZSBmcmFjdGlvbmFsIGNvbXBvbmVudHMgYmVsb3csIGFuZCBlYWNoIG9wZXJhdGlvblxuICogIGNvcnJlY3RzIGZvciB0aGlzIGFmdGVyIGVhY2ggb3BlcmF0aW9uLlxuICpcbiAqICBAX3NlY3Rpb246IGFwaS91dGlscy9maXhlZC1wb2ludC1tYXRoOkZpeGVkLVBvaW50IE1hdGhzICBbYWJvdXQtZml4ZWQtcG9pbnQtbWF0aF1cbiAqL1xuaW1wb3J0IHsgZ2V0Qnl0ZXMgfSBmcm9tIFwiLi9kYXRhLmpzXCI7XG5pbXBvcnQgeyBhc3NlcnQsIGFzc2VydEFyZ3VtZW50LCBhc3NlcnRQcml2YXRlIH0gZnJvbSBcIi4vZXJyb3JzLmpzXCI7XG5pbXBvcnQgeyBnZXRCaWdJbnQsIGdldE51bWJlciwgZnJvbVR3b3MsIG1hc2ssIHRvQmlnSW50IH0gZnJvbSBcIi4vbWF0aHMuanNcIjtcbmltcG9ydCB7IGRlZmluZVByb3BlcnRpZXMgfSBmcm9tIFwiLi9wcm9wZXJ0aWVzLmpzXCI7XG5jb25zdCBCTl9OMSA9IEJpZ0ludCgtMSk7XG5jb25zdCBCTl8wID0gQmlnSW50KDApO1xuY29uc3QgQk5fMSA9IEJpZ0ludCgxKTtcbmNvbnN0IEJOXzUgPSBCaWdJbnQoNSk7XG5jb25zdCBfZ3VhcmQgPSB7fTtcbi8vIENvbnN0YW50IHRvIHB1bGwgemVyb3MgZnJvbSBmb3IgbXVsdGlwbGllcnNcbmxldCBaZXJvcyA9IFwiMDAwMFwiO1xud2hpbGUgKFplcm9zLmxlbmd0aCA8IDgwKSB7XG4gICAgWmVyb3MgKz0gWmVyb3M7XG59XG4vLyBSZXR1cm5zIGEgc3RyaW5nIFwiMVwiIGZvbGxvd2VkIGJ5IGRlY2ltYWwgXCIwXCJzXG5mdW5jdGlvbiBnZXRUZW5zKGRlY2ltYWxzKSB7XG4gICAgbGV0IHJlc3VsdCA9IFplcm9zO1xuICAgIHdoaWxlIChyZXN1bHQubGVuZ3RoIDwgZGVjaW1hbHMpIHtcbiAgICAgICAgcmVzdWx0ICs9IHJlc3VsdDtcbiAgICB9XG4gICAgcmV0dXJuIEJpZ0ludChcIjFcIiArIHJlc3VsdC5zdWJzdHJpbmcoMCwgZGVjaW1hbHMpKTtcbn1cbmZ1bmN0aW9uIGNoZWNrVmFsdWUodmFsLCBmb3JtYXQsIHNhZmVPcCkge1xuICAgIGNvbnN0IHdpZHRoID0gQmlnSW50KGZvcm1hdC53aWR0aCk7XG4gICAgaWYgKGZvcm1hdC5zaWduZWQpIHtcbiAgICAgICAgY29uc3QgbGltaXQgPSAoQk5fMSA8PCAod2lkdGggLSBCTl8xKSk7XG4gICAgICAgIGFzc2VydChzYWZlT3AgPT0gbnVsbCB8fCAodmFsID49IC1saW1pdCAmJiB2YWwgPCBsaW1pdCksIFwib3ZlcmZsb3dcIiwgXCJOVU1FUklDX0ZBVUxUXCIsIHtcbiAgICAgICAgICAgIG9wZXJhdGlvbjogc2FmZU9wLCBmYXVsdDogXCJvdmVyZmxvd1wiLCB2YWx1ZTogdmFsXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAodmFsID4gQk5fMCkge1xuICAgICAgICAgICAgdmFsID0gZnJvbVR3b3MobWFzayh2YWwsIHdpZHRoKSwgd2lkdGgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFsID0gLWZyb21Ud29zKG1hc2soLXZhbCwgd2lkdGgpLCB3aWR0aCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IGxpbWl0ID0gKEJOXzEgPDwgd2lkdGgpO1xuICAgICAgICBhc3NlcnQoc2FmZU9wID09IG51bGwgfHwgKHZhbCA+PSAwICYmIHZhbCA8IGxpbWl0KSwgXCJvdmVyZmxvd1wiLCBcIk5VTUVSSUNfRkFVTFRcIiwge1xuICAgICAgICAgICAgb3BlcmF0aW9uOiBzYWZlT3AsIGZhdWx0OiBcIm92ZXJmbG93XCIsIHZhbHVlOiB2YWxcbiAgICAgICAgfSk7XG4gICAgICAgIHZhbCA9ICgoKHZhbCAlIGxpbWl0KSArIGxpbWl0KSAlIGxpbWl0KSAmIChsaW1pdCAtIEJOXzEpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsO1xufVxuZnVuY3Rpb24gZ2V0Rm9ybWF0KHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiAodmFsdWUpID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgIHZhbHVlID0gYGZpeGVkMTI4eCR7dmFsdWV9YDtcbiAgICB9XG4gICAgbGV0IHNpZ25lZCA9IHRydWU7XG4gICAgbGV0IHdpZHRoID0gMTI4O1xuICAgIGxldCBkZWNpbWFscyA9IDE4O1xuICAgIGlmICh0eXBlb2YgKHZhbHVlKSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAvLyBQYXJzZSB0aGUgZm9ybWF0IHN0cmluZ1xuICAgICAgICBpZiAodmFsdWUgPT09IFwiZml4ZWRcIikge1xuICAgICAgICAgICAgLy8gZGVmYXVsdHMuLi5cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh2YWx1ZSA9PT0gXCJ1Zml4ZWRcIikge1xuICAgICAgICAgICAgc2lnbmVkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBtYXRjaCA9IHZhbHVlLm1hdGNoKC9eKHU/KWZpeGVkKFswLTldKyl4KFswLTldKykkLyk7XG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudChtYXRjaCwgXCJpbnZhbGlkIGZpeGVkIGZvcm1hdFwiLCBcImZvcm1hdFwiLCB2YWx1ZSk7XG4gICAgICAgICAgICBzaWduZWQgPSAobWF0Y2hbMV0gIT09IFwidVwiKTtcbiAgICAgICAgICAgIHdpZHRoID0gcGFyc2VJbnQobWF0Y2hbMl0pO1xuICAgICAgICAgICAgZGVjaW1hbHMgPSBwYXJzZUludChtYXRjaFszXSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAodmFsdWUpIHtcbiAgICAgICAgLy8gRXh0cmFjdCB0aGUgdmFsdWVzIGZyb20gdGhlIG9iamVjdFxuICAgICAgICBjb25zdCB2ID0gdmFsdWU7XG4gICAgICAgIGNvbnN0IGNoZWNrID0gKGtleSwgdHlwZSwgZGVmYXVsdFZhbHVlKSA9PiB7XG4gICAgICAgICAgICBpZiAodltrZXldID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGVmYXVsdFZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQodHlwZW9mICh2W2tleV0pID09PSB0eXBlLCBcImludmFsaWQgZml4ZWQgZm9ybWF0IChcIiArIGtleSArIFwiIG5vdCBcIiArIHR5cGUgKyBcIilcIiwgXCJmb3JtYXQuXCIgKyBrZXksIHZba2V5XSk7XG4gICAgICAgICAgICByZXR1cm4gdltrZXldO1xuICAgICAgICB9O1xuICAgICAgICBzaWduZWQgPSBjaGVjayhcInNpZ25lZFwiLCBcImJvb2xlYW5cIiwgc2lnbmVkKTtcbiAgICAgICAgd2lkdGggPSBjaGVjayhcIndpZHRoXCIsIFwibnVtYmVyXCIsIHdpZHRoKTtcbiAgICAgICAgZGVjaW1hbHMgPSBjaGVjayhcImRlY2ltYWxzXCIsIFwibnVtYmVyXCIsIGRlY2ltYWxzKTtcbiAgICB9XG4gICAgYXNzZXJ0QXJndW1lbnQoKHdpZHRoICUgOCkgPT09IDAsIFwiaW52YWxpZCBGaXhlZE51bWJlciB3aWR0aCAobm90IGJ5dGUgYWxpZ25lZClcIiwgXCJmb3JtYXQud2lkdGhcIiwgd2lkdGgpO1xuICAgIGFzc2VydEFyZ3VtZW50KGRlY2ltYWxzIDw9IDgwLCBcImludmFsaWQgRml4ZWROdW1iZXIgZGVjaW1hbHMgKHRvbyBsYXJnZSlcIiwgXCJmb3JtYXQuZGVjaW1hbHNcIiwgZGVjaW1hbHMpO1xuICAgIGNvbnN0IG5hbWUgPSAoc2lnbmVkID8gXCJcIiA6IFwidVwiKSArIFwiZml4ZWRcIiArIFN0cmluZyh3aWR0aCkgKyBcInhcIiArIFN0cmluZyhkZWNpbWFscyk7XG4gICAgcmV0dXJuIHsgc2lnbmVkLCB3aWR0aCwgZGVjaW1hbHMsIG5hbWUgfTtcbn1cbmZ1bmN0aW9uIHRvU3RyaW5nKHZhbCwgZGVjaW1hbHMpIHtcbiAgICBsZXQgbmVnYXRpdmUgPSBcIlwiO1xuICAgIGlmICh2YWwgPCBCTl8wKSB7XG4gICAgICAgIG5lZ2F0aXZlID0gXCItXCI7XG4gICAgICAgIHZhbCAqPSBCTl9OMTtcbiAgICB9XG4gICAgbGV0IHN0ciA9IHZhbC50b1N0cmluZygpO1xuICAgIC8vIE5vIGRlY2ltYWwgcG9pbnQgZm9yIHdob2xlIHZhbHVlc1xuICAgIGlmIChkZWNpbWFscyA9PT0gMCkge1xuICAgICAgICByZXR1cm4gKG5lZ2F0aXZlICsgc3RyKTtcbiAgICB9XG4gICAgLy8gUGFkIG91dCB0byB0aGUgd2hvbGUgY29tcG9uZW50IChpbmNsdWRpbmcgYSB3aG9sZSBkaWdpdClcbiAgICB3aGlsZSAoc3RyLmxlbmd0aCA8PSBkZWNpbWFscykge1xuICAgICAgICBzdHIgPSBaZXJvcyArIHN0cjtcbiAgICB9XG4gICAgLy8gSW5zZXJ0IHRoZSBkZWNpbWFsIHBvaW50XG4gICAgY29uc3QgaW5kZXggPSBzdHIubGVuZ3RoIC0gZGVjaW1hbHM7XG4gICAgc3RyID0gc3RyLnN1YnN0cmluZygwLCBpbmRleCkgKyBcIi5cIiArIHN0ci5zdWJzdHJpbmcoaW5kZXgpO1xuICAgIC8vIFRyaW0gdGhlIHdob2xlIGNvbXBvbmVudCAobGVhdmluZyBhdCBsZWFzdCBvbmUgMClcbiAgICB3aGlsZSAoc3RyWzBdID09PSBcIjBcIiAmJiBzdHJbMV0gIT09IFwiLlwiKSB7XG4gICAgICAgIHN0ciA9IHN0ci5zdWJzdHJpbmcoMSk7XG4gICAgfVxuICAgIC8vIFRyaW0gdGhlIGRlY2ltYWwgY29tcG9uZW50IChsZWF2aW5nIGF0IGxlYXN0IG9uZSAwKVxuICAgIHdoaWxlIChzdHJbc3RyLmxlbmd0aCAtIDFdID09PSBcIjBcIiAmJiBzdHJbc3RyLmxlbmd0aCAtIDJdICE9PSBcIi5cIikge1xuICAgICAgICBzdHIgPSBzdHIuc3Vic3RyaW5nKDAsIHN0ci5sZW5ndGggLSAxKTtcbiAgICB9XG4gICAgcmV0dXJuIChuZWdhdGl2ZSArIHN0cik7XG59XG4vKipcbiAqICBBIEZpeGVkTnVtYmVyIHJlcHJlc2VudHMgYSB2YWx1ZSBvdmVyIGl0cyBbW0ZpeGVkRm9ybWF0XV1cbiAqICBhcml0aG1ldGljIGZpZWxkLlxuICpcbiAqICBBIEZpeGVkTnVtYmVyIGNhbiBiZSB1c2VkIHRvIHBlcmZvcm0gbWF0aCwgbG9zc2xlc3NseSwgb25cbiAqICB2YWx1ZXMgd2hpY2ggaGF2ZSBkZWNtaWFsIHBsYWNlcy5cbiAqXG4gKiAgQSBGaXhlZE51bWJlciBoYXMgYSBmaXhlZCBiaXQtd2lkdGggdG8gc3RvcmUgdmFsdWVzIGluLCBhbmQgc3RvcmVzIGFsbFxuICogIHZhbHVlcyBpbnRlcm5hbGx5IGJ5IG11bHRpcGx5aW5nIHRoZSB2YWx1ZSBieSAxMCByYWlzZWQgdG8gdGhlIHBvd2VyIG9mXG4gKiAgJSVkZWNpbWFscyUlLlxuICpcbiAqICBJZiBvcGVyYXRpb25zIGFyZSBwZXJmb3JtZWQgdGhhdCBjYXVzZSBhIHZhbHVlIHRvIGdyb3cgdG9vIGhpZ2ggKGNsb3NlIHRvXG4gKiAgcG9zaXRpdmUgaW5maW5pdHkpIG9yIHRvbyBsb3cgKGNsb3NlIHRvIG5lZ2F0aXZlIGluZmluaXR5KSwgdGhlIHZhbHVlXG4gKiAgaXMgc2FpZCB0byAvL292ZXJmbG93Ly8uXG4gKlxuICogIEZvciBleGFtcGxlLCBhbiA4LWJpdCBzaWduZWQgdmFsdWUsIHdpdGggMCBkZWNpbWFscyBtYXkgb25seSBiZSB3aXRoaW5cbiAqICB0aGUgcmFuZ2UgYGAtMTI4YGAgdG8gYGAxMjdgYDsgc28gYGAtMTI4IC0gMWBgIHdpbGwgb3ZlcmZsb3cgYW5kIGJlY29tZVxuICogIGBgMTI3YGAuIExpa2V3aXNlLCBgYDEyNyArIDFgYCB3aWxsIG92ZXJmbG93IGFuZCBiZWNvbWUgYGAtMTI3YGAuXG4gKlxuICogIE1hbnkgb3BlcmF0aW9uIGhhdmUgYSBub3JtYWwgYW5kIC8vdW5zYWZlLy8gdmFyaWFudC4gVGhlIG5vcm1hbCB2YXJpYW50XG4gKiAgd2lsbCB0aHJvdyBhIFtbTnVtZXJpY0ZhdWx0RXJyb3JdXSBvbiBhbnkgb3ZlcmZsb3csIHdoaWxlIHRoZSAvL3Vuc2FmZS8vXG4gKiAgdmFyaWFudCB3aWxsIHNpbGVudGx5IGFsbG93IG92ZXJmbG93LCBjb3JydXB0aW5nIGl0cyB2YWx1ZSB2YWx1ZS5cbiAqXG4gKiAgSWYgb3BlcmF0aW9ucyBhcmUgcGVyZm9ybWVkIHRoYXQgY2F1c2UgYSB2YWx1ZSB0byBiZWNvbWUgdG9vIHNtYWxsXG4gKiAgKGNsb3NlIHRvIHplcm8pLCB0aGUgdmFsdWUgbG9zZXMgcHJlY2lzb24gYW5kIGlzIHNhaWQgdG8gLy91bmRlcmZsb3cvLy5cbiAqXG4gKiAgRm9yIGV4YW1wbGUsIGEgdmFsdWUgd2l0aCAxIGRlY2ltYWwgcGxhY2UgbWF5IHN0b3JlIGEgbnVtYmVyIGFzIHNtYWxsXG4gKiAgYXMgYGAwLjFgYCwgYnV0IHRoZSB2YWx1ZSBvZiBgYDAuMSAvIDJgYCBpcyBgYDAuMDVgYCwgd2hpY2ggY2Fubm90IGZpdFxuICogIGludG8gMSBkZWNpbWFsIHBsYWNlLCBzbyB1bmRlcmZsb3cgb2NjdXJzIHdoaWNoIG1lYW5zIHByZWNpc2lvbiBpcyBsb3N0XG4gKiAgYW5kIHRoZSB2YWx1ZSBiZWNvbWVzIGBgMGBgLlxuICpcbiAqICBTb21lIG9wZXJhdGlvbnMgaGF2ZSBhIG5vcm1hbCBhbmQgLy9zaWduYWxsaW5nLy8gdmFyaWFudC4gVGhlIG5vcm1hbFxuICogIHZhcmlhbnQgd2lsbCBzaWxlbnRseSBpZ25vcmUgdW5kZXJmbG93LCB3aGlsZSB0aGUgLy9zaWduYWxsaW5nLy8gdmFyaWFudFxuICogIHdpbGwgdGhvdyBhIFtbTnVtZXJpY0ZhdWx0RXJyb3JdXSBvbiB1bmRlcmZsb3cuXG4gKi9cbmV4cG9ydCBjbGFzcyBGaXhlZE51bWJlciB7XG4gICAgLyoqXG4gICAgICogIFRoZSBzcGVjaWZpYyBmaXhlZC1wb2ludCBhcml0aG1ldGljIGZpZWxkIGZvciB0aGlzIHZhbHVlLlxuICAgICAqL1xuICAgIGZvcm1hdDtcbiAgICAjZm9ybWF0O1xuICAgIC8vIFRoZSBhY3R1YWwgdmFsdWUgKGFjY291bnRpbmcgZm9yIGRlY2ltYWxzKVxuICAgICN2YWw7XG4gICAgLy8gQSBiYXNlLTEwIHZhbHVlIHRvIG11bHRpcGxlIHZhbHVlcyBieSB0byBtYWludGFpbiB0aGUgbWFnbml0dWRlXG4gICAgI3RlbnM7XG4gICAgLyoqXG4gICAgICogIFRoaXMgaXMgYSBwcm9wZXJ0eSBzbyBjb25zb2xlLmxvZyBzaG93cyBhIGh1bWFuLW1lYW5pbmdmdWwgdmFsdWUuXG4gICAgICpcbiAgICAgKiAgQHByaXZhdGVcbiAgICAgKi9cbiAgICBfdmFsdWU7XG4gICAgLy8gVXNlIHRoaXMgd2hlbiBjaGFuZ2luZyB0aGlzIGZpbGUgdG8gZ2V0IHNvbWUgdHlwaW5nIGluZm8sXG4gICAgLy8gYnV0IHRoZW4gc3dpdGNoIHRvIGFueSB0byBtYXNrIHRoZSBpbnRlcm5hbCB0eXBlXG4gICAgLy9jb25zdHJ1Y3RvcihndWFyZDogYW55LCB2YWx1ZTogYmlnaW50LCBmb3JtYXQ6IF9GaXhlZEZvcm1hdCkge1xuICAgIC8qKlxuICAgICAqICBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGd1YXJkLCB2YWx1ZSwgZm9ybWF0KSB7XG4gICAgICAgIGFzc2VydFByaXZhdGUoZ3VhcmQsIF9ndWFyZCwgXCJGaXhlZE51bWJlclwiKTtcbiAgICAgICAgdGhpcy4jdmFsID0gdmFsdWU7XG4gICAgICAgIHRoaXMuI2Zvcm1hdCA9IGZvcm1hdDtcbiAgICAgICAgY29uc3QgX3ZhbHVlID0gdG9TdHJpbmcodmFsdWUsIGZvcm1hdC5kZWNpbWFscyk7XG4gICAgICAgIGRlZmluZVByb3BlcnRpZXModGhpcywgeyBmb3JtYXQ6IGZvcm1hdC5uYW1lLCBfdmFsdWUgfSk7XG4gICAgICAgIHRoaXMuI3RlbnMgPSBnZXRUZW5zKGZvcm1hdC5kZWNpbWFscyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBJZiB0cnVlLCBuZWdhdGl2ZSB2YWx1ZXMgYXJlIHBlcm1pdHRlZCwgb3RoZXJ3aXNlIG9ubHlcbiAgICAgKiAgcG9zaXRpdmUgdmFsdWVzIGFuZCB6ZXJvIGFyZSBhbGxvd2VkLlxuICAgICAqL1xuICAgIGdldCBzaWduZWQoKSB7IHJldHVybiB0aGlzLiNmb3JtYXQuc2lnbmVkOyB9XG4gICAgLyoqXG4gICAgICogIFRoZSBudW1iZXIgb2YgYml0cyBhdmFpbGFibGUgdG8gc3RvcmUgdGhlIHZhbHVlLlxuICAgICAqL1xuICAgIGdldCB3aWR0aCgpIHsgcmV0dXJuIHRoaXMuI2Zvcm1hdC53aWR0aDsgfVxuICAgIC8qKlxuICAgICAqICBUaGUgbnVtYmVyIG9mIGRlY2ltYWwgcGxhY2VzIGluIHRoZSBmaXhlZC1wb2ludCBhcml0aG1lbnQgZmllbGQuXG4gICAgICovXG4gICAgZ2V0IGRlY2ltYWxzKCkgeyByZXR1cm4gdGhpcy4jZm9ybWF0LmRlY2ltYWxzOyB9XG4gICAgLyoqXG4gICAgICogIFRoZSB2YWx1ZSBhcyBhbiBpbnRlZ2VyLCBiYXNlZCBvbiB0aGUgc21hbGxlc3QgdW5pdCB0aGVcbiAgICAgKiAgW1tkZWNpbWFsc11dIGFsbG93LlxuICAgICAqL1xuICAgIGdldCB2YWx1ZSgpIHsgcmV0dXJuIHRoaXMuI3ZhbDsgfVxuICAgICNjaGVja0Zvcm1hdChvdGhlcikge1xuICAgICAgICBhc3NlcnRBcmd1bWVudCh0aGlzLmZvcm1hdCA9PT0gb3RoZXIuZm9ybWF0LCBcImluY29tcGF0aWJsZSBmb3JtYXQ7IHVzZSBmaXhlZE51bWJlci50b0Zvcm1hdFwiLCBcIm90aGVyXCIsIG90aGVyKTtcbiAgICB9XG4gICAgI2NoZWNrVmFsdWUodmFsLCBzYWZlT3ApIHtcbiAgICAgICAgLypcbiAgICAgICAgICAgICAgICBjb25zdCB3aWR0aCA9IEJpZ0ludCh0aGlzLndpZHRoKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zaWduZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbGltaXQgPSAoQk5fMSA8PCAod2lkdGggLSBCTl8xKSk7XG4gICAgICAgICAgICAgICAgICAgIGFzc2VydChzYWZlT3AgPT0gbnVsbCB8fCAodmFsID49IC1saW1pdCAgJiYgdmFsIDwgbGltaXQpLCBcIm92ZXJmbG93XCIsIFwiTlVNRVJJQ19GQVVMVFwiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcGVyYXRpb246IDxzdHJpbmc+c2FmZU9wLCBmYXVsdDogXCJvdmVyZmxvd1wiLCB2YWx1ZTogdmFsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbCA+IEJOXzApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbCA9IGZyb21Ud29zKG1hc2sodmFsLCB3aWR0aCksIHdpZHRoKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbCA9IC1mcm9tVHdvcyhtYXNrKC12YWwsIHdpZHRoKSwgd2lkdGgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG1hc2tlZCA9IG1hc2sodmFsLCB3aWR0aCk7XG4gICAgICAgICAgICAgICAgICAgIGFzc2VydChzYWZlT3AgPT0gbnVsbCB8fCAodmFsID49IDAgJiYgdmFsID09PSBtYXNrZWQpLCBcIm92ZXJmbG93XCIsIFwiTlVNRVJJQ19GQVVMVFwiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcGVyYXRpb246IDxzdHJpbmc+c2FmZU9wLCBmYXVsdDogXCJvdmVyZmxvd1wiLCB2YWx1ZTogdmFsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB2YWwgPSBtYXNrZWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAqL1xuICAgICAgICB2YWwgPSBjaGVja1ZhbHVlKHZhbCwgdGhpcy4jZm9ybWF0LCBzYWZlT3ApO1xuICAgICAgICByZXR1cm4gbmV3IEZpeGVkTnVtYmVyKF9ndWFyZCwgdmFsLCB0aGlzLiNmb3JtYXQpO1xuICAgIH1cbiAgICAjYWRkKG8sIHNhZmVPcCkge1xuICAgICAgICB0aGlzLiNjaGVja0Zvcm1hdChvKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuI2NoZWNrVmFsdWUodGhpcy4jdmFsICsgby4jdmFsLCBzYWZlT3ApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBhIG5ldyBbW0ZpeGVkTnVtYmVyXV0gd2l0aCB0aGUgcmVzdWx0IG9mICUldGhpcyUlIGFkZGVkXG4gICAgICogIHRvICUlb3RoZXIlJSwgaWdub3Jpbmcgb3ZlcmZsb3cuXG4gICAgICovXG4gICAgYWRkVW5zYWZlKG90aGVyKSB7IHJldHVybiB0aGlzLiNhZGQob3RoZXIpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYSBuZXcgW1tGaXhlZE51bWJlcl1dIHdpdGggdGhlIHJlc3VsdCBvZiAlJXRoaXMlJSBhZGRlZFxuICAgICAqICB0byAlJW90aGVyJSUuIEEgW1tOdW1lcmljRmF1bHRFcnJvcl1dIGlzIHRocm93biBpZiBvdmVyZmxvd1xuICAgICAqICBvY2N1cnMuXG4gICAgICovXG4gICAgYWRkKG90aGVyKSB7IHJldHVybiB0aGlzLiNhZGQob3RoZXIsIFwiYWRkXCIpOyB9XG4gICAgI3N1YihvLCBzYWZlT3ApIHtcbiAgICAgICAgdGhpcy4jY2hlY2tGb3JtYXQobyk7XG4gICAgICAgIHJldHVybiB0aGlzLiNjaGVja1ZhbHVlKHRoaXMuI3ZhbCAtIG8uI3ZhbCwgc2FmZU9wKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYSBuZXcgW1tGaXhlZE51bWJlcl1dIHdpdGggdGhlIHJlc3VsdCBvZiAlJW90aGVyJSUgc3VidHJhY3RlZFxuICAgICAqICBmcm9tICUldGhpcyUlLCBpZ25vcmluZyBvdmVyZmxvdy5cbiAgICAgKi9cbiAgICBzdWJVbnNhZmUob3RoZXIpIHsgcmV0dXJuIHRoaXMuI3N1YihvdGhlcik7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBhIG5ldyBbW0ZpeGVkTnVtYmVyXV0gd2l0aCB0aGUgcmVzdWx0IG9mICUlb3RoZXIlJSBzdWJ0cmFjdGVkXG4gICAgICogIGZyb20gJSV0aGlzJSUuIEEgW1tOdW1lcmljRmF1bHRFcnJvcl1dIGlzIHRocm93biBpZiBvdmVyZmxvd1xuICAgICAqICBvY2N1cnMuXG4gICAgICovXG4gICAgc3ViKG90aGVyKSB7IHJldHVybiB0aGlzLiNzdWIob3RoZXIsIFwic3ViXCIpOyB9XG4gICAgI211bChvLCBzYWZlT3ApIHtcbiAgICAgICAgdGhpcy4jY2hlY2tGb3JtYXQobyk7XG4gICAgICAgIHJldHVybiB0aGlzLiNjaGVja1ZhbHVlKCh0aGlzLiN2YWwgKiBvLiN2YWwpIC8gdGhpcy4jdGVucywgc2FmZU9wKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYSBuZXcgW1tGaXhlZE51bWJlcl1dIHdpdGggdGhlIHJlc3VsdCBvZiAlJXRoaXMlJSBtdWx0aXBsaWVkXG4gICAgICogIGJ5ICUlb3RoZXIlJSwgaWdub3Jpbmcgb3ZlcmZsb3cgYW5kIHVuZGVyZmxvdyAocHJlY2lzaW9uIGxvc3MpLlxuICAgICAqL1xuICAgIG11bFVuc2FmZShvdGhlcikgeyByZXR1cm4gdGhpcy4jbXVsKG90aGVyKTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGEgbmV3IFtbRml4ZWROdW1iZXJdXSB3aXRoIHRoZSByZXN1bHQgb2YgJSV0aGlzJSUgbXVsdGlwbGllZFxuICAgICAqICBieSAlJW90aGVyJSUuIEEgW1tOdW1lcmljRmF1bHRFcnJvcl1dIGlzIHRocm93biBpZiBvdmVyZmxvd1xuICAgICAqICBvY2N1cnMuXG4gICAgICovXG4gICAgbXVsKG90aGVyKSB7IHJldHVybiB0aGlzLiNtdWwob3RoZXIsIFwibXVsXCIpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYSBuZXcgW1tGaXhlZE51bWJlcl1dIHdpdGggdGhlIHJlc3VsdCBvZiAlJXRoaXMlJSBtdWx0aXBsaWVkXG4gICAgICogIGJ5ICUlb3RoZXIlJS4gQSBbW051bWVyaWNGYXVsdEVycm9yXV0gaXMgdGhyb3duIGlmIG92ZXJmbG93XG4gICAgICogIG9jY3VycyBvciBpZiB1bmRlcmZsb3cgKHByZWNpc2lvbiBsb3NzKSBvY2N1cnMuXG4gICAgICovXG4gICAgbXVsU2lnbmFsKG90aGVyKSB7XG4gICAgICAgIHRoaXMuI2NoZWNrRm9ybWF0KG90aGVyKTtcbiAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLiN2YWwgKiBvdGhlci4jdmFsO1xuICAgICAgICBhc3NlcnQoKHZhbHVlICUgdGhpcy4jdGVucykgPT09IEJOXzAsIFwicHJlY2lzaW9uIGxvc3QgZHVyaW5nIHNpZ25hbGxpbmcgbXVsXCIsIFwiTlVNRVJJQ19GQVVMVFwiLCB7XG4gICAgICAgICAgICBvcGVyYXRpb246IFwibXVsU2lnbmFsXCIsIGZhdWx0OiBcInVuZGVyZmxvd1wiLCB2YWx1ZTogdGhpc1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuI2NoZWNrVmFsdWUodmFsdWUgLyB0aGlzLiN0ZW5zLCBcIm11bFNpZ25hbFwiKTtcbiAgICB9XG4gICAgI2RpdihvLCBzYWZlT3ApIHtcbiAgICAgICAgYXNzZXJ0KG8uI3ZhbCAhPT0gQk5fMCwgXCJkaXZpc2lvbiBieSB6ZXJvXCIsIFwiTlVNRVJJQ19GQVVMVFwiLCB7XG4gICAgICAgICAgICBvcGVyYXRpb246IFwiZGl2XCIsIGZhdWx0OiBcImRpdmlkZS1ieS16ZXJvXCIsIHZhbHVlOiB0aGlzXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLiNjaGVja0Zvcm1hdChvKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuI2NoZWNrVmFsdWUoKHRoaXMuI3ZhbCAqIHRoaXMuI3RlbnMpIC8gby4jdmFsLCBzYWZlT3ApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBhIG5ldyBbW0ZpeGVkTnVtYmVyXV0gd2l0aCB0aGUgcmVzdWx0IG9mICUldGhpcyUlIGRpdmlkZWRcbiAgICAgKiAgYnkgJSVvdGhlciUlLCBpZ25vcmluZyB1bmRlcmZsb3cgKHByZWNpc2lvbiBsb3NzKS4gQVxuICAgICAqICBbW051bWVyaWNGYXVsdEVycm9yXV0gaXMgdGhyb3duIGlmIG92ZXJmbG93IG9jY3Vycy5cbiAgICAgKi9cbiAgICBkaXZVbnNhZmUob3RoZXIpIHsgcmV0dXJuIHRoaXMuI2RpdihvdGhlcik7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBhIG5ldyBbW0ZpeGVkTnVtYmVyXV0gd2l0aCB0aGUgcmVzdWx0IG9mICUldGhpcyUlIGRpdmlkZWRcbiAgICAgKiAgYnkgJSVvdGhlciUlLCBpZ25vcmluZyB1bmRlcmZsb3cgKHByZWNpc2lvbiBsb3NzKS4gQVxuICAgICAqICBbW051bWVyaWNGYXVsdEVycm9yXV0gaXMgdGhyb3duIGlmIG92ZXJmbG93IG9jY3Vycy5cbiAgICAgKi9cbiAgICBkaXYob3RoZXIpIHsgcmV0dXJuIHRoaXMuI2RpdihvdGhlciwgXCJkaXZcIik7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBhIG5ldyBbW0ZpeGVkTnVtYmVyXV0gd2l0aCB0aGUgcmVzdWx0IG9mICUldGhpcyUlIGRpdmlkZWRcbiAgICAgKiAgYnkgJSVvdGhlciUlLiBBIFtbTnVtZXJpY0ZhdWx0RXJyb3JdXSBpcyB0aHJvd24gaWYgdW5kZXJmbG93XG4gICAgICogIChwcmVjaXNpb24gbG9zcykgb2NjdXJzLlxuICAgICAqL1xuICAgIGRpdlNpZ25hbChvdGhlcikge1xuICAgICAgICBhc3NlcnQob3RoZXIuI3ZhbCAhPT0gQk5fMCwgXCJkaXZpc2lvbiBieSB6ZXJvXCIsIFwiTlVNRVJJQ19GQVVMVFwiLCB7XG4gICAgICAgICAgICBvcGVyYXRpb246IFwiZGl2XCIsIGZhdWx0OiBcImRpdmlkZS1ieS16ZXJvXCIsIHZhbHVlOiB0aGlzXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLiNjaGVja0Zvcm1hdChvdGhlcik7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gKHRoaXMuI3ZhbCAqIHRoaXMuI3RlbnMpO1xuICAgICAgICBhc3NlcnQoKHZhbHVlICUgb3RoZXIuI3ZhbCkgPT09IEJOXzAsIFwicHJlY2lzaW9uIGxvc3QgZHVyaW5nIHNpZ25hbGxpbmcgZGl2XCIsIFwiTlVNRVJJQ19GQVVMVFwiLCB7XG4gICAgICAgICAgICBvcGVyYXRpb246IFwiZGl2U2lnbmFsXCIsIGZhdWx0OiBcInVuZGVyZmxvd1wiLCB2YWx1ZTogdGhpc1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuI2NoZWNrVmFsdWUodmFsdWUgLyBvdGhlci4jdmFsLCBcImRpdlNpZ25hbFwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYSBjb21wYXJpc29uIHJlc3VsdCBiZXR3ZWVuICUldGhpcyUlIGFuZCAlJW90aGVyJSUuXG4gICAgICpcbiAgICAgKiAgVGhpcyBpcyBzdWl0YWJsZSBmb3IgdXNlIGluIHNvcnRpbmcsIHdoZXJlIGBgLTFgYCBpbXBsaWVzICUldGhpcyUlXG4gICAgICogIGlzIHNtYWxsZXIsIGBgMWBgIGltcGxpZXMgJSV0aGlzJSUgaXMgbGFyZ2VyIGFuZCBgYDBgYCBpbXBsaWVzXG4gICAgICogIGJvdGggYXJlIGVxdWFsLlxuICAgICAqL1xuICAgIGNtcChvdGhlcikge1xuICAgICAgICBsZXQgYSA9IHRoaXMudmFsdWUsIGIgPSBvdGhlci52YWx1ZTtcbiAgICAgICAgLy8gQ29lcmNlIGEgYW5kIGIgdG8gdGhlIHNhbWUgbWFnbml0dWRlXG4gICAgICAgIGNvbnN0IGRlbHRhID0gdGhpcy5kZWNpbWFscyAtIG90aGVyLmRlY2ltYWxzO1xuICAgICAgICBpZiAoZGVsdGEgPiAwKSB7XG4gICAgICAgICAgICBiICo9IGdldFRlbnMoZGVsdGEpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGRlbHRhIDwgMCkge1xuICAgICAgICAgICAgYSAqPSBnZXRUZW5zKC1kZWx0YSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ29tbnBhcmVcbiAgICAgICAgaWYgKGEgPCBiKSB7XG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGEgPiBiKSB7XG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdHJ1ZSBpZiAlJW90aGVyJSUgaXMgZXF1YWwgdG8gJSV0aGlzJSUuXG4gICAgICovXG4gICAgZXEob3RoZXIpIHsgcmV0dXJuIHRoaXMuY21wKG90aGVyKSA9PT0gMDsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRydWUgaWYgJSVvdGhlciUlIGlzIGxlc3MgdGhhbiB0byAlJXRoaXMlJS5cbiAgICAgKi9cbiAgICBsdChvdGhlcikgeyByZXR1cm4gdGhpcy5jbXAob3RoZXIpIDwgMDsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRydWUgaWYgJSVvdGhlciUlIGlzIGxlc3MgdGhhbiBvciBlcXVhbCB0byAlJXRoaXMlJS5cbiAgICAgKi9cbiAgICBsdGUob3RoZXIpIHsgcmV0dXJuIHRoaXMuY21wKG90aGVyKSA8PSAwOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdHJ1ZSBpZiAlJW90aGVyJSUgaXMgZ3JlYXRlciB0aGFuIHRvICUldGhpcyUlLlxuICAgICAqL1xuICAgIGd0KG90aGVyKSB7IHJldHVybiB0aGlzLmNtcChvdGhlcikgPiAwOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdHJ1ZSBpZiAlJW90aGVyJSUgaXMgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvICUldGhpcyUlLlxuICAgICAqL1xuICAgIGd0ZShvdGhlcikgeyByZXR1cm4gdGhpcy5jbXAob3RoZXIpID49IDA7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBhIG5ldyBbW0ZpeGVkTnVtYmVyXV0gd2hpY2ggaXMgdGhlIGxhcmdlc3QgKippbnRlZ2VyKipcbiAgICAgKiAgdGhhdCBpcyBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gJSV0aGlzJSUuXG4gICAgICpcbiAgICAgKiAgVGhlIGRlY2ltYWwgY29tcG9uZW50IG9mIHRoZSByZXN1bHQgd2lsbCBhbHdheXMgYmUgYGAwYGAuXG4gICAgICovXG4gICAgZmxvb3IoKSB7XG4gICAgICAgIGxldCB2YWwgPSB0aGlzLiN2YWw7XG4gICAgICAgIGlmICh0aGlzLiN2YWwgPCBCTl8wKSB7XG4gICAgICAgICAgICB2YWwgLT0gdGhpcy4jdGVucyAtIEJOXzE7XG4gICAgICAgIH1cbiAgICAgICAgdmFsID0gKHRoaXMuI3ZhbCAvIHRoaXMuI3RlbnMpICogdGhpcy4jdGVucztcbiAgICAgICAgcmV0dXJuIHRoaXMuI2NoZWNrVmFsdWUodmFsLCBcImZsb29yXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBhIG5ldyBbW0ZpeGVkTnVtYmVyXV0gd2hpY2ggaXMgdGhlIHNtYWxsZXN0ICoqaW50ZWdlcioqXG4gICAgICogIHRoYXQgaXMgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvICUldGhpcyUlLlxuICAgICAqXG4gICAgICogIFRoZSBkZWNpbWFsIGNvbXBvbmVudCBvZiB0aGUgcmVzdWx0IHdpbGwgYWx3YXlzIGJlIGBgMGBgLlxuICAgICAqL1xuICAgIGNlaWxpbmcoKSB7XG4gICAgICAgIGxldCB2YWwgPSB0aGlzLiN2YWw7XG4gICAgICAgIGlmICh0aGlzLiN2YWwgPiBCTl8wKSB7XG4gICAgICAgICAgICB2YWwgKz0gdGhpcy4jdGVucyAtIEJOXzE7XG4gICAgICAgIH1cbiAgICAgICAgdmFsID0gKHRoaXMuI3ZhbCAvIHRoaXMuI3RlbnMpICogdGhpcy4jdGVucztcbiAgICAgICAgcmV0dXJuIHRoaXMuI2NoZWNrVmFsdWUodmFsLCBcImNlaWxpbmdcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGEgbmV3IFtbRml4ZWROdW1iZXJdXSB3aXRoIHRoZSBkZWNpbWFsIGNvbXBvbmVudFxuICAgICAqICByb3VuZGVkIHVwIG9uIHRpZXMgYXQgJSVkZWNpbWFscyUlIHBsYWNlcy5cbiAgICAgKi9cbiAgICByb3VuZChkZWNpbWFscykge1xuICAgICAgICBpZiAoZGVjaW1hbHMgPT0gbnVsbCkge1xuICAgICAgICAgICAgZGVjaW1hbHMgPSAwO1xuICAgICAgICB9XG4gICAgICAgIC8vIE5vdCBlbm91Z2ggcHJlY2lzaW9uIHRvIG5vdCBhbHJlYWR5IGJlIHJvdW5kZWRcbiAgICAgICAgaWYgKGRlY2ltYWxzID49IHRoaXMuZGVjaW1hbHMpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRlbHRhID0gdGhpcy5kZWNpbWFscyAtIGRlY2ltYWxzO1xuICAgICAgICBjb25zdCBidW1wID0gQk5fNSAqIGdldFRlbnMoZGVsdGEgLSAxKTtcbiAgICAgICAgbGV0IHZhbHVlID0gdGhpcy52YWx1ZSArIGJ1bXA7XG4gICAgICAgIGNvbnN0IHRlbnMgPSBnZXRUZW5zKGRlbHRhKTtcbiAgICAgICAgdmFsdWUgPSAodmFsdWUgLyB0ZW5zKSAqIHRlbnM7XG4gICAgICAgIGNoZWNrVmFsdWUodmFsdWUsIHRoaXMuI2Zvcm1hdCwgXCJyb3VuZFwiKTtcbiAgICAgICAgcmV0dXJuIG5ldyBGaXhlZE51bWJlcihfZ3VhcmQsIHZhbHVlLCB0aGlzLiNmb3JtYXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0cnVlIGlmICUldGhpcyUlIGlzIGVxdWFsIHRvIGBgMGBgLlxuICAgICAqL1xuICAgIGlzWmVybygpIHsgcmV0dXJuICh0aGlzLiN2YWwgPT09IEJOXzApOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdHJ1ZSBpZiAlJXRoaXMlJSBpcyBsZXNzIHRoYW4gYGAwYGAuXG4gICAgICovXG4gICAgaXNOZWdhdGl2ZSgpIHsgcmV0dXJuICh0aGlzLiN2YWwgPCBCTl8wKTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgJSV0aGlzJSUuXG4gICAgICovXG4gICAgdG9TdHJpbmcoKSB7IHJldHVybiB0aGlzLl92YWx1ZTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGEgZmxvYXQgYXBwcm94aW1hdGlvbi5cbiAgICAgKlxuICAgICAqICBEdWUgdG8gSUVFRSA3NTQgcHJlY2lzc2lvbiAob3IgbGFjayB0aGVyZW9mKSwgdGhpcyBmdW5jdGlvblxuICAgICAqICBjYW4gb25seSByZXR1cm4gYW4gYXBwcm94aW1hdGlvbiBhbmQgbW9zdCB2YWx1ZXMgd2lsbCBjb250YWluXG4gICAgICogIHJvdW5kaW5nIGVycm9ycy5cbiAgICAgKi9cbiAgICB0b1Vuc2FmZUZsb2F0KCkgeyByZXR1cm4gcGFyc2VGbG9hdCh0aGlzLnRvU3RyaW5nKCkpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBbW0ZpeGVkTnVtYmVyXV0gd2l0aCB0aGUgc2FtZSB2YWx1ZSBidXQgaGFzIGhhZFxuICAgICAqICBpdHMgZmllbGQgc2V0IHRvICUlZm9ybWF0JSUuXG4gICAgICpcbiAgICAgKiAgVGhpcyB3aWxsIHRocm93IGlmIHRoZSB2YWx1ZSBjYW5ub3QgZml0IGludG8gJSVmb3JtYXQlJS5cbiAgICAgKi9cbiAgICB0b0Zvcm1hdChmb3JtYXQpIHtcbiAgICAgICAgcmV0dXJuIEZpeGVkTnVtYmVyLmZyb21TdHJpbmcodGhpcy50b1N0cmluZygpLCBmb3JtYXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlcyBhIG5ldyBbW0ZpeGVkTnVtYmVyXV0gZm9yICUldmFsdWUlJSBkaXZpZGVkIGJ5XG4gICAgICogICUlZGVjaW1hbCUlIHBsYWNlcyB3aXRoICUlZm9ybWF0JSUuXG4gICAgICpcbiAgICAgKiAgVGhpcyB3aWxsIHRocm93IGEgW1tOdW1lcmljRmF1bHRFcnJvcl1dIGlmICUldmFsdWUlJSAob25jZSBhZGp1c3RlZFxuICAgICAqICBmb3IgJSVkZWNpbWFscyUlKSBjYW5ub3QgZml0IGluICUlZm9ybWF0JSUsIGVpdGhlciBkdWUgdG8gb3ZlcmZsb3dcbiAgICAgKiAgb3IgdW5kZXJmbG93IChwcmVjaXNpb24gbG9zcykuXG4gICAgICovXG4gICAgc3RhdGljIGZyb21WYWx1ZShfdmFsdWUsIF9kZWNpbWFscywgX2Zvcm1hdCkge1xuICAgICAgICBjb25zdCBkZWNpbWFscyA9IChfZGVjaW1hbHMgPT0gbnVsbCkgPyAwIDogZ2V0TnVtYmVyKF9kZWNpbWFscyk7XG4gICAgICAgIGNvbnN0IGZvcm1hdCA9IGdldEZvcm1hdChfZm9ybWF0KTtcbiAgICAgICAgbGV0IHZhbHVlID0gZ2V0QmlnSW50KF92YWx1ZSwgXCJ2YWx1ZVwiKTtcbiAgICAgICAgY29uc3QgZGVsdGEgPSBkZWNpbWFscyAtIGZvcm1hdC5kZWNpbWFscztcbiAgICAgICAgaWYgKGRlbHRhID4gMCkge1xuICAgICAgICAgICAgY29uc3QgdGVucyA9IGdldFRlbnMoZGVsdGEpO1xuICAgICAgICAgICAgYXNzZXJ0KCh2YWx1ZSAlIHRlbnMpID09PSBCTl8wLCBcInZhbHVlIGxvc2VzIHByZWNpc2lvbiBmb3IgZm9ybWF0XCIsIFwiTlVNRVJJQ19GQVVMVFwiLCB7XG4gICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBcImZyb21WYWx1ZVwiLCBmYXVsdDogXCJ1bmRlcmZsb3dcIiwgdmFsdWU6IF92YWx1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB2YWx1ZSAvPSB0ZW5zO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGRlbHRhIDwgMCkge1xuICAgICAgICAgICAgdmFsdWUgKj0gZ2V0VGVucygtZGVsdGEpO1xuICAgICAgICB9XG4gICAgICAgIGNoZWNrVmFsdWUodmFsdWUsIGZvcm1hdCwgXCJmcm9tVmFsdWVcIik7XG4gICAgICAgIHJldHVybiBuZXcgRml4ZWROdW1iZXIoX2d1YXJkLCB2YWx1ZSwgZm9ybWF0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIENyZWF0ZXMgYSBuZXcgW1tGaXhlZE51bWJlcl1dIGZvciAlJXZhbHVlJSUgd2l0aCAlJWZvcm1hdCUlLlxuICAgICAqXG4gICAgICogIFRoaXMgd2lsbCB0aHJvdyBhIFtbTnVtZXJpY0ZhdWx0RXJyb3JdXSBpZiAlJXZhbHVlJSUgY2Fubm90IGZpdFxuICAgICAqICBpbiAlJWZvcm1hdCUlLCBlaXRoZXIgZHVlIHRvIG92ZXJmbG93IG9yIHVuZGVyZmxvdyAocHJlY2lzaW9uIGxvc3MpLlxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tU3RyaW5nKF92YWx1ZSwgX2Zvcm1hdCkge1xuICAgICAgICBjb25zdCBtYXRjaCA9IF92YWx1ZS5tYXRjaCgvXigtPykoWzAtOV0qKVxcLj8oWzAtOV0qKSQvKTtcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQobWF0Y2ggJiYgKG1hdGNoWzJdLmxlbmd0aCArIG1hdGNoWzNdLmxlbmd0aCkgPiAwLCBcImludmFsaWQgRml4ZWROdW1iZXIgc3RyaW5nIHZhbHVlXCIsIFwidmFsdWVcIiwgX3ZhbHVlKTtcbiAgICAgICAgY29uc3QgZm9ybWF0ID0gZ2V0Rm9ybWF0KF9mb3JtYXQpO1xuICAgICAgICBsZXQgd2hvbGUgPSAobWF0Y2hbMl0gfHwgXCIwXCIpLCBkZWNpbWFsID0gKG1hdGNoWzNdIHx8IFwiXCIpO1xuICAgICAgICAvLyBQYWQgb3V0IHRoZSBkZWNpbWFsc1xuICAgICAgICB3aGlsZSAoZGVjaW1hbC5sZW5ndGggPCBmb3JtYXQuZGVjaW1hbHMpIHtcbiAgICAgICAgICAgIGRlY2ltYWwgKz0gWmVyb3M7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2hlY2sgcHJlY2lzaW9uIGlzIHNhZmVcbiAgICAgICAgYXNzZXJ0KGRlY2ltYWwuc3Vic3RyaW5nKGZvcm1hdC5kZWNpbWFscykubWF0Y2goL14wKiQvKSwgXCJ0b28gbWFueSBkZWNpbWFscyBmb3IgZm9ybWF0XCIsIFwiTlVNRVJJQ19GQVVMVFwiLCB7XG4gICAgICAgICAgICBvcGVyYXRpb246IFwiZnJvbVN0cmluZ1wiLCBmYXVsdDogXCJ1bmRlcmZsb3dcIiwgdmFsdWU6IF92YWx1ZVxuICAgICAgICB9KTtcbiAgICAgICAgLy8gUmVtb3ZlIGV4dHJhIHBhZGRpbmdcbiAgICAgICAgZGVjaW1hbCA9IGRlY2ltYWwuc3Vic3RyaW5nKDAsIGZvcm1hdC5kZWNpbWFscyk7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gQmlnSW50KG1hdGNoWzFdICsgd2hvbGUgKyBkZWNpbWFsKTtcbiAgICAgICAgY2hlY2tWYWx1ZSh2YWx1ZSwgZm9ybWF0LCBcImZyb21TdHJpbmdcIik7XG4gICAgICAgIHJldHVybiBuZXcgRml4ZWROdW1iZXIoX2d1YXJkLCB2YWx1ZSwgZm9ybWF0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIENyZWF0ZXMgYSBuZXcgW1tGaXhlZE51bWJlcl1dIHdpdGggdGhlIGJpZy1lbmRpYW4gcmVwcmVzZW50YXRpb25cbiAgICAgKiAgJSV2YWx1ZSUlIHdpdGggJSVmb3JtYXQlJS5cbiAgICAgKlxuICAgICAqICBUaGlzIHdpbGwgdGhyb3cgYSBbW051bWVyaWNGYXVsdEVycm9yXV0gaWYgJSV2YWx1ZSUlIGNhbm5vdCBmaXRcbiAgICAgKiAgaW4gJSVmb3JtYXQlJSBkdWUgdG8gb3ZlcmZsb3cuXG4gICAgICovXG4gICAgc3RhdGljIGZyb21CeXRlcyhfdmFsdWUsIF9mb3JtYXQpIHtcbiAgICAgICAgbGV0IHZhbHVlID0gdG9CaWdJbnQoZ2V0Qnl0ZXMoX3ZhbHVlLCBcInZhbHVlXCIpKTtcbiAgICAgICAgY29uc3QgZm9ybWF0ID0gZ2V0Rm9ybWF0KF9mb3JtYXQpO1xuICAgICAgICBpZiAoZm9ybWF0LnNpZ25lZCkge1xuICAgICAgICAgICAgdmFsdWUgPSBmcm9tVHdvcyh2YWx1ZSwgZm9ybWF0LndpZHRoKTtcbiAgICAgICAgfVxuICAgICAgICBjaGVja1ZhbHVlKHZhbHVlLCBmb3JtYXQsIFwiZnJvbUJ5dGVzXCIpO1xuICAgICAgICByZXR1cm4gbmV3IEZpeGVkTnVtYmVyKF9ndWFyZCwgdmFsdWUsIGZvcm1hdCk7XG4gICAgfVxufVxuLy9jb25zdCBmMSA9IEZpeGVkTnVtYmVyLmZyb21TdHJpbmcoXCIxMi41NlwiLCBcImZpeGVkMTZ4MlwiKTtcbi8vY29uc3QgZjIgPSBGaXhlZE51bWJlci5mcm9tU3RyaW5nKFwiMC4zXCIsIFwiZml4ZWQxNngyXCIpO1xuLy9jb25zb2xlLmxvZyhmMS5kaXZTaWduYWwoZjIpKTtcbi8vY29uc3QgQlVNUCA9IEZpeGVkTnVtYmVyLmZyb20oXCIwLjVcIik7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1maXhlZG51bWJlci5qcy5tYXAiXSwibmFtZXMiOlsiZ2V0Qnl0ZXMiLCJhc3NlcnQiLCJhc3NlcnRBcmd1bWVudCIsImFzc2VydFByaXZhdGUiLCJnZXRCaWdJbnQiLCJnZXROdW1iZXIiLCJmcm9tVHdvcyIsIm1hc2siLCJ0b0JpZ0ludCIsImRlZmluZVByb3BlcnRpZXMiLCJCTl9OMSIsIkJpZ0ludCIsIkJOXzAiLCJCTl8xIiwiQk5fNSIsIl9ndWFyZCIsIlplcm9zIiwibGVuZ3RoIiwiZ2V0VGVucyIsImRlY2ltYWxzIiwicmVzdWx0Iiwic3Vic3RyaW5nIiwiY2hlY2tWYWx1ZSIsInZhbCIsImZvcm1hdCIsInNhZmVPcCIsIndpZHRoIiwic2lnbmVkIiwibGltaXQiLCJvcGVyYXRpb24iLCJmYXVsdCIsInZhbHVlIiwiZ2V0Rm9ybWF0IiwibWF0Y2giLCJwYXJzZUludCIsInYiLCJjaGVjayIsImtleSIsInR5cGUiLCJkZWZhdWx0VmFsdWUiLCJuYW1lIiwiU3RyaW5nIiwidG9TdHJpbmciLCJuZWdhdGl2ZSIsInN0ciIsImluZGV4IiwiRml4ZWROdW1iZXIiLCJ0ZW5zIiwiY29uc3RydWN0b3IiLCJndWFyZCIsIl92YWx1ZSIsImNoZWNrRm9ybWF0Iiwib3RoZXIiLCJhZGQiLCJvIiwiYWRkVW5zYWZlIiwic3ViIiwic3ViVW5zYWZlIiwibXVsIiwibXVsVW5zYWZlIiwibXVsU2lnbmFsIiwiZGl2IiwiZGl2VW5zYWZlIiwiZGl2U2lnbmFsIiwiY21wIiwiYSIsImIiLCJkZWx0YSIsImVxIiwibHQiLCJsdGUiLCJndCIsImd0ZSIsImZsb29yIiwiY2VpbGluZyIsInJvdW5kIiwiYnVtcCIsImlzWmVybyIsImlzTmVnYXRpdmUiLCJ0b1Vuc2FmZUZsb2F0IiwicGFyc2VGbG9hdCIsInRvRm9ybWF0IiwiZnJvbVN0cmluZyIsImZyb21WYWx1ZSIsIl9kZWNpbWFscyIsIl9mb3JtYXQiLCJ3aG9sZSIsImRlY2ltYWwiLCJmcm9tQnl0ZXMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ethers/lib.esm/utils/fixednumber.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ethers/lib.esm/utils/maths.js":
/*!****************************************************!*\
  !*** ./node_modules/ethers/lib.esm/utils/maths.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   fromTwos: () => (/* binding */ fromTwos),\n/* harmony export */   getBigInt: () => (/* binding */ getBigInt),\n/* harmony export */   getNumber: () => (/* binding */ getNumber),\n/* harmony export */   getUint: () => (/* binding */ getUint),\n/* harmony export */   mask: () => (/* binding */ mask),\n/* harmony export */   toBeArray: () => (/* binding */ toBeArray),\n/* harmony export */   toBeHex: () => (/* binding */ toBeHex),\n/* harmony export */   toBigInt: () => (/* binding */ toBigInt),\n/* harmony export */   toNumber: () => (/* binding */ toNumber),\n/* harmony export */   toQuantity: () => (/* binding */ toQuantity),\n/* harmony export */   toTwos: () => (/* binding */ toTwos)\n/* harmony export */ });\n/* harmony import */ var _data_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./data.js */ \"(rsc)/./node_modules/ethers/lib.esm/utils/data.js\");\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./errors.js */ \"(rsc)/./node_modules/ethers/lib.esm/utils/errors.js\");\n/**\n *  Some mathematic operations.\n *\n *  @_subsection: api/utils:Math Helpers  [about-maths]\n */ \n\nconst BN_0 = BigInt(0);\nconst BN_1 = BigInt(1);\n//const BN_Max256 = (BN_1 << BigInt(256)) - BN_1;\n// IEEE 754 support 53-bits of mantissa\nconst maxValue = 0x1fffffffffffff;\n/**\n *  Convert %%value%% from a twos-compliment representation of %%width%%\n *  bits to its value.\n *\n *  If the highest bit is ``1``, the result will be negative.\n */ function fromTwos(_value, _width) {\n    const value = getUint(_value, \"value\");\n    const width = BigInt(getNumber(_width, \"width\"));\n    (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assert)(value >> width === BN_0, \"overflow\", \"NUMERIC_FAULT\", {\n        operation: \"fromTwos\",\n        fault: \"overflow\",\n        value: _value\n    });\n    // Top bit set; treat as a negative value\n    if (value >> width - BN_1) {\n        const mask = (BN_1 << width) - BN_1;\n        return -((~value & mask) + BN_1);\n    }\n    return value;\n}\n/**\n *  Convert %%value%% to a twos-compliment representation of\n *  %%width%% bits.\n *\n *  The result will always be positive.\n */ function toTwos(_value, _width) {\n    let value = getBigInt(_value, \"value\");\n    const width = BigInt(getNumber(_width, \"width\"));\n    const limit = BN_1 << width - BN_1;\n    if (value < BN_0) {\n        value = -value;\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assert)(value <= limit, \"too low\", \"NUMERIC_FAULT\", {\n            operation: \"toTwos\",\n            fault: \"overflow\",\n            value: _value\n        });\n        const mask = (BN_1 << width) - BN_1;\n        return (~value & mask) + BN_1;\n    } else {\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assert)(value < limit, \"too high\", \"NUMERIC_FAULT\", {\n            operation: \"toTwos\",\n            fault: \"overflow\",\n            value: _value\n        });\n    }\n    return value;\n}\n/**\n *  Mask %%value%% with a bitmask of %%bits%% ones.\n */ function mask(_value, _bits) {\n    const value = getUint(_value, \"value\");\n    const bits = BigInt(getNumber(_bits, \"bits\"));\n    return value & (BN_1 << bits) - BN_1;\n}\n/**\n *  Gets a BigInt from %%value%%. If it is an invalid value for\n *  a BigInt, then an ArgumentError will be thrown for %%name%%.\n */ function getBigInt(value, name) {\n    switch(typeof value){\n        case \"bigint\":\n            return value;\n        case \"number\":\n            (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(Number.isInteger(value), \"underflow\", name || \"value\", value);\n            (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(value >= -maxValue && value <= maxValue, \"overflow\", name || \"value\", value);\n            return BigInt(value);\n        case \"string\":\n            try {\n                if (value === \"\") {\n                    throw new Error(\"empty string\");\n                }\n                if (value[0] === \"-\" && value[1] !== \"-\") {\n                    return -BigInt(value.substring(1));\n                }\n                return BigInt(value);\n            } catch (e) {\n                (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(false, `invalid BigNumberish string: ${e.message}`, name || \"value\", value);\n            }\n    }\n    (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(false, \"invalid BigNumberish value\", name || \"value\", value);\n}\n/**\n *  Returns %%value%% as a bigint, validating it is valid as a bigint\n *  value and that it is positive.\n */ function getUint(value, name) {\n    const result = getBigInt(value, name);\n    (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assert)(result >= BN_0, \"unsigned value cannot be negative\", \"NUMERIC_FAULT\", {\n        fault: \"overflow\",\n        operation: \"getUint\",\n        value\n    });\n    return result;\n}\nconst Nibbles = \"0123456789abcdef\";\n/*\n * Converts %%value%% to a BigInt. If %%value%% is a Uint8Array, it\n * is treated as Big Endian data.\n */ function toBigInt(value) {\n    if (value instanceof Uint8Array) {\n        let result = \"0x0\";\n        for (const v of value){\n            result += Nibbles[v >> 4];\n            result += Nibbles[v & 0x0f];\n        }\n        return BigInt(result);\n    }\n    return getBigInt(value);\n}\n/**\n *  Gets a //number// from %%value%%. If it is an invalid value for\n *  a //number//, then an ArgumentError will be thrown for %%name%%.\n */ function getNumber(value, name) {\n    switch(typeof value){\n        case \"bigint\":\n            (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(value >= -maxValue && value <= maxValue, \"overflow\", name || \"value\", value);\n            return Number(value);\n        case \"number\":\n            (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(Number.isInteger(value), \"underflow\", name || \"value\", value);\n            (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(value >= -maxValue && value <= maxValue, \"overflow\", name || \"value\", value);\n            return value;\n        case \"string\":\n            try {\n                if (value === \"\") {\n                    throw new Error(\"empty string\");\n                }\n                return getNumber(BigInt(value), name);\n            } catch (e) {\n                (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(false, `invalid numeric string: ${e.message}`, name || \"value\", value);\n            }\n    }\n    (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(false, \"invalid numeric value\", name || \"value\", value);\n}\n/**\n *  Converts %%value%% to a number. If %%value%% is a Uint8Array, it\n *  is treated as Big Endian data. Throws if the value is not safe.\n */ function toNumber(value) {\n    return getNumber(toBigInt(value));\n}\n/**\n *  Converts %%value%% to a Big Endian hexstring, optionally padded to\n *  %%width%% bytes.\n */ function toBeHex(_value, _width) {\n    const value = getUint(_value, \"value\");\n    let result = value.toString(16);\n    if (_width == null) {\n        // Ensure the value is of even length\n        if (result.length % 2) {\n            result = \"0\" + result;\n        }\n    } else {\n        const width = getNumber(_width, \"width\");\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assert)(width * 2 >= result.length, `value exceeds width (${width} bytes)`, \"NUMERIC_FAULT\", {\n            operation: \"toBeHex\",\n            fault: \"overflow\",\n            value: _value\n        });\n        // Pad the value to the required width\n        while(result.length < width * 2){\n            result = \"0\" + result;\n        }\n    }\n    return \"0x\" + result;\n}\n/**\n *  Converts %%value%% to a Big Endian Uint8Array.\n */ function toBeArray(_value) {\n    const value = getUint(_value, \"value\");\n    if (value === BN_0) {\n        return new Uint8Array([]);\n    }\n    let hex = value.toString(16);\n    if (hex.length % 2) {\n        hex = \"0\" + hex;\n    }\n    const result = new Uint8Array(hex.length / 2);\n    for(let i = 0; i < result.length; i++){\n        const offset = i * 2;\n        result[i] = parseInt(hex.substring(offset, offset + 2), 16);\n    }\n    return result;\n}\n/**\n *  Returns a [[HexString]] for %%value%% safe to use as a //Quantity//.\n *\n *  A //Quantity// does not have and leading 0 values unless the value is\n *  the literal value `0x0`. This is most commonly used for JSSON-RPC\n *  numeric values.\n */ function toQuantity(value) {\n    let result = (0,_data_js__WEBPACK_IMPORTED_MODULE_1__.hexlify)((0,_data_js__WEBPACK_IMPORTED_MODULE_1__.isBytesLike)(value) ? value : toBeArray(value)).substring(2);\n    while(result.startsWith(\"0\")){\n        result = result.substring(1);\n    }\n    if (result === \"\") {\n        result = \"0\";\n    }\n    return \"0x\" + result;\n} //# sourceMappingURL=maths.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vdXRpbHMvbWF0aHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7OztBQUFBOzs7O0NBSUMsR0FDZ0Q7QUFDSTtBQUNyRCxNQUFNSSxPQUFPQyxPQUFPO0FBQ3BCLE1BQU1DLE9BQU9ELE9BQU87QUFDcEIsaURBQWlEO0FBQ2pELHVDQUF1QztBQUN2QyxNQUFNRSxXQUFXO0FBQ2pCOzs7OztDQUtDLEdBQ00sU0FBU0MsU0FBU0MsTUFBTSxFQUFFQyxNQUFNO0lBQ25DLE1BQU1DLFFBQVFDLFFBQVFILFFBQVE7SUFDOUIsTUFBTUksUUFBUVIsT0FBT1MsVUFBVUosUUFBUTtJQUN2Q1Isa0RBQU1BLENBQUMsU0FBVVcsVUFBV1QsTUFBTSxZQUFZLGlCQUFpQjtRQUMzRFcsV0FBVztRQUFZQyxPQUFPO1FBQVlMLE9BQU9GO0lBQ3JEO0lBQ0EseUNBQXlDO0lBQ3pDLElBQUlFLFNBQVVFLFFBQVFQLE1BQU87UUFDekIsTUFBTVcsT0FBTyxDQUFDWCxRQUFRTyxLQUFJLElBQUtQO1FBQy9CLE9BQU8sQ0FBRSxFQUFDLENBQUVLLFFBQVNNLElBQUcsSUFBS1gsSUFBRztJQUNwQztJQUNBLE9BQU9LO0FBQ1g7QUFDQTs7Ozs7Q0FLQyxHQUNNLFNBQVNPLE9BQU9ULE1BQU0sRUFBRUMsTUFBTTtJQUNqQyxJQUFJQyxRQUFRUSxVQUFVVixRQUFRO0lBQzlCLE1BQU1JLFFBQVFSLE9BQU9TLFVBQVVKLFFBQVE7SUFDdkMsTUFBTVUsUUFBU2QsUUFBU08sUUFBUVA7SUFDaEMsSUFBSUssUUFBUVAsTUFBTTtRQUNkTyxRQUFRLENBQUNBO1FBQ1RULGtEQUFNQSxDQUFDUyxTQUFTUyxPQUFPLFdBQVcsaUJBQWlCO1lBQy9DTCxXQUFXO1lBQVVDLE9BQU87WUFBWUwsT0FBT0Y7UUFDbkQ7UUFDQSxNQUFNUSxPQUFPLENBQUNYLFFBQVFPLEtBQUksSUFBS1A7UUFDL0IsT0FBTyxDQUFDLENBQUVLLFFBQVNNLElB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SUFBSSxHQUFHQSxJQUFJWCxPQUFPUSxNQUFNLEVBQUVHLElBQUs7UUFDcEMsTUFBTUMsU0FBU0QsSUFBSTtRQUNuQlgsTUFBTSxDQUFDVyxFQUFFLEdBQUdFLFNBQVNILElBQUliLFNBQVMsQ0FBQ2UsUUFBUUEsU0FBUyxJQUFJO0lBQzVEO0lBQ0EsT0FBT1o7QUFDWDtBQUNBOzs7Ozs7Q0FNQyxHQUNNLFNBQVNjLFdBQVdqQyxLQUFLO0lBQzVCLElBQUltQixTQUFTOUIsaURBQU9BLENBQUNDLHFEQUFXQSxDQUFDVSxTQUFTQSxRQUFRNEIsVUFBVTVCLFFBQVFnQixTQUFTLENBQUM7SUFDOUUsTUFBT0csT0FBT2UsVUFBVSxDQUFDLEtBQU07UUFDM0JmLFNBQVNBLE9BQU9ILFNBQVMsQ0FBQztJQUM5QjtJQUNBLElBQUlHLFdBQVcsSUFBSTtRQUNmQSxTQUFTO0lBQ2I7SUFDQSxPQUFPLE9BQU9BO0FBQ2xCLEVBQ0EsaUNBQWlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbWVnYXZpYmUtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vdXRpbHMvbWF0aHMuanM/YmNlMCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqICBTb21lIG1hdGhlbWF0aWMgb3BlcmF0aW9ucy5cbiAqXG4gKiAgQF9zdWJzZWN0aW9uOiBhcGkvdXRpbHM6TWF0aCBIZWxwZXJzICBbYWJvdXQtbWF0aHNdXG4gKi9cbmltcG9ydCB7IGhleGxpZnksIGlzQnl0ZXNMaWtlIH0gZnJvbSBcIi4vZGF0YS5qc1wiO1xuaW1wb3J0IHsgYXNzZXJ0LCBhc3NlcnRBcmd1bWVudCB9IGZyb20gXCIuL2Vycm9ycy5qc1wiO1xuY29uc3QgQk5fMCA9IEJpZ0ludCgwKTtcbmNvbnN0IEJOXzEgPSBCaWdJbnQoMSk7XG4vL2NvbnN0IEJOX01heDI1NiA9IChCTl8xIDw8IEJpZ0ludCgyNTYpKSAtIEJOXzE7XG4vLyBJRUVFIDc1NCBzdXBwb3J0IDUzLWJpdHMgb2YgbWFudGlzc2FcbmNvbnN0IG1heFZhbHVlID0gMHgxZmZmZmZmZmZmZmZmZjtcbi8qKlxuICogIENvbnZlcnQgJSV2YWx1ZSUlIGZyb20gYSB0d29zLWNvbXBsaW1lbnQgcmVwcmVzZW50YXRpb24gb2YgJSV3aWR0aCUlXG4gKiAgYml0cyB0byBpdHMgdmFsdWUuXG4gKlxuICogIElmIHRoZSBoaWdoZXN0IGJpdCBpcyBgYDFgYCwgdGhlIHJlc3VsdCB3aWxsIGJlIG5lZ2F0aXZlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbVR3b3MoX3ZhbHVlLCBfd2lkdGgpIHtcbiAgICBjb25zdCB2YWx1ZSA9IGdldFVpbnQoX3ZhbHVlLCBcInZhbHVlXCIpO1xuICAgIGNvbnN0IHdpZHRoID0gQmlnSW50KGdldE51bWJlcihfd2lkdGgsIFwid2lkdGhcIikpO1xuICAgIGFzc2VydCgodmFsdWUgPj4gd2lkdGgpID09PSBCTl8wLCBcIm92ZXJmbG93XCIsIFwiTlVNRVJJQ19GQVVMVFwiLCB7XG4gICAgICAgIG9wZXJhdGlvbjogXCJmcm9tVHdvc1wiLCBmYXVsdDogXCJvdmVyZmxvd1wiLCB2YWx1ZTogX3ZhbHVlXG4gICAgfSk7XG4gICAgLy8gVG9wIGJpdCBzZXQ7IHRyZWF0IGFzIGEgbmVnYXRpdmUgdmFsdWVcbiAgICBpZiAodmFsdWUgPj4gKHdpZHRoIC0gQk5fMSkpIHtcbiAgICAgICAgY29uc3QgbWFzayA9IChCTl8xIDw8IHdpZHRoKSAtIEJOXzE7XG4gICAgICAgIHJldHVybiAtKCgofnZhbHVlKSAmIG1hc2spICsgQk5fMSk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbn1cbi8qKlxuICogIENvbnZlcnQgJSV2YWx1ZSUlIHRvIGEgdHdvcy1jb21wbGltZW50IHJlcHJlc2VudGF0aW9uIG9mXG4gKiAgJSV3aWR0aCUlIGJpdHMuXG4gKlxuICogIFRoZSByZXN1bHQgd2lsbCBhbHdheXMgYmUgcG9zaXRpdmUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b1R3b3MoX3ZhbHVlLCBfd2lkdGgpIHtcbiAgICBsZXQgdmFsdWUgPSBnZXRCaWdJbnQoX3ZhbHVlLCBcInZhbHVlXCIpO1xuICAgIGNvbnN0IHdpZHRoID0gQmlnSW50KGdldE51bWJlcihfd2lkdGgsIFwid2lkdGhcIikpO1xuICAgIGNvbnN0IGxpbWl0ID0gKEJOXzEgPDwgKHdpZHRoIC0gQk5fMSkpO1xuICAgIGlmICh2YWx1ZSA8IEJOXzApIHtcbiAgICAgICAgdmFsdWUgPSAtdmFsdWU7XG4gICAgICAgIGFzc2VydCh2YWx1ZSA8PSBsaW1pdCwgXCJ0b28gbG93XCIsIFwiTlVNRVJJQ19GQVVMVFwiLCB7XG4gICAgICAgICAgICBvcGVyYXRpb246IFwidG9Ud29zXCIsIGZhdWx0OiBcIm92ZXJmbG93XCIsIHZhbHVlOiBfdmFsdWVcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IG1hc2sgPSAoQk5fMSA8PCB3aWR0aCkgLSBCTl8xO1xuICAgICAgICByZXR1cm4gKCh+dmFsdWUpICYgbWFzaykgKyBCTl8xO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgYXNzZXJ0KHZhbHVlIDwgbGltaXQsIFwidG9vIGhpZ2hcIiwgXCJOVU1FUklDX0ZBVUxUXCIsIHtcbiAgICAgICAgICAgIG9wZXJhdGlvbjogXCJ0b1R3b3NcIiwgZmF1bHQ6IFwib3ZlcmZsb3dcIiwgdmFsdWU6IF92YWx1ZVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xufVxuLyoqXG4gKiAgTWFzayAlJXZhbHVlJSUgd2l0aCBhIGJpdG1hc2sgb2YgJSViaXRzJSUgb25lcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1hc2soX3ZhbHVlLCBfYml0cykge1xuICAgIGNvbnN0IHZhbHVlID0gZ2V0VWludChfdmFsdWUsIFwidmFsdWVcIik7XG4gICAgY29uc3QgYml0cyA9IEJpZ0ludChnZXROdW1iZXIoX2JpdHMsIFwiYml0c1wiKSk7XG4gICAgcmV0dXJuIHZhbHVlICYgKChCTl8xIDw8IGJpdHMpIC0gQk5fMSk7XG59XG4vKipcbiAqICBHZXRzIGEgQmlnSW50IGZyb20gJSV2YWx1ZSUlLiBJZiBpdCBpcyBhbiBpbnZhbGlkIHZhbHVlIGZvclxuICogIGEgQmlnSW50LCB0aGVuIGFuIEFyZ3VtZW50RXJyb3Igd2lsbCBiZSB0aHJvd24gZm9yICUlbmFtZSUlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0QmlnSW50KHZhbHVlLCBuYW1lKSB7XG4gICAgc3dpdGNoICh0eXBlb2YgKHZhbHVlKSkge1xuICAgICAgICBjYXNlIFwiYmlnaW50XCI6IHJldHVybiB2YWx1ZTtcbiAgICAgICAgY2FzZSBcIm51bWJlclwiOlxuICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoTnVtYmVyLmlzSW50ZWdlcih2YWx1ZSksIFwidW5kZXJmbG93XCIsIG5hbWUgfHwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudCh2YWx1ZSA+PSAtbWF4VmFsdWUgJiYgdmFsdWUgPD0gbWF4VmFsdWUsIFwib3ZlcmZsb3dcIiwgbmFtZSB8fCBcInZhbHVlXCIsIHZhbHVlKTtcbiAgICAgICAgICAgIHJldHVybiBCaWdJbnQodmFsdWUpO1xuICAgICAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gXCJcIikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJlbXB0eSBzdHJpbmdcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZVswXSA9PT0gXCItXCIgJiYgdmFsdWVbMV0gIT09IFwiLVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAtQmlnSW50KHZhbHVlLnN1YnN0cmluZygxKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBCaWdJbnQodmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBhc3NlcnRBcmd1bWVudChmYWxzZSwgYGludmFsaWQgQmlnTnVtYmVyaXNoIHN0cmluZzogJHtlLm1lc3NhZ2V9YCwgbmFtZSB8fCBcInZhbHVlXCIsIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICB9XG4gICAgYXNzZXJ0QXJndW1lbnQoZmFsc2UsIFwiaW52YWxpZCBCaWdOdW1iZXJpc2ggdmFsdWVcIiwgbmFtZSB8fCBcInZhbHVlXCIsIHZhbHVlKTtcbn1cbi8qKlxuICogIFJldHVybnMgJSV2YWx1ZSUlIGFzIGEgYmlnaW50LCB2YWxpZGF0aW5nIGl0IGlzIHZhbGlkIGFzIGEgYmlnaW50XG4gKiAgdmFsdWUgYW5kIHRoYXQgaXQgaXMgcG9zaXRpdmUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRVaW50KHZhbHVlLCBuYW1lKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gZ2V0QmlnSW50KHZhbHVlLCBuYW1lKTtcbiAgICBhc3NlcnQocmVzdWx0ID49IEJOXzAsIFwidW5zaWduZWQgdmFsdWUgY2Fubm90IGJlIG5lZ2F0aXZlXCIsIFwiTlVNRVJJQ19GQVVMVFwiLCB7XG4gICAgICAgIGZhdWx0OiBcIm92ZXJmbG93XCIsIG9wZXJhdGlvbjogXCJnZXRVaW50XCIsIHZhbHVlXG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmNvbnN0IE5pYmJsZXMgPSBcIjAxMjM0NTY3ODlhYmNkZWZcIjtcbi8qXG4gKiBDb252ZXJ0cyAlJXZhbHVlJSUgdG8gYSBCaWdJbnQuIElmICUldmFsdWUlJSBpcyBhIFVpbnQ4QXJyYXksIGl0XG4gKiBpcyB0cmVhdGVkIGFzIEJpZyBFbmRpYW4gZGF0YS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvQmlnSW50KHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgICAgICBsZXQgcmVzdWx0ID0gXCIweDBcIjtcbiAgICAgICAgZm9yIChjb25zdCB2IG9mIHZhbHVlKSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gTmliYmxlc1t2ID4+IDRdO1xuICAgICAgICAgICAgcmVzdWx0ICs9IE5pYmJsZXNbdiAmIDB4MGZdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBCaWdJbnQocmVzdWx0KTtcbiAgICB9XG4gICAgcmV0dXJuIGdldEJpZ0ludCh2YWx1ZSk7XG59XG4vKipcbiAqICBHZXRzIGEgLy9udW1iZXIvLyBmcm9tICUldmFsdWUlJS4gSWYgaXQgaXMgYW4gaW52YWxpZCB2YWx1ZSBmb3JcbiAqICBhIC8vbnVtYmVyLy8sIHRoZW4gYW4gQXJndW1lbnRFcnJvciB3aWxsIGJlIHRocm93biBmb3IgJSVuYW1lJSUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXROdW1iZXIodmFsdWUsIG5hbWUpIHtcbiAgICBzd2l0Y2ggKHR5cGVvZiAodmFsdWUpKSB7XG4gICAgICAgIGNhc2UgXCJiaWdpbnRcIjpcbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KHZhbHVlID49IC1tYXhWYWx1ZSAmJiB2YWx1ZSA8PSBtYXhWYWx1ZSwgXCJvdmVyZmxvd1wiLCBuYW1lIHx8IFwidmFsdWVcIiwgdmFsdWUpO1xuICAgICAgICAgICAgcmV0dXJuIE51bWJlcih2YWx1ZSk7XG4gICAgICAgIGNhc2UgXCJudW1iZXJcIjpcbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KE51bWJlci5pc0ludGVnZXIodmFsdWUpLCBcInVuZGVyZmxvd1wiLCBuYW1lIHx8IFwidmFsdWVcIiwgdmFsdWUpO1xuICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQodmFsdWUgPj0gLW1heFZhbHVlICYmIHZhbHVlIDw9IG1heFZhbHVlLCBcIm92ZXJmbG93XCIsIG5hbWUgfHwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID09PSBcIlwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImVtcHR5IHN0cmluZ1wiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGdldE51bWJlcihCaWdJbnQodmFsdWUpLCBuYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoZmFsc2UsIGBpbnZhbGlkIG51bWVyaWMgc3RyaW5nOiAke2UubWVzc2FnZX1gLCBuYW1lIHx8IFwidmFsdWVcIiwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgIH1cbiAgICBhc3NlcnRBcmd1bWVudChmYWxzZSwgXCJpbnZhbGlkIG51bWVyaWMgdmFsdWVcIiwgbmFtZSB8fCBcInZhbHVlXCIsIHZhbHVlKTtcbn1cbi8qKlxuICogIENvbnZlcnRzICUldmFsdWUlJSB0byBhIG51bWJlci4gSWYgJSV2YWx1ZSUlIGlzIGEgVWludDhBcnJheSwgaXRcbiAqICBpcyB0cmVhdGVkIGFzIEJpZyBFbmRpYW4gZGF0YS4gVGhyb3dzIGlmIHRoZSB2YWx1ZSBpcyBub3Qgc2FmZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvTnVtYmVyKHZhbHVlKSB7XG4gICAgcmV0dXJuIGdldE51bWJlcih0b0JpZ0ludCh2YWx1ZSkpO1xufVxuLyoqXG4gKiAgQ29udmVydHMgJSV2YWx1ZSUlIHRvIGEgQmlnIEVuZGlhbiBoZXhzdHJpbmcsIG9wdGlvbmFsbHkgcGFkZGVkIHRvXG4gKiAgJSV3aWR0aCUlIGJ5dGVzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9CZUhleChfdmFsdWUsIF93aWR0aCkge1xuICAgIGNvbnN0IHZhbHVlID0gZ2V0VWludChfdmFsdWUsIFwidmFsdWVcIik7XG4gICAgbGV0IHJlc3VsdCA9IHZhbHVlLnRvU3RyaW5nKDE2KTtcbiAgICBpZiAoX3dpZHRoID09IG51bGwpIHtcbiAgICAgICAgLy8gRW5zdXJlIHRoZSB2YWx1ZSBpcyBvZiBldmVuIGxlbmd0aFxuICAgICAgICBpZiAocmVzdWx0Lmxlbmd0aCAlIDIpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IFwiMFwiICsgcmVzdWx0O1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb25zdCB3aWR0aCA9IGdldE51bWJlcihfd2lkdGgsIFwid2lkdGhcIik7XG4gICAgICAgIGFzc2VydCh3aWR0aCAqIDIgPj0gcmVzdWx0Lmxlbmd0aCwgYHZhbHVlIGV4Y2VlZHMgd2lkdGggKCR7d2lkdGh9IGJ5dGVzKWAsIFwiTlVNRVJJQ19GQVVMVFwiLCB7XG4gICAgICAgICAgICBvcGVyYXRpb246IFwidG9CZUhleFwiLFxuICAgICAgICAgICAgZmF1bHQ6IFwib3ZlcmZsb3dcIixcbiAgICAgICAgICAgIHZhbHVlOiBfdmFsdWVcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIFBhZCB0aGUgdmFsdWUgdG8gdGhlIHJlcXVpcmVkIHdpZHRoXG4gICAgICAgIHdoaWxlIChyZXN1bHQubGVuZ3RoIDwgKHdpZHRoICogMikpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IFwiMFwiICsgcmVzdWx0O1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBcIjB4XCIgKyByZXN1bHQ7XG59XG4vKipcbiAqICBDb252ZXJ0cyAlJXZhbHVlJSUgdG8gYSBCaWcgRW5kaWFuIFVpbnQ4QXJyYXkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0JlQXJyYXkoX3ZhbHVlKSB7XG4gICAgY29uc3QgdmFsdWUgPSBnZXRVaW50KF92YWx1ZSwgXCJ2YWx1ZVwiKTtcbiAgICBpZiAodmFsdWUgPT09IEJOXzApIHtcbiAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KFtdKTtcbiAgICB9XG4gICAgbGV0IGhleCA9IHZhbHVlLnRvU3RyaW5nKDE2KTtcbiAgICBpZiAoaGV4Lmxlbmd0aCAlIDIpIHtcbiAgICAgICAgaGV4ID0gXCIwXCIgKyBoZXg7XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBVaW50OEFycmF5KGhleC5sZW5ndGggLyAyKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlc3VsdC5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBvZmZzZXQgPSBpICogMjtcbiAgICAgICAgcmVzdWx0W2ldID0gcGFyc2VJbnQoaGV4LnN1YnN0cmluZyhvZmZzZXQsIG9mZnNldCArIDIpLCAxNik7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG4vKipcbiAqICBSZXR1cm5zIGEgW1tIZXhTdHJpbmddXSBmb3IgJSV2YWx1ZSUlIHNhZmUgdG8gdXNlIGFzIGEgLy9RdWFudGl0eS8vLlxuICpcbiAqICBBIC8vUXVhbnRpdHkvLyBkb2VzIG5vdCBoYXZlIGFuZCBsZWFkaW5nIDAgdmFsdWVzIHVubGVzcyB0aGUgdmFsdWUgaXNcbiAqICB0aGUgbGl0ZXJhbCB2YWx1ZSBgMHgwYC4gVGhpcyBpcyBtb3N0IGNvbW1vbmx5IHVzZWQgZm9yIEpTU09OLVJQQ1xuICogIG51bWVyaWMgdmFsdWVzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9RdWFudGl0eSh2YWx1ZSkge1xuICAgIGxldCByZXN1bHQgPSBoZXhsaWZ5KGlzQnl0ZXNMaWtlKHZhbHVlKSA/IHZhbHVlIDogdG9CZUFycmF5KHZhbHVlKSkuc3Vic3RyaW5nKDIpO1xuICAgIHdoaWxlIChyZXN1bHQuc3RhcnRzV2l0aChcIjBcIikpIHtcbiAgICAgICAgcmVzdWx0ID0gcmVzdWx0LnN1YnN0cmluZygxKTtcbiAgICB9XG4gICAgaWYgKHJlc3VsdCA9PT0gXCJcIikge1xuICAgICAgICByZXN1bHQgPSBcIjBcIjtcbiAgICB9XG4gICAgcmV0dXJuIFwiMHhcIiArIHJlc3VsdDtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1hdGhzLmpzLm1hcCJdLCJuYW1lcyI6WyJoZXhsaWZ5IiwiaXNCeXRlc0xpa2UiLCJhc3NlcnQiLCJhc3NlcnRBcmd1bWVudCIsIkJOXzAiLCJCaWdJbnQiLCJCTl8xIiwibWF4VmFsdWUiLCJmcm9tVHdvcyIsIl92YWx1ZSIsIl93aWR0aCIsInZhbHVlIiwiZ2V0VWludCIsIndpZHRoIiwiZ2V0TnVtYmVyIiwib3BlcmF0aW9uIiwiZmF1bHQiLCJtYXNrIiwidG9Ud29zIiwiZ2V0QmlnSW50IiwibGltaXQiLCJfYml0cyIsImJpdHMiLCJuYW1lIiwiTnVtYmVyIiwiaXNJbnRlZ2VyIiwiRXJyb3IiLCJzdWJzdHJpbmciLCJlIiwibWVzc2FnZSIsInJlc3VsdCIsIk5pYmJsZXMiLCJ0b0JpZ0ludCIsIlVpbnQ4QXJyYXkiLCJ2IiwidG9OdW1iZXIiLCJ0b0JlSGV4IiwidG9TdHJpbmciLCJsZW5ndGgiLCJ0b0JlQXJyYXkiLCJoZXgiLCJpIiwib2Zmc2V0IiwicGFyc2VJbnQiLCJ0b1F1YW50aXR5Iiwic3RhcnRzV2l0aCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ethers/lib.esm/utils/maths.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ethers/lib.esm/utils/properties.js":
/*!*********************************************************!*\
  !*** ./node_modules/ethers/lib.esm/utils/properties.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   defineProperties: () => (/* binding */ defineProperties),\n/* harmony export */   resolveProperties: () => (/* binding */ resolveProperties)\n/* harmony export */ });\n/**\n *  Property helper functions.\n *\n *  @_subsection api/utils:Properties  [about-properties]\n */ function checkType(value, type, name) {\n    const types = type.split(\"|\").map((t)=>t.trim());\n    for(let i = 0; i < types.length; i++){\n        switch(type){\n            case \"any\":\n                return;\n            case \"bigint\":\n            case \"boolean\":\n            case \"number\":\n            case \"string\":\n                if (typeof value === type) {\n                    return;\n                }\n        }\n    }\n    const error = new Error(`invalid value for type ${type}`);\n    error.code = \"INVALID_ARGUMENT\";\n    error.argument = `value.${name}`;\n    error.value = value;\n    throw error;\n}\n/**\n *  Resolves to a new object that is a copy of %%value%%, but with all\n *  values resolved.\n */ async function resolveProperties(value) {\n    const keys = Object.keys(value);\n    const results = await Promise.all(keys.map((k)=>Promise.resolve(value[k])));\n    return results.reduce((accum, v, index)=>{\n        accum[keys[index]] = v;\n        return accum;\n    }, {});\n}\n/**\n *  Assigns the %%values%% to %%target%% as read-only values.\n *\n *  It %%types%% is specified, the values are checked.\n */ function defineProperties(target, values, types) {\n    for(let key in values){\n        let value = values[key];\n        const type = types ? types[key] : null;\n        if (type) {\n            checkType(value, type, key);\n        }\n        Object.defineProperty(target, key, {\n            enumerable: true,\n            value,\n            writable: false\n        });\n    }\n} //# sourceMappingURL=properties.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vdXRpbHMvcHJvcGVydGllcy5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBOzs7O0NBSUMsR0FDRCxTQUFTQSxVQUFVQyxLQUFLLEVBQUVDLElBQUksRUFBRUMsSUFBSTtJQUNoQyxNQUFNQyxRQUFRRixLQUFLRyxLQUFLLENBQUMsS0FBS0MsR0FBRyxDQUFDQyxDQUFBQSxJQUFLQSxFQUFFQyxJQUFJO0lBQzdDLElBQUssSUFBSUMsSUFBSSxHQUFHQSxJQUFJTCxNQUFNTSxNQUFNLEVBQUVELElBQUs7UUFDbkMsT0FBUVA7WUFDSixLQUFLO2dCQUNEO1lBQ0osS0FBSztZQUNMLEtBQUs7WUFDTCxLQUFLO1lBQ0wsS0FBSztnQkFDRCxJQUFJLE9BQVFELFVBQVdDLE1BQU07b0JBQ3pCO2dCQUNKO1FBQ1I7SUFDSjtJQUNBLE1BQU1TLFFBQVEsSUFBSUMsTUFBTSxDQUFDLHVCQUF1QixFQUFFVixLQUFLLENBQUM7SUFDeERTLE1BQU1FLElBQUksR0FBRztJQUNiRixNQUFNRyxRQUFRLEdBQUcsQ0FBQyxNQUFNLEVBQUVYLEtBQUssQ0FBQztJQUNoQ1EsTUFBTVYsS0FBSyxHQUFHQTtJQUNkLE1BQU1VO0FBQ1Y7QUFDQTs7O0NBR0MsR0FDTSxlQUFlSSxrQkFBa0JkLEtBQUs7SUFDekMsTUFBTWUsT0FBT0MsT0FBT0QsSUFBSSxDQUFDZjtJQUN6QixNQUFNaUIsVUFBVSxNQUFNQyxRQUFRQyxHQUFHLENBQUNKLEtBQUtWLEdBQUcsQ0FBQyxDQUFDZSxJQUFNRixRQUFRRyxPQUFPLENBQUNyQixLQUFLLENBQUNvQixFQUFFO0lBQzFFLE9BQU9ILFFBQVFLLE1BQU0sQ0FBQyxDQUFDQyxPQUFPQyxHQUFHQztRQUM3QkYsS0FBSyxDQUFDUixJQUFJLENBQUNVLE1BQU0sQ0FBQyxHQUFHRDtRQUNyQixPQUFPRDtJQUNYLEdBQUcsQ0FBQztBQUNSO0FBQ0E7Ozs7Q0FJQyxHQUNNLFNBQVNHLGlCQUFpQkMsTUFBTSxFQUFFQyxNQUFNLEVBQUV6QixLQUFLO0lBQ2xELElBQUssSUFBSTBCLE9BQU9ELE9BQVE7UUFDcEIsSUFBSTVCLFFBQVE0QixNQUFNLENBQUNDLElBQUk7UUFDdkIsTUFBTTVCLE9BQVFFLFFBQVFBLEtBQUssQ0FBQzBCLElBQUksR0FBRztRQUNuQyxJQUFJNUIsTUFBTTtZQUNORixVQUFVQyxPQUFPQyxNQUFNNEI7UUFDM0I7UUFDQWIsT0FBT2MsY0FBYyxDQUFDSCxRQUFRRSxLQUFLO1lBQUVFLFlBQVk7WUFBTS9CO1lBQU9nQyxVQUFVO1FBQU07SUFDbEY7QUFDSixFQUNBLHNDQUFzQyIsInNvdXJjZXMiOlsid2VicGFjazovL21lZ2F2aWJlLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL3V0aWxzL3Byb3BlcnRpZXMuanM/NTIwNyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqICBQcm9wZXJ0eSBoZWxwZXIgZnVuY3Rpb25zLlxuICpcbiAqICBAX3N1YnNlY3Rpb24gYXBpL3V0aWxzOlByb3BlcnRpZXMgIFthYm91dC1wcm9wZXJ0aWVzXVxuICovXG5mdW5jdGlvbiBjaGVja1R5cGUodmFsdWUsIHR5cGUsIG5hbWUpIHtcbiAgICBjb25zdCB0eXBlcyA9IHR5cGUuc3BsaXQoXCJ8XCIpLm1hcCh0ID0+IHQudHJpbSgpKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHR5cGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgICAgY2FzZSBcImFueVwiOlxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGNhc2UgXCJiaWdpbnRcIjpcbiAgICAgICAgICAgIGNhc2UgXCJib29sZWFuXCI6XG4gICAgICAgICAgICBjYXNlIFwibnVtYmVyXCI6XG4gICAgICAgICAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiAodmFsdWUpID09PSB0eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoYGludmFsaWQgdmFsdWUgZm9yIHR5cGUgJHt0eXBlfWApO1xuICAgIGVycm9yLmNvZGUgPSBcIklOVkFMSURfQVJHVU1FTlRcIjtcbiAgICBlcnJvci5hcmd1bWVudCA9IGB2YWx1ZS4ke25hbWV9YDtcbiAgICBlcnJvci52YWx1ZSA9IHZhbHVlO1xuICAgIHRocm93IGVycm9yO1xufVxuLyoqXG4gKiAgUmVzb2x2ZXMgdG8gYSBuZXcgb2JqZWN0IHRoYXQgaXMgYSBjb3B5IG9mICUldmFsdWUlJSwgYnV0IHdpdGggYWxsXG4gKiAgdmFsdWVzIHJlc29sdmVkLlxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcmVzb2x2ZVByb3BlcnRpZXModmFsdWUpIHtcbiAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXModmFsdWUpO1xuICAgIGNvbnN0IHJlc3VsdHMgPSBhd2FpdCBQcm9taXNlLmFsbChrZXlzLm1hcCgoaykgPT4gUHJvbWlzZS5yZXNvbHZlKHZhbHVlW2tdKSkpO1xuICAgIHJldHVybiByZXN1bHRzLnJlZHVjZSgoYWNjdW0sIHYsIGluZGV4KSA9PiB7XG4gICAgICAgIGFjY3VtW2tleXNbaW5kZXhdXSA9IHY7XG4gICAgICAgIHJldHVybiBhY2N1bTtcbiAgICB9LCB7fSk7XG59XG4vKipcbiAqICBBc3NpZ25zIHRoZSAlJXZhbHVlcyUlIHRvICUldGFyZ2V0JSUgYXMgcmVhZC1vbmx5IHZhbHVlcy5cbiAqXG4gKiAgSXQgJSV0eXBlcyUlIGlzIHNwZWNpZmllZCwgdGhlIHZhbHVlcyBhcmUgY2hlY2tlZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCB2YWx1ZXMsIHR5cGVzKSB7XG4gICAgZm9yIChsZXQga2V5IGluIHZhbHVlcykge1xuICAgICAgICBsZXQgdmFsdWUgPSB2YWx1ZXNba2V5XTtcbiAgICAgICAgY29uc3QgdHlwZSA9ICh0eXBlcyA/IHR5cGVzW2tleV0gOiBudWxsKTtcbiAgICAgICAgaWYgKHR5cGUpIHtcbiAgICAgICAgICAgIGNoZWNrVHlwZSh2YWx1ZSwgdHlwZSwga2V5KTtcbiAgICAgICAgfVxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWUsIHdyaXRhYmxlOiBmYWxzZSB9KTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wcm9wZXJ0aWVzLmpzLm1hcCJdLCJuYW1lcyI6WyJjaGVja1R5cGUiLCJ2YWx1ZSIsInR5cGUiLCJuYW1lIiwidHlwZXMiLCJzcGxpdCIsIm1hcCIsInQiLCJ0cmltIiwiaSIsImxlbmd0aCIsImVycm9yIiwiRXJyb3IiLCJjb2RlIiwiYXJndW1lbnQiLCJyZXNvbHZlUHJvcGVydGllcyIsImtleXMiLCJPYmplY3QiLCJyZXN1bHRzIiwiUHJvbWlzZSIsImFsbCIsImsiLCJyZXNvbHZlIiwicmVkdWNlIiwiYWNjdW0iLCJ2IiwiaW5kZXgiLCJkZWZpbmVQcm9wZXJ0aWVzIiwidGFyZ2V0IiwidmFsdWVzIiwia2V5IiwiZGVmaW5lUHJvcGVydHkiLCJlbnVtZXJhYmxlIiwid3JpdGFibGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ethers/lib.esm/utils/properties.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ethers/lib.esm/utils/units.js":
/*!****************************************************!*\
  !*** ./node_modules/ethers/lib.esm/utils/units.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   formatEther: () => (/* binding */ formatEther),\n/* harmony export */   formatUnits: () => (/* binding */ formatUnits),\n/* harmony export */   parseEther: () => (/* binding */ parseEther),\n/* harmony export */   parseUnits: () => (/* binding */ parseUnits)\n/* harmony export */ });\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./errors.js */ \"(rsc)/./node_modules/ethers/lib.esm/utils/errors.js\");\n/* harmony import */ var _fixednumber_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./fixednumber.js */ \"(rsc)/./node_modules/ethers/lib.esm/utils/fixednumber.js\");\n/* harmony import */ var _maths_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./maths.js */ \"(rsc)/./node_modules/ethers/lib.esm/utils/maths.js\");\n/**\n *  Most interactions with Ethereum requires integer values, which use\n *  the smallest magnitude unit.\n *\n *  For example, imagine dealing with dollars and cents. Since dollars\n *  are divisible, non-integer values are possible, such as ``$10.77``.\n *  By using the smallest indivisible unit (i.e. cents), the value can\n *  be kept as the integer ``1077``.\n *\n *  When receiving decimal input from the user (as a decimal string),\n *  the value should be converted to an integer and when showing a user\n *  a value, the integer value should be converted to a decimal string.\n *\n *  This creates a clear distinction, between values to be used by code\n *  (integers) and values used for display logic to users (decimals).\n *\n *  The native unit in Ethereum, //ether// is divisible to 18 decimal places,\n *  where each individual unit is called a //wei//.\n *\n *  @_subsection api/utils:Unit Conversion  [about-units]\n */ \n\n\nconst names = [\n    \"wei\",\n    \"kwei\",\n    \"mwei\",\n    \"gwei\",\n    \"szabo\",\n    \"finney\",\n    \"ether\"\n];\n/**\n *  Converts %%value%% into a //decimal string//, assuming %%unit%% decimal\n *  places. The %%unit%% may be the number of decimal places or the name of\n *  a unit (e.g. ``\"gwei\"`` for 9 decimal places).\n *\n */ function formatUnits(value, unit) {\n    let decimals = 18;\n    if (typeof unit === \"string\") {\n        const index = names.indexOf(unit);\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(index >= 0, \"invalid unit\", \"unit\", unit);\n        decimals = 3 * index;\n    } else if (unit != null) {\n        decimals = (0,_maths_js__WEBPACK_IMPORTED_MODULE_1__.getNumber)(unit, \"unit\");\n    }\n    return _fixednumber_js__WEBPACK_IMPORTED_MODULE_2__.FixedNumber.fromValue(value, decimals, {\n        decimals,\n        width: 512\n    }).toString();\n}\n/**\n *  Converts the //decimal string// %%value%% to a BigInt, assuming\n *  %%unit%% decimal places. The %%unit%% may the number of decimal places\n *  or the name of a unit (e.g. ``\"gwei\"`` for 9 decimal places).\n */ function parseUnits(value, unit) {\n    (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(typeof value === \"string\", \"value must be a string\", \"value\", value);\n    let decimals = 18;\n    if (typeof unit === \"string\") {\n        const index = names.indexOf(unit);\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(index >= 0, \"invalid unit\", \"unit\", unit);\n        decimals = 3 * index;\n    } else if (unit != null) {\n        decimals = (0,_maths_js__WEBPACK_IMPORTED_MODULE_1__.getNumber)(unit, \"unit\");\n    }\n    return _fixednumber_js__WEBPACK_IMPORTED_MODULE_2__.FixedNumber.fromString(value, {\n        decimals,\n        width: 512\n    }).value;\n}\n/**\n *  Converts %%value%% into a //decimal string// using 18 decimal places.\n */ function formatEther(wei) {\n    return formatUnits(wei, 18);\n}\n/**\n *  Converts the //decimal string// %%ether%% to a BigInt, using 18\n *  decimal places.\n */ function parseEther(ether) {\n    return parseUnits(ether, 18);\n} //# sourceMappingURL=units.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vdXRpbHMvdW5pdHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQW9CQyxHQUM0QztBQUNFO0FBQ1I7QUFDdkMsTUFBTUcsUUFBUTtJQUNWO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0NBQ0g7QUFDRDs7Ozs7Q0FLQyxHQUNNLFNBQVNDLFlBQVlDLEtBQUssRUFBRUMsSUFBSTtJQUNuQyxJQUFJQyxXQUFXO0lBQ2YsSUFBSSxPQUFRRCxTQUFVLFVBQVU7UUFDNUIsTUFBTUUsUUFBUUwsTUFBTU0sT0FBTyxDQUFDSDtRQUM1Qk4sMERBQWNBLENBQUNRLFNBQVMsR0FBRyxnQkFBZ0IsUUFBUUY7UUFDbkRDLFdBQVcsSUFBSUM7SUFDbkIsT0FDSyxJQUFJRixRQUFRLE1BQU07UUFDbkJDLFdBQVdMLG9EQUFTQSxDQUFDSSxNQUFNO0lBQy9CO0lBQ0EsT0FBT0wsd0RBQVdBLENBQUNTLFNBQVMsQ0FBQ0wsT0FBT0UsVUFBVTtRQUFFQTtRQUFVSSxPQUFPO0lBQUksR0FBR0MsUUFBUTtBQUNwRjtBQUNBOzs7O0NBSUMsR0FDTSxTQUFTQyxXQUFXUixLQUFLLEVBQUVDLElBQUk7SUFDbENOLDBEQUFjQSxDQUFDLE9BQVFLLFVBQVcsVUFBVSwwQkFBMEIsU0FBU0E7SUFDL0UsSUFBSUUsV0FBVztJQUNmLElBQUksT0FBUUQsU0FBVSxVQUFVO1FBQzVCLE1BQU1FLFFBQVFMLE1BQU1NLE9BQU8sQ0FBQ0g7UUFDNUJOLDBEQUFjQSxDQUFDUSxTQUFTLEdBQUcsZ0JBQWdCLFFBQVFGO1FBQ25EQyxXQUFXLElBQUlDO0lBQ25CLE9BQ0ssSUFBSUYsUUFBUSxNQUFNO1FBQ25CQyxXQUFXTCxvREFBU0EsQ0FBQ0ksTUFBTTtJQUMvQjtJQUNBLE9BQU9MLHdEQUFXQSxDQUFDYSxVQUFVLENBQUNULE9BQU87UUFBRUU7UUFBVUksT0FBTztJQUFJLEdBQUdOLEtBQUs7QUFDeEU7QUFDQTs7Q0FFQyxHQUNNLFNBQVNVLFlBQVlDLEdBQUc7SUFDM0IsT0FBT1osWUFBWVksS0FBSztBQUM1QjtBQUNBOzs7Q0FHQyxHQUNNLFNBQVNDLFdBQVdDLEtBQUs7SUFDNUIsT0FBT0wsV0FBV0ssT0FBTztBQUM3QixFQUNBLGlDQUFpQyIsInNvdXJjZXMiOlsid2VicGFjazovL21lZ2F2aWJlLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL3V0aWxzL3VuaXRzLmpzPzY4YWEiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiAgTW9zdCBpbnRlcmFjdGlvbnMgd2l0aCBFdGhlcmV1bSByZXF1aXJlcyBpbnRlZ2VyIHZhbHVlcywgd2hpY2ggdXNlXG4gKiAgdGhlIHNtYWxsZXN0IG1hZ25pdHVkZSB1bml0LlxuICpcbiAqICBGb3IgZXhhbXBsZSwgaW1hZ2luZSBkZWFsaW5nIHdpdGggZG9sbGFycyBhbmQgY2VudHMuIFNpbmNlIGRvbGxhcnNcbiAqICBhcmUgZGl2aXNpYmxlLCBub24taW50ZWdlciB2YWx1ZXMgYXJlIHBvc3NpYmxlLCBzdWNoIGFzIGBgJDEwLjc3YGAuXG4gKiAgQnkgdXNpbmcgdGhlIHNtYWxsZXN0IGluZGl2aXNpYmxlIHVuaXQgKGkuZS4gY2VudHMpLCB0aGUgdmFsdWUgY2FuXG4gKiAgYmUga2VwdCBhcyB0aGUgaW50ZWdlciBgYDEwNzdgYC5cbiAqXG4gKiAgV2hlbiByZWNlaXZpbmcgZGVjaW1hbCBpbnB1dCBmcm9tIHRoZSB1c2VyIChhcyBhIGRlY2ltYWwgc3RyaW5nKSxcbiAqICB0aGUgdmFsdWUgc2hvdWxkIGJlIGNvbnZlcnRlZCB0byBhbiBpbnRlZ2VyIGFuZCB3aGVuIHNob3dpbmcgYSB1c2VyXG4gKiAgYSB2YWx1ZSwgdGhlIGludGVnZXIgdmFsdWUgc2hvdWxkIGJlIGNvbnZlcnRlZCB0byBhIGRlY2ltYWwgc3RyaW5nLlxuICpcbiAqICBUaGlzIGNyZWF0ZXMgYSBjbGVhciBkaXN0aW5jdGlvbiwgYmV0d2VlbiB2YWx1ZXMgdG8gYmUgdXNlZCBieSBjb2RlXG4gKiAgKGludGVnZXJzKSBhbmQgdmFsdWVzIHVzZWQgZm9yIGRpc3BsYXkgbG9naWMgdG8gdXNlcnMgKGRlY2ltYWxzKS5cbiAqXG4gKiAgVGhlIG5hdGl2ZSB1bml0IGluIEV0aGVyZXVtLCAvL2V0aGVyLy8gaXMgZGl2aXNpYmxlIHRvIDE4IGRlY2ltYWwgcGxhY2VzLFxuICogIHdoZXJlIGVhY2ggaW5kaXZpZHVhbCB1bml0IGlzIGNhbGxlZCBhIC8vd2VpLy8uXG4gKlxuICogIEBfc3Vic2VjdGlvbiBhcGkvdXRpbHM6VW5pdCBDb252ZXJzaW9uICBbYWJvdXQtdW5pdHNdXG4gKi9cbmltcG9ydCB7IGFzc2VydEFyZ3VtZW50IH0gZnJvbSBcIi4vZXJyb3JzLmpzXCI7XG5pbXBvcnQgeyBGaXhlZE51bWJlciB9IGZyb20gXCIuL2ZpeGVkbnVtYmVyLmpzXCI7XG5pbXBvcnQgeyBnZXROdW1iZXIgfSBmcm9tIFwiLi9tYXRocy5qc1wiO1xuY29uc3QgbmFtZXMgPSBbXG4gICAgXCJ3ZWlcIixcbiAgICBcImt3ZWlcIixcbiAgICBcIm13ZWlcIixcbiAgICBcImd3ZWlcIixcbiAgICBcInN6YWJvXCIsXG4gICAgXCJmaW5uZXlcIixcbiAgICBcImV0aGVyXCIsXG5dO1xuLyoqXG4gKiAgQ29udmVydHMgJSV2YWx1ZSUlIGludG8gYSAvL2RlY2ltYWwgc3RyaW5nLy8sIGFzc3VtaW5nICUldW5pdCUlIGRlY2ltYWxcbiAqICBwbGFjZXMuIFRoZSAlJXVuaXQlJSBtYXkgYmUgdGhlIG51bWJlciBvZiBkZWNpbWFsIHBsYWNlcyBvciB0aGUgbmFtZSBvZlxuICogIGEgdW5pdCAoZS5nLiBgYFwiZ3dlaVwiYGAgZm9yIDkgZGVjaW1hbCBwbGFjZXMpLlxuICpcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZvcm1hdFVuaXRzKHZhbHVlLCB1bml0KSB7XG4gICAgbGV0IGRlY2ltYWxzID0gMTg7XG4gICAgaWYgKHR5cGVvZiAodW5pdCkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgY29uc3QgaW5kZXggPSBuYW1lcy5pbmRleE9mKHVuaXQpO1xuICAgICAgICBhc3NlcnRBcmd1bWVudChpbmRleCA+PSAwLCBcImludmFsaWQgdW5pdFwiLCBcInVuaXRcIiwgdW5pdCk7XG4gICAgICAgIGRlY2ltYWxzID0gMyAqIGluZGV4O1xuICAgIH1cbiAgICBlbHNlIGlmICh1bml0ICE9IG51bGwpIHtcbiAgICAgICAgZGVjaW1hbHMgPSBnZXROdW1iZXIodW5pdCwgXCJ1bml0XCIpO1xuICAgIH1cbiAgICByZXR1cm4gRml4ZWROdW1iZXIuZnJvbVZhbHVlKHZhbHVlLCBkZWNpbWFscywgeyBkZWNpbWFscywgd2lkdGg6IDUxMiB9KS50b1N0cmluZygpO1xufVxuLyoqXG4gKiAgQ29udmVydHMgdGhlIC8vZGVjaW1hbCBzdHJpbmcvLyAlJXZhbHVlJSUgdG8gYSBCaWdJbnQsIGFzc3VtaW5nXG4gKiAgJSV1bml0JSUgZGVjaW1hbCBwbGFjZXMuIFRoZSAlJXVuaXQlJSBtYXkgdGhlIG51bWJlciBvZiBkZWNpbWFsIHBsYWNlc1xuICogIG9yIHRoZSBuYW1lIG9mIGEgdW5pdCAoZS5nLiBgYFwiZ3dlaVwiYGAgZm9yIDkgZGVjaW1hbCBwbGFjZXMpLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VVbml0cyh2YWx1ZSwgdW5pdCkge1xuICAgIGFzc2VydEFyZ3VtZW50KHR5cGVvZiAodmFsdWUpID09PSBcInN0cmluZ1wiLCBcInZhbHVlIG11c3QgYmUgYSBzdHJpbmdcIiwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG4gICAgbGV0IGRlY2ltYWxzID0gMTg7XG4gICAgaWYgKHR5cGVvZiAodW5pdCkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgY29uc3QgaW5kZXggPSBuYW1lcy5pbmRleE9mKHVuaXQpO1xuICAgICAgICBhc3NlcnRBcmd1bWVudChpbmRleCA+PSAwLCBcImludmFsaWQgdW5pdFwiLCBcInVuaXRcIiwgdW5pdCk7XG4gICAgICAgIGRlY2ltYWxzID0gMyAqIGluZGV4O1xuICAgIH1cbiAgICBlbHNlIGlmICh1bml0ICE9IG51bGwpIHtcbiAgICAgICAgZGVjaW1hbHMgPSBnZXROdW1iZXIodW5pdCwgXCJ1bml0XCIpO1xuICAgIH1cbiAgICByZXR1cm4gRml4ZWROdW1iZXIuZnJvbVN0cmluZyh2YWx1ZSwgeyBkZWNpbWFscywgd2lkdGg6IDUxMiB9KS52YWx1ZTtcbn1cbi8qKlxuICogIENvbnZlcnRzICUldmFsdWUlJSBpbnRvIGEgLy9kZWNpbWFsIHN0cmluZy8vIHVzaW5nIDE4IGRlY2ltYWwgcGxhY2VzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZm9ybWF0RXRoZXIod2VpKSB7XG4gICAgcmV0dXJuIGZvcm1hdFVuaXRzKHdlaSwgMTgpO1xufVxuLyoqXG4gKiAgQ29udmVydHMgdGhlIC8vZGVjaW1hbCBzdHJpbmcvLyAlJWV0aGVyJSUgdG8gYSBCaWdJbnQsIHVzaW5nIDE4XG4gKiAgZGVjaW1hbCBwbGFjZXMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZUV0aGVyKGV0aGVyKSB7XG4gICAgcmV0dXJuIHBhcnNlVW5pdHMoZXRoZXIsIDE4KTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXVuaXRzLmpzLm1hcCJdLCJuYW1lcyI6WyJhc3NlcnRBcmd1bWVudCIsIkZpeGVkTnVtYmVyIiwiZ2V0TnVtYmVyIiwibmFtZXMiLCJmb3JtYXRVbml0cyIsInZhbHVlIiwidW5pdCIsImRlY2ltYWxzIiwiaW5kZXgiLCJpbmRleE9mIiwiZnJvbVZhbHVlIiwid2lkdGgiLCJ0b1N0cmluZyIsInBhcnNlVW5pdHMiLCJmcm9tU3RyaW5nIiwiZm9ybWF0RXRoZXIiLCJ3ZWkiLCJwYXJzZUV0aGVyIiwiZXRoZXIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ethers/lib.esm/utils/units.js\n");

/***/ })

};
;